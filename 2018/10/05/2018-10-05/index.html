<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">
  <script>
    (function () {
        if ('') {
            if (prompt('请输入文章密码') !== '') {
                alert('密码错误！');
                if (history.length === 1) {
                    location.replace("http://qianyouyou.cn"); // 这里替换成你的首页
                } else {
                    history.back();
                }
            }
        }
    })();
</script>







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "28d5c19f"
    });
  daovoice('update');
  </script>















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.2.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=5.2.0" color="#222">





  <meta name="keywords" content="字符串,算法,数据结构,博弈论,图论,数论,计算几何,动态规划,">





  <link rel="alternate" href="/atom.xml" title="浅悠悠的个人博客" type="application/atom+xml">






<meta name="description" content="标签：位运算，gcd，exgcd，欧拉筛，快速乘，矩阵快速幂，中国剩余定理，欧拉函数，逆元，高斯消元，母函数，斯特林数，卡特兰数，莫比乌斯反演，SG函数与Nim博弈，奇异函数与Wythoff博弈，并查集，线段树，主席树，树状数组，ST表，LCA，BM算法，KMP，Trie树，AC自动机，匈牙利算法，KM算法，Floyd，dijkstra，dijkstra+heap优化，SPFA及LLL与SLF优化">
<meta name="keywords" content="字符串,算法,数据结构,博弈论,图论,数论,计算几何,动态规划">
<meta property="og:type" content="article">
<meta property="og:title" content="ACM算法专用模板(持续更新中)">
<meta property="og:url" content="http://qianyouyou.cn/2018/10/05/2018-10-05/index.html">
<meta property="og:site_name" content="浅悠悠的个人博客">
<meta property="og:description" content="标签：位运算，gcd，exgcd，欧拉筛，快速乘，矩阵快速幂，中国剩余定理，欧拉函数，逆元，高斯消元，母函数，斯特林数，卡特兰数，莫比乌斯反演，SG函数与Nim博弈，奇异函数与Wythoff博弈，并查集，线段树，主席树，树状数组，ST表，LCA，BM算法，KMP，Trie树，AC自动机，匈牙利算法，KM算法，Floyd，dijkstra，dijkstra+heap优化，SPFA及LLL与SLF优化">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-04-27T15:32:56.614Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ACM算法专用模板(持续更新中)">
<meta name="twitter:description" content="标签：位运算，gcd，exgcd，欧拉筛，快速乘，矩阵快速幂，中国剩余定理，欧拉函数，逆元，高斯消元，母函数，斯特林数，卡特兰数，莫比乌斯反演，SG函数与Nim博弈，奇异函数与Wythoff博弈，并查集，线段树，主席树，树状数组，ST表，LCA，BM算法，KMP，Trie树，AC自动机，匈牙利算法，KM算法，Floyd，dijkstra，dijkstra+heap优化，SPFA及LLL与SLF优化">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.2.0',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://qianyouyou.cn/2018/10/05/2018-10-05/">





  <title>ACM算法专用模板(持续更新中) | 浅悠悠的个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

<a href="https://www.qianyouyou.cn" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>   
	<header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">浅悠悠的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">When there is no sunshine,talking to the moon.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-notes">
          <a href="/notes/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            随笔
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>


 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://qianyouyou.cn/2018/10/05/2018-10-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王骏">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅悠悠的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ACM算法专用模板(持续更新中)</h1>
        

        <div class="post-meta">
		  
            <i class="fa fa-thumb-tack"></i>
            <font color="7D26CD">置顶</font>
            <span class="post-meta-divider">|</span>
          
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-05T14:16:34+08:00">
                2018-10-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/程序人生/" itemprop="url" rel="index">
                    <span itemprop="name">程序人生</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/程序人生/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 热度
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>℃
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  47,183
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  275
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>标签：位运算，gcd，exgcd，欧拉筛，快速乘，矩阵快速幂，中国剩余定理，欧拉函数，逆元，高斯消元，母函数，斯特林数，卡特兰数，莫比乌斯反演，SG函数与Nim博弈，奇异函数与Wythoff博弈，并查集，线段树，主席树，树状数组，ST表，LCA，BM算法，KMP，Trie树，AC自动机，匈牙利算法，KM算法，Floyd，dijkstra，dijkstra+heap优化，SPFA及LLL与SLF优化，Dinic，MCMF，Kruscal，Prim等等。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int fa[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    for(int i = 0; i &lt; maxn; i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int root(int x)&#123;</span><br><span class="line">    return x==fa[x] ? x : x=root(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">void Union(int px, int py)&#123;</span><br><span class="line">    px = root(px);</span><br><span class="line">    py = root(py);</span><br><span class="line">    if(px != py)&#123;</span><br><span class="line">        fa[py] = px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并查集路径压缩按雉合并"><a href="#并查集路径压缩按雉合并" class="headerlink" title="并查集路径压缩按雉合并"></a>并查集路径压缩按雉合并</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn=1e5+7;</span><br><span class="line">int fa[maxn],r[maxn];</span><br><span class="line">int a[maxn];</span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    for(int i=0;i&lt;=n;i++)&#123;</span><br><span class="line">        fa[i]=i;</span><br><span class="line">        r[i]=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Find(int x)&#123;</span><br><span class="line">    return x==fa[x]?x:Find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Merge(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int t1=Find(x),t2=Find(y);</span><br><span class="line">    if(t1==t2) return ;//已合并返回</span><br><span class="line">    if(r[t1]&gt;r[t2]) fa[t2]=t1;  //把y的祖先t2和并到x的祖先t1上。因以t1为根的树更高</span><br><span class="line">    else &#123;</span><br><span class="line">        fa[t1]=t2;</span><br><span class="line">        if(r[t1]==r[t2]) r[t2]++; //若两树一样高，那么合并后，高度加一。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int sum[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    init();</span><br><span class="line">    memset(sum,0,sizeof(sum));</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int flag,x,y,z;</span><br><span class="line">        cin&gt;&gt;flag;</span><br><span class="line">        if(flag==1)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">            int cnt=0;</span><br><span class="line">            for(int j=y+1;j&lt;=z;j++)&#123;</span><br><span class="line">                Merge(j,j-1);</span><br><span class="line">                cnt+=a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            Merge(x,y);</span><br><span class="line">            cnt+=a[y];</span><br><span class="line">            sum[fa[x]]+=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            sum[fa[x]]=sum[fa[x]]-a[x]+y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int minn=0x3f3f3f3f;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(fa[i]==i)&#123;</span><br><span class="line">            minn=min(minn,sum[fa[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;minn&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加权并查集"><a href="#加权并查集" class="headerlink" title="加权并查集"></a>加权并查集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">int n,m,s[N],p[N],ans;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    ans=0;</span><br><span class="line">    memset(s,0,sizeof(s));</span><br><span class="line">    for(int i=0;i&lt;N;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fd(int x) &#123; ///此时find不单有查找任务，还有更新距离任务</span><br><span class="line">    if(x==p[x]) return x;</span><br><span class="line">    int t=p[x];</span><br><span class="line">    p[x]=fd(p[x]);</span><br><span class="line">    s[x]+=s[t]; ///记录到根节点的距离，一定要有一个思想，根节点是一个区间的一个端点而不是一个区间，输入的区间被合并成了两个点</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Union(int a,int b,int num) &#123;</span><br><span class="line">    int x=fd(a),y=fd(b);</span><br><span class="line">    if(x==y) &#123;</span><br><span class="line">        if(s[b]!=s[a]+num) ans++;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        p[y]=x;</span><br><span class="line">        s[y]=s[a]+num-s[b]; ///y到x的距离等于a到x的距离+b到a的距离-b到y的距离</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m) &#123;</span><br><span class="line">        init();</span><br><span class="line">        for(int i=0;i&lt;m;i++) &#123;</span><br><span class="line">            int a,b,c;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            Union(a-1,b,c);</span><br><span class="line">            ///等价于Union(a,b+1,c);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e6+7;</span><br><span class="line">int a[maxn];</span><br><span class="line">int maxq[maxn];</span><br><span class="line">int minq[maxn];</span><br><span class="line">int q[maxn];</span><br><span class="line">int n,k;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;k)&#123;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        int head,tail,t;</span><br><span class="line">        memset(q,0,sizeof(q));</span><br><span class="line">        head=1,tail=1;</span><br><span class="line">        q[tail]=1;</span><br><span class="line">        minq[1]=a[1];</span><br><span class="line">        for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">            while(head&lt;=tail&amp;&amp;a[i]&lt;a[q[tail]])</span><br><span class="line">                tail--;</span><br><span class="line">            q[++tail]=i;</span><br><span class="line">            if(head&lt;=tail&amp;&amp;q[head]&lt;i-k+1)</span><br><span class="line">                head++;</span><br><span class="line">            minq[i]=a[q[head]];</span><br><span class="line">        &#125;</span><br><span class="line">        memset(q,0,sizeof(q));</span><br><span class="line">        head=1,tail=1;</span><br><span class="line">        q[tail]=1;</span><br><span class="line">        maxq[1]=a[1];</span><br><span class="line">        for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">            while(head&lt;=tail&amp;&amp;a[i]&gt;a[q[tail]])</span><br><span class="line">                tail--;</span><br><span class="line">            q[++tail]=i;</span><br><span class="line">            if(head&lt;=tail&amp;&amp;q[head]&lt;i-k+1)</span><br><span class="line">                head++;</span><br><span class="line">            maxq[i]=a[q[head]];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=k;i&lt;n;i++)</span><br><span class="line">            cout&lt;&lt;minq[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;minq[n]&lt;&lt;endl;</span><br><span class="line">        for(int i=k;i&lt;n;i++)</span><br><span class="line">            cout&lt;&lt;maxq[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;maxq[n]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int head[maxn], cnt;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, u, w;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    //memset(edge, 0, sizeof(edge));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h2><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,i,num[100001],t[200001],l,r;//num:原数组；t：树状数组</span><br><span class="line">int lowbit(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line">void change(int x,int p)//将第x个数加p</span><br><span class="line">&#123;</span><br><span class="line">    while(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=p;</span><br><span class="line">        x+=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int sum(int k)//前k个数的和</span><br><span class="line">&#123;</span><br><span class="line">    int ans=0;</span><br><span class="line">    while(k&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[k];</span><br><span class="line">        k-=lowbit(k);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int ask(int l,int r)//求l-r区间和</span><br><span class="line">&#123;</span><br><span class="line">    return sum(r)-sum(l-1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">        change(i,num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=1;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        cout&lt;&lt;ask(l,r)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define MAXN 100010</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">    int l,r;//区间[l,r]</span><br><span class="line">    int add;//区间的延时标记</span><br><span class="line">    int sum;//区间和</span><br><span class="line">    int mx; //区间最大值</span><br><span class="line">    int mn; //区间最小值</span><br><span class="line">&#125;tree[MAXN&lt;&lt;2];//一定要开到4倍多的空间</span><br><span class="line"></span><br><span class="line">void pushup(int index)&#123;</span><br><span class="line">    tree[index].sum = tree[index&lt;&lt;1].sum+tree[index&lt;&lt;1|1].sum;</span><br><span class="line">    tree[index].mx = max(tree[index&lt;&lt;1].mx,tree[index&lt;&lt;1|1].mx);</span><br><span class="line">    tree[index].mn = min(tree[index&lt;&lt;1].mn,tree[index&lt;&lt;1|1].mn);</span><br><span class="line">&#125;</span><br><span class="line">void pushdown(int index)&#123;</span><br><span class="line">    //说明该区间之前更新过</span><br><span class="line">    //要想更新该区间下面的子区间，就要把上次更新该区间的值向下更新</span><br><span class="line">    if(tree[index].add)&#123;</span><br><span class="line">        //替换原来的值</span><br><span class="line">        /*</span><br><span class="line">        tree[index&lt;&lt;1].sum = (tree[index&lt;&lt;1].r-tree[index&lt;&lt;1].l+1)*tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].sum = (tree[index&lt;&lt;1|1].r-tree[index&lt;&lt;1|1].l+1)*tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1].mx = tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].mx = tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1].mn = tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].mn = tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1].add = tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].add = tree[index].add;</span><br><span class="line">        tree[index].add = 0;*/</span><br><span class="line">        //在原来的值的基础上加上val</span><br><span class="line"></span><br><span class="line">        tree[index&lt;&lt;1].sum += (tree[index&lt;&lt;1].r-tree[index&lt;&lt;1].l+1)*tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].sum +=(tree[index&lt;&lt;1|1].r-tree[index&lt;&lt;1|1].l+1)*tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1].mx += tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].mx += tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1].mn += tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].mn += tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1].add += tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].add += tree[index].add;</span><br><span class="line">        tree[index].add = 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void build(int l,int r,int index)&#123;</span><br><span class="line">    tree[index].l = l;</span><br><span class="line">    tree[index].r = r;</span><br><span class="line">    tree[index].add = 0;//刚开始一定要清0</span><br><span class="line">    if(l == r)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;tree[index].sum);</span><br><span class="line">        tree[index].mn = tree[index].mx = tree[index].sum;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (l+r)&gt;&gt;1;</span><br><span class="line">    build(l,mid,index&lt;&lt;1);</span><br><span class="line">    build(mid+1,r,index&lt;&lt;1|1);</span><br><span class="line">    pushup(index);</span><br><span class="line">&#125;</span><br><span class="line">void updata(int l,int r,int index,int val)&#123;</span><br><span class="line">    if(l &lt;= tree[index].l &amp;&amp; r &gt;= tree[index].r)&#123;</span><br><span class="line">        /*把原来的值替换成val,因为该区间有tree[index].r-tree[index].l+1</span><br><span class="line">        个数，所以区间和 以及 最值为：</span><br><span class="line">        */</span><br><span class="line">        /*tree[index].sum = (tree[index].r-tree[index].l+1)*val;</span><br><span class="line">        tree[index].mn = val;</span><br><span class="line">        tree[index].mx = val;</span><br><span class="line">        tree[index].add = val;//延时标记*/</span><br><span class="line">        //在原来的值的基础上加上val,因为该区间有tree[index].r-tree[index].l+1</span><br><span class="line">        //个数，所以区间和 以及 最值为：</span><br><span class="line">        tree[index].sum += (tree[index].r-tree[index].l+1)*val;</span><br><span class="line">        tree[index].mn += val;</span><br><span class="line">        tree[index].mx += val;</span><br><span class="line">        tree[index].add += val;//延时标记</span><br><span class="line"></span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(index);</span><br><span class="line">    int mid = (tree[index].l+tree[index].r)&gt;&gt;1;</span><br><span class="line">    if(l &lt;= mid)&#123;</span><br><span class="line">        updata(l,r,index&lt;&lt;1,val);</span><br><span class="line">    &#125;</span><br><span class="line">    if(r &gt; mid)&#123;</span><br><span class="line">        updata(l,r,index&lt;&lt;1|1,val);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(index);</span><br><span class="line">&#125;</span><br><span class="line">int query(int l,int r,int index)&#123;</span><br><span class="line">    if(l &lt;= tree[index].l &amp;&amp; r &gt;= tree[index].r)&#123;</span><br><span class="line">        //return tree[index].sum;</span><br><span class="line">        return tree[index].mx;</span><br><span class="line">        //return tree[index].mn;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(index);</span><br><span class="line">    int mid = (tree[index].l+tree[index].r)&gt;&gt;1;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    int Max = 0;</span><br><span class="line">    int Min = inf;</span><br><span class="line">    if(l &lt;= mid)&#123;</span><br><span class="line">        ans += query(l,r,index&lt;&lt;1);</span><br><span class="line">        Max = max(query(l,r,index&lt;&lt;1),Max);</span><br><span class="line">        Min = min(query(l,r,index&lt;&lt;1),Min);</span><br><span class="line">    &#125;</span><br><span class="line">    if(r &gt; mid)&#123;</span><br><span class="line">        ans += query(l,r,index&lt;&lt;1|1);</span><br><span class="line">        Max = max(query(l,r,index&lt;&lt;1|1),Max);</span><br><span class="line">        Min = min(query(l,r,index&lt;&lt;1|1),Min);</span><br><span class="line">    &#125;</span><br><span class="line">    //return ans;</span><br><span class="line">    return Max;</span><br><span class="line">    //return Min;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,q,x,y,z;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">        build(1,n,1);</span><br><span class="line">        while(m--)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">            if(q == 1)&#123;</span><br><span class="line">                cout&lt;&lt;&quot;查询:(x,y)&quot;&lt;&lt;endl;</span><br><span class="line">                scanf(&quot;%d %d&quot;,&amp;x,&amp;y);</span><br><span class="line">                cout&lt;&lt;query(x,y,1)&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                cout&lt;&lt;&quot;更新(x,y)为z：&quot;&lt;&lt;endl;</span><br><span class="line">                scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z);</span><br><span class="line">                updata(x,y,1,z);</span><br><span class="line">                for(int i = 1; i &lt;= n; ++i)&#123;</span><br><span class="line">                    printf(&quot;a[%d] = %d\n&quot;,i,query(i,i,1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">// luogu-judger-enable-o2</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[100010],hash[101000],tot,root[201000],cnt,n,m,tt,qll[200100],qrr[20000];</span><br><span class="line">int q1,q2,id[201000],b[201000];</span><br><span class="line">struct TREE</span><br><span class="line">&#123;</span><br><span class="line">    int ln,rn,zhi;</span><br><span class="line">&#125;t[10010000];</span><br><span class="line">struct NODE</span><br><span class="line">&#123;</span><br><span class="line">    int l,r,k,flag;</span><br><span class="line">&#125;q[100100];</span><br><span class="line">int lowbit(int x) &#123;return (x)&amp;(-x);&#125;</span><br><span class="line">void gai(int &amp;node,int l,int r,int hs,int v)</span><br><span class="line">&#123;</span><br><span class="line">    if(!node) node=++tot;</span><br><span class="line">    t[node].zhi+=v;</span><br><span class="line">    if(l==r) return;</span><br><span class="line">    int mid=(l+r)/2;</span><br><span class="line">    if(hs&lt;=mid) gai(t[node].ln,l,mid,hs,v);</span><br><span class="line">    else gai(t[node].rn,mid+1,r,hs,v);</span><br><span class="line">&#125;</span><br><span class="line">void add(int p,int v)</span><br><span class="line">&#123;</span><br><span class="line">    hash[p]=lower_bound(a+1,a+1+tt,hash[p])-a;</span><br><span class="line">    //cout&lt;&lt;hash[p]&lt;&lt;endl;</span><br><span class="line">    for(int i=p;i&lt;=n;i+=lowbit(i)) gai(root[i],1,tt,hash[p],v);</span><br><span class="line">&#125;</span><br><span class="line">char s[2];</span><br><span class="line">int SUM()</span><br><span class="line">&#123;</span><br><span class="line">    int ans1=0,ans2=0;</span><br><span class="line">    for(int i=1;i&lt;=q1;i++) ans1+=t[t[qrr[i]].ln].zhi;</span><br><span class="line">    for(int i=1;i&lt;=q2;i++) ans2+=t[t[qll[i]].ln].zhi;</span><br><span class="line">    return ans1-ans2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int cha(int qr,int ql,int l,int r,int k)</span><br><span class="line">&#123;</span><br><span class="line">    q1=0,q2=0;</span><br><span class="line">    for(int i=qr;i&gt;=1;i-=lowbit(i)) qrr[++q1]=root[i];</span><br><span class="line">    for(int i=ql;i&gt;=1;i-=lowbit(i)) qll[++q2]=root[i];</span><br><span class="line">    while(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        int lsiz=SUM(),mid=(l+r)/2;</span><br><span class="line">        if(k&lt;=lsiz) </span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=1;i&lt;=q1;i++) qrr[i]=t[qrr[i]].ln;</span><br><span class="line">            for(int i=1;i&lt;=q2;i++) qll[i]=t[qll[i]].ln;</span><br><span class="line">            r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=1;i&lt;=q1;i++) qrr[i]=t[qrr[i]].rn;</span><br><span class="line">            for(int i=1;i&lt;=q2;i++) qll[i]=t[qll[i]].rn;</span><br><span class="line">            l=mid+1;k-=lsiz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int x,y,z;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);b[i]=a[i];</span><br><span class="line">        hash[++cnt]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%s&quot;,s);</span><br><span class="line">        if(s[0]==&apos;Q&apos;)</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;q[i].l,&amp;q[i].r,&amp;q[i].k),q[i].flag=1;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r);</span><br><span class="line">            a[++cnt]=q[i].r;hash[cnt]=a[cnt];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+1,a+1+cnt);</span><br><span class="line">    tt=unique(a+1,a+1+cnt)-a-1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    add(i,1);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(q[i].flag==1)</span><br><span class="line">        printf(&quot;%d\n&quot;,a[cha(q[i].r,q[i].l-1,1,tt,q[i].k)]);</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            hash[q[i].l]=b[q[i].l];</span><br><span class="line">            add(q[i].l,-1);</span><br><span class="line">            hash[q[i].l]=q[i].r;</span><br><span class="line">            b[q[i].l]=q[i].r;</span><br><span class="line">            add(q[i].l,1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="划分树"><a href="#划分树" class="headerlink" title="划分树"></a>划分树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">/** 划分树（查询区间第 k 大）*/</span><br><span class="line">const int MAXN = 100010;</span><br><span class="line">int tree[20][MAXN];//表示每层每个位置的值</span><br><span class="line">int sorted[MAXN];//已经排序好的数</span><br><span class="line">int toleft[20][MAXN];//toleft[p][i] 表示第 i 层从 1 到 i 有数分入左边</span><br><span class="line">void build(int l,int r,int dep)</span><br><span class="line">&#123;</span><br><span class="line">    if(l == r)</span><br><span class="line">        return;</span><br><span class="line">    int mid = (l+r)&gt;&gt;1;</span><br><span class="line">    int same = mid − l + 1;//表示等于中间值而且被分入左边的个数</span><br><span class="line">    for(int i = l; i &lt;= r; i++) //注意是 l, 不是 one</span><br><span class="line">        if(tree[dep][i] &lt; sorted[mid])</span><br><span class="line">            same−−;</span><br><span class="line">    int lpos = l;</span><br><span class="line">    int rpos = mid+1;</span><br><span class="line">    for(int i = l; i &lt;= r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(tree[dep][i] &lt; sorted[mid])</span><br><span class="line">            tree[dep+1][lpos++] = tree[dep][i];</span><br><span class="line">        else if(tree[dep][i] == sorted[mid] &amp;&amp; same &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            tree[dep+1][lpos++] = tree[dep][i];</span><br><span class="line">            same−−;</span><br><span class="line">        &#125;</span><br><span class="line">        elsetree[dep+1][rpos++] = tree[dep][i];</span><br><span class="line">        toleft[dep][i] = toleft[dep][l−1] + lpos − l</span><br><span class="line">    &#125;</span><br><span class="line">    build(l,mid,dep+1);</span><br><span class="line">    build(mid+1,r,dep+1);</span><br><span class="line">&#125;</span><br><span class="line">//查询区间第 k 大的数,[L,R] 是大区间，[l,r] 是要查询的小区间</span><br><span class="line">int query(int L,int R,int l,int r,int dep,int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(l == r)</span><br><span class="line">        return tree[dep][l];</span><br><span class="line">    int mid = (L+R)&gt;&gt;1;</span><br><span class="line">    int cnt = toleft[dep][r] − toleft[dep][l−1];</span><br><span class="line">    if(cnt &gt;= k)</span><br><span class="line">    &#123;</span><br><span class="line">        int newl = L + toleft[dep][l−1] − toleft[dep][L−1];</span><br><span class="line">        int newr = newl + cnt − 1;</span><br><span class="line">        return query(L,mid,newl,newr,dep+1,k);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        int newr = r + toleft[dep][R] − toleft[dep][r];</span><br><span class="line">        int newl = newr − (r−l−cnt);</span><br><span class="line">        return query(mid+1,R,newl,newr,dep+1,k−cnt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)==2)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(tree,0,sizeof(tree));</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;tree[0][i]);</span><br><span class="line">            sorted[i] = tree[0][i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(sorted+1,sorted+n+1);</span><br><span class="line">        build(1,n,0);</span><br><span class="line">        int s,t,k;</span><br><span class="line">        while(m−−)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;,&amp;s,&amp;t,&amp;k);</span><br><span class="line">            printf(&quot;%d\n&quot;,query(1,n,s,t,0,k));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+7;</span><br><span class="line">char s[maxn];</span><br><span class="line">int n,m;</span><br><span class="line">bool p;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int count;</span><br><span class="line">    node * next[26];</span><br><span class="line">&#125;*root;</span><br><span class="line">node * build()</span><br><span class="line">&#123;</span><br><span class="line">    node * k=new(node);</span><br><span class="line">    k-&gt;count=0;</span><br><span class="line">    memset(k-&gt;next,0,sizeof(k-&gt;next));</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br><span class="line">void insert()</span><br><span class="line">&#123;</span><br><span class="line">    node * r=root;</span><br><span class="line">    char * word=s;</span><br><span class="line">     while(*word)</span><br><span class="line">    &#123;</span><br><span class="line">        int id=*word-&apos;a&apos;;</span><br><span class="line">        if(r-&gt;next[id]==NULL) r-&gt;next[id]=build();</span><br><span class="line">        r=r-&gt;next[id];</span><br><span class="line">        r-&gt;count++;</span><br><span class="line">        word++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int search()</span><br><span class="line">&#123;</span><br><span class="line">    node * r=root;</span><br><span class="line">    char * word=s;</span><br><span class="line">    while(*word)</span><br><span class="line">    &#123;</span><br><span class="line">        int id=*word-&apos;a&apos;;</span><br><span class="line">        r=r-&gt;next[id];</span><br><span class="line">        if(r==NULL) return 0;</span><br><span class="line">        word++;</span><br><span class="line">    &#125;</span><br><span class="line">    return r-&gt;count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	char str[11];</span><br><span class="line">	int i,j;</span><br><span class="line">	root=(struct dictree*)malloc(sizeof(struct dictree));</span><br><span class="line">	for(i=0;i&lt;26;i++)</span><br><span class="line">	root-&gt;child[i]=0;</span><br><span class="line">	root-&gt;n=2;</span><br><span class="line">	while(gets(str),strcmp(str,&quot;&quot;)!=0)&#123;</span><br><span class="line">		insert(str);</span><br><span class="line">	&#125;</span><br><span class="line">	while(scanf(&quot;%s&quot;,str)!=EOF)&#123;</span><br><span class="line">		printf(&quot;%d\n&quot;,find(str));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"> /*</span><br><span class="line">                 An implementation of top-down splaying</span><br><span class="line">                     D. Sleator &lt;sleator@cs.cmu.edu&gt;</span><br><span class="line">                              March 1992</span><br><span class="line">  */</span><br><span class="line"> #include &lt;stdlib.h&gt;</span><br><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line">  int size;  /* number of nodes in the tree */</span><br><span class="line">            /* Not actually needed for any of the operations */</span><br><span class="line"> typedef struct tree_node Tree;</span><br><span class="line">  struct tree_node</span><br><span class="line"> &#123;</span><br><span class="line">     Tree * left, * right;</span><br><span class="line">     int item;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> Tree * splay (int i, Tree * t)</span><br><span class="line"> &#123;</span><br><span class="line">  /* Simple top down splay, not requiring i to be in the tree t.  */</span><br><span class="line">  /* What it does is described above.                             */</span><br><span class="line">     Tree N, *l, *r, *y;</span><br><span class="line">     if (t == NULL)</span><br><span class="line">         return t;</span><br><span class="line">     N.left = N.right = NULL;</span><br><span class="line">     l = r = &amp;N;</span><br><span class="line">     for (;;)</span><br><span class="line">     &#123;</span><br><span class="line">         if (i &lt; t-&gt;item)</span><br><span class="line">         &#123;</span><br><span class="line">             if (t-&gt;left == NULL)</span><br><span class="line">             &#123;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">             if (i &lt; t-&gt;left-&gt;item)</span><br><span class="line">             &#123;</span><br><span class="line">                 y = t-&gt;left;                           /* rotate right */</span><br><span class="line">                 t-&gt;left = y-&gt;right;</span><br><span class="line">                 y-&gt;right = t;</span><br><span class="line">                 t = y;</span><br><span class="line">                 if (t-&gt;left == NULL)</span><br><span class="line">                 &#123;</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             r-&gt;left = t;                               /* link right */</span><br><span class="line">             r = t;</span><br><span class="line">             t = t-&gt;left;</span><br><span class="line">         &#125;     </span><br><span class="line">         else if (i &gt; t-&gt;item)</span><br><span class="line">         &#123;    </span><br><span class="line">             if (t-&gt;right == NULL)</span><br><span class="line">             &#123;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">             if (i &gt; t-&gt;right-&gt;item)</span><br><span class="line">             &#123;</span><br><span class="line">                 y = t-&gt;right;                          /* rotate left */</span><br><span class="line">                 t-&gt;right = y-&gt;left;</span><br><span class="line">                 y-&gt;left = t;</span><br><span class="line">                 t = y;</span><br><span class="line">                 if (t-&gt;right == NULL)</span><br><span class="line">                 &#123;</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             l-&gt;right = t;                              /* link left */</span><br><span class="line">             l = t;</span><br><span class="line">             t = t-&gt;right;</span><br><span class="line">         &#125;     </span><br><span class="line">         else    </span><br><span class="line">         &#123;</span><br><span class="line">             break;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     l-&gt;right = t-&gt;left;                                /* assemble */</span><br><span class="line">     r-&gt;left = t-&gt;right;</span><br><span class="line">     t-&gt;left = N.right;</span><br><span class="line">     t-&gt;right = N.left;</span><br><span class="line">     return t;</span><br><span class="line"> &#125;</span><br><span class="line">  /* Here is how sedgewick would have written this.                    */</span><br><span class="line"> /* It does the same thing.                                           */</span><br><span class="line"> Tree * sedgewickized_splay (int i, Tree * t)</span><br><span class="line"> &#123;</span><br><span class="line">     Tree N, *l, *r, *y;</span><br><span class="line">     if (t == NULL)</span><br><span class="line">     &#123;</span><br><span class="line">         return t;</span><br><span class="line">     &#125;</span><br><span class="line">     N.left = N.right = NULL;</span><br><span class="line">     l = r = &amp;N;</span><br><span class="line">     for (;;)</span><br><span class="line">     &#123;</span><br><span class="line">         if (i &lt; t-&gt;item)</span><br><span class="line">         &#123;</span><br><span class="line">             if (t-&gt;left != NULL &amp;&amp; i &lt; t-&gt;left-&gt;item)</span><br><span class="line">             &#123;</span><br><span class="line">                 y = t-&gt;left;</span><br><span class="line">                 t-&gt;left = y-&gt;right;</span><br><span class="line">                 y-&gt;right = t;</span><br><span class="line">                 t = y;</span><br><span class="line">             &#125;</span><br><span class="line">             if (t-&gt;left == NULL)</span><br><span class="line">             &#123;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">             r-&gt;left = t;</span><br><span class="line">             r = t;</span><br><span class="line">             t = t-&gt;left;</span><br><span class="line">         &#125;</span><br><span class="line">         else if (i &gt; t-&gt;item)</span><br><span class="line">         &#123;</span><br><span class="line">             if (t-&gt;right != NULL &amp;&amp; i &gt; t-&gt;right-&gt;item)</span><br><span class="line">             &#123;</span><br><span class="line">                 y = t-&gt;right;</span><br><span class="line">                 t-&gt;right = y-&gt;left;</span><br><span class="line">                 y-&gt;left = t;</span><br><span class="line">                 t = y;</span><br><span class="line">             &#125;</span><br><span class="line">             if (t-&gt;right == NULL)</span><br><span class="line">             &#123;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">             l-&gt;right = t;</span><br><span class="line">             l = t;</span><br><span class="line">             t = t-&gt;right;</span><br><span class="line">         &#125;</span><br><span class="line">         else</span><br><span class="line">         &#123;</span><br><span class="line">             break;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     l-&gt;right=t-&gt;left;</span><br><span class="line">     r-&gt;left=t-&gt;right;</span><br><span class="line">     t-&gt;left=N.right;</span><br><span class="line">     t-&gt;right=N.left;</span><br><span class="line">     return t;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> Tree * insert(int i, Tree * t)</span><br><span class="line"> &#123;</span><br><span class="line"> /* Insert i into the tree t, unless it&apos;s already there.    */</span><br><span class="line"> /* Return a pointer to the resulting tree.                 */</span><br><span class="line">     Tree * new;</span><br><span class="line">     </span><br><span class="line">     new = (Tree *) malloc (sizeof (Tree));</span><br><span class="line">     if (new == NULL)</span><br><span class="line">     &#123;</span><br><span class="line">         printf(&quot;Ran out of space\n&quot;);</span><br><span class="line">         exit(1);</span><br><span class="line">     &#125;</span><br><span class="line">     new-&gt;item = i;</span><br><span class="line">     if (t == NULL)</span><br><span class="line">     &#123;</span><br><span class="line">         new-&gt;left = new-&gt;right = NULL;</span><br><span class="line">         size = 1;</span><br><span class="line">         return new;</span><br><span class="line">     &#125;</span><br><span class="line">     t = splay(i,t);</span><br><span class="line">     if (i &lt; t-&gt;item)</span><br><span class="line">     &#123;</span><br><span class="line">         new-&gt;left = t-&gt;left;</span><br><span class="line">         new-&gt;right = t;</span><br><span class="line">         t-&gt;left = NULL;</span><br><span class="line">         size ++;</span><br><span class="line">         return new;</span><br><span class="line">     &#125;</span><br><span class="line">     else if (i &gt; t-&gt;item)</span><br><span class="line">     &#123;</span><br><span class="line">         new-&gt;right = t-&gt;right;</span><br><span class="line">         new-&gt;left = t;</span><br><span class="line">         t-&gt;right = NULL;</span><br><span class="line">         size++;</span><br><span class="line">         return new;</span><br><span class="line">     &#125;</span><br><span class="line">     else</span><br><span class="line">     &#123;</span><br><span class="line">         /* We get here if it&apos;s already in the tree */</span><br><span class="line">         /* Don&apos;t add it again                      */</span><br><span class="line">         free(new);</span><br><span class="line">         return t;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree * delete(int i, Tree * t)</span><br><span class="line">&#123;</span><br><span class="line">/* Deletes i from the tree if it&apos;s there.               */</span><br><span class="line">/* Return a pointer to the resulting tree.              */</span><br><span class="line">    Tree * x;</span><br><span class="line">    if (t==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    t = splay(i,t);</span><br><span class="line">    if (i == t-&gt;item)</span><br><span class="line">    &#123;               /* found it */</span><br><span class="line">        if (t-&gt;left == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            x = t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            x = splay(i, t-&gt;left);</span><br><span class="line">            x-&gt;right = t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        free(t);</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;                         /* It wasn&apos;t there */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argv, char *argc[])</span><br><span class="line">&#123;</span><br><span class="line">/* A sample use of these functions.  Start with the empty tree,         */</span><br><span class="line">/* insert some stuff into it, and then delete it                        */</span><br><span class="line">    Tree * root;</span><br><span class="line">    int i;</span><br><span class="line">    root = NULL;              /* the empty tree */</span><br><span class="line">    size = 0;</span><br><span class="line">    for (i = 0; i &lt; 1024; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        root = insert((541*i) &amp; (1023), root);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;size = %d\n&quot;, size);</span><br><span class="line">    for (i = 0; i &lt; 1024; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        root = delete((541*i) &amp; (1023), root);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;size = %d\n&quot;, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LCA-Tarjan"><a href="#LCA-Tarjan" class="headerlink" title="LCA(Tarjan)"></a>LCA(Tarjan)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e4 + 7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, head[maxn], fa[maxn], head_2[maxn], cnt, cnt_2, sx;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, u;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line">struct QUERY&#123;</span><br><span class="line">    int next, to, u, lca;</span><br><span class="line">&#125;query[maxn];</span><br><span class="line">void add_edge(int u, int v)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add_query(int u, int v)&#123;</span><br><span class="line">    query[cnt_2].next = head_2[u];</span><br><span class="line">    query[cnt_2].to = v;</span><br><span class="line">    query[cnt_2].u = u;</span><br><span class="line">    head_2[u] = cnt_2++;</span><br><span class="line">    query[cnt_2].next = head_2[v];</span><br><span class="line">    query[cnt_2].to = u;</span><br><span class="line">    query[cnt_2].u = v;</span><br><span class="line">    head_2[v] = cnt_2++;</span><br><span class="line">&#125;</span><br><span class="line">void init_edge()&#123;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">void init_query()&#123;</span><br><span class="line">    memset(head_2, -1, sizeof(head_2));</span><br><span class="line">    cnt_2 = 0;</span><br><span class="line">&#125;</span><br><span class="line">int root(int x)&#123;</span><br><span class="line">    return x = x == fa[x] ? x : root(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">void tarjan(int x) &#123;</span><br><span class="line">    fa[x] = x;</span><br><span class="line">    for (int i = head[x]; i != -1; i = edge[i].next) &#123;</span><br><span class="line">        int v = edge[i].to;</span><br><span class="line">        tarjan(v);</span><br><span class="line">        fa[root(v)] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = true;</span><br><span class="line">    for (int i = head_2[x]; i != -1; i = query[i].next) &#123;</span><br><span class="line">        int v = query[i].to;</span><br><span class="line">        if (vis[v]) &#123;</span><br><span class="line">            query[i].lca = query[i^1].lca = root(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    for(int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</span><br><span class="line">        add_edge(u, v);</span><br><span class="line">        vis[v] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i&lt;=n; i++)&#123;</span><br><span class="line">        if(!vis[i])&#123;</span><br><span class="line">            sx = i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</span><br><span class="line">    add_query(u, v);</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    tarjan(sx);</span><br><span class="line">    for(int i = 0; i &lt; cnt_2; i+=2)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, query[i].lca);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        init_edge();</span><br><span class="line">        init_query();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">2</span><br><span class="line">16</span><br><span class="line">1 14</span><br><span class="line">8 5</span><br><span class="line">10 16</span><br><span class="line">5 9</span><br><span class="line">4 6</span><br><span class="line">8 4</span><br><span class="line">4 10</span><br><span class="line">1 13</span><br><span class="line">6 15</span><br><span class="line">10 11</span><br><span class="line">6 7</span><br><span class="line">10 2</span><br><span class="line">16 3</span><br><span class="line">8 1</span><br><span class="line">16 12</span><br><span class="line">16 7</span><br><span class="line">5</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">3 1</span><br><span class="line">1 5</span><br><span class="line">3 5</span><br><span class="line">*/</span><br><span class="line">//4 3</span><br></pre></td></tr></table></figure>
<h2 id="RMQ"><a href="#RMQ" class="headerlink" title="RMQ"></a>RMQ</h2><h3 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn=1e5+7;</span><br><span class="line">int stmax[maxn][30];</span><br><span class="line">int stmin[maxn][30];</span><br><span class="line">int a[maxn];</span><br><span class="line"></span><br><span class="line">void rmq_st(int n)&#123;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        stmax[i][0]=stmin[i][0]=a[i];</span><br><span class="line">    int m=(int)(double(log(n))/log(2.0));</span><br><span class="line">    for(int j=1;j&lt;=m;j++)</span><br><span class="line">    for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++)&#123;</span><br><span class="line">        stmax[i][j]=max(stmax[i][j-1],stmax[i+(1&lt;&lt;j-1)][j-1]);</span><br><span class="line">        stmin[i][j]=min(stmin[i][j-1],stmin[i+(1&lt;&lt;j-1)][j-1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void rmq_query(int l,int r)&#123;</span><br><span class="line">    int k=(int)((double)log(r-l+1)/log(2.0));</span><br><span class="line">    cout&lt;&lt;&quot;Max is : &quot;&lt;&lt;max(stmax[l][k],stmax[r-(1&lt;&lt;k)+1][k])&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;Min is : &quot;&lt;&lt;min(stmin[l][k],stmin[r-(1&lt;&lt;k)+1][k])&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    rmq_st(n);</span><br><span class="line">    int l,r;</span><br><span class="line">    while(cin&gt;&gt;l&gt;&gt;r)&#123;</span><br><span class="line">        rmq_query(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/*	解释：</span><br><span class="line">		belong[x]x属于分块后的哪一块，Q[i]每个询问</span><br><span class="line">		modify(p,t)对p位置进行t修改，一般只有增加或者缩减这两种操作，具体问题具体分析</span><br><span class="line">	注意：</span><br><span class="line">		最后也可以不对询问id排序，直接保存到一个数组里面输出即可</span><br><span class="line">*/</span><br><span class="line">int a[nmax], belong[nmax];</span><br><span class="line">ll ans = 0;</span><br><span class="line">struct node &#123;int l, r, id;ll ans;&#125; Q[nmax];</span><br><span class="line">bool cmp(node a, node b) &#123;</span><br><span class="line">	if (belong[a.l] != belong[b.l]) return a.l &lt; b.l;</span><br><span class="line">	else return a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line">bool cmpid(node a, node b) &#123;return a.id &lt; b.id;&#125;</span><br><span class="line">void modify(int pos, int tag) &#123;</span><br><span class="line">	// ......... 增删操作</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);</span><br><span class="line">	int sz = sqrt(n);</span><br><span class="line">	for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">	for (int i = 1; i &lt;= m; ++i) &#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i;</span><br><span class="line">		belong[i] = (i - 1) / sz + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(Q + 1, Q + 1 + m, cmp);</span><br><span class="line">	int l = 1, r = 0;</span><br><span class="line">	for (int i = 1; i &lt;= m; ++i) &#123;</span><br><span class="line">		while (l &lt; Q[i].l) modify(l++, -1);</span><br><span class="line">		while (l &gt; Q[i].l) modify(--l, 1);</span><br><span class="line">		while (r &gt; Q[i].r) modify(r--, -1);</span><br><span class="line">		while (r &lt; Q[i].r) modify(++r, 1);</span><br><span class="line">		Q[i].ans = ans;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(Q + 1, Q + 1 + m, cmpid);</span><br><span class="line">	for (int i = 1; i &lt;= m; ++i) printf(&quot;%I64d\n&quot;, Q[i].ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=3e5+5;//区间范围</span><br><span class="line">const int MAX=1e6+5;//最大数字</span><br><span class="line">int unit,cnt[MAX],arr[N],res[N],ans=0;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">    int l,r,id;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line">bool cmp(node a,node b)&#123;</span><br><span class="line">    return a.l/unit!=b.l/unit?a.l/unit&lt;b.l/unit:a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int pos)&#123;</span><br><span class="line">    cnt[arr[pos]]++;</span><br><span class="line">    if(cnt[arr[pos]]==1)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void remove(int pos)&#123;</span><br><span class="line">    cnt[arr[pos]]--;</span><br><span class="line">    if(cnt[arr[pos]]==0)&#123;</span><br><span class="line">        ans--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    unit=sqrt(n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    int m;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r);</span><br><span class="line">        q[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(q+1,q+m+1,cmp);</span><br><span class="line"></span><br><span class="line">    int L=q[1].l,R=L-1;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        while(L&gt;q[i].l)</span><br><span class="line">            add(--L);</span><br><span class="line">        while(L&lt;q[i].l)</span><br><span class="line">            remove(L++);</span><br><span class="line">        while(R&gt;q[i].r)</span><br><span class="line">            remove(R--);</span><br><span class="line">        while(R&lt;q[i].r)</span><br><span class="line">            add(++R);</span><br><span class="line">        res[q[i].id]=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int nValue,nKind;</span><br><span class="line">//0-1 背包，代价为 cost, 获得的价值为 weight</span><br><span class="line">void ZeroOnePack(int cost,int weight)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=nValue; i&gt;=cost; i−−)</span><br><span class="line">        dp[i]=max(dp[i],dp[i−cost]+weight);</span><br><span class="line">&#125;</span><br><span class="line">//完全背包，代价为 cost, 获得的价值为 weight</span><br><span class="line">void CompletePack(int cost,int weight)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=cost; i&lt;=nValue; i++)</span><br><span class="line">        dp[i]=max(dp[i],dp[i−cost]+weight);</span><br><span class="line">&#125;</span><br><span class="line">//多重背包</span><br><span class="line">void MultiplePack(int cost,int weight,int amount)</span><br><span class="line">&#123;</span><br><span class="line">    if(cost*amount&gt;=nValue)</span><br><span class="line">        CompletePack(cost,weight);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        int k=1;</span><br><span class="line">        while(k&lt;amount)</span><br><span class="line">        &#123;</span><br><span class="line">            ZeroOnePack(k*cost,k*weight);</span><br><span class="line">            amount−=k;</span><br><span class="line">            k&lt;&lt;=1;</span><br><span class="line">        &#125;</span><br><span class="line">        ZeroOnePack(amount*cost,amount*weight);//这个不要忘记了，经常掉了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//分组背包：</span><br><span class="line">for k = 1 to K</span><br><span class="line">for v = V to 0</span><br><span class="line">for item i in group k</span><br><span class="line">F[v] = maxF[v],F[v-Ci]+Wi</span><br></pre></td></tr></table></figure>
<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const int MAXN=500010;</span><br><span class="line">int a[MAXN],b[MAXN]//用二分查找的方法找到一个位置，使得 num&gt;b[i-1] 并且 num&lt;b[i], 并用 num 代替</span><br><span class="line">b[i]int Search(int num,int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">    int mid;</span><br><span class="line">    while(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(low+high)/2;</span><br><span class="line">        if(num&gt;=b[mid])</span><br><span class="line">            low=mid+1;</span><br><span class="line">        else</span><br><span class="line">            high=mid−1;</span><br><span class="line">    &#125;</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br><span class="line">int DP(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,len,pos;</span><br><span class="line">    b[1]=a[1];</span><br><span class="line">    len=1;</span><br><span class="line">    for(i=2; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]&gt;=b[len])//如果 a[i] 比 b[] 数组中最大还大直接插入到后面即可</span><br><span class="line">        &#123;</span><br><span class="line">            len=len+1;</span><br><span class="line">            b[len]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        else //用二分的方法在 b[] 数组中找出第一个比 a[i] 大的位置并且让a[i] 替代这个位置</span><br><span class="line">        &#123;</span><br><span class="line">            pos=Search(a[i],1,len);</span><br><span class="line">            b[pos]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">const int MAXN = 1005;</span><br><span class="line"> </span><br><span class="line">int DP[MAXN][MAXN];</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	string a;</span><br><span class="line">	string b;</span><br><span class="line">	while(cin &gt;&gt; a &gt;&gt; b)</span><br><span class="line">	&#123;</span><br><span class="line">		int l1 = a.size();</span><br><span class="line">		int l2 = b.size();</span><br><span class="line">		memset(DP, 0, sizeof(DP)); </span><br><span class="line">		for(int i = 1; i &lt;= l1; i++)</span><br><span class="line">			for(int j = 1; j &lt;= l2; j++)</span><br><span class="line">				if(a[i - 1] == b[j - 1])</span><br><span class="line">					DP[i][j] = max(DP[i][j], DP[i - 1][j - 1] + 1);</span><br><span class="line">				else</span><br><span class="line">					DP[i][j] = max(DP[i][j - 1], DP[i - 1][j]);</span><br><span class="line">		printf(&quot;%d\n&quot;, DP[l1][l2]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="概率dp"><a href="#概率dp" class="headerlink" title="概率dp"></a>概率dp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">POJ 2096</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">POJ 2096</span><br><span class="line">概率DP</span><br><span class="line"></span><br><span class="line">dp求期望</span><br><span class="line">逆着递推求解</span><br><span class="line">题意：（题意看题目确实比较难道，n和s都要找半天才能找到）</span><br><span class="line">   一个软件有s个子系统，会产生n种bug</span><br><span class="line">   某人一天发现一个bug,这个bug属于一个子系统，属于一个分类</span><br><span class="line">   每个bug属于某个子系统的概率是1/s,属于某种分类的概率是1/n</span><br><span class="line">   问发现n种bug,每个子系统都发现bug的天数的期望。</span><br><span class="line"></span><br><span class="line">求解：</span><br><span class="line">         dp[i][j]表示已经找到i种bug,j个系统的bug，达到目标状态的天数的期望</span><br><span class="line">         dp[n][s]=0;要求的答案是dp[0][0];</span><br><span class="line">         dp[i][j]可以转化成以下四种状态:</span><br><span class="line">              dp[i][j],发现一个bug属于已经有的i个分类和j个系统。概率为(i/n)*(j/s);</span><br><span class="line">              dp[i][j+1],发现一个bug属于已有的分类，不属于已有的系统.概率为 (i/n)*(1-j/s);</span><br><span class="line">              dp[i+1][j],发现一个bug属于已有的系统，不属于已有的分类,概率为 (1-i/n)*(j/s);</span><br><span class="line">              dp[i+1][j+1],发现一个bug不属于已有的系统，不属于已有的分类,概率为 (1-i/n)*(1-j/s);</span><br><span class="line">        整理便得到转移方程</span><br><span class="line">*/</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1010;</span><br><span class="line">double dp[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,s;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;s)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[n][s]=0;</span><br><span class="line">        for(int i=n;i&gt;=0;i--)</span><br><span class="line">          for(int j=s;j&gt;=0;j--)</span><br><span class="line">          &#123;</span><br><span class="line">              if(i==n&amp;&amp;j==s)continue;</span><br><span class="line">              dp[i][j]=(i*(s-j)*dp[i][j+1]+(n-i)*j*dp[i+1][j]+(n-i)*(s-j)*dp[i+1][j+1]+n*s)/(n*s-i*j);</span><br><span class="line">          &#125;</span><br><span class="line">        printf(&quot;%.4lf\n&quot;,dp[0][0]);//POJ上G++要改成%.4f</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="轮廓线dp"><a href="#轮廓线dp" class="headerlink" title="轮廓线dp"></a>轮廓线dp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">HDU 4285</span><br><span class="line">要形成刚好 K 条回路的方法数要避免环套环的情况。</span><br><span class="line">所以形成回路时，要保证两边的插头数是偶数</span><br><span class="line">G++ 11265ms 11820K</span><br><span class="line">C++ 10656ms 11764K</span><br><span class="line">*/</span><br><span class="line">const int MAXD=15;</span><br><span class="line">const int STATE=1000010;</span><br><span class="line">const int HASH=300007;//这个大一点可以防止 TLE, 但是容易 MLE</span><br><span class="line">const int MOD=1000000007;</span><br><span class="line">int N,M,K;</span><br><span class="line">int maze[MAXD][MAXD];</span><br><span class="line">int code[MAXD];</span><br><span class="line">int ch[MAXD];</span><br><span class="line">int num;//圈的个数</span><br><span class="line">struct HASHMAP</span><br><span class="line">&#123;</span><br><span class="line">    int head[HASH],next[STATE],size;</span><br><span class="line">    long long state[STATE];</span><br><span class="line">    int f[STATE];</span><br><span class="line">    void init()</span><br><span class="line">    &#123;</span><br><span class="line">        size=0;</span><br><span class="line">        memset(head,−1,sizeof(head));</span><br><span class="line">    &#125; void push(long long st,int ans)</span><br><span class="line">    &#123;</span><br><span class="line">        int i;</span><br><span class="line">        int h=st%HASH;</span><br><span class="line">        for(i=head[h]; i!=−1; i=next[i])</span><br><span class="line">            if(state[i]==st)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i]+=ans;</span><br><span class="line">                f[i]%=MOD;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        state[size]=st;</span><br><span class="line">        f[size]=ans;</span><br><span class="line">        next[size]=head[h];</span><br><span class="line">        head[h]=size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; hm[2];</span><br><span class="line">void decode(int *code,int m,long long st)</span><br><span class="line">&#123;</span><br><span class="line">    num=st&amp;63;</span><br><span class="line">    st&gt;&gt;=6;</span><br><span class="line">    for(int i=m; i&gt;=0; i−−)</span><br><span class="line">    &#123;</span><br><span class="line">        code[i]=st&amp;7;</span><br><span class="line">        st&gt;&gt;=3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">long long encode(int *code,int m)//最小表示法</span><br><span class="line">&#123;</span><br><span class="line">    int cnt=1;</span><br><span class="line">    memset(ch,−1,sizeof(ch));</span><br><span class="line">    ch[0]=0;</span><br><span class="line">    long long st=0;</span><br><span class="line">    for(int i=0; i&lt;=m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(ch[code[i]]==−1)</span><br><span class="line">            ch[code[i]]=cnt++;</span><br><span class="line">        code[i]=ch[code[i]];</span><br><span class="line">        st&lt;&lt;=3;</span><br><span class="line">        st|=code[i];</span><br><span class="line">    &#125;</span><br><span class="line">    st&lt;&lt;=6;</span><br><span class="line">    st|=num;</span><br><span class="line">    return st;</span><br><span class="line">&#125;</span><br><span class="line">void shift(int *code,int m)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=m; i&gt;0; i−−)</span><br><span class="line">        code[i]=code[i−1];</span><br><span class="line">    code[0]=0;</span><br><span class="line">&#125;</span><br><span class="line">void dpblank(int i,int j,int cur)</span><br><span class="line">&#123;</span><br><span class="line">    int k,left,up;</span><br><span class="line">    for(k=0; k&lt;hm[cur].size; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        decode(code,M,hm[cur].state[k]);</span><br><span class="line">        left=code[j−1];</span><br><span class="line">        up=code[j];</span><br><span class="line">        if(left&amp;&amp;up)</span><br><span class="line">        &#123;</span><br><span class="line">            if(left==up)</span><br><span class="line">            &#123;</span><br><span class="line">                if(num&gt;=K)</span><br><span class="line">                    continue;</span><br><span class="line">                int t=0;//要避免环套环的情况，需要两边插头数为偶数</span><br><span class="line">                for(int p=0; p&lt;j−1; p++)</span><br><span class="line">                    if(code[p])</span><br><span class="line">                        t++;</span><br><span class="line">                if(t&amp;1)</span><br><span class="line">                    continue;</span><br><span class="line">                if(num&lt;K)</span><br><span class="line">                &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    code[j−1]=code[j]=0;</span><br><span class="line">                    hm[cur^1].push(encode(code,j==M?M−1:M),hm[cur].f[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                code[j−1]=code[j]=0;</span><br><span class="line">                for(int t=0; t&lt;=M; t++)</span><br><span class="line">                    if(code[t]==up)</span><br><span class="line">                        code[t]=left;</span><br><span class="line">                hm[cur^1].push(encode(code,j==M?M−1:M),hm[cur].f[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(left||up)</span><br><span class="line">        &#123;</span><br><span class="line">            int t;</span><br><span class="line">            if(left)</span><br><span class="line">                t=left;</span><br><span class="line">            else</span><br><span class="line">                t=up;</span><br><span class="line">            if(maze[i][j+1])</span><br><span class="line">            &#123;</span><br><span class="line">                code[j−1]=0;</span><br><span class="line">                code[j]=t;</span><br><span class="line">                hm[cur^1].push(encode(code,M),hm[cur].f[k]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(maze[i+1][j])</span><br><span class="line">            &#123;</span><br><span class="line">                code[j]=0;</span><br><span class="line">                code[j−1]=t;</span><br><span class="line">                hm[cur^1].push(encode(code,j==M?M−1:M),hm[cur].f[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(maze[i][j+1]&amp;&amp;maze[i+1][j])</span><br><span class="line">            &#123;</span><br><span class="line">                code[j−1]=code[j]=13;</span><br><span class="line">                hm[cur^1].push(encode(code,j==M?M−1:M),hm[cur].f[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dpblock(int i,int j,int cur)</span><br><span class="line">&#123;</span><br><span class="line">    int k;</span><br><span class="line">    for(k=0; k&lt;hm[cur].size; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        decode(code,M,hm[cur].state[k]);</span><br><span class="line">        code[j−1]=code[j]=0;</span><br><span class="line">        hm[cur^1].push(encode(code,j==M?M−1:M),hm[cur].f[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">char str[20];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;N,&amp;M,&amp;K);</span><br><span class="line">    memset(maze,0,sizeof(maze));</span><br><span class="line">    for(int i=1; i&lt;=N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%s&quot;,&amp;str);</span><br><span class="line">        for(int j=1; j&lt;=M; j++)</span><br><span class="line">            if(str[j−1]==&apos;.&apos;)</span><br><span class="line">                maze[i][j]=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,cur=0;</span><br><span class="line">    hm[cur].init();</span><br><span class="line">    hm[cur].push(0,1);</span><br><span class="line">    for(i=1; i&lt;=N; i++)</span><br><span class="line">        for(j=1; j&lt;=M; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            hm[cur^1].init();</span><br><span class="line">            if(maze[i][j])</span><br><span class="line">                dpblank(i,j,cur);</span><br><span class="line">            else</span><br><span class="line">                dpblock(i,j,cur);</span><br><span class="line">            cur^=1;</span><br><span class="line">        &#125;</span><br><span class="line">    int ans=0;</span><br><span class="line">    for(i=0; i&lt;hm[cur].size; i++)</span><br><span class="line">        if(hm[cur].state[i]==K)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=hm[cur].f[i];</span><br><span class="line">            ans%=MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T−−)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">Sample Input</span><br><span class="line"> 4 4 1</span><br><span class="line"> **..</span><br><span class="line"> ....</span><br><span class="line"> ....</span><br><span class="line"> ....</span><br><span class="line"> 4 1</span><br><span class="line"> ....</span><br><span class="line"> ....</span><br><span class="line"> ....</span><br><span class="line"> ....</span><br><span class="line">Sample Output</span><br><span class="line"> 6</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="Dijkstra-邻接矩阵"><a href="#Dijkstra-邻接矩阵" class="headerlink" title="Dijkstra(邻接矩阵)"></a>Dijkstra(邻接矩阵)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 3007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int road[maxn][maxn];</span><br><span class="line">int dis[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(road, inf, sizeof(road));</span><br><span class="line">&#125;</span><br><span class="line">int dijkstra(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    for(int u = 1; u&lt;=n; u++)&#123;</span><br><span class="line">        int minD = inf, k = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i] &amp;&amp; dis[i] &lt; minD)&#123;</span><br><span class="line">                k = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //if(k == ex)</span><br><span class="line">        //    return dis[ex];</span><br><span class="line">        vis[k] = true;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i] &amp;&amp; dis[k] + road[k][i] &lt; dis[i])&#123;</span><br><span class="line">                dis[i] = dis[k] + road[k][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v, w;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        road[u][v] = min(road[u][v], w);</span><br><span class="line">        //road[v][u] = min(road[v][u], w);  //双向边</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, dijkstra(sx, ex));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 3007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;4];</span><br><span class="line">int head[maxn], dis[maxn], cnt;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">int dijkstra(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    for(int cas = 1; cas&lt;=n; cas++)&#123;</span><br><span class="line">        int minD = inf, kk = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i] &amp;&amp; dis[i] &lt; minD)&#123;</span><br><span class="line">                kk = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //if(kk == ex)</span><br><span class="line">        //    return dis[ex];</span><br><span class="line">        vis[kk] = true;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            int v = edge[i].to;</span><br><span class="line">            if(!vis[v] &amp;&amp; dis[kk] + edge[i].w &lt; dis[v])&#123;</span><br><span class="line">                dis[v] = dis[kk] + edge[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v, w;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        //add(v, u, w);  //双向边</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, dijkstra(sx, ex));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dijkstra-heap"><a href="#Dijkstra-heap" class="headerlink" title="Dijkstra+heap"></a>Dijkstra+heap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 3007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;4];</span><br><span class="line">int head[maxn], dis[maxn], cnt;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int u;</span><br><span class="line">    int dis;</span><br><span class="line">    NODE()&#123;&#125;</span><br><span class="line">    NODE(int x, int y) : u(x), dis(y)&#123;&#125;</span><br><span class="line">    bool operator &lt;(const NODE &amp;a)const&#123;</span><br><span class="line">		return dis&gt;a.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">int dijkstra(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    priority_queue&lt;NODE&gt;que;</span><br><span class="line">    que.push(NODE(sx, 0));</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        NODE tmp = que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        int kk = tmp.u;</span><br><span class="line">        if(vis[kk])&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[kk] = true;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            int v = edge[i].to;</span><br><span class="line">            if(!vis[v] &amp;&amp; dis[kk] + edge[i].w &lt; dis[v])&#123;</span><br><span class="line">                dis[v] = dis[kk] + edge[i].w;</span><br><span class="line">                que.push(NODE(v, dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    int u, v, w;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        add(v, u, w);  //双向边</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, dijkstra(sx, ex));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">const int maxn = 1e3+7;</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">int head[maxn], dis[maxn], cnt;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, w, u;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">int SPFA(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[kk] = false;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            int v = edge[i].to;</span><br><span class="line">            if(dis[v] &gt; dis[kk] + edge[i].w)&#123;</span><br><span class="line">                dis[v] = dis[kk] + edge[i].w;</span><br><span class="line">                if(!vis[v])&#123;</span><br><span class="line">                    vis[v] = true;</span><br><span class="line">                    que.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        sx = 1, ex = n;</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            add(u, v, w);</span><br><span class="line">            //add(v, u, w);   //双向边</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, SPFA(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SPFA-SLF优化"><a href="#SPFA-SLF优化" class="headerlink" title="SPFA+SLF优化"></a>SPFA+SLF优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN=1e2;</span><br><span class="line"></span><br><span class="line">int phi[MAXN],n,tot;</span><br><span class="line">int pri[MAXN];</span><br><span class="line">bool mark[MAXN];</span><br><span class="line"></span><br><span class="line">void getphi()&#123;</span><br><span class="line">    phi[1]=1;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!mark[i])&#123;</span><br><span class="line">            phi[i]=i-1;</span><br><span class="line">            pri[++tot]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=1;j&lt;=tot;j++)&#123;</span><br><span class="line">            int x=pri[j];</span><br><span class="line">            if(i*x&gt;n) break;</span><br><span class="line">            mark[i*x]=1;</span><br><span class="line">            if(i%x==0)&#123;</span><br><span class="line">                phi[i*x]=phi[i]*x;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else phi[i*x]=phi[i]*phi[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">        tot=0;</span><br><span class="line">        getphi();</span><br><span class="line"></span><br><span class="line">            printf(&quot;%d\n&quot;,phi[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(k=1; k&lt;=n; k++)</span><br><span class="line">    for(i=1; i&lt;=n; i++)</span><br><span class="line">        for(j=1; j&lt;=n; j++)</span><br><span class="line">            if(e[i][j]&gt;e[i][k]+e[k][j])</span><br><span class="line">                e[i][j]=e[i][k]+e[k][j];</span><br></pre></td></tr></table></figure>
<h3 id="K短路"><a href="#K短路" class="headerlink" title="K短路"></a>K短路</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * poj</span><br><span class="line"> * Problem#2449</span><br><span class="line"> * Accepted</span><br><span class="line"> * Time: 438ms</span><br><span class="line"> * Memory: 15196k </span><br><span class="line"> */</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef bool boolean;</span><br><span class="line"></span><br><span class="line">#define pii pair&lt;int, int&gt;</span><br><span class="line">#define fi first</span><br><span class="line">#define sc second</span><br><span class="line"></span><br><span class="line">typedef class Node &#123;</span><br><span class="line">    public:</span><br><span class="line">        int val, ed;</span><br><span class="line">        Node *l, *r;</span><br><span class="line">        </span><br><span class="line">        Node()    &#123;        &#125;</span><br><span class="line">        Node(int val, int ed, Node *l, Node *r):val(val), ed(ed), l(l), r(r) &#123;        &#125;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">#define Limit 1000000</span><br><span class="line"></span><br><span class="line">Node pool[Limit];</span><br><span class="line">Node* top = pool;</span><br><span class="line"></span><br><span class="line">Node* newnode(int val, int ed) &#123;</span><br><span class="line">    if(top &gt;= pool + Limit)</span><br><span class="line">        return new Node(val, ed, NULL, NULL);</span><br><span class="line">    top-&gt;val = val, top-&gt;ed = ed, top-&gt;l = top-&gt;r = NULL;</span><br><span class="line">    return top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* merge(Node* a, Node* b) &#123;</span><br><span class="line">    if (!a)    return b;</span><br><span class="line">    if (!b)    return a;</span><br><span class="line">    if (a-&gt;val &gt; b-&gt;val)    swap(a, b);</span><br><span class="line">    Node* p = newnode(a-&gt;val, a-&gt;ed);</span><br><span class="line">    p-&gt;l = a-&gt;l, p-&gt;r = a-&gt;r;</span><br><span class="line">    p-&gt;r = merge(p-&gt;r, b);</span><br><span class="line">    swap(p-&gt;l, p-&gt;r);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef class Status &#123;</span><br><span class="line">    public:</span><br><span class="line">        int dist;</span><br><span class="line">        Node* p;</span><br><span class="line">        </span><br><span class="line">        Status(int dist = 0, Node* p = NULL):dist(dist), p(p) &#123;        &#125;</span><br><span class="line"></span><br><span class="line">        boolean operator &lt; (Status b) const &#123;</span><br><span class="line">            return dist &gt; b.dist;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;Status;</span><br><span class="line"></span><br><span class="line">typedef class Edge &#123;</span><br><span class="line">    public:</span><br><span class="line">        int end, next, w;</span><br><span class="line">        </span><br><span class="line">        Edge(int end = 0, int next = 0, int w = 0):end(end), next(next), w(w) &#123;        &#125;</span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line">typedef class MapManager &#123;</span><br><span class="line">    public:</span><br><span class="line">        int ce;</span><br><span class="line">        int* h;</span><br><span class="line">        Edge* es;</span><br><span class="line">        </span><br><span class="line">        MapManager() &#123;            &#125;</span><br><span class="line">        MapManager(int n, int m):ce(0) &#123;</span><br><span class="line">            h = new int[(n + 1)];</span><br><span class="line">            es = new Edge[(m + 5)];</span><br><span class="line">            memset(h, 0, sizeof(int) * (n + 1));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        void addEdge(int u, int v, int w) &#123;</span><br><span class="line">            es[++ce] = Edge(v, h[u], w);</span><br><span class="line">            h[u] = ce;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Edge&amp; operator [] (int pos) &#123;</span><br><span class="line">            return es[pos];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;MapManager;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int s, t, k;</span><br><span class="line">MapManager g;</span><br><span class="line">MapManager rg;</span><br><span class="line">boolean *vis;</span><br><span class="line">int* f, *lase;</span><br><span class="line"></span><br><span class="line">inline void init() &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    g = MapManager(n, m);</span><br><span class="line">    rg = MapManager(n, m);</span><br><span class="line">    for (int i = 1, u, v, w; i &lt;= m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        g.addEdge(u, v, w);</span><br><span class="line">        rg.addEdge(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;, &amp;s, &amp;t, &amp;k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt; que;</span><br><span class="line">void spfa(MapManager&amp; g, int s) &#123;</span><br><span class="line">    vis = new boolean[(n + 1)];</span><br><span class="line">    f = new int[(n + 1)];</span><br><span class="line">    lase = new int[(n + 1)];</span><br><span class="line">    memset(f, 0x7f, sizeof(int) * (n + 1));</span><br><span class="line">    memset(vis, false, sizeof(boolean) * (n + 1));</span><br><span class="line">    que.push(s);</span><br><span class="line">    f[s] = 0, lase[s] = 0;</span><br><span class="line">    while (!que.empty()) &#123;</span><br><span class="line">        int e = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[e] = false;</span><br><span class="line">        for (int i = g.h[e]; i; i = g[i].next) &#123;</span><br><span class="line">            int eu = g[i].end, w = g[i].w;</span><br><span class="line">            if (f[e] + w &lt; f[eu]) &#123;</span><br><span class="line">                f[eu] = f[e] + w, lase[eu] = i;</span><br><span class="line">                if (!vis[eu]) &#123;</span><br><span class="line">                    vis[eu] = true;</span><br><span class="line">                    que.push(eu); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">Node** hs;</span><br><span class="line">inline void rebuild() &#123;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">        for (int j = g.h[i]; j; j = g[j].next) &#123;</span><br><span class="line">            int e = g[j].end;</span><br><span class="line">            if (lase[i] != j)</span><br><span class="line">                g[j].w += f[e] - f[i];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    hs = new Node*[(n + 1)];</span><br><span class="line">    que.push(t);</span><br><span class="line">    hs[t] = NULL;</span><br><span class="line">    while (!que.empty()) &#123;</span><br><span class="line">        int e = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        if (lase[e])</span><br><span class="line">            hs[e] = hs[g[lase[e]].end];</span><br><span class="line">        for (int i = g.h[e]; i; i = g[i].next)</span><br><span class="line">            if (lase[e] != i &amp;&amp; f[g[i].end] != 0x7f7f7f7f)</span><br><span class="line">                hs[e] = merge(hs[e], new Node(g[i].w, g[i].end, NULL, NULL));</span><br><span class="line">        for (int i = rg.h[e]; i; i = rg[i].next) &#123;</span><br><span class="line">            int eu = rg[i].end;</span><br><span class="line">            if (lase[eu] == i)</span><br><span class="line">                que.push(eu);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int kthpath(int k) &#123;</span><br><span class="line">    if (s == t)</span><br><span class="line">        k++;</span><br><span class="line">    if (f[s] == 0x7f7f7f7f)</span><br><span class="line">        return -1;</span><br><span class="line">    if (k == 1)</span><br><span class="line">        return f[s];</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;Status&gt; q;</span><br><span class="line">    if (!hs[s])</span><br><span class="line">        return -1;</span><br><span class="line">        </span><br><span class="line">    q.push(Status(hs[s]-&gt;val, hs[s]));</span><br><span class="line">    while (--k &amp;&amp; !q.empty()) &#123;</span><br><span class="line">        Status e = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        if(k == 1)</span><br><span class="line">            return e.dist + f[s];</span><br><span class="line">        </span><br><span class="line">        int eu = e.p-&gt;ed;</span><br><span class="line">        if (hs[eu])</span><br><span class="line">            q.push(Status(e.dist + hs[eu]-&gt;val, hs[eu]));</span><br><span class="line">        if (e.p-&gt;l)</span><br><span class="line">            q.push(Status(e.dist - e.p-&gt;val + e.p-&gt;l-&gt;val, e.p-&gt;l));</span><br><span class="line">        if (e.p-&gt;r)</span><br><span class="line">            q.push(Status(e.dist - e.p-&gt;val + e.p-&gt;r-&gt;val, e.p-&gt;r));</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void solve() &#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, kthpath(k));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    spfa(rg, t);</span><br><span class="line">    rebuild();</span><br><span class="line">    solve();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//最短路算法+可持久化堆</span><br></pre></td></tr></table></figure>
<h2 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h2><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//并查集实现最小生成树</span><br><span class="line">vector&lt;int&gt; u, v, weights, w_r, father;</span><br><span class="line">int mycmp(int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    return weights[i] &lt; weights[j];</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return father[x] == x ? x : father[x] = find(father[x]);</span><br><span class="line">&#125;</span><br><span class="line">void kruskal_test()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; A(n, vector&lt;int&gt;(n));</span><br><span class="line">    for(int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int edges = 0;</span><br><span class="line">    // 共计n*(n - 1)/2条边</span><br><span class="line">    for (int i = 0; i &lt; n - 1; ++i) &#123;</span><br><span class="line">        for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class="line">            u.push_back(i);</span><br><span class="line">            v.push_back(j);</span><br><span class="line">            weights.push_back(A[i][j]);</span><br><span class="line">            w_r.push_back(edges++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        father.push_back(i);    // 记录n个节点的根节点，初始化为各自本身</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(w_r.begin(), w_r.end(), mycmp); //以weight的大小来对索引值进行排序</span><br><span class="line"></span><br><span class="line">    int min_tree = 0, cnt = 0;</span><br><span class="line">    for (int i = 0; i &lt; edges; ++i) &#123;</span><br><span class="line">        int e = w_r[i];    //e代表排序后的权值的索引</span><br><span class="line">        int x = find(u[e]), y = find(v[e]);</span><br><span class="line">        //x不等于y表示u[e]和v[e]两个节点没有公共根节点，可以合并</span><br><span class="line">        if (x != y) &#123;</span><br><span class="line">            min_tree += weights[e];</span><br><span class="line">            father[x] = y;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (cnt &lt; n - 1) min_tree = 0;</span><br><span class="line">    cout &lt;&lt; min_tree &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    kruskal_test();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//Prim算法实现</span><br><span class="line">void prim_test()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; A(n, vector&lt;int&gt;(n));</span><br><span class="line">    for(int i = 0; i &lt; n ; ++i) &#123;</span><br><span class="line">        for(int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pos, minimum;</span><br><span class="line">    int min_tree = 0;</span><br><span class="line">    //lowcost数组记录每2个点间最小权值，visited数组标记某点是否已访问</span><br><span class="line">    vector&lt;int&gt; visited, lowcost;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        visited.push_back(0);    //初始化为0，表示都没加入</span><br><span class="line">    &#125;</span><br><span class="line">    visited[0] = 1;   //最小生成树从第一个顶点开始</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        lowcost.push_back(A[0][i]);    //权值初始化为0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;    //枚举n个顶点</span><br><span class="line">        minimum = max_int;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;    //找到最小权边对应顶点</span><br><span class="line">            if(!visited[j] &amp;&amp; minimum &gt; lowcost[j]) &#123;</span><br><span class="line">                minimum = lowcost[j];</span><br><span class="line">                pos = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (minimum == max_int)    //如果min = max_int表示已经不再有点可以加入最小生成树中</span><br><span class="line">            break;</span><br><span class="line">        min_tree += minimum;</span><br><span class="line">        visited[pos] = 1;     //加入最小生成树中</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            if(!visited[j] &amp;&amp; lowcost[j] &gt; A[pos][j]) lowcost[j] = A[pos][j];   //更新可更新边的权值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; min_tree &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    prim_test();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line">const int MAXN = 500;</span><br><span class="line">const int MAXE = 500 * 500;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">int pre[MAXN + 7];</span><br><span class="line"></span><br><span class="line">void initPre(int n)&#123; for(int i = 0; i &lt;= n; i++) pre[i] = i; &#125;</span><br><span class="line"></span><br><span class="line">//并查集</span><br><span class="line">int Find(int x)&#123; return x == pre[x] ? x : pre[x] = Find(pre[x]); &#125;</span><br><span class="line"></span><br><span class="line">void merge(int x, int y)&#123; int fx = Find(x), fy = Find(y); if(fx != fy) pre[fx] = fy; &#125;</span><br><span class="line"></span><br><span class="line">struct Edge&#123; //前向星存边</span><br><span class="line">    int u, v; //起点  终点 </span><br><span class="line">    int w;</span><br><span class="line">    bool select;</span><br><span class="line">&#125;edge[MAXE + 7];</span><br><span class="line"></span><br><span class="line">bool cmp(Edge a, Edge b)&#123;</span><br><span class="line">    if(a.w != b.w) return a.w &lt; b.w;</span><br><span class="line">    if(a.u != b.u) return a.u &lt; b.u;</span><br><span class="line">    return a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Node&#123;//链式前向星 用于存储每个集合里面的边</span><br><span class="line">    int to;</span><br><span class="line">    int next;</span><br><span class="line">&#125;link[MAXN + 7];</span><br><span class="line"></span><br><span class="line">int head[MAXN + 7];//邻接表的头结点的位置</span><br><span class="line">int End[MAXN + 7];//邻接表的尾节点的位置</span><br><span class="line">int length[MAXN + 7][MAXN + 7];//最小生成树中任意两点路径上的最长边 </span><br><span class="line"></span><br><span class="line">int kruskal(int n, int m)&#123;</span><br><span class="line">    //初始化邻接表,对于每一个顶点添加一个指向自身的边,表示以i为代表元的集合中只有点i</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">        link[i].to = i, link[i].next = head[i];</span><br><span class="line">        End[i] = i, head[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(edge + 1, edge + 1 + m, cmp);</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for(int i = 1; i &lt;= m; i++)&#123;</span><br><span class="line">        if(cnt == n - 1) break;//当找到的边数等于节点数-1,说明mst已经找到</span><br><span class="line">        int fx = Find(edge[i].u);</span><br><span class="line">        int fy = Find(edge[i].v);</span><br><span class="line">        if(fx != fy)&#123;</span><br><span class="line">            for(int j = head[fx]; j != -1; j = link[j].next)//修改length数组 </span><br><span class="line">                for(int k = head[fy]; k != -1; k = link[k].next)</span><br><span class="line">                //每次合并两个等价类的之后,分别属于两个等价类的两个节点之间的最长边一定是当前加入的边</span><br><span class="line">                    length[link[j].to][link[k].to] = length[link[k].to][link[j].to] = edge[i].w;</span><br><span class="line">            //合并邻接表</span><br><span class="line">            link[End[fy]].next = head[fx];</span><br><span class="line">            End[fy] = End[fx];</span><br><span class="line">            merge(fx, fy);</span><br><span class="line">            cnt++;</span><br><span class="line">            edge[i].select = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cnt &lt; n - 1) return -1;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //初始化建图后执行以下操作</span><br><span class="line">    int flag = kruskal(n, m);</span><br><span class="line">    int mst = 0;</span><br><span class="line">    for(int i = 1; i &lt;= m; i++) if(edge[i].select) mst += edge[i].w;//计算出最小生成树</span><br><span class="line">    int secmst = INF;</span><br><span class="line">    //在 T/(u,v) + (x, y)中寻得次小生成树</span><br><span class="line">    for(int i = 1; i &lt;= m; i++) if(!edge[i].select) secmst = min(secmst, mst + edge[i].w - length[edge[i].u][edge[i].v]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*hdu1285--采用二维数组记录两者之间的关系*/</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int map[510][510];//前驱数量 </span><br><span class="line">int indegree[510];</span><br><span class="line">int queue[510];//保存拓扑序列 </span><br><span class="line">void topo(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,m,t=0;</span><br><span class="line">    for(j=1;j&lt;=n;j++)&#123;</span><br><span class="line">        for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(indegree[i]==0)&#123;//找出前驱数量为零的的点即每次找到第一名 </span><br><span class="line">                m=i;break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[t++]=m;indegree[m]=-1;//将第一名的前驱数量设为-1 </span><br><span class="line">        for(i=1;i&lt;=n;++i)&#123;//第二步将前驱中含有第一名的点前驱数量减1 </span><br><span class="line">            if(map[m][i])indegree[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,queue[0]);//输出拓扑序列 </span><br><span class="line">    for(i=1;i&lt;n;++i)&#123;</span><br><span class="line">        printf(&quot; %d&quot;,queue[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,i,j,a,b;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">        memset(indegree,0,sizeof(indegree));//初始化 </span><br><span class="line">        memset(map,0,sizeof(map));</span><br><span class="line">        for(i=0;i&lt;m;++i)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">            if(map[a][b]==0)&#123; //避免重复的数据输入 </span><br><span class="line">                map[a][b]=1;indegree[b]++;//第一步记录关系和点的前驱数量 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        topo(n);//调用拓扑排序 </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><h3 id="FF"><a href="#FF" class="headerlink" title="FF"></a>FF</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#define maxn 1200</span><br><span class="line">#define INF 2e9</span><br><span class="line">using namespace std;</span><br><span class="line">int i,j,k,n,m,h,t,tot,ans,st,en;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int c,f;</span><br><span class="line">&#125;edge[maxn][maxn];</span><br><span class="line">int flag[maxn],pre[maxn],alpha[maxn],q[maxn],v;</span><br><span class="line">int read()&#123;</span><br><span class="line">    char c;int x;while(c=getchar(),c&lt;&apos;0&apos;||c&gt;&apos;9&apos;);x=c-&apos;0&apos;;</span><br><span class="line">    while(c=getchar(),c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;) x=x*10+c-&apos;0&apos;;return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bfs()&#123;</span><br><span class="line">    memset(flag,0xff,sizeof(flag));memset(pre,0xff,sizeof(pre));memset(alpha,0xff,sizeof(alpha));</span><br><span class="line">    flag[st]=0;pre[st]=0;alpha[st]=INF;h=0,t=1;q[t]=st;</span><br><span class="line">    while(h&lt;t)&#123;</span><br><span class="line">        h++;v=q[h];</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(flag[i]==-1)&#123;</span><br><span class="line">                if(edge[v][i].c&lt;INF&amp;&amp;edge[v][i].f&lt;edge[v][i].c)&#123;</span><br><span class="line">                    flag[i]=0;pre[i]=v;alpha[i]=min(alpha[v],edge[v][i].c-edge[v][i].f);q[++t]=i;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(edge[i][v].c&lt;INF&amp;&amp;edge[i][v].f&gt;0)&#123;</span><br><span class="line">                    flag[i]=0;pre[i]=-v;alpha[i]=min(alpha[v],edge[i][v].f);q[++t]=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[v]=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Ford_Fulkerson()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        bfs();</span><br><span class="line">        if(alpha[en]==0||flag[en]==-1)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        int k1=en,k2=abs(pre[k1]);int a=alpha[en];</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            if(edge[k2][k1].c&lt;INF) edge[k2][k1].f+=a;</span><br><span class="line">            else if(edge[k1][k2].c&lt;INF) edge[k1][k2].f-=a;</span><br><span class="line">            if(k2==st) break;</span><br><span class="line">            k1=k2;k2=abs(pre[k1]);</span><br><span class="line">        &#125;</span><br><span class="line">        alpha[en]=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void flow()&#123;</span><br><span class="line">    int maxflow=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">      for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">        if(i==st&amp;&amp;edge[i][j].f&lt;INF) maxflow+=edge[i][j].f;</span><br><span class="line">      &#125;</span><br><span class="line">    printf(&quot;%d&quot;,maxflow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int u,v,c,f;</span><br><span class="line">    n=read();m=read();st=read();en=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">      for(int j=1;j&lt;=n;j++) edge[i][j].c=INF,edge[i][j].f=0;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        u=read();v=read();c=read();</span><br><span class="line">        edge[u][v].c=c;</span><br><span class="line">    &#125;</span><br><span class="line">    Ford_Fulkerson();</span><br><span class="line">    flow();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EK"><a href="#EK" class="headerlink" title="EK"></a>EK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">#define maxn 10005</span><br><span class="line"></span><br><span class="line">int n, m, st, en, flow[maxn][maxn], pre[maxn];</span><br><span class="line">int q[maxn], curr_pos, st_pos, end_pos;</span><br><span class="line">bool wh[maxn];</span><br><span class="line">int max_flow;</span><br><span class="line"></span><br><span class="line">void Init()//初始化</span><br><span class="line">&#123;</span><br><span class="line">    int i, a, b, c;</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;st, &amp;en);</span><br><span class="line">    for(i = 0; i != m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        flow[a][b] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Bfs(int st, int en)//广搜找源点</span><br><span class="line">&#123;</span><br><span class="line">    st_pos = -1, end_pos = 0;</span><br><span class="line">    memset(wh, 0, sizeof wh);</span><br><span class="line">    wh[st] = 1;</span><br><span class="line">    q[0] = st;</span><br><span class="line">    while(st_pos != end_pos)</span><br><span class="line">    &#123;</span><br><span class="line">        curr_pos = q[++st_pos];</span><br><span class="line">        for(int i = 1; i != n+1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!wh[i] &amp;&amp; flow[curr_pos][i] &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                wh[i] = 1;</span><br><span class="line">                pre[i] = curr_pos;</span><br><span class="line">                if(i == en)</span><br><span class="line">                &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                q[++end_pos] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int EK(int start_pos, int end_pos)</span><br><span class="line">&#123;</span><br><span class="line">    int i, minn;</span><br><span class="line">    while(Bfs(start_pos, end_pos))//回溯</span><br><span class="line">    &#123;</span><br><span class="line">        minn = INF;</span><br><span class="line"></span><br><span class="line">        for(i = end_pos; i != start_pos; i = pre[i])</span><br><span class="line">        &#123;</span><br><span class="line">            minn = min(minn, flow[pre[i]][i]);</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        for(i = end_pos; i != start_pos; i = pre[i])</span><br><span class="line">        &#123;</span><br><span class="line">            flow[pre[i]][i] -= minn;</span><br><span class="line">            flow[i][pre[i]] += minn;//反向弧加上该值（具体原因下文详解）</span><br><span class="line">        &#125; </span><br><span class="line">        max_flow += minn;</span><br><span class="line">    &#125;</span><br><span class="line">    return max_flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    //freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line"></span><br><span class="line">    Init();</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d&quot;, EK(st, en));</span><br><span class="line"></span><br><span class="line">    //fclose(stdin);</span><br><span class="line">    //fclose(stdout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DINIC"><a href="#DINIC" class="headerlink" title="DINIC"></a>DINIC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m, sx, ex, cnt;</span><br><span class="line">int head[maxn], pre[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int u, next, to, c;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void add_edge(int u, int v, int c)&#123;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].c = c&lt;=inf ? c : inf;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int c)&#123;</span><br><span class="line">    add_edge(u, v, c);</span><br><span class="line">    add_edge(v, u, 0);//双向边容量为c</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    //memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        int u, v, w;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool BFS(int sx, int ex)&#123;</span><br><span class="line">    memset(pre, 0, sizeof(pre));</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    pre[sx] = 1;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">                int v = edge[i].to;</span><br><span class="line">            if(!pre[v]&amp;&amp;edge[i].c)&#123;</span><br><span class="line">                pre[v] = pre[kk] + 1;</span><br><span class="line">                que.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex] != 0;</span><br><span class="line">&#125;</span><br><span class="line">int DFS(int pos, int flow)&#123;</span><br><span class="line">    if(pos == ex || flow == 0)</span><br><span class="line">        return flow;</span><br><span class="line">    int f = flow;</span><br><span class="line">    for(int i = head[pos]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">        int tmp, v = edge[i].to;</span><br><span class="line">        if(edge[i].c &amp;&amp; pre[pos] + 1 == pre[v] &amp;&amp; (tmp = DFS(v, min(edge[i].c, flow)))&gt;0)&#123;</span><br><span class="line">            edge[i].c -= tmp;</span><br><span class="line">            edge[i^1].c += tmp;</span><br><span class="line">            flow -= tmp;</span><br><span class="line">            if(flow == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f - flow;</span><br><span class="line">&#125;</span><br><span class="line">int Dinic(int sx, int ex)&#123;</span><br><span class="line">    int flow = 0;</span><br><span class="line">    while(BFS(sx, ex))&#123;</span><br><span class="line">        flow += DFS(sx, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;m, &amp;n))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;, Dinic(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DINIC优化"><a href="#DINIC优化" class="headerlink" title="DINIC优化"></a>DINIC优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m, sx, ex, cnt;</span><br><span class="line">int head[maxn], pre[maxn], cur[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int u, next, to, c;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void add_edge(int u, int v, int c)&#123;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].c = c&lt;=inf ? c : inf;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int c)&#123;</span><br><span class="line">    add_edge(u, v, c);</span><br><span class="line">    add_edge(v, u, 0);//双向边容量为c</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    //memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        int u, v, w;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool BFS(int sx, int ex)&#123;</span><br><span class="line">    memset(pre, 0, sizeof(pre));</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    pre[sx] = 1;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int&amp; i = cur[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">                int v = edge[i].to;</span><br><span class="line">            if(!pre[v]&amp;&amp;edge[i].c)&#123;</span><br><span class="line">                pre[v] = pre[kk] + 1;</span><br><span class="line">                que.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex] != 0;</span><br><span class="line">&#125;</span><br><span class="line">int DFS(int pos, int flow)&#123;</span><br><span class="line">    if(pos == ex || flow == 0)</span><br><span class="line">        return flow;</span><br><span class="line">    int f = flow;</span><br><span class="line">    for(int i = head[pos]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">        int tmp, v = edge[i].to;</span><br><span class="line">        if(edge[i].c &amp;&amp; pre[pos] + 1 == pre[v] &amp;&amp; (tmp = DFS(v, min(edge[i].c, flow)))&gt;0)&#123;</span><br><span class="line">            edge[i].c -= tmp;</span><br><span class="line">            edge[i^1].c += tmp;</span><br><span class="line">            flow -= tmp;</span><br><span class="line">            if(flow == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f - flow;</span><br><span class="line">&#125;</span><br><span class="line">int Dinic(int sx, int ex)&#123;</span><br><span class="line">    int flow = 0;</span><br><span class="line">    while(BFS(sx, ex))&#123;</span><br><span class="line">        memcpy(cur, head, sizeof(head));</span><br><span class="line">        flow += DFS(sx, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;m, &amp;n))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;, Dinic(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DINIC-邻接矩阵"><a href="#DINIC-邻接矩阵" class="headerlink" title="DINIC(邻接矩阵)"></a>DINIC(邻接矩阵)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">const int maxn = 307;</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int c;</span><br><span class="line">    int f;</span><br><span class="line">&#125;;</span><br><span class="line">int sx,ex;</span><br><span class="line">int pre[maxn];</span><br><span class="line">NODE road[maxn][maxn];</span><br><span class="line">int n, m, N;</span><br><span class="line">bool BFS()&#123;</span><br><span class="line">    memset(pre,0,sizeof(pre));</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    q.push(sx);</span><br><span class="line">    pre[sx] = 1;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int d = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i = 1;i&lt;=N;i++)&#123;</span><br><span class="line">            if(!pre[i]&amp;&amp;road[d][i].c-road[d][i].f)&#123;</span><br><span class="line">                pre[i] = pre[d] + 1;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex]!=0;</span><br><span class="line">&#125;</span><br><span class="line">int dfs(int pos, int flow)&#123;</span><br><span class="line">    int f = flow;</span><br><span class="line">    if(pos==ex)</span><br><span class="line">        return flow;</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        if(road[pos][i].c - road[pos][i].f &amp;&amp; pre[pos] + 1 == pre[i])&#123;</span><br><span class="line">            int a = road[pos][i].c - road[pos][i].f;</span><br><span class="line">            int t = dfs(i, min(a, flow));</span><br><span class="line">            road[pos][i].f += t;</span><br><span class="line">            road[i][pos].f -= t;</span><br><span class="line">            flow -= t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f - flow;</span><br><span class="line">&#125;</span><br><span class="line">int dinic()&#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    while(BFS())&#123;</span><br><span class="line">        sum+=dfs(sx,inf);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    N = n;</span><br><span class="line">    sx = 0;</span><br><span class="line">    ex = N;</span><br><span class="line">    memset(road,0,sizeof(road));</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u,v,w;</span><br><span class="line">    for(int i = 1;i&lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        road[u][v].c+=w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;m,&amp;n))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;,dinic());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ISAP"><a href="#ISAP" class="headerlink" title="ISAP"></a>ISAP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int read() &#123;</span><br><span class="line">    int x=0,f=1;</span><br><span class="line">    char c=getchar();</span><br><span class="line">    for (;!isdigit(c);c=getchar()) if (c==&apos;-&apos;) f=-1;</span><br><span class="line">    for (;isdigit(c);c=getchar()) x=x*10+c-&apos;0&apos;;</span><br><span class="line">    return x*f;</span><br><span class="line">&#125;</span><br><span class="line">const int maxn=205;</span><br><span class="line">const int maxm=205;</span><br><span class="line">const int inf=2e9+7;</span><br><span class="line">struct edge &#123;</span><br><span class="line">    int v,w,nxt;</span><br><span class="line">&#125; e[maxm&lt;&lt;1];</span><br><span class="line">int h[maxn],tot,n,m,gap[maxn],last[maxn],d[maxn],que[maxn],ql,qr;</span><br><span class="line">vector&lt;int&gt; inv[maxn];</span><br><span class="line">void add(int u,int v,int w) &#123;</span><br><span class="line">    e[++tot]=(edge)&#123;v,w,h[u]&#125;;</span><br><span class="line">    h[u]=tot;</span><br><span class="line">    e[++tot]=(edge)&#123;u,0,h[v]&#125;;</span><br><span class="line">    h[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void init(int s,int t) &#123;</span><br><span class="line">    memset(gap,0,sizeof gap),memset(d,0,sizeof d),++gap[d[t]=1];</span><br><span class="line">    for (int i=1;i&lt;=n;++i) last[i]=h[i];</span><br><span class="line">    que[ql=qr=1]=t;</span><br><span class="line">    while (ql&lt;=qr) &#123;</span><br><span class="line">        int x=que[ql++];</span><br><span class="line">        for (int i=h[x],v=e[i].v;i;i=e[i].nxt,v=e[i].v) if (!d[v]) ++gap[d[v]=d[x]+1],que[++qr]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int aug(int x,int s,int t,int mi) &#123;</span><br><span class="line">    if (x==t) return mi;</span><br><span class="line">    int flow=0;</span><br><span class="line">    for (int &amp;i=last[x],v=e[i].v;i;i=e[i].nxt,v=e[i].v) if (d[x]==d[v]+1) &#123;</span><br><span class="line">        int tmp=aug(v,s,t,min(mi,e[i].w));</span><br><span class="line">        flow+=tmp,mi-=tmp,e[i].w-=tmp,e[i^1].w+=tmp;</span><br><span class="line">        if (!mi) return flow;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(--gap[d[x]])) d[s]=n+1;</span><br><span class="line">    ++gap[++d[x]],last[x]=h[x];</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int maxflow(int s,int t) &#123;</span><br><span class="line">    init(s,t);</span><br><span class="line">    int ret=aug(s,s,t,inf);</span><br><span class="line">    while (d[s]&lt;=n) ret+=aug(s,s,t,inf);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">#ifndef ONLINE_JUDGE</span><br><span class="line">    freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">#endif</span><br><span class="line">    while (~scanf(&quot;%d%d&quot;,&amp;m,&amp;n)) &#123;</span><br><span class="line">        tot=1,memset(h,0,sizeof h);</span><br><span class="line">        for (int i=1;i&lt;=n;++i) inv[i].clear();</span><br><span class="line">        for (int i=1;i&lt;=m;++i) &#123;</span><br><span class="line">            int u=read(),v=read(),w=read();</span><br><span class="line">            add(u,v,w);</span><br><span class="line">            if (w) inv[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        int ans=maxflow(1,n);</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MCMF"><a href="#MCMF" class="headerlink" title="MCMF"></a>MCMF</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxm = 1e5+7;</span><br><span class="line">const int maxn = 1e4+7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m, cnt, sx, ex;</span><br><span class="line">int head[maxn], pre[maxn], dis[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next;</span><br><span class="line">    int to;</span><br><span class="line">    int w;</span><br><span class="line">    int c;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line">void init()&#123;</span><br><span class="line">    sx = 0;</span><br><span class="line">    ex = 1;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">void add_edge(int u, int v, int c, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].c = c&lt;=inf ? c : inf;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int c, int w)&#123;</span><br><span class="line">    add_edge(u, v, c, w);</span><br><span class="line">    add_edge(v, u, 0, -w);</span><br><span class="line">&#125;</span><br><span class="line">bool SPFA(int sx, int ex)&#123;</span><br><span class="line">    memset(pre, -1, sizeof(pre));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[kk] = false;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            EDGE tmp = edge[i];</span><br><span class="line">            if(tmp.c &amp;&amp; dis[tmp.to]&gt;dis[kk]+tmp.w)&#123;</span><br><span class="line">                dis[tmp.to] = dis[kk] + tmp.w;</span><br><span class="line">                pre[tmp.to] = i;</span><br><span class="line">                if(!vis[tmp.to])&#123;</span><br><span class="line">                    vis[tmp.to] = true;</span><br><span class="line">                    que.push(tmp.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex] != -1;</span><br><span class="line">&#125;</span><br><span class="line">int MCMF(int sx, int ex)&#123;</span><br><span class="line">    int flow = 0, cost = 0;</span><br><span class="line">    while(SPFA(sx, ex))&#123;</span><br><span class="line">    	int min_flow = inf;</span><br><span class="line">        for(int i = pre[ex]; i != -1; i = pre[edge[i^1].to])&#123;</span><br><span class="line">            min_flow = min(min_flow, edge[i].c);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = pre[ex]; i != -1; i = pre[edge[i^1].to])&#123;</span><br><span class="line">            edge[i].c -= min_flow;</span><br><span class="line">            edge[i^1].c += min_flow;</span><br><span class="line">            cost += min_flow * edge[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        flow += min_flow;</span><br><span class="line">    &#125;</span><br><span class="line">    return cost;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v, c, w;</span><br><span class="line">    ex = n+1;</span><br><span class="line">    for(int i = 0;i&lt;m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d&quot;,&amp;u,&amp;v,&amp;c,&amp;w);</span><br><span class="line">        add(u,v,c, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">        if(n+m==0)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;,MCMF(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><h3 id="匈牙利算法-邻接矩阵"><a href="#匈牙利算法-邻接矩阵" class="headerlink" title="匈牙利算法(邻接矩阵)"></a>匈牙利算法(邻接矩阵)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 107;</span><br><span class="line">int N, K;</span><br><span class="line">int edge[maxn][maxn], head[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, 0, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">bool find_edge(int x) &#123;</span><br><span class="line">	for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">		if (edge[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">			vis[i] = true;</span><br><span class="line">			if (!head[i] || find_edge(head[i])) &#123;</span><br><span class="line">				head[i] = x;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int Magyar(int N)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        memset(vis, false, sizeof(vis));</span><br><span class="line">        if (find_edge(i)) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (cin &gt;&gt; N &gt;&gt; K) &#123;</span><br><span class="line">		int x, y;</span><br><span class="line">		for (int i = 1; i &lt;= K; i++)&#123;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			edge[x][y] = 1;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; Magyar(N) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 107;</span><br><span class="line">int T, N, m;</span><br><span class="line">int head[maxn], link[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int cnt;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, u, to, w;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(link, 0, sizeof(link));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">bool find_edge(int x)&#123;</span><br><span class="line">    for(int i = head[x]; i!= -1; i = edge[i].next)&#123;</span><br><span class="line">        int v = edge[i].to;</span><br><span class="line">        if(!vis[v])&#123;</span><br><span class="line">            vis[v] = true;</span><br><span class="line">            if (!link[v] || find_edge(link[v])) &#123;</span><br><span class="line">				link[v] = x;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int Magyar(int N)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        memset(vis, false, sizeof(vis));</span><br><span class="line">        if (find_edge(i)) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int solve()&#123;</span><br><span class="line">    int ans = Magyar(N);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;N, &amp;m);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int x, y;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;x, &amp;y);</span><br><span class="line">        add(x, y, 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;, solve());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 207;</span><br><span class="line">const int maxm = 30007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int minD, cntx, cnty, edge[maxn][maxn];</span><br><span class="line">bool visx[maxn], visy[maxn];</span><br><span class="line">int linkx[maxn], link[maxn], wx[maxn], wy[maxn];</span><br><span class="line">bool dfs(int x)&#123; //匈牙利算法找增广路径</span><br><span class="line">    visx[x] = true;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i++)&#123;</span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            int t = wx[x] + wy[i] - edge[x][i];</span><br><span class="line">            if(t == 0) &#123;</span><br><span class="line">                visy[i] = true;</span><br><span class="line">                if(link[i] == 0 || dfs(link[i]))&#123;</span><br><span class="line">                    linkx[x] = i;</span><br><span class="line">                    link[i] = x;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t &gt; 0)&#123;  //找出边权与顶标和的最小的差值</span><br><span class="line">                if(t &lt; minD)&#123;</span><br><span class="line">                    minD = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int km()&#123;</span><br><span class="line">    memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点</span><br><span class="line">    memset(link, 0, sizeof link);</span><br><span class="line">    memset(wy, 0, sizeof(wy));</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        wx[i] = -inf;</span><br><span class="line">        for(int j = 1; j &lt;= cnty; j++)&#123;</span><br><span class="line">            if(wx[i] &lt; edge[i][j])&#123;</span><br><span class="line">                wx[i] = edge[i][j];//初始化为权值最大的边的权值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            minD = inf;</span><br><span class="line">            memset(visx, false, sizeof visx);</span><br><span class="line">            memset(visy, false, sizeof visy);</span><br><span class="line">            if(dfs(i))&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cntx; j++)&#123;  //将交错树中X部的点的顶标减去minz</span><br><span class="line">                if(visx[j])&#123;</span><br><span class="line">                    wx[j] -= minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz</span><br><span class="line">                if(visy[j])&#123;</span><br><span class="line">                    wy[j] += minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i ++)&#123;</span><br><span class="line">        if(link[i]!=0)&#123;</span><br><span class="line">            ans += edge[link[i]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        cntx = cnty = n;</span><br><span class="line">        memset(edge, 0, sizeof(edge));</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            edge[u][v] = max(edge[u][v], w);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, km());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KM算法最小权匹配"><a href="#KM算法最小权匹配" class="headerlink" title="KM算法最小权匹配"></a>KM算法最小权匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 207;</span><br><span class="line">const int maxm = 30007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int minD, cntx, cnty, edge[maxn][maxn];</span><br><span class="line">bool visx[maxn], visy[maxn];</span><br><span class="line">int linkx[maxn], link[maxn], wx[maxn], wy[maxn];</span><br><span class="line">bool dfs(int x)&#123; //匈牙利算法找增广路径</span><br><span class="line">    visx[x] = true;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i++)&#123;</span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            int t = wx[x] + wy[i] - edge[x][i];</span><br><span class="line">            if(t == 0) &#123;</span><br><span class="line">                visy[i] = true;</span><br><span class="line">                if(link[i] == 0 || dfs(link[i]))&#123;</span><br><span class="line">                    linkx[x] = i;</span><br><span class="line">                    link[i] = x;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t &gt; 0)&#123;  //找出边权与顶标和的最小的差值</span><br><span class="line">                if(t &lt; minD)&#123;</span><br><span class="line">                    minD = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int km()&#123;</span><br><span class="line">    memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点</span><br><span class="line">    memset(link, 0, sizeof link);</span><br><span class="line">    memset(wy, 0, sizeof(wy));</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        wx[i] = -inf;</span><br><span class="line">        for(int j = 1; j &lt;= cnty; j++)&#123;</span><br><span class="line">            if(wx[i] &lt; edge[i][j])&#123;</span><br><span class="line">                wx[i] = edge[i][j];//初始化为权值最大的边的权值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            minD = inf;</span><br><span class="line">            memset(visx, false, sizeof visx);</span><br><span class="line">            memset(visy, false, sizeof visy);</span><br><span class="line">            if(dfs(i))&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cntx; j++)&#123;  //将交错树中X部的点的顶标减去minz</span><br><span class="line">                if(visx[j])&#123;</span><br><span class="line">                    wx[j] -= minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz</span><br><span class="line">                if(visy[j])&#123;</span><br><span class="line">                    wy[j] += minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i ++)&#123;</span><br><span class="line">        if(link[i]!=0&amp;&amp;edge[link[i]][i]!=-inf)&#123;</span><br><span class="line">            ans += edge[link[i]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        cntx = cnty = n;</span><br><span class="line">        for(int i = 0; i &lt;= cntx; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt;= cnty; j++)&#123;</span><br><span class="line">                edge[i][j] = -inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            edge[u][v] = max(edge[u][v], -w);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, km());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KM算法最小权匹配优化版"><a href="#KM算法最小权匹配优化版" class="headerlink" title="KM算法最小权匹配优化版"></a>KM算法最小权匹配优化版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 207;</span><br><span class="line">const int maxm = 30007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int minD, cntx, cnty, edge[maxn][maxn];</span><br><span class="line">bool visx[maxn], visy[maxn];</span><br><span class="line">int linkx[maxn], link[maxn], wx[maxn], wy[maxn];</span><br><span class="line">bool dfs(int x)&#123; //匈牙利算法找增广路径</span><br><span class="line">    visx[x] = true;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i++)&#123;</span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            int t = wx[x] + wy[i] - edge[x][i];</span><br><span class="line">            if(t == 0) &#123;</span><br><span class="line">                visy[i] = true;</span><br><span class="line">                if(link[i] == 0 || dfs(link[i]))&#123;</span><br><span class="line">                    linkx[x] = i;</span><br><span class="line">                    link[i] = x;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t &gt; 0)&#123;  //找出边权与顶标和的最小的差值</span><br><span class="line">                if(t &lt; minD)&#123;</span><br><span class="line">                    minD = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int km()&#123;</span><br><span class="line">    memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点</span><br><span class="line">    memset(link, 0, sizeof link);</span><br><span class="line">    memset(wy, 0, sizeof(wy));</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        wx[i] = -inf;</span><br><span class="line">        for(int j = 1; j &lt;= cnty; j++)&#123;</span><br><span class="line">            if(wx[i] &lt; edge[i][j])&#123;</span><br><span class="line">                wx[i] = edge[i][j];//初始化为权值最大的边的权值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            minD = inf;</span><br><span class="line">            memset(visx, false, sizeof visx);</span><br><span class="line">            memset(visy, false, sizeof visy);</span><br><span class="line">            if(dfs(i))&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cntx; j++)&#123;  //将交错树中X部的点的顶标减去minz</span><br><span class="line">                if(visx[j])&#123;</span><br><span class="line">                    wx[j] -= minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz</span><br><span class="line">                if(visy[j])&#123;</span><br><span class="line">                    wy[j] += minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i ++)&#123;</span><br><span class="line">        if(link[i]!=0&amp;&amp;edge[link[i]][i]!=-inf)&#123;</span><br><span class="line">            ans += edge[link[i]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        cntx = cnty = n;</span><br><span class="line">        for(int i = 0; i &lt;= cntx; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt;= cnty; j++)&#123;</span><br><span class="line">                edge[i][j] = -inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            edge[u][v] = max(edge[u][v], -w);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, km());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="强连通"><a href="#强连通" class="headerlink" title="强连通"></a>强连通</h2><h3 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5 + 7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int head[maxn], cnt, top, dfs_num, col_num;</span><br><span class="line">int dfn[maxn], low[maxn], Stack[maxn], color[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, u;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void add(int u, int v)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void Tarjan(int x)&#123;</span><br><span class="line">    dfn[x] = ++dfs_num;</span><br><span class="line">    low[x] = dfs_num;</span><br><span class="line">    vis[x] = true;  //是否在栈中</span><br><span class="line">    Stack[++top] = x;</span><br><span class="line">    for(int i = head[x]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">        int v = edge[i].to;</span><br><span class="line">        if(!dfn[v])&#123;</span><br><span class="line">            Tarjan(v);</span><br><span class="line">            low[x] = min(low[x], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(vis[v])&#123;</span><br><span class="line">            low[x] = min(low[x], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(dfn[x] == low[x])&#123;   //构成强连通分量</span><br><span class="line">        vis[x] = false;</span><br><span class="line">        color[x] = ++col_num;   //染色</span><br><span class="line">        while(Stack[top] != x)&#123; //清空</span><br><span class="line">            color[Stack[top]] = col_num;</span><br><span class="line">            vis [ Stack[ top-- ] ] = false ;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    top = dfs_num = col_num = cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    memset(dfn, 0, sizeof(dfn));</span><br><span class="line">    memset(low, 0, sizeof(low));</span><br><span class="line">    memset(color, 0, sizeof(color));</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</span><br><span class="line">        add(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">        if(!color[i])&#123;</span><br><span class="line">            Tarjan(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(col_num != 1)&#123;</span><br><span class="line">        printf(&quot;No\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;Yes\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &amp;&amp; n+m)&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tarjan缩点"><a href="#Tarjan缩点" class="headerlink" title="Tarjan缩点"></a>Tarjan缩点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#define MAXN 10010</span><br><span class="line">#define MAXE 100010</span><br><span class="line">using namespace std;</span><br><span class="line">int head[MAXN],tot1,tot2;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">    int u,v,next;</span><br><span class="line">&#125;e1[MAXE],e2[MAXN];</span><br><span class="line">void addEdge(int u,int v,Edge* edge,int&amp; tol)&#123;</span><br><span class="line">    edge[tol].u=u;edge[tol].v=v;</span><br><span class="line">    edge[tol].next=head[u];head[u]=tol++;</span><br><span class="line">&#125;</span><br><span class="line">int n,m;</span><br><span class="line">int low[MAXN],dfn[MAXN],stack[MAXN],belong[MAXN],num[MAXN];</span><br><span class="line">bool instack[MAXN];</span><br><span class="line">int scc,top,INDEX;</span><br><span class="line">void Tarjan(int u)&#123;</span><br><span class="line">    int v;</span><br><span class="line">    low[u]=dfn[u]=++INDEX;</span><br><span class="line">    stack[top++]=u;</span><br><span class="line">    instack[u]=true;</span><br><span class="line">    for(int i=head[u];i!=-1;i=e1[i].next)&#123;</span><br><span class="line">        v=e1[i].v;</span><br><span class="line">        if(!dfn[v])&#123;</span><br><span class="line">            Tarjan(v);</span><br><span class="line">            if(low[u]&gt;low[v]) low[u]=low[v];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(instack[v]&amp;&amp;low[u]&gt;dfn[v])</span><br><span class="line">            low[u]=dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line">    if(low[u]==dfn[u])&#123;</span><br><span class="line">        ++scc;</span><br><span class="line">        do&#123;</span><br><span class="line">            v=stack[--top];</span><br><span class="line">            instack[v]=false;</span><br><span class="line">            belong[v]=scc;</span><br><span class="line">            num[scc]++;</span><br><span class="line">        &#125;while(u!=v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int inde[MAXN],outde[MAXN];</span><br><span class="line">void solve()&#123;</span><br><span class="line">    memset(dfn,0,sizeof(dfn));</span><br><span class="line">    memset(instack,false,sizeof(instack));</span><br><span class="line">    memset(num,0,sizeof(num));</span><br><span class="line">    scc=top=INDEX=0;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)</span><br><span class="line">        if(!dfn[i]) Tarjan(i);</span><br><span class="line">    tot2=0;memset(head,-1,sizeof(head));</span><br><span class="line">    memset(inde,0,sizeof(inde));</span><br><span class="line">    memset(outde,0,sizeof(outde));</span><br><span class="line">    int u,v;</span><br><span class="line">    for(int i=0;i&lt;m;++i)&#123;</span><br><span class="line">        u=belong[e1[i].u];</span><br><span class="line">        v=belong[e1[i].v];</span><br><span class="line">        if(u!=v)&#123;</span><br><span class="line">            addEdge(u,v,e2,tot2);</span><br><span class="line">            inde[v]++;</span><br><span class="line">            outde[u]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int a=0,b=0;</span><br><span class="line">    for(int i=1;i&lt;=scc;++i)&#123;</span><br><span class="line">        if(!inde[i]) a++;</span><br><span class="line">        if(!outde[i]) b++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(scc==1)printf(&quot;0\n&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;%d\n&quot;,max(a,b));</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;   int zushu;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;zushu);</span><br><span class="line">    while(zushu--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        tot1=0;memset(head,-1,sizeof(head));</span><br><span class="line">        int u,v;</span><br><span class="line">        for(int i=0;i&lt;m;++i)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">            addEdge(u,v,e1,tot1);</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">HDU 3622</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">HDU 3622</span><br><span class="line">题意:给n对炸弹可以放置的位置(每个位置为一个二维平面上的点),</span><br><span class="line">每次放置炸弹是时只能选择这一对中的其中一个点,每个炸弹爆炸</span><br><span class="line">的范围半径都一样,控制爆炸的半径使得所有的爆炸范围都不相</span><br><span class="line">交(可以相切),求解这个最大半径.</span><br><span class="line">     首先二分最大半径值,然后2-sat构图判断其可行性,对于每</span><br><span class="line">     两队位置(u,uu)和(v,vv),如果u和v之间的距离小于2*id,也就</span><br><span class="line">     是说位置u和位置v处不能同时防止炸弹(两范围相交),所以连边(u,vv)</span><br><span class="line">     和(v,uu),求解强连通分量判断可行性.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意精度问题</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=210;</span><br><span class="line">const int MAXM=40005;//边的最大数</span><br><span class="line">const double eps=1e-5;</span><br><span class="line"></span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int to,next;</span><br><span class="line">&#125;edge1[MAXM],edge2[MAXM];</span><br><span class="line">int head1[MAXN];</span><br><span class="line">int head2[MAXN];</span><br><span class="line">int tol1,tol2;</span><br><span class="line">bool vis1[MAXN],vis2[MAXN];</span><br><span class="line">int Belong[MAXN];//连通分量标记</span><br><span class="line">int T[MAXN];//dfs结点结束时间</span><br><span class="line">int Bcnt,Tcnt;</span><br><span class="line">void add(int a,int b)//原图和逆图都要添加</span><br><span class="line">&#123;</span><br><span class="line">    edge1[tol1].to=b;</span><br><span class="line">    edge1[tol1].next=head1[a];</span><br><span class="line">    head1[a]=tol1++;</span><br><span class="line">    edge2[tol2].to=a;</span><br><span class="line">    edge2[tol2].next=head2[b];</span><br><span class="line">    head2[b]=tol2++;</span><br><span class="line">&#125;</span><br><span class="line">void init()//建图前初始化</span><br><span class="line">&#123;</span><br><span class="line">    memset(head1,-1,sizeof(head1));</span><br><span class="line">    memset(head2,-1,sizeof(head2));</span><br><span class="line">    memset(vis1,false,sizeof(vis1));</span><br><span class="line">    memset(vis2,false,sizeof(vis2));</span><br><span class="line">    tol1=tol2=0;</span><br><span class="line">    Bcnt=Tcnt=0;</span><br><span class="line">&#125;</span><br><span class="line">void dfs1(int x)//对原图进行dfs,算出每个结点的结束时间，哪个点开始无所谓</span><br><span class="line">&#123;</span><br><span class="line">    vis1[x]=true;</span><br><span class="line">    int j;</span><br><span class="line">    for(int j=head1[x];j!=-1;j=edge1[j].next)</span><br><span class="line">      if(!vis1[edge1[j].to])</span><br><span class="line">        dfs1(edge1[j].to);</span><br><span class="line">    T[Tcnt++]=x;</span><br><span class="line">&#125;</span><br><span class="line">void dfs2(int x)</span><br><span class="line">&#123;</span><br><span class="line">    vis2[x]=true;</span><br><span class="line">    Belong[x]=Bcnt;</span><br><span class="line">    int j;</span><br><span class="line">    for(j=head2[x];j!=-1;j=edge2[j].next)</span><br><span class="line">       if(!vis2[edge2[j].to])</span><br><span class="line">         dfs2(edge2[j].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">&#125;s[MAXN];</span><br><span class="line">double dist(Point a,Point b)</span><br><span class="line">&#123;</span><br><span class="line">    return sqrt((double)(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool ok(int n)//判断可行性</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;2*n;i++)</span><br><span class="line">      if(!vis1[i])</span><br><span class="line">        dfs1(i);</span><br><span class="line">    for(int i=Tcnt-1;i&gt;=0;i--)</span><br><span class="line">      if(!vis2[T[i]])//这个别写错，是vis2[T[i]]</span><br><span class="line">      &#123;</span><br><span class="line">          dfs2(T[i]);</span><br><span class="line">          Bcnt++;</span><br><span class="line">      &#125;</span><br><span class="line">    for(int i=0;i&lt;=2*n-2;i+=2)</span><br><span class="line">      if(Belong[i]==Belong[i+1])</span><br><span class="line">        return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    int n;</span><br><span class="line">    double left,right,mid;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">          scanf(&quot;%d%d%d%d&quot;,&amp;s[2*i].x,&amp;s[2*i].y,&amp;s[2*i+1].x,&amp;s[2*i+1].y);</span><br><span class="line">        left=0;</span><br><span class="line">        right=40000.0;</span><br><span class="line">        while(right-left&gt;=eps)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(left+right)/2;</span><br><span class="line">            init();</span><br><span class="line">            for(int i=0;i&lt;2*n-2;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int t;</span><br><span class="line">                if(i%2==0)t=i+2;</span><br><span class="line">                else t=i+1;</span><br><span class="line">                for(int j=t;j&lt;2*n;j++)</span><br><span class="line">                   if(dist(s[i],s[j])&lt;2*mid)//冲突了</span><br><span class="line">                   &#123;</span><br><span class="line">                       add(i,j^1);</span><br><span class="line">                       add(j,i^1);//注意顺序不能变的</span><br><span class="line">                   &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(ok(n))left=mid;</span><br><span class="line">            else right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%.2lf\n&quot;,right);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int gcd(int a, int b)&#123;</span><br><span class="line">    return !b ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exgcd"><a href="#exgcd" class="headerlink" title="exgcd"></a>exgcd</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int exgcd(int a,int b,int &amp;x,int &amp;y)&#123;</span><br><span class="line">    if (b==0)&#123;</span><br><span class="line">        x=1,y=0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    int d=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int Extended_Euclid(int a,int b,int &amp;x,int &amp;y)    //扩展欧几里得算法</span><br><span class="line">&#123;</span><br><span class="line">	int d;</span><br><span class="line">	if(b==0)</span><br><span class="line">	&#123;</span><br><span class="line">		x=1;y=0;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">	d=Extended_Euclid(b,a%b,y,x);</span><br><span class="line">	y-=a/b*x;</span><br><span class="line">	return d;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int Chinese_Remainder(int a[],int w[],int len)    //中国剩余定理  a[]存放余数  w[]存放两两互质的数</span><br><span class="line">&#123;</span><br><span class="line">	int i,d,x,y,m,n,ret;</span><br><span class="line">	ret=0;</span><br><span class="line">	n=1;</span><br><span class="line">	for (i=0;i&lt;len;i++)</span><br><span class="line">		n*=w[i];</span><br><span class="line">	for (i=0;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m=n/w[i];</span><br><span class="line">		d=Extended_Euclid(w[i],m,x,y);</span><br><span class="line">		ret=(ret+y*m*a[i])%n;</span><br><span class="line">	&#125;</span><br><span class="line">	return (n+ret%n)%n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,i;</span><br><span class="line">	int w[15],b[15];</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n),n)   </span><br><span class="line">	&#123;</span><br><span class="line">		for (i=0;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;w[i],&amp;b[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d/n&quot;,Chinese_Remainder(b,w,n));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int oula(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int rea=n;</span><br><span class="line">    for(int i=2; i&lt;=n; i++)</span><br><span class="line">        if(n%i==0)//第一次找到的必为素因子</span><br><span class="line">        &#123;</span><br><span class="line">            rea=rea-rea/i;</span><br><span class="line">            do</span><br><span class="line">                n/=i;//把该素因子全部约掉</span><br><span class="line">            while(n%i==0);</span><br><span class="line">        &#125;</span><br><span class="line">    return rea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int prime[maxn];</span><br><span class="line">int visit[maxn];</span><br><span class="line">void Prime()&#123;</span><br><span class="line">    mem(visit,0);</span><br><span class="line">    mem(prime, 0);</span><br><span class="line">    for (int i = 2;i &lt;= maxn; i++) &#123;</span><br><span class="line">        cout&lt;&lt;&quot; i = &quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        if (!visit[i]) &#123;</span><br><span class="line">            prime[++prime[0]] = i;      //纪录素数， 这个prime[0] 相当于 cnt，用来计数</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;=prime[0] &amp;&amp; i*prime[j] &lt;= maxn; j++) &#123;</span><br><span class="line">            visit[i*prime[j]] = 1;</span><br><span class="line">            if (i % prime[j] == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><h4 id="卡特兰数打表"><a href="#卡特兰数打表" class="headerlink" title="卡特兰数打表"></a>卡特兰数打表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">unsigned long long ctl[34] = &#123;0,1&#125;;</span><br><span class="line">void calc()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 2; i &lt; 34; i ++)</span><br><span class="line">        ctl[i] = ctl[i-1]*(4*i-2)/(i+1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    calc();</span><br><span class="line">    for(i = 0; i &lt; 34; i ++)</span><br><span class="line">        printf(&quot;%d: %llu\n&quot;,i, ctl[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="卡特兰数表"><a href="#卡特兰数表" class="headerlink" title="卡特兰数表"></a>卡特兰数表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string catalan[]=</span><br><span class="line">&#123;</span><br><span class="line">    &quot;1&quot;,</span><br><span class="line">    &quot;2&quot;,</span><br><span class="line">    &quot;5&quot;,</span><br><span class="line">    &quot;14&quot;,</span><br><span class="line">    &quot;42&quot;,</span><br><span class="line">    &quot;132&quot;,</span><br><span class="line">    &quot;429&quot;,</span><br><span class="line">    &quot;1430&quot;,</span><br><span class="line">    &quot;4862&quot;,</span><br><span class="line">    &quot;16796&quot;,</span><br><span class="line">    &quot;58786&quot;,</span><br><span class="line">    &quot;208012&quot;,</span><br><span class="line">    &quot;742900&quot;,</span><br><span class="line">    &quot;2674440&quot;,</span><br><span class="line">    &quot;9694845&quot;,</span><br><span class="line">    &quot;35357670&quot;,</span><br><span class="line">    &quot;129644790&quot;,</span><br><span class="line">    &quot;477638700&quot;,</span><br><span class="line">    &quot;1767263190&quot;,</span><br><span class="line">    &quot;6564120420&quot;,</span><br><span class="line">    &quot;24466267020&quot;,</span><br><span class="line">    &quot;91482563640&quot;,</span><br><span class="line">    &quot;343059613650&quot;,</span><br><span class="line">    &quot;1289904147324&quot;,</span><br><span class="line">    &quot;4861946401452&quot;,</span><br><span class="line">    &quot;18367353072152&quot;,</span><br><span class="line">    &quot;69533550916004&quot;,</span><br><span class="line">    &quot;263747951750360&quot;,</span><br><span class="line">    &quot;1002242216651368&quot;,</span><br><span class="line">    &quot;3814986502092304&quot;,</span><br><span class="line">    &quot;14544636039226909&quot;,</span><br><span class="line">    &quot;55534064877048198&quot;,</span><br><span class="line">    &quot;212336130412243110&quot;,</span><br><span class="line">    &quot;812944042149730764&quot;,</span><br><span class="line">    &quot;3116285494907301262&quot;,</span><br><span class="line">    &quot;11959798385860453492&quot;,</span><br><span class="line">    &quot;45950804324621742364&quot;,</span><br><span class="line">    &quot;176733862787006701400&quot;,</span><br><span class="line">    &quot;680425371729975800390&quot;,</span><br><span class="line">    &quot;2622127042276492108820&quot;,</span><br><span class="line">    &quot;10113918591637898134020&quot;,</span><br><span class="line">    &quot;39044429911904443959240&quot;,</span><br><span class="line">    &quot;150853479205085351660700&quot;,</span><br><span class="line">    &quot;583300119592996693088040&quot;,</span><br><span class="line">    &quot;2257117854077248073253720&quot;,</span><br><span class="line">    &quot;8740328711533173390046320&quot;,</span><br><span class="line">    &quot;33868773757191046886429490&quot;,</span><br><span class="line">    &quot;131327898242169365477991900&quot;,</span><br><span class="line">    &quot;509552245179617138054608572&quot;,</span><br><span class="line">    &quot;1978261657756160653623774456&quot;,</span><br><span class="line">    &quot;7684785670514316385230816156&quot;,</span><br><span class="line">    &quot;29869166945772625950142417512&quot;,</span><br><span class="line">    &quot;116157871455782434250553845880&quot;,</span><br><span class="line">    &quot;451959718027953471447609509424&quot;,</span><br><span class="line">    &quot;1759414616608818870992479875972&quot;,</span><br><span class="line">    &quot;6852456927844873497549658464312&quot;,</span><br><span class="line">    &quot;26700952856774851904245220912664&quot;,</span><br><span class="line">    &quot;104088460289122304033498318812080&quot;,</span><br><span class="line">    &quot;405944995127576985730643443367112&quot;,</span><br><span class="line">    &quot;1583850964596120042686772779038896&quot;,</span><br><span class="line">    &quot;6182127958584855650487080847216336&quot;,</span><br><span class="line">    &quot;24139737743045626825711458546273312&quot;,</span><br><span class="line">    &quot;94295850558771979787935384946380125&quot;,</span><br><span class="line">    &quot;368479169875816659479009042713546950&quot;,</span><br><span class="line">    &quot;1440418573150919668872489894243865350&quot;,</span><br><span class="line">    &quot;5632681584560312734993915705849145100&quot;,</span><br><span class="line">    &quot;22033725021956517463358552614056949950&quot;,</span><br><span class="line">    &quot;86218923998960285726185640663701108500&quot;,</span><br><span class="line">    &quot;337485502510215975556783793455058624700&quot;,</span><br><span class="line">    &quot;1321422108420282270489942177190229544600&quot;,</span><br><span class="line">    &quot;5175569924646105559418940193995065716350&quot;,</span><br><span class="line">    &quot;20276890389709399862928998568254641025700&quot;,</span><br><span class="line">    &quot;79463489365077377841208237632349268884500&quot;,</span><br><span class="line">    &quot;311496878311103321137536291518809134027240&quot;,</span><br><span class="line">    &quot;1221395654430378811828760722007962130791020&quot;,</span><br><span class="line">    &quot;4790408930363303911328386208394864461024520&quot;,</span><br><span class="line">    &quot;18793142726809884575211361279087545193250040&quot;,</span><br><span class="line">    &quot;73745243611532458459690151854647329239335600&quot;,</span><br><span class="line">    &quot;289450081175264899454283846029490767264392230&quot;,</span><br><span class="line">    &quot;1136359577947336271931632877004667456667613940&quot;,</span><br><span class="line">    &quot;4462290049988320482463241297506133183499654740&quot;,</span><br><span class="line">    &quot;17526585015616776834735140517915655636396234280&quot;,</span><br><span class="line">    &quot;68854441132780194707888052034668647142985206100&quot;,</span><br><span class="line">    &quot;270557451039395118028642463289168566420671280440&quot;,</span><br><span class="line">    &quot;1063353702922273835973036658043476458723103404520&quot;,</span><br><span class="line">    &quot;4180080073556524734514695828170907458428751314320&quot;,</span><br><span class="line">    &quot;16435314834665426797069144960762886143367590394940&quot;,</span><br><span class="line">    &quot;64633260585762914370496637486146181462681535261000&quot;,</span><br><span class="line">    &quot;254224158304000796523953440778841647086547372026600&quot;,</span><br><span class="line">    &quot;1000134600800354781929399250536541864362461089950800&quot;,</span><br><span class="line">    &quot;3935312233584004685417853572763349509774031680023800&quot;,</span><br><span class="line">    &quot;15487357822491889407128326963778343232013931127835600&quot;,</span><br><span class="line">    &quot;60960876535340415751462563580829648891969728907438000&quot;,</span><br><span class="line">    &quot;239993345518077005168915776623476723006280827488229600&quot;,</span><br><span class="line">    &quot;944973797977428207852605870454939596837230758234904050&quot;,</span><br><span class="line">    &quot;3721443204405954385563870541379246659709506697378694300&quot;,</span><br><span class="line">    &quot;14657929356129575437016877846657032761712954950899755100&quot;,</span><br><span class="line">    &quot;57743358069601357782187700608042856334020731624756611000&quot;,</span><br><span class="line">    &quot;227508830794229349661819540395688853956041682601541047340&quot;,</span><br><span class="line">    &quot;896519947090131496687170070074100632420837521538745909320&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int i;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;i)!=EOF)&#123;</span><br><span class="line">		cout&lt;&lt;catalan[i-1]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="斯特林数"><a href="#斯特林数" class="headerlink" title="斯特林数"></a>斯特林数</h3><h4 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define RI register int</span><br><span class="line">const int N=200005,mod=998244353,G=3;</span><br><span class="line">int n,A,B,ans,a[18][N],rev[N];</span><br><span class="line">int ksm(int x,int y) &#123;</span><br><span class="line">	int re=1;</span><br><span class="line">	for(RI i=y;i;i&gt;&gt;=1,x=1LL*x*x%mod) if(i&amp;1) re=1LL*re*x%mod;</span><br><span class="line">	return re;</span><br><span class="line">&#125;</span><br><span class="line">void NTT(int *a,int n,int x) &#123;</span><br><span class="line">	for(RI i=0;i&lt;n;++i) if(rev[i]&gt;i) swap(a[i],a[rev[i]]);</span><br><span class="line">	for(RI i=1;i&lt;n;i&lt;&lt;=1) &#123;</span><br><span class="line">		int gn=ksm(G,(mod-1)/(i&lt;&lt;1));</span><br><span class="line">		for(RI j=0;j&lt;n;j+=(i&lt;&lt;1)) &#123;</span><br><span class="line">			int g=1,t1,t2;</span><br><span class="line">			for(RI k=0;k&lt;i;++k,g=1LL*g*gn%mod) &#123;</span><br><span class="line">				t1=a[j+k],t2=1LL*g*a[j+i+k]%mod;</span><br><span class="line">				a[j+k]=(t1+t2)%mod,a[j+i+k]=(t1-t2+mod)%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(x==1) return;</span><br><span class="line">	int inv=ksm(n,mod-2);reverse(a+1,a+n);//a+1!!!</span><br><span class="line">	for(RI i=0;i&lt;n;++i) a[i]=1LL*a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">void work(int s,int t,int d) &#123;</span><br><span class="line">	if(s==t) &#123;a[d][0]=s,a[d][1]=1;return;&#125;</span><br><span class="line">	int mid=(s+t)&gt;&gt;1,len=0,kn=1;</span><br><span class="line">	work(s,mid,d+1);</span><br><span class="line">	for(RI i=0;i&lt;=mid-s+1;++i) a[d][i]=a[d+1][i];</span><br><span class="line">	work(mid+1,t,d+1);</span><br><span class="line">	while(kn&lt;=t-s+1) kn&lt;&lt;=1,++len;</span><br><span class="line">	for(RI i=0;i&lt;kn;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(len-1));</span><br><span class="line">	for(RI i=mid-s+2;i&lt;kn;++i) a[d][i]=0;</span><br><span class="line">	for(RI i=t-mid+1;i&lt;kn;++i) a[d+1][i]=0;</span><br><span class="line">	NTT(a[d],kn,1),NTT(a[d+1],kn,1);</span><br><span class="line">	for(RI i=0;i&lt;kn;++i) a[d][i]=1LL*a[d][i]*a[d+1][i]%mod;</span><br><span class="line">	NTT(a[d],kn,-1);</span><br><span class="line">&#125;</span><br><span class="line">int C(int d,int u) &#123;</span><br><span class="line">	int k1=1,k2=1;</span><br><span class="line">	for(RI i=d-u+1;i&lt;=d;++i) k1=1LL*k1*i%mod;</span><br><span class="line">	for(RI i=1;i&lt;=u;++i) k2=1LL*k2*i%mod;</span><br><span class="line">	return 1LL*k1*ksm(k2,mod-2)%mod;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;A,&amp;B);</span><br><span class="line">	if(!A||!B||A+B-2&gt;n-1) &#123;puts(&quot;0&quot;);return 0;&#125;</span><br><span class="line">	if(n==1) &#123;puts(&quot;1&quot;);return 0;&#125;</span><br><span class="line">	work(0,n-2,0);</span><br><span class="line">	ans=1LL*a[0][A+B-2]*C(A+B-2,B-1)%mod;</span><br><span class="line">	printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define RI register int</span><br><span class="line">const int mod=998244353,G=3,N=262150;</span><br><span class="line">int n,kn,len,ans;</span><br><span class="line">int a[N],b[N],fac[N],ni[N],rev[N];</span><br><span class="line">int ksm(int x,int y) &#123;</span><br><span class="line">	int re=1;</span><br><span class="line">	for(;y;y&gt;&gt;=1,x=1LL*x*x%mod) if(y&amp;1) re=1LL*re*x%mod;</span><br><span class="line">	return re;</span><br><span class="line">&#125;</span><br><span class="line">void NTT(int *a,int n,int x) &#123;</span><br><span class="line">    for(RI i=0;i&lt;n;++i) if(rev[i]&gt;i) swap(a[i],a[rev[i]]);</span><br><span class="line">    for(RI i=1;i&lt;n;i&lt;&lt;=1) &#123;</span><br><span class="line">        int gn=ksm(G,(mod-1)/(i&lt;&lt;1));</span><br><span class="line">        for(RI j=0;j&lt;n;j+=(i&lt;&lt;1)) &#123;</span><br><span class="line">            int g=1,t1,t2;</span><br><span class="line">            for(RI k=0;k&lt;i;++k,g=1LL*g*gn%mod) &#123;</span><br><span class="line">                t1=a[j+k],t2=1LL*g*a[j+i+k]%mod;</span><br><span class="line">                a[j+k]=(t1+t2)%mod,a[j+i+k]=(t1-t2+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x==1) return;</span><br><span class="line">    int inv=ksm(n,mod-2);reverse(a+1,a+n);</span><br><span class="line">    for(RI i=0;i&lt;n;++i) a[i]=1LL*a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	fac[0]=1;for(RI i=1;i&lt;=n;++i) fac[i]=1LL*fac[i-1]*i%mod;</span><br><span class="line">	ni[n]=ksm(fac[n],mod-2);</span><br><span class="line">	for(RI i=n-1;i&gt;=0;--i) ni[i]=1LL*ni[i+1]*(i+1)%mod;</span><br><span class="line">	for(RI i=0;i&lt;=n;++i) &#123;</span><br><span class="line">		a[i]=1LL*(1-2*(i&amp;1)+mod)%mod*ni[i]%mod;</span><br><span class="line">		if(i!=1) b[i]=1LL*(ksm(i,n+1)-1+mod)%mod*ni[i]%mod*ksm(i-1+mod,mod-2)%mod;</span><br><span class="line">		else b[i]=n+1;</span><br><span class="line">	&#125;</span><br><span class="line">	kn=1;while(kn&lt;=n+n) kn&lt;&lt;=1,++len;</span><br><span class="line">	for(RI i=0;i&lt;kn;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(len-1));</span><br><span class="line">	NTT(a,kn,1),NTT(b,kn,1);</span><br><span class="line">	for(RI i=0;i&lt;kn;++i) a[i]=1LL*a[i]*b[i]%mod;</span><br><span class="line">	NTT(a,kn,-1);</span><br><span class="line">	for(RI i=0,j=1;i&lt;=n;++i,j=(j+j)%mod)</span><br><span class="line">		ans=(ans+1LL*j*fac[i]%mod*a[i]%mod)%mod;</span><br><span class="line">	printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>逆元(Inverse element)就是在mod意义下，不能直接除以一个数，而要乘以它的逆元。<br>比如a∗b≡1(modp)a∗b≡1(modp)，那么a，b互为模n意义下的逆元，比如你要算x/a，就可以改成x*b%p</p>
<p>观察a∗b≡1(modp)a∗b≡1(modp),变形为a∗b+k∗p=1a∗b+k∗p=1，就可以用扩展欧几里得算法求a了，同时这里也说明了a和p只有在互素的情况下才存在逆元。</p>
<p>注意<br>在下面所有的算法中，最好先把除数取个模再运算。</p>
<h4 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h4><p>原理<br>a∗b≡1(modp)a∗b≡1(modp)<br>a∗b+k∗p=1a∗b+k∗p=1<br>然后a就是我们要求的逆元，最终得到一个正数a的话就要对a mod p，因为a加上mp的时侯k减少mb可以使得等式依然成立。</p>
<p>如果你不想让逆元为正数，那么直接返回x也是可以正确的逆元</p>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y)//扩展欧几里得算法 </span><br><span class="line">&#123;</span><br><span class="line">    if(b==0)</span><br><span class="line">    &#123;</span><br><span class="line">        x=1,y=0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">LL getInv(int a,int mod)//求a在mod下的逆元，不存在逆元返回-1 </span><br><span class="line">&#123;</span><br><span class="line">    LL x,y;</span><br><span class="line">    LL d=exgcd(a,mod,x,y);</span><br><span class="line">    return d==1?(x%mod+mod)%mod:-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：返回的时候可以改成(x+mod)%mod，因为扩展欧几里得算法算出来的x应该不会太大.</p>
<p>性能分析:</p>
<p>时间复杂度:O(logn)（实际是斐波那契数列）<br>适用范围：只要存在逆元即可求，适用于个数不多但是mod很大的时候，也是最常见的一种求逆元的方法。</p>
<h4 id="费马小定理-欧拉定理"><a href="#费马小定理-欧拉定理" class="headerlink" title="费马小定理/欧拉定理"></a>费马小定理/欧拉定理</h4><p>原理<br>费马小定理：若p为素数，则有ap−1≡1(modp)ap−1≡1(modp)<br>ap−2∗a≡1(modp)ap−2∗a≡1(modp)<br>ap−2ap−2就是a在mod p意义下的逆元啦。</p>
<p>欧拉定理：若a、p互素，则有aφ(p)≡1(modp)aφ(p)≡1(modp)(费马小定理的一般形式)<br>aφ(p)∗a≡1(modp)aφ(p)∗a≡1(modp)<br>aφ(p)−1aφ(p)−1就是a在mod p意义下的逆元啦。</p>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LL qkpow(LL a,LL p,LL mod)</span><br><span class="line">&#123;</span><br><span class="line">    LL t=1,tt=a%mod;</span><br><span class="line">    while(p)</span><br><span class="line">    &#123;</span><br><span class="line">        if(p&amp;1)t=t*tt%mod;</span><br><span class="line">        tt=tt*tt%mod;</span><br><span class="line">        p&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line">LL getInv(LL a,LL mod)</span><br><span class="line">&#123;</span><br><span class="line">    return qkpow(a,mod-2,mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能分析：</p>
<p>O(logmod)<br>适用范围：一般在mod是个素数的时候用，比扩欧快一点而且好写。<br>但是如果是合数，相信一般没人无聊到去算个欧拉函数。</p>
<h4 id="递推求逆元"><a href="#递推求逆元" class="headerlink" title="递推求逆元"></a>递推求逆元</h4><p>原理<br>p是模数，i是待求的逆元，我们求的是i−1i−1在mod p意义下的值<br>p=k∗i+rp=k∗i+r令 r &lt; i,则k=p/i,r=p%i<br>k∗i+r≡0(modp)k∗i+r≡0(modp)<br>k∗r−1+i−1≡0(modp)k∗r−1+i−1≡0(modp)<br>i−1≡−k∗r−1(modp)i−1≡−k∗r−1(modp)<br>i−1≡−p/i∗inv[pmodi]i−1≡−p/i∗inv[pmodi]<br>嗯。。好难看的公式<br>说白了就是:inv[i]=-(mod/i)*inv[i%mod]<br>然后边界是inv[1]=1<br>这不仅为我们提供了一个线性求逆元的方法，也提供了一种O(logmod)求逆元的方法</p>
<p>代码<br>线性求逆元</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LL inv[mod+5];</span><br><span class="line">void getInv(LL mod)</span><br><span class="line">&#123;</span><br><span class="line">    inv[1]=1;</span><br><span class="line">    for(int i=2;i&lt;mod;i++)</span><br><span class="line">        inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>调用前要先预处理<br>调用的时候要先对除数取mod<br>性能分析：</p>
<p>时间复杂度O(n)<br>适用范围：mod数是不大的素数而且多次调用，比如卢卡斯定理。<br>递归求逆元</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LL inv(LL i)</span><br><span class="line">&#123;</span><br><span class="line">    if(i==1)return 1;</span><br><span class="line">    return (mod-mod/i)*inv(mod%i)%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能分析</p>
<p>时间复杂度:O(logmod)<br>好像找到了最简单的算法了！！</p>
<p>适用范围： mod数是素数，所以并不好用，比如中国剩余定理中就不好使，因为很多时候可能会忘记考虑mod数是不是素数。</p>
<h3 id="miller-rabin，Pollard-rho算法"><a href="#miller-rabin，Pollard-rho算法" class="headerlink" title="miller-rabin，Pollard_rho算法"></a>miller-rabin，Pollard_rho算法</h3><h4 id="大素数判断和素因子分解"><a href="#大素数判断和素因子分解" class="headerlink" title="大素数判断和素因子分解"></a>大素数判断和素因子分解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//****************************************************************</span><br><span class="line">// Miller_Rabin 算法进行素数测试</span><br><span class="line">//速度快，而且可以判断 &lt;2^63的数</span><br><span class="line">//****************************************************************</span><br><span class="line">const int S=20;//随机算法判定次数，S越大，判错概率越小</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//计算 (a*b)%c.   a,b都是long long的数，直接相乘可能溢出的</span><br><span class="line">//  a,b,c &lt;2^63</span><br><span class="line">long long mult_mod(long long a,long long b,long long c)</span><br><span class="line">&#123;</span><br><span class="line">    a%=c;</span><br><span class="line">    b%=c;</span><br><span class="line">    long long ret=0;</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b&amp;1)&#123;ret+=a;ret%=c;&#125;</span><br><span class="line">        a&lt;&lt;=1;</span><br><span class="line">        if(a&gt;=c)a%=c;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//计算  x^n %c</span><br><span class="line">long long pow_mod(long long x,long long n,long long mod)//x^n%c</span><br><span class="line">&#123;</span><br><span class="line">    if(n==1)return x%mod;</span><br><span class="line">    x%=mod;</span><br><span class="line">    long long tmp=x;</span><br><span class="line">    long long ret=1;</span><br><span class="line">    while(n)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&amp;1) ret=mult_mod(ret,tmp,mod);</span><br><span class="line">        tmp=mult_mod(tmp,tmp,mod);</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//以a为基,n-1=x*2^t      a^(n-1)=1(mod n)  验证n是不是合数</span><br><span class="line">//一定是合数返回true,不一定返回false</span><br><span class="line">bool check(long long a,long long n,long long x,long long t)</span><br><span class="line">&#123;</span><br><span class="line">    long long ret=pow_mod(a,x,n);</span><br><span class="line">    long long last=ret;</span><br><span class="line">    for(int i=1;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret=mult_mod(ret,ret,n);</span><br><span class="line">        if(ret==1&amp;&amp;last!=1&amp;&amp;last!=n-1) return true;//合数</span><br><span class="line">        last=ret;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ret!=1) return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Miller_Rabin()算法素数判定</span><br><span class="line">//是素数返回true.(可能是伪素数，但概率极小)</span><br><span class="line">//合数返回false;</span><br><span class="line"></span><br><span class="line">bool Miller_Rabin(long long n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n&lt;2)return false;</span><br><span class="line">    if(n==2)return true;</span><br><span class="line">    if((n&amp;1)==0) return false;//偶数</span><br><span class="line">    long long x=n-1;</span><br><span class="line">    long long t=0;</span><br><span class="line">    while((x&amp;1)==0)&#123;x&gt;&gt;=1;t++;&#125;</span><br><span class="line">    for(int i=0;i&lt;S;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        long long a=rand()%(n-1)+1;//rand()需要stdlib.h头文件</span><br><span class="line">        if(check(a,n,x,t))</span><br><span class="line">            return false;//合数</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//************************************************</span><br><span class="line">//pollard_rho 算法进行质因数分解</span><br><span class="line">//************************************************</span><br><span class="line">long long factor[100];//质因数分解结果（刚返回时是无序的）</span><br><span class="line">int tol;//质因数的个数。数组小标从0开始</span><br><span class="line"></span><br><span class="line">long long gcd(long long a,long long b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a==0)return 1;//???????</span><br><span class="line">    if(a&lt;0) return gcd(-a,b);</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        long long t=a%b;</span><br><span class="line">        a=b;</span><br><span class="line">        b=t;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long Pollard_rho(long long x,long long c)</span><br><span class="line">&#123;</span><br><span class="line">    long long i=1,k=2;</span><br><span class="line">    long long x0=rand()%x;</span><br><span class="line">    long long y=x0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        x0=(mult_mod(x0,x0,x)+c)%x;</span><br><span class="line">        long long d=gcd(y-x0,x);</span><br><span class="line">        if(d!=1&amp;&amp;d!=x) return d;</span><br><span class="line">        if(y==x0) return x;</span><br><span class="line">        if(i==k)&#123;y=x0;k+=k;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//对n进行素因子分解</span><br><span class="line">void findfac(long long n)</span><br><span class="line">&#123;</span><br><span class="line">    if(Miller_Rabin(n))//素数</span><br><span class="line">    &#123;</span><br><span class="line">        factor[tol++]=n;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    long long p=n;</span><br><span class="line">    while(p&gt;=n)p=Pollard_rho(p,rand()%(n-1)+1);</span><br><span class="line">    findfac(p);</span><br><span class="line">    findfac(n/p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //srand(time(NULL));//需要time.h头文件//POJ上G++不能加这句话</span><br><span class="line">    long long n;</span><br><span class="line">    while(scanf(&quot;%I64d&quot;,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        tol=0;</span><br><span class="line">        findfac(n);</span><br><span class="line">        for(int i=0;i&lt;tol;i++)printf(&quot;%I64d &quot;,factor[i]);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        if(Miller_Rabin(n))printf(&quot;Yes\n&quot;);</span><br><span class="line">        else printf(&quot;No\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h2><h3 id="Lucas定理"><a href="#Lucas定理" class="headerlink" title="Lucas定理"></a>Lucas定理</h3><h4 id="费马小定理实现"><a href="#费马小定理实现" class="headerlink" title="费马小定理实现"></a>费马小定理实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">ll mulit(ll a,ll b,ll m)&#123;</span><br><span class="line">    ll ans=0;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) ans=(ans+a)%m;</span><br><span class="line">        a=(a&lt;&lt;1)%m;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll quick_mod(ll a,ll b,ll m)&#123;</span><br><span class="line">    ll ans=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans=mulit(ans,a,m);</span><br><span class="line">        &#125;</span><br><span class="line">        a=mulit(a,a,m);</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll comp(ll a,ll b,ll m)&#123;</span><br><span class="line">    if(a&lt;b) return 0;</span><br><span class="line">    if(a==b) return 1;</span><br><span class="line">    if(b&gt;a-b) b=a-b;</span><br><span class="line">    ll ans=1,ca=1,cb=1;</span><br><span class="line">    for(int i=0;i&lt;b;i++)&#123;</span><br><span class="line">        ca=ca*(a-i)%m;</span><br><span class="line">        cb=cb*(b-i)%m;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=ca*quick_mod(cb,m-2,m)%m;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll lucas(ll a,ll b,ll m)&#123;</span><br><span class="line">    ll ans=1;</span><br><span class="line">    while(a&amp;&amp;b)&#123;</span><br><span class="line">        ans=(ans*comp(a%m,b%m,m))%m;</span><br><span class="line">        a/=m;</span><br><span class="line">        b/=m;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll a,b,m;</span><br><span class="line">    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;m)&#123;</span><br><span class="line">        cout&lt;&lt;lucas(a,b,m)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="exgcd实现"><a href="#exgcd实现" class="headerlink" title="exgcd实现"></a>exgcd实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">ll exgcd(ll a,ll b,ll&amp; x,ll&amp; y)&#123;</span><br><span class="line">    if(a%b==0)&#123;</span><br><span class="line">        x=0,y=1;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">    ll r,tx,ty;</span><br><span class="line">    r=exgcd(b,a%b,tx,ty);</span><br><span class="line">    x=ty;</span><br><span class="line">    y=tx-a/b*ty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll comp(ll a,ll b,ll m)&#123;</span><br><span class="line">    if(a&lt;b) return 0;</span><br><span class="line">    if(a==b) return 1;</span><br><span class="line">    if(b&gt;a-b) b=a-b;</span><br><span class="line">    ll ans=1,ca=1,cb=1;</span><br><span class="line">    for(int i=0;i&lt;b;i++)&#123;</span><br><span class="line">        ca=ca*(a-i)%m;</span><br><span class="line">        cb=cb*(b-i)%m;</span><br><span class="line">    &#125;</span><br><span class="line">    ll x,y;</span><br><span class="line">    exgcd(cb,m,x,y);</span><br><span class="line">    x=(x%m+m)%m;</span><br><span class="line">    ans=ca*x%m;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll lucas(ll a,ll b,ll m)&#123;</span><br><span class="line">    ll ans=1;</span><br><span class="line">    while(a&amp;&amp;b)&#123;</span><br><span class="line">        ans=(ans*comp(a%m,b%m,m))%m;</span><br><span class="line">        a/=m;</span><br><span class="line">        b/=m;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll a,b,m;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;m;</span><br><span class="line">        cout&lt;&lt;lucas(a+b,b,m)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="全排列全组合"><a href="#全排列全组合" class="headerlink" title="全排列全组合"></a>全排列全组合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">/**** **** **** **** **** ****</span><br><span class="line">* Function Name : 全排列,全组合</span><br><span class="line">**** **** **** **** **** ****/</span><br><span class="line">void createper(int n) //全排列</span><br><span class="line">&#123;</span><br><span class="line">    int total,i,j,k,t,*a=new int[n],top;</span><br><span class="line">    total=1;</span><br><span class="line">    for(i=1; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=i;</span><br><span class="line">        total*=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=1; i&lt;n; i++)</span><br><span class="line">        printf(&quot;%d &quot;,a[i]);</span><br><span class="line">    printf(&quot;%d\n&quot;,a[n]);</span><br><span class="line">    for(i=1; i&lt;total; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j=n;</span><br><span class="line">        while(a[j]&lt;a[j-1])</span><br><span class="line">            j--;</span><br><span class="line">        k=n;</span><br><span class="line">        while(a[j-1]&gt;a[k])</span><br><span class="line">            k--;</span><br><span class="line">        t=a[j-1];</span><br><span class="line">        a[j-1]=a[k];</span><br><span class="line">        a[k]=t;</span><br><span class="line">        top=(j+n-1)/2;</span><br><span class="line">        for(k=j; k&lt;=top; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            t=a[k];</span><br><span class="line">            a[k]=a[n-k+j];</span><br><span class="line">            a[n-k+j]=t;</span><br><span class="line">        &#125;</span><br><span class="line">        for(j=1; j&lt;n; j++)</span><br><span class="line">            printf(&quot;%d &quot;,a[j]);</span><br><span class="line">        printf(&quot;%d\n&quot;,a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void createfab(int m,int n) //全组合</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,lcount,*a=new int[n+2];</span><br><span class="line">    for(i=1; i&lt;=n; i++)</span><br><span class="line">        a[i]=i;</span><br><span class="line">    a[n+1]=m+1;</span><br><span class="line">    for(j=1; j&lt;n; j++)</span><br><span class="line">        printf(&quot;%d &quot;,a[j]);</span><br><span class="line">    printf(&quot;%d\n&quot;,a[n]);</span><br><span class="line">    lcount=1;</span><br><span class="line">    while(a[1]&lt;m-n+1)</span><br><span class="line">    &#123;</span><br><span class="line">        for(i=n; i&gt;0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[i]&lt;a[i+1]-1)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i]++;</span><br><span class="line">                for(j=i; j&lt;n; j++)</span><br><span class="line">                    a[j+1]=a[j]+1;</span><br><span class="line">                for(j=1; j&lt;n; j++)</span><br><span class="line">                    printf(&quot;%d &quot;,a[j]);</span><br><span class="line">                printf(&quot;%d\n&quot;,a[n]);</span><br><span class="line">                lcount++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="母函数"><a href="#母函数" class="headerlink" title="母函数"></a>母函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// Author: Tanky Woo</span><br><span class="line">// www.wutianqi.com</span><br><span class="line">const int _max = 10001; </span><br><span class="line">// c1是保存各项质量砝码可以组合的数目</span><br><span class="line">// c2是中间量，保存每一次的情况</span><br><span class="line">int c1[_max], c2[_max];   </span><br><span class="line">int main()</span><br><span class="line">&#123;	//int n,i,j,k;</span><br><span class="line">	int nNum;   // </span><br><span class="line">	int i, j, k;</span><br><span class="line"> </span><br><span class="line">	while(cin &gt;&gt; nNum)</span><br><span class="line">	&#123;</span><br><span class="line">		for(i=0; i&lt;=nNum; ++i)   // ---- ①</span><br><span class="line">		&#123;</span><br><span class="line">			c1[i] = 1;</span><br><span class="line">			c2[i] = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		for(i=2; i&lt;=nNum; ++i)   // ----- ②</span><br><span class="line">		&#123;</span><br><span class="line"> </span><br><span class="line">			for(j=0; j&lt;=nNum; ++j)   // ----- ③</span><br><span class="line">				for(k=0; k+j&lt;=nNum; k+=i)  // ---- ④</span><br><span class="line">				&#123;</span><br><span class="line">					c2[j+k] += c1[j];</span><br><span class="line">				&#125;</span><br><span class="line">				for(j=0; j&lt;=nNum; ++j)     // ---- ⑤</span><br><span class="line">				&#123;</span><br><span class="line">					c1[j] = c2[j];</span><br><span class="line">					c2[j] = 0;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; c1[nNum] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int p[10]=&#123;0&#125;;</span><br><span class="line">int k;</span><br><span class="line">void getp(int n)</span><br><span class="line">&#123;</span><br><span class="line">	k=0;</span><br><span class="line">	for(int i=2;i*i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(n%i==0)</span><br><span class="line">		&#123;</span><br><span class="line">			p[k++]=i;	</span><br><span class="line">		&#125;</span><br><span class="line">		while(n%i==0)</span><br><span class="line">			n/=i;</span><br><span class="line">	&#125;</span><br><span class="line">	if(n&gt;1) p[k++]=n;</span><br><span class="line">&#125;</span><br><span class="line">int nop(int m)</span><br><span class="line">&#123;</span><br><span class="line">	int que[1000];</span><br><span class="line">	int top=0;</span><br><span class="line">	que[top++]=-1;</span><br><span class="line">	for(int i=0;i&lt;k;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int t=top;</span><br><span class="line">		for(int j=0;j&lt;t;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			que[top++]=que[j]*p[i]*(-1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int sum=0;</span><br><span class="line">	for(int i=1;i&lt;top;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=m/que[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">	getp(n);</span><br><span class="line">	printf(&quot;%d\n&quot;,m-nop(m));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const int MAXN = 1000000;</span><br><span class="line">bool check[MAXN+10];</span><br><span class="line">int prime[MAXN+10];</span><br><span class="line">int mu[MAXN+10];</span><br><span class="line">void Moblus()</span><br><span class="line">&#123;</span><br><span class="line">    memset(check,false,sizeof(check));</span><br><span class="line">    mu[1] = 1;</span><br><span class="line">    int tot = 0;</span><br><span class="line">    for(int i = 2; i &lt;= MAXN; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if( !check[i] )</span><br><span class="line">        &#123;</span><br><span class="line">            prime[tot++] = i;</span><br><span class="line">            mu[i] = −1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 0; j &lt; tot; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i * prime[j] &gt; MAXN)</span><br><span class="line">                break;</span><br><span class="line">            check[i * prime[j]] = true;</span><br><span class="line">            if( i % prime[j] == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                mu[i * prime[j]] = 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                mu[i * prime[j]] = −mu[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="莫比乌斯Euler打表"><a href="#莫比乌斯Euler打表" class="headerlink" title="莫比乌斯Euler打表"></a>莫比乌斯Euler打表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN=1e2;</span><br><span class="line"></span><br><span class="line">int phi[MAXN],n,tot;</span><br><span class="line">int pri[MAXN];</span><br><span class="line">bool mark[MAXN];</span><br><span class="line"></span><br><span class="line">void getphi()&#123;</span><br><span class="line">    phi[1]=1;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!mark[i])&#123;</span><br><span class="line">            phi[i]=i-1;</span><br><span class="line">            pri[++tot]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=1;j&lt;=tot;j++)&#123;</span><br><span class="line">            int x=pri[j];</span><br><span class="line">            if(i*x&gt;n) break;</span><br><span class="line">            mark[i*x]=1;</span><br><span class="line">            if(i%x==0)&#123;</span><br><span class="line">                phi[i*x]=phi[i]*x;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else phi[i*x]=phi[i]*phi[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">        tot=0;</span><br><span class="line">        getphi();</span><br><span class="line"></span><br><span class="line">            printf(&quot;%d\n&quot;,phi[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long exgcd(long long a, long long b, long long &amp;x, long long &amp;y) &#123;</span><br><span class="line">    if (!b) &#123;x = 1; y = 0; return a;&#125;</span><br><span class="line">    long long d = exgcd(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long inv(long long a, long long n) &#123;</span><br><span class="line">    long long x, y;</span><br><span class="line">    exgcd(a, n, x, y);</span><br><span class="line">    return (x + n) % n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long pow_mod(long long x, long long k, long long n) &#123;</span><br><span class="line">    if (k == 0) return 1;</span><br><span class="line">    long long ans = pow_mod(x * x % n, k&gt;&gt;1, n);</span><br><span class="line">    if (k&amp;1)</span><br><span class="line">    ans = ans * x % n;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long log_mod(long long a, long long b, long long n) &#123;</span><br><span class="line">    long long m = (long long)sqrt(n + 0.5), v, e = 1, i;</span><br><span class="line">    v = inv(pow_mod(a, m, n), n);</span><br><span class="line">    map&lt;long long, long long&gt; x;</span><br><span class="line">    x[1] = 0;</span><br><span class="line">    for (long long i = 1; i &lt; m; i++) &#123;</span><br><span class="line">    e = e * a % n;</span><br><span class="line">    if (!x.count(e)) x[e] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    for (long long i = 0; i &lt; m; i++) &#123;</span><br><span class="line">    if (x.count(b)) return i * m + x[b];</span><br><span class="line">    b = b * v % n;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const long long MOD = 100000007;</span><br><span class="line">long long n, k, b, r, Max, x[505], y[505];</span><br><span class="line">typedef pair&lt;long long, long long&gt; pii;</span><br><span class="line"></span><br><span class="line">set&lt;pii&gt; beats;</span><br><span class="line"></span><br><span class="line">long long cal() &#123;</span><br><span class="line">    long long ans = 0;</span><br><span class="line">    for (long long i = 0; i &lt; b; i++) &#123;</span><br><span class="line">    if (x[i] != Max &amp;&amp; !beats.count(make_pair(x[i] + 1, y[i])))</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += n;</span><br><span class="line">    for (long long i = 0; i &lt; b; i++) if (x[i] == 1) ans--;</span><br><span class="line">    return pow_mod(k, ans,  MOD) * pow_mod(k - 1, Max * n - b - ans, MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long solve() &#123;</span><br><span class="line">    long long m = cal();</span><br><span class="line">    if (m == r) return Max;</span><br><span class="line">    long long tmp = n;</span><br><span class="line">    for (long long i = 0; i &lt; b; i++)</span><br><span class="line">    if (x[i] == Max) tmp--;</span><br><span class="line">    long long ans = pow_mod(k - 1, tmp, MOD) * pow_mod(k, n - tmp, MOD) % MOD;</span><br><span class="line">    m = m * ans % MOD;</span><br><span class="line">    if (m == r) return Max + 1;</span><br><span class="line">    return log_mod(pow_mod(k - 1, n, MOD), r * inv(m, MOD) % MOD, MOD) + Max + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    while (~scanf(&quot;%lld%lld%lld%lld&quot;, &amp;n, &amp;k, &amp;b, &amp;r)) &#123;</span><br><span class="line">    beats.clear();</span><br><span class="line">    Max = 1;</span><br><span class="line"></span><br><span class="line">    for (long long i = 0; i &lt; b; i++) &#123;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;, &amp;x[i], &amp;y[i]);</span><br><span class="line">        beats.insert(make_pair(x[i], y[i]));</span><br><span class="line">        Max = max(Max, x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,solve());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自适应-simpson-积分"><a href="#自适应-simpson-积分" class="headerlink" title="自适应 simpson 积分"></a>自适应 simpson 积分</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">double simpson(double a,double b)</span><br><span class="line">&#123;</span><br><span class="line">    double c = a + (b−a)/2;</span><br><span class="line">    return (F(a) + 4*F(c) + F(b))*(b−a)/6</span><br><span class="line">&#125;</span><br><span class="line">double asr(double a,double b,double eps,double A)</span><br><span class="line">&#123;</span><br><span class="line">    double c = a + (b−a)/2;</span><br><span class="line">    double L = simpson(a,c), R = simpson(c,b);</span><br><span class="line">    if(fabs(L + R − A) &lt;= 15*eps)</span><br><span class="line">        return L + R + (L + R − A)/15.0;</span><br><span class="line">    return asr(a,c,eps/2,L) + asr(c,b,eps/2,R)</span><br><span class="line">&#125;</span><br><span class="line">double asr(double a,double b,double eps)return asr(a,b,eps,simpson(a,b));</span><br></pre></td></tr></table></figure>
<h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int pow_mod(int a, int n, int m)</span><br><span class="line">&#123;</span><br><span class="line">    long long ans = 1;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1)&#123;</span><br><span class="line">            ans = (ans * a) % m;</span><br><span class="line">        &#125;</span><br><span class="line">        a = (a * a) % m;</span><br><span class="line">        n &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, n, m;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; pow_mod(a, n, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const int N=10;  </span><br><span class="line">int tmp[N][N];  </span><br><span class="line">void multi(int a[][N],int b[][N],int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(tmp,0,sizeof tmp);  </span><br><span class="line">    for(int i=0;i&lt;n;i++)  </span><br><span class="line">        for(int j=0;j&lt;n;j++)  </span><br><span class="line">        for(int k=0;k&lt;n;k++)  </span><br><span class="line">        tmp[i][j]+=a[i][k]*b[k][j];  </span><br><span class="line">    for(int i=0;i&lt;n;i++)  </span><br><span class="line">        for(int j=0;j&lt;n;j++)  </span><br><span class="line">        a[i][j]=tmp[i][j];  </span><br><span class="line">&#125;  </span><br><span class="line">int res[N][N];  </span><br><span class="line">void Pow(int a[][N],int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(res,0,sizeof res);//n是幂，N是矩阵大小  </span><br><span class="line">    for(int i=0;i&lt;N;i++) res[i][i]=1;  </span><br><span class="line">    while(n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if(n&amp;1)  </span><br><span class="line">            multi(res,a,N);//res=res*a;复制直接在multi里面实现了；  </span><br><span class="line">        multi(a,a,N);//a=a*a  </span><br><span class="line">        n&gt;&gt;=1;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h3><p>如果要求模的常数是一个64bit整数，那么在做乘法时，就没有扩展类型使用，必须手写一个高精度整数运算。</p>
<h4 id="O-logn-快速乘"><a href="#O-logn-快速乘" class="headerlink" title="O(logn)快速乘"></a>O(logn)快速乘</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline LL quick_mul(LL a,LL n,LL m)&#123;</span><br><span class="line">    LL ans=0;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) ans=(ans+a)%m;</span><br><span class="line">        a=(a&lt;&lt;1)%m;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="O-1-快速乘"><a href="#O-1-快速乘" class="headerlink" title="O(1)快速乘"></a>O(1)快速乘</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef long long ll;</span><br><span class="line">#define MOL 123456789012345LL</span><br><span class="line">inline ll mul_mod_ll(ll a,ll b)&#123;</span><br><span class="line">    ll d=(ll)floor(a*(long double)b/MOL+0.5);</span><br><span class="line">    ll ret=a*b-d*MOL;</span><br><span class="line">    if(ret&lt;0)   ret+=MOL;</span><br><span class="line">    return   ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，使用浮点数计算 a<em>b/MOL 的值，关键在于第二句，显然 a</em>b - d*MOL 两个乘法都可能溢出，不过没关系，因为可以预见，其差是一个64bit可以容纳的正整数，那么溢出部分的差仅可能是0或者1。最后一句符号的特判用来处理溢出部分差为1的情况。</p>
<p>考虑到计算 a*b/MOL 使用了浮点数计算，误差是不可避免的，故建议不要用太大的MOL使用这个方法。</p>
<h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline ll ksc(ll x,ll y,ll mod)&#123;</span><br><span class="line">    return (x*y-(ll)((long double)x/mod*y)*mod+mod)%mod;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为x,y都是mod意义下的，保证了x*y/mod不会爆long long。</p>
<h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**** **** **** **** **** ****</span><br><span class="line">* Function Name : 高斯消元法</span><br><span class="line">* Description : 求解线性方程组</span><br><span class="line">*</span><br><span class="line">* void exchange_col(int p1,int p2,int n)</span><br><span class="line">* 交换 p1 行和 p2 行的所有数据</span><br><span class="line">*</span><br><span class="line">* bool gauss(int n)</span><br><span class="line">* 求解系数矩阵为 n 的线性方程组，方程组无解返回 false，否则 true</span><br><span class="line">*</span><br><span class="line">* x1 = x0 - f(x0)/f&apos;(x0) 牛顿迭代法</span><br><span class="line">**** **** **** **** **** ****/</span><br><span class="line">const int num = 100;</span><br><span class="line">double matrix[num][num + 1]; //系数矩阵，从 0 开始</span><br><span class="line">double ans[num]; //结果数组</span><br><span class="line">void exchange_col(int p1,int p2,int n) //交换 p1 行和 p2 行的所有数据</span><br><span class="line">&#123;</span><br><span class="line">    double t;</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 0 ; i &lt;= n ; i++)</span><br><span class="line">        t = matrix[p1][i],matrix[p1][i] = matrix[p2][i],matrix[p2][i] = t;</span><br><span class="line">&#125;</span><br><span class="line">bool gauss(int n) //求解系数矩阵为 n 的线性方程组</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    int p;</span><br><span class="line">    double r;</span><br><span class="line">    for(i = 0 ; i &lt; n - 1 ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = i;</span><br><span class="line">        for(j = i + 1 ; j &lt; n ; j++)   //寻找 i 列绝对值最大值位置</span><br><span class="line">        &#123;</span><br><span class="line">            if(abs(matrix[j][i]) &gt; abs(matrix[p][i]))</span><br><span class="line">                p = j;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p != i)</span><br><span class="line">            exchange_col(i,p,n);</span><br><span class="line">        if(matrix[i][i] == 0)</span><br><span class="line">            return false;</span><br><span class="line">        for(j = i + 1 ; j &lt; n ; j++)   //剩余列进行消元</span><br><span class="line">        &#123;</span><br><span class="line">            r = matrix[j][i] / matrix[i][i];</span><br><span class="line">            for(k = i ; k &lt;= n ; k++)</span><br><span class="line">                matrix[j][k] -= r * matrix[i][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i = n - 1 ; i &gt;= 0 ; i--)   //获得结果</span><br><span class="line">    &#123;</span><br><span class="line">        ans[i] = matrix[i][n];</span><br><span class="line">        for(j = n - 1 ; j &gt; i ; j--)</span><br><span class="line">            ans[i] -= matrix[i][j] * ans[j];</span><br><span class="line">        if(matrix[i][i] == 0)</span><br><span class="line">            return false;</span><br><span class="line">        ans[i] /= matrix[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">const int HASH = 10007;</span><br><span class="line">const int MAXN = 2010;</span><br><span class="line">struct HASHMAP</span><br><span class="line">&#123;</span><br><span class="line">    int head[HASH],next[MAXN],size;</span><br><span class="line">    unsigned long long state[MAXN];</span><br><span class="line">    int f[MAXN];</span><br><span class="line">    void init()</span><br><span class="line">    &#123;</span><br><span class="line">        size = 0;</span><br><span class="line">        memset(head,−1,sizeof(head));</span><br><span class="line">    &#125; int insert(unsigned long long val,int _id)</span><br><span class="line">    &#123;</span><br><span class="line">        int h = val%HASH;</span><br><span class="line">        for(int i = head[h]; i != −1; i = next[i])</span><br><span class="line">            if(val == state[i])</span><br><span class="line">            &#123;</span><br><span class="line">                int tmp = f[i];</span><br><span class="line">                f[i] = _id;</span><br><span class="line">                return tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        f[size] = _id;</span><br><span class="line">        state[size] = val;</span><br><span class="line">        next[size] = head[h];</span><br><span class="line">        head[h] = size++;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; H;</span><br><span class="line">const int SEED = 13331;</span><br><span class="line">unsigned long long P[MAXN];</span><br><span class="line">unsigned long long S[MAXN];</span><br><span class="line">char str[MAXN];</span><br><span class="line">int ans[MAXN][MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    P[0] = 1;</span><br><span class="line">    for(int i = 1; i &lt; MAXN; i++)</span><br><span class="line">        P[i] = P[i−1] * SEED;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T−−)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%s&quot;,str);</span><br><span class="line">        int n = strlen(str);</span><br><span class="line">        S[0] = 0;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)</span><br><span class="line">            S[i] = S[i−1]*SEED + str[i−1];</span><br><span class="line">        memset(ans,0,sizeof(ans));</span><br><span class="line">        for(int L = 1; L &lt;= n; L++)</span><br><span class="line">        &#123;</span><br><span class="line">            H.init();</span><br><span class="line">            for(int i = 1; i + L − 1 &lt;= n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int l = H.insert(S[i+L−1] − S[i−1]*P[L],i);</span><br><span class="line">                ans[i][i+L−1] ++;</span><br><span class="line">                ans[l][i+L−1]−−;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = n; i &gt;= 0; i−−)</span><br><span class="line">            for(int j = i; j &lt;= n; j++)</span><br><span class="line">                ans[i][j] += ans[i+1][j] + ans[i][j−1] − ans[i−1];</span><br><span class="line">        int m,u,v;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">        while(m−−)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">            printf(&quot;%d\n&quot;,ans[u][v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串和数值hash"><a href="#字符串和数值hash" class="headerlink" title="字符串和数值hash"></a>字符串和数值hash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// 整数hash</span><br><span class="line">// 104729, 224737, 350377, 479909, 611953, 882377</span><br><span class="line">// 1020379, 1299709, 1583539, 1870667, 2015177</span><br><span class="line">// 4256233,5800079,7368787, 10570841, 15485863</span><br><span class="line">const int MOD = 20023;</span><br><span class="line">bool bhash[MOD];</span><br><span class="line">int vhash[MOD];</span><br><span class="line">int cnt[MOD];</span><br><span class="line">bool find_hash(int &amp; pos)</span><br><span class="line">&#123;</span><br><span class="line">    int val = pos;</span><br><span class="line">    pos %= MOD;</span><br><span class="line">    for (; bhash[pos]; pos=(pos+1)%MOD)</span><br><span class="line">    &#123;</span><br><span class="line">        if (vhash[pos] == val)</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int make_hash(int val)</span><br><span class="line">&#123;</span><br><span class="line">    int pos = val;</span><br><span class="line">    if (! find_hash(pos))</span><br><span class="line">    &#123;</span><br><span class="line">        bhash[pos] = true;</span><br><span class="line">        vhash[pos] = val;</span><br><span class="line">        cnt[pos] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[pos] ++;</span><br><span class="line">    return pos;</span><br><span class="line">&#125;</span><br><span class="line">//字符串hash</span><br><span class="line">const int MOD = 20023;</span><br><span class="line">bool bhash[MOD];</span><br><span class="line">char vhash[MOD][45];</span><br><span class="line">char str[45];</span><br><span class="line">int cal_str()</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, pos;</span><br><span class="line">    for (i=pos=0,j=1; str[i]; i++,j=(j*27)&amp;INT_MAX,pos&amp;=INT_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        int num = str[i] - &apos;a&apos;;</span><br><span class="line">        if (str[i] == &apos; &apos;)</span><br><span class="line">            num = 26;</span><br><span class="line">        pos += j*num;</span><br><span class="line">    &#125;</span><br><span class="line">    return pos % MOD;</span><br><span class="line">&#125;</span><br><span class="line">bool find_hash(int &amp; pos)</span><br><span class="line">&#123;</span><br><span class="line">    pos = cal_str();</span><br><span class="line">    for (; bhash[pos]; pos=(pos+1)%MOD)</span><br><span class="line">    &#123;</span><br><span class="line">        if (strcmp(vhash[pos], str) == 0)</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int make_hash()</span><br><span class="line">&#123;</span><br><span class="line">    int pos;</span><br><span class="line">    if (! find_hash(pos))</span><br><span class="line">    &#123;</span><br><span class="line">        bhash[pos] = true;</span><br><span class="line">        strcpy(vhash[pos], str);</span><br><span class="line">    &#125;</span><br><span class="line">    return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BM"><a href="#BM" class="headerlink" title="BM"></a>BM</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">int* CreateBC(char* pattern, int len)</span><br><span class="line">&#123;</span><br><span class="line">	int* bc = new int[256];</span><br><span class="line"> </span><br><span class="line">	for(int i = 0; i &lt; 256; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		bc[i] = -1;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	for(int i = 0; i &lt; len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		bc[pattern[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	for(int i = 0; i &lt; 256; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		if(bc[i] != -1)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; &quot;bc[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; bc[i] &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return bc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int* CreateSuffix(char* pattern, int len)</span><br><span class="line">&#123;</span><br><span class="line">	int* suffix = new int[len];</span><br><span class="line">	suffix[len - 1] = len;</span><br><span class="line"> </span><br><span class="line">	for(int i = len - 2; i &gt;= 0; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		int j = i;</span><br><span class="line">		for(; pattern[j] == pattern[len - 1 - i + j] &amp;&amp; j &gt;= 0; --j);</span><br><span class="line">		suffix[i] = i - j;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	for(int i = 0; i &lt; len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;suffix[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; suffix[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return suffix;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int* CreateGS(char* pattern, int len)</span><br><span class="line">&#123;</span><br><span class="line">	int* suffix = CreateSuffix(pattern, len);</span><br><span class="line">	int* gs = new int[len];</span><br><span class="line">	/*</span><br><span class="line">	在计算gs数组时，从移动数最大的情况依次到移动数最少的情况赋值，</span><br><span class="line">	确保在合理的移动范围内，移动最少的距离，避免失配的情况。</span><br><span class="line">	*/</span><br><span class="line"> </span><br><span class="line">    //第三种情况</span><br><span class="line">	for(int i = 1; i &lt; len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		gs[i] = len;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    //第二种情况</span><br><span class="line">	for(int i = len - 1; i &gt;= 0; --i) //从右往左扫描，确保模式串移动最少。</span><br><span class="line">	&#123;</span><br><span class="line">		if(suffix[i] == i + 1) //是一个与好后缀匹配的最大前缀</span><br><span class="line">		&#123;</span><br><span class="line">			for(int j = 0; j &lt; len - 1 - i; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				if(gs[j] == len) //gs[j]初始值为len, 这样确保gs[j]只被修改一次</span><br><span class="line">				&#123;</span><br><span class="line">					gs[j] = len - 1 - i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    //第一种情况</span><br><span class="line">	for(int i = 0; i &lt; len - 1; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		gs[len - 1 - suffix[i]] = len - 1 - i;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return gs;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int bm_search(char* text, int text_len, char* pattern, int pattern_len)</span><br><span class="line">&#123;</span><br><span class="line">	int* bc = CreateBC(pattern, pattern_len);</span><br><span class="line">	int* gs = CreateGS(pattern, pattern_len);</span><br><span class="line"> </span><br><span class="line">	for(int i = 0; i &lt;= text_len - pattern_len; )</span><br><span class="line">	&#123;</span><br><span class="line">		int j = pattern_len - 1;</span><br><span class="line">		for(; j &gt;= 0 &amp;&amp; pattern[j] == text[i+j]; --j);</span><br><span class="line"> </span><br><span class="line">		if(j &lt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			return i;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		int bad_char_index = j;</span><br><span class="line">		char bad_char = text[i + j];</span><br><span class="line"> </span><br><span class="line">		int bc_move = bad_char_index - bc[bad_char];</span><br><span class="line">		if(bc_move &lt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			bc_move = bad_char_index + 1;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		int gs_move = gs[bad_char_index];</span><br><span class="line"> </span><br><span class="line">		int move = (bc_move &gt; gs_move ? bc_move : gs_move);</span><br><span class="line"> </span><br><span class="line">		i += move;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	if(bc != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		delete bc;</span><br><span class="line">		bc = NULL;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	if(gs != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		delete bc;</span><br><span class="line">		gs = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**** **** **** **** **** ****</span><br><span class="line">* Function Name : 字符串匹配(KMP 算法)</span><br><span class="line">* Description : O(N+M)</span><br><span class="line">**** **** **** **** **** ****/</span><br><span class="line">void get_nextval(const string &amp; s, int * p)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0,j = -1;</span><br><span class="line">    p[0] = -1;</span><br><span class="line">    while(i &lt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        if(j == -1 || s[i] == s[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i,++j;</span><br><span class="line">            if(s[i] != s[j])</span><br><span class="line">                p[i] = j;</span><br><span class="line">            else</span><br><span class="line">                p[i] = p[j];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            j = p[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int Index_KMP(const string &amp; s, const string &amp; s1, int pos)</span><br><span class="line">&#123;</span><br><span class="line">    int i = pos - 1,j = 0;</span><br><span class="line">    int * next = new int[s1.size()];</span><br><span class="line">    get_nextval(s1,next);</span><br><span class="line">    while(i &lt;= s.size() &amp;&amp; j &lt;= s1.size())</span><br><span class="line">    &#123;</span><br><span class="line">        if(j == -1 || s[i] == s1[j])</span><br><span class="line">            ++i,++j;</span><br><span class="line">        else</span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    if(j &gt; s1.size())</span><br><span class="line">        return i - s1.size();</span><br><span class="line">    else</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">//该程序不能判别相同模式串，因此若模式串重复，答案会将相同模式串当做不同的处理，因此若需要可以用map去重或修改insert</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxm=500006;    //maxm是总结点数：约为字母数+++</span><br><span class="line"></span><br><span class="line">char s[1000005],word[55];</span><br><span class="line">int nxt[maxm][26],tail[maxm],f[maxm],size;    //nxt是结点指向不同字母的结点下标，tail是表示该结点为几个单词的词尾(可能需要计算重复的模式串情况),f是当不匹配时转跳到的结点下标,size是结点数</span><br><span class="line"></span><br><span class="line">int newnode()&#123;    //初始化整个trie或建立新的结点时，首先初始化当前结点所指向的26个字母的结点为0，表示暂时还没有指向的字母，然后暂定该结点不是单词尾结点，暂无失配时转跳位置（即转跳到根节点），返回结点标号</span><br><span class="line">    memset(nxt[size],0,sizeof(nxt[size]));</span><br><span class="line">    f[size]=tail[size]=0;</span><br><span class="line">    return size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(char s[])&#123;    //构造trie,p为当前结点的上一个结点标号，初始为0；x即为当前结点（上个结点标号指向当前字母的结点）标号,若此结点还未出现过，那么就建立这个结点；然后更新p为当前结点标号以便后续操作</span><br><span class="line">    int i,p=0;</span><br><span class="line">    for(i=0;s[i];i++)&#123;</span><br><span class="line">        int &amp;x=nxt[p][s[i]-&apos;a&apos;];</span><br><span class="line">        p=x?x:x=newnode();</span><br><span class="line">    &#125;</span><br><span class="line">    tail[p]++;    //此时仅将s串记录，即将s串结尾的结点加1，若无相同模式串，则此操作只会使所有串尾结点的tail值由0变为1，但有相同模式串，则会重复记录，需要去重可以用map或用tail[p]=1;语句来完成</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void makenxt()&#123;    //利用bfs来构造失配指针</span><br><span class="line">    int i;</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    f[0]=0;    //先将0结点挂的字母加入队列，失配指针指向0结点</span><br><span class="line">    for(i=0;i&lt;26;i++)&#123;</span><br><span class="line">        int v=nxt[0][i];</span><br><span class="line">        if(v)&#123;</span><br><span class="line">            f[v]=0;</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(i=0;i&lt;26;i++)&#123;</span><br><span class="line">            int v=nxt[u][i];</span><br><span class="line">            if(!v)nxt[u][i]=nxt[f[u]][i];    //当u结点没有i对应字母，则视为失配，将其指向失配后转跳到的结点所指向的i对应字母</span><br><span class="line">            else&#123;</span><br><span class="line">                q.push(v);    //u结点存在指向i的结点，则将所指向的结点下标加入队列</span><br><span class="line">                f[v]=nxt[f[u]][i];    //失配指针指向上个结点失配指针指向结点所挂当前字母的结点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(char s[])&#123;    //查询s串中模式串出现了多少种/次</span><br><span class="line">    int ans=0,v=0;</span><br><span class="line">    for(int i=0;s[i];i++)&#123;</span><br><span class="line">        while(v&amp;&amp;!nxt[v][s[i]-&apos;a&apos;])v=f[v];    //先匹配直到没有失配</span><br><span class="line">        v=nxt[v][s[i]-&apos;a&apos;];</span><br><span class="line">        int tmp=v;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            ans+=tail[tmp];</span><br><span class="line">            tail[tmp]=0;    //这里加这句是为了仅计算出现多少种模式链，而若不加这句则可以计算累计出现多少次</span><br><span class="line">            tmp=f[tmp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        int n;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        size=0,newnode();</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,word);</span><br><span class="line">            insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        makenxt();</span><br><span class="line">        scanf(&quot;%s&quot;,s);</span><br><span class="line">        printf(&quot;%d\n&quot;,query(s));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">const int CHAR = 26;</span><br><span class="line">const int MAXN = 250010;</span><br><span class="line">struct SAM_Node</span><br><span class="line">&#123;</span><br><span class="line">    SAM_Node *fa,*next[CHAR];</span><br><span class="line">    int len;</span><br><span class="line">    long long cnt;</span><br><span class="line">    void clear()</span><br><span class="line">    &#123;</span><br><span class="line">        fa = 0;</span><br><span class="line">        memset(next,0,sizeof(next));</span><br><span class="line">        cnt = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; pool[MAXN*2];</span><br><span class="line">SAM_Node *root,*tail;</span><br><span class="line">SAM_Node* newnode(int len)</span><br><span class="line">&#123;</span><br><span class="line">    SAM_Node* cur = tail++;</span><br><span class="line">    cur−&gt;clear();</span><br><span class="line">    cur−&gt;len = len;</span><br><span class="line">    return cur;</span><br><span class="line">&#125;</span><br><span class="line">void SAM_init()</span><br><span class="line">&#123;</span><br><span class="line">    tail = pool;</span><br><span class="line">    root = newnode(0);</span><br><span class="line">&#125;</span><br><span class="line">SAM_Node* extend(SAM_Node* last,int x)</span><br><span class="line">&#123;</span><br><span class="line">    SAM_Node *p = last, *np = newnode(p−&gt;len+1);</span><br><span class="line">    while(p &amp;&amp; !p−&gt;next[x])</span><br><span class="line">        p−&gt;next[x] = np, p = p−&gt;fa;</span><br><span class="line">    if(!p)</span><br><span class="line">        np−&gt;fa = root;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        SAM_Node* q = p−&gt;next[x];</span><br><span class="line">        if(q−&gt;len == p−&gt;len+1)</span><br><span class="line">            np−&gt;fa = q;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            SAM_Node* nq = newnode(p−&gt;len+1);</span><br><span class="line">            memcpy(nq−&gt;next,q−&gt;next,sizeof(q−&gt;nextnq−&gt;fa = q−&gt;fa; q−&gt;fa = np−&gt;fa = nq;</span><br><span class="line">                                               while(p &amp;&amp; p−&gt;next[x] == q)p−&gt;next[x] = nq, p = p−&gt;fa;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">return np;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><h2 id="基础计算几何"><a href="#基础计算几何" class="headerlink" title="基础计算几何"></a>基础计算几何</h2><h3 id="几何公式"><a href="#几何公式" class="headerlink" title="几何公式"></a><strong>几何公式</strong></h3><h4 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a><strong>三角形</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">\1. 半周长 P=(a+b+c)/2</span><br><span class="line"></span><br><span class="line">\2. 面积 S=aHa/2=absin(C)/2=sqrt(P(P-a)(P-b)(P-c))</span><br><span class="line"></span><br><span class="line">\3. 中线 Ma=sqrt(2(b^2+c^2)-a^2)/2=sqrt(b^2+c^2+2bccos(A))/2</span><br><span class="line"></span><br><span class="line">\4. 角平分线 Ta=sqrt(bc((b+c)^2-a^2))/(b+c)=2bccos(A/2)/(b+c)</span><br><span class="line"></span><br><span class="line">\5. 高线 Ha=bsin(C)=csin(B)=sqrt(b^2-((a^2+b^2-c^2)/(2a))^2)</span><br><span class="line"></span><br><span class="line">\6. 内切圆半径 r=S/P=asin(B/2)sin(C/2)/sin((B+C)/2)</span><br><span class="line"></span><br><span class="line">               =4Rsin(A/2)sin(B/2)sin(C/2)=sqrt((P-a)(P-b)(P-c)/P)</span><br><span class="line"></span><br><span class="line">               =Ptan(A/2)tan(B/2)tan(C/2)</span><br><span class="line"></span><br><span class="line">\7. 外接圆半径 R=abc/(4S)=a/(2sin(A))=b/(2sin(B))=c/(2sin(C))</span><br></pre></td></tr></table></figure>
<h4 id="四边形"><a href="#四边形" class="headerlink" title="四边形"></a><strong>四边形</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D1,D2为对角线,M对角线中点连线,A为对角线夹角</span><br><span class="line"></span><br><span class="line">\1. a^2+b^2+c^2+d^2=D1^2+D2^2+4M^2</span><br><span class="line"></span><br><span class="line">\2. S=D1D2sin(A)/2</span><br><span class="line"></span><br><span class="line">(以下对圆的内接四边形)</span><br><span class="line"></span><br><span class="line">\3. ac+bd=D1D2</span><br><span class="line"></span><br><span class="line">\4. S=sqrt((P-a)(P-b)(P-c)(P-d)),P为半周长</span><br></pre></td></tr></table></figure>
<h4 id="正n边形"><a href="#正n边形" class="headerlink" title="正n边形"></a><strong>正n边形</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">R为外接圆半径,r为内切圆半径</span><br><span class="line"></span><br><span class="line">\1. 中心角 A=2PI/n</span><br><span class="line"></span><br><span class="line">\2. 内角 C=(n-2)PI/n</span><br><span class="line"></span><br><span class="line">\3. 边长 a=2sqrt(R^2-r^2)=2Rsin(A/2)=2rtan(A/2)</span><br><span class="line"></span><br><span class="line">\4. 面积 S=nar/2=nr^2tan(A/2)=nR^2sin(A)/2=na^2/(4tan(A/2))</span><br></pre></td></tr></table></figure>
<h4 id="圆"><a href="#圆" class="headerlink" title="圆"></a><strong>圆</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\1. 弧长 l=rA</span><br><span class="line"></span><br><span class="line">\2. 弦长 a=2sqrt(2hr-h^2)=2rsin(A/2)</span><br><span class="line"></span><br><span class="line">\3. 弓形高 h=r-sqrt(r^2-a^2/4)=r(1-cos(A/2))=atan(A/4)/2</span><br><span class="line"></span><br><span class="line">\4. 扇形面积 S1=rl/2=r^2A/2</span><br><span class="line"></span><br><span class="line">\5. 弓形面积 S2=(rl-a(r-h))/2=r^2(A-sin(A))/2</span><br></pre></td></tr></table></figure>
<h4 id="棱柱"><a href="#棱柱" class="headerlink" title="棱柱"></a><strong>棱柱</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\1. 体积 V=Ah,A为底面积,h为高</span><br><span class="line"></span><br><span class="line">\2. 侧面积 S=lp,l为棱长,p为直截面周长</span><br><span class="line"></span><br><span class="line">\3. 全面积 T=S+2A</span><br></pre></td></tr></table></figure>
<h4 id="棱锥"><a href="#棱锥" class="headerlink" title="棱锥"></a><strong>棱锥</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\1. 体积 V=Ah/3,A为底面积,h为高</span><br><span class="line"></span><br><span class="line">(以下对正棱锥)</span><br><span class="line"></span><br><span class="line">\2. 侧面积 S=lp/2,l为斜高,p为底面周长</span><br><span class="line"></span><br><span class="line">\3. 全面积 T=S+A</span><br></pre></td></tr></table></figure>
<h4 id="棱台"><a href="#棱台" class="headerlink" title="棱台"></a><strong>棱台</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\1. 体积 V=(A1+A2+sqrt(A1A2))h/3,A1.A2为上下底面积,h为高</span><br><span class="line"></span><br><span class="line">(以下为正棱台)</span><br><span class="line"></span><br><span class="line">\2. 侧面积 S=(p1+p2)l/2,p1.p2为上下底面周长,l为斜高</span><br><span class="line"></span><br><span class="line">\3. 全面积 T=S+A1+A2</span><br></pre></td></tr></table></figure>
<h4 id="圆柱"><a href="#圆柱" class="headerlink" title="圆柱"></a><strong>圆柱</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\1. 侧面积 S=2PIrh</span><br><span class="line"></span><br><span class="line">\2. 全面积 T=2PIr(h+r)</span><br><span class="line"></span><br><span class="line">\3. 体积 V=PIr^2h</span><br></pre></td></tr></table></figure>
<h4 id="圆锥"><a href="#圆锥" class="headerlink" title="圆锥"></a><strong>圆锥</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\1. 母线 l=sqrt(h^2+r^2)</span><br><span class="line"></span><br><span class="line">\2. 侧面积 S=PIrl</span><br><span class="line"></span><br><span class="line">\3. 全面积 T=PIr(l+r)</span><br><span class="line"></span><br><span class="line">\4. 体积 V=PIr^2h/3</span><br></pre></td></tr></table></figure>
<h4 id="圆台"><a href="#圆台" class="headerlink" title="圆台"></a><strong>圆台</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\1. 母线 l=sqrt(h^2+(r1-r2)^2)</span><br><span class="line"></span><br><span class="line">\2. 侧面积 S=PI(r1+r2)l</span><br><span class="line"></span><br><span class="line">\3. 全面积 T=PIr1(l+r1)+PIr2(l+r2)</span><br><span class="line"></span><br><span class="line">\4. 体积 V=PI(r1^2+r2^2+r1r2)h/3</span><br></pre></td></tr></table></figure>
<h4 id="球"><a href="#球" class="headerlink" title="球"></a><strong>球</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\1. 全面积 T=4PIr^2</span><br><span class="line"></span><br><span class="line">\2. 体积 V=4PIr^3/3</span><br></pre></td></tr></table></figure>
<h4 id="球台"><a href="#球台" class="headerlink" title="球台"></a><strong>球台</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\1. 侧面积 S=2PIrh</span><br><span class="line"></span><br><span class="line">\2. 全面积 T=PI(2rh+r1^2+r2^2)</span><br><span class="line"></span><br><span class="line">\3. 体积 V=PIh(3(r1^2+r2^2)+h^2)/6</span><br></pre></td></tr></table></figure>
<h4 id="球扇形"><a href="#球扇形" class="headerlink" title="球扇形"></a><strong>球扇形</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\1. 全面积 T=PIr(2h+r0),h为球冠高,r0为球冠底面半径</span><br><span class="line"></span><br><span class="line">\2. 体积 V=2PIr^2h/3</span><br></pre></td></tr></table></figure>
<h3 id="直线与线段"><a href="#直线与线段" class="headerlink" title="直线与线段"></a><strong>直线与线段</strong></h3><h4 id="预备函数"><a href="#预备函数" class="headerlink" title="预备函数"></a><strong>预备函数</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">**//结构定义与宏定义**</span><br><span class="line"></span><br><span class="line">\#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#define eps 1e-8</span><br><span class="line"></span><br><span class="line">\#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)</span><br><span class="line"></span><br><span class="line">struct point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    double x,y;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct line</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    point a,b;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//计算cross product (P1-P0)x(P2-P0)**</span><br><span class="line"></span><br><span class="line">double xmult(point p1,point p2,point p0)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double xmult(double x1,double y1,double x2,double y2,double x0,double y0)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    return (x1-x0)*(y2-y0)-(x2-x0)*(y1-y0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//计算dot product (P1-P0).(P2-P0)**</span><br><span class="line"></span><br><span class="line">double dmult(point p1,point p2,point p0)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    return (p1.x-p0.x)*(p2.x-p0.x)+(p1.y-p0.y)*(p2.y-p0.y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double dmult(double x1,double y1,double x2,double y2,double x0,double y0)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    return (x1-x0)*(x2-x0)+(y1-y0)*(y2-y0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//两点距离**</span><br><span class="line"></span><br><span class="line">double distance(point p1,point p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double distance(double x1,double y1,double x2,double y2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判三点是否共线"><a href="#判三点是否共线" class="headerlink" title="判三点是否共线"></a><strong>判三点是否共线</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int dots_inline(point p1,point p2,point p3)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return zero(xmult(p1,p2,p3));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判点是否在线段上"><a href="#判点是否在线段上" class="headerlink" title="判点是否在线段上"></a><strong>判点是否在线段上</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">**//判点是否在线段上,包括端点（下面为两种接口模式）**</span><br><span class="line"></span><br><span class="line">int dot_online_in(point p,line l)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return zero(xmult(p,l.a,l.b))&amp;&amp;(l.a.x-p.x)*(l.b.x-p.x)&lt;eps&amp;&amp;(l.a.y-p.y)*(l.b.y-p.y)&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dot_online_in(point p,point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return zero(xmult(p,l1,l2))&amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps&amp;&amp;(l1.y-p.y)*(l2.y-p.y)&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//判点是否在线段上,不包括端点**</span><br><span class="line"></span><br><span class="line">int dot_online_ex(point p,line l)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return dot_online_in(p,l)&amp;&amp;(!zero(p.x-l.a.x)||!zero(p.y-l.a.y))</span><br><span class="line"></span><br><span class="line">           &amp;&amp;(!zero(p.x-l.b.x)||!zero(p.y-l.b.y));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两点在线段的同一侧"><a href="#判断两点在线段的同一侧" class="headerlink" title="判断两点在线段的同一侧"></a><strong>判断两点在线段的同一侧</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">**//判两点在线段同侧,点在线段上返回0**</span><br><span class="line"></span><br><span class="line">int same_side(point p1,point p2,line l)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return xmult(l.a,p1,l.b)*xmult(l.a,p2,l.b)&gt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int same_side(point p1,point p2,point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return xmult(l1,p1,l2)*xmult(l1,p2,l2)&gt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两点是否在线段的异侧"><a href="#判断两点是否在线段的异侧" class="headerlink" title="判断两点是否在线段的异侧"></a><strong>判断两点是否在线段的异侧</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">**//判两点在线段异侧,点在线段上返回0**</span><br><span class="line"></span><br><span class="line">int opposite_side(point p1,point p2,line l)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return xmult(l.a,p1,l.b)*xmult(l.a,p2,l.b)&lt;-eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int opposite_side(point p1,point p2,point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return xmult(l1,p1,l2)*xmult(l1,p2,l2)&lt;-eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="求点关于直线的对称点"><a href="#求点关于直线的对称点" class="headerlink" title="求点关于直线的对称点"></a><strong>求点关于直线的对称点</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">**// 点关于直线的对称点 // by lyt**</span><br><span class="line"></span><br><span class="line">**// 缺点：用了斜率**</span><br><span class="line"></span><br><span class="line">**// 也可以利用&quot;点到直线上的最近点&quot;来做，避免使用斜率。**</span><br><span class="line"></span><br><span class="line">point symmetric_point(point p1, point l1, point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point ret;</span><br><span class="line"></span><br><span class="line">    if (l1.x &gt; l2.x - eps &amp;&amp; l1.x &lt; l2.x + eps)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        ret.x = (2 * l1.x - p1.x);</span><br><span class="line"></span><br><span class="line">        ret.y = p1.y;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        double k = (l1.y - l2.y ) / (l1.x - l2.x);</span><br><span class="line"></span><br><span class="line">        ret.x = (2*k*k*l1.x + 2*k*p1.y - 2*k*l1.y - k*k*p1.x + p1.x) / (1 + k*k);</span><br><span class="line"></span><br><span class="line">        ret.y = p1.y - (ret.x - p1.x ) / k;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两线段是否相交"><a href="#判断两线段是否相交" class="headerlink" title="判断两线段是否相交"></a><strong>判断两线段是否相交</strong></h4><h5 id="常用版"><a href="#常用版" class="headerlink" title="常用版"></a><strong>常用版</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//定义点</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x;</span><br><span class="line"></span><br><span class="line">    double y;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct Point point;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//叉积</span><br><span class="line"></span><br><span class="line">double multi(point p0, point p1, point p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return ( p1.x - p0.x )*( p2.y - p0.y )-( p2.x - p0.x )*( p1.y - p0.y );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//相交返回true,否则为false, 接口为两线段的端点</span><br><span class="line"></span><br><span class="line">bool isIntersected(point s1,point e1, point s2,point e2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return  (max(s1.x,e1.x) &gt;= min(s2.x,e2.x))  &amp;&amp;</span><br><span class="line"></span><br><span class="line">            (max(s2.x,e2.x) &gt;= min(s1.x,e1.x))  &amp;&amp;</span><br><span class="line"></span><br><span class="line">            (max(s1.y,e1.y) &gt;= min(s2.y,e2.y))  &amp;&amp;</span><br><span class="line"></span><br><span class="line">            (max(s2.y,e2.y) &gt;= min(s1.y,e1.y))  &amp;&amp;</span><br><span class="line"></span><br><span class="line">            (multi(s1,s2,e1)*multi(s1,e1,e2)&gt;0) &amp;&amp;</span><br><span class="line"></span><br><span class="line">            (multi(s2,s1,e2)*multi(s2,e2,e1)&gt;0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="不常用版"><a href="#不常用版" class="headerlink" title="不常用版"></a><strong>不常用版</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">**//判两线段相交,包括端点和部分重合**</span><br><span class="line"></span><br><span class="line">int intersect_in(line u,line v)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (!dots_inline(u.a,u.b,v.a)||!dots_inline(u.a,u.b,v.b))</span><br><span class="line"></span><br><span class="line">        return !same_side(u.a,u.b,v)&amp;&amp;!same_side(v.a,v.b,u);</span><br><span class="line"></span><br><span class="line">    return dot_online_in(u.a,v)||dot_online_in(u.b,v)||dot_online_in(v.a,u)||dot_online_in(v.b,u);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int intersect_in(point u1,point u2,point v1,point v2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (!dots_inline(u1,u2,v1)||!dots_inline(u1,u2,v2))</span><br><span class="line"></span><br><span class="line">        return !same_side(u1,u2,v1,v2)&amp;&amp;!same_side(v1,v2,u1,u2);</span><br><span class="line"></span><br><span class="line">    return dot_online_in(u1,v1,v2)||dot_online_in(u2,v1,v2)||dot_online_in(v1,u1,u2)||dot_online_in(v2,u1,u2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//判两线段相交,不包括端点和部分重合**</span><br><span class="line"></span><br><span class="line">int intersect_ex(line u,line v)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return opposite_side(u.a,u.b,v)&amp;&amp;opposite_side(v.a,v.b,u);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int intersect_ex(point u1,point u2,point v1,point v2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return opposite_side(u1,u2,v1,v2)&amp;&amp;opposite_side(v1,v2,u1,u2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="求两条直线的交点"><a href="#求两条直线的交点" class="headerlink" title="求两条直线的交点"></a><strong>求两条直线的交点</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">**//计算两直线交点,注意事先判断直线是否平行!**</span><br><span class="line"></span><br><span class="line">**//线段交点请另外判线段相交(同时还是要判断是否平行!)**</span><br><span class="line"></span><br><span class="line">point intersection(point u1,point u2,point v1,point v2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point ret=u1;</span><br><span class="line"></span><br><span class="line">    double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))</span><br><span class="line"></span><br><span class="line">             /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));</span><br><span class="line"></span><br><span class="line">    ret.x+=(u2.x-u1.x)*t;</span><br><span class="line"></span><br><span class="line">    ret.y+=(u2.y-u1.y)*t;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="点到直线的最近距离"><a href="#点到直线的最近距离" class="headerlink" title="点到直线的最近距离"></a><strong>点到直线的最近距离</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">point ptoline(point p,point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point t=p;</span><br><span class="line"></span><br><span class="line">    t.x+=l1.y-l2.y,t.y+=l2.x-l1.x;</span><br><span class="line"></span><br><span class="line">    return intersection(p,t,l1,l2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="点到线段的最近距离"><a href="#点到线段的最近距离" class="headerlink" title="点到线段的最近距离"></a><strong>点到线段的最近距离</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">point ptoseg(point p,point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point t=p;</span><br><span class="line"></span><br><span class="line">    t.x+=l1.y-l2.y,t.y+=l2.x-l1.x;</span><br><span class="line"></span><br><span class="line">    if (xmult(l1,t,p)*xmult(l2,t,p)&gt;eps)</span><br><span class="line"></span><br><span class="line">        return distance(p,l1)&lt;distance(p,l2)?l1:l2;</span><br><span class="line"></span><br><span class="line">    return intersection(p,t,l1,l2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a><strong>多边形</strong></h3><h4 id="预备浮点函数"><a href="#预备浮点函数" class="headerlink" title="预备浮点函数"></a><strong>预备浮点函数</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#define MAXN 1000</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//offset为多变形坐标的最大绝对值**</span><br><span class="line"></span><br><span class="line">\#define offset 10000</span><br><span class="line"></span><br><span class="line">\#define eps 1e-8</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//浮点数判0**</span><br><span class="line"></span><br><span class="line">\#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//浮点数判断符**</span><br><span class="line"></span><br><span class="line">\#define _sign(x) ((x)&gt;eps?1:((x)&lt;-eps?2:0))</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//定义点**</span><br><span class="line"></span><br><span class="line">struct point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x,y;</span><br><span class="line"></span><br><span class="line">&#125;pt[MAXN ];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//定义线段**</span><br><span class="line"></span><br><span class="line">struct line</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point a,b;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//叉积**</span><br><span class="line"></span><br><span class="line">double xmult(point p1,point p2,point p0)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判定是否是凸多边形"><a href="#判定是否是凸多边形" class="headerlink" title="判定是否是凸多边形"></a><strong>判定是否是凸多边形</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">**//判定凸多边形,顶点按顺时针或逆时针给出,允许相邻边共线,是凸多边形返回1，否则返回0**</span><br><span class="line"></span><br><span class="line">int is_convex(int n,point* p)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i,s[3]=&#123;1,1,1&#125;;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n&amp;&amp;s[1]|s[2];i++)</span><br><span class="line"></span><br><span class="line">        s[_sign(xmult(p[(i+1)%n],p[(i+2)%n],p[i]))]=0;</span><br><span class="line"></span><br><span class="line">    return s[1]|s[2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//判凸行，顶点按顺时针或逆时针给出,不允许相邻边共线,是凸多边形返回1，否则返回0**</span><br><span class="line"></span><br><span class="line">int is_convex_v2(int n,point* p)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i,s[3]=&#123;1,1,1&#125;;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n&amp;&amp;s[0]&amp;&amp;s[1]|s[2];i++)</span><br><span class="line"></span><br><span class="line">        s[_sign(xmult(p[(i+1)%n],p[(i+2)%n],p[i]))]=0;</span><br><span class="line"></span><br><span class="line">    return s[0]&amp;&amp;s[1]|s[2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判定点是否在多边形内"><a href="#判定点是否在多边形内" class="headerlink" title="判定点是否在多边形内"></a><strong>判定点是否在多边形内</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">**//判点在凸多边形内或多边形边上时返回1，严格在凸多边形外返回0**</span><br><span class="line"></span><br><span class="line">int inside_convex(point q,int n,point* p)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i,s[3]=&#123;1,1,1&#125;;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n&amp;&amp;s[1]|s[2];i++)</span><br><span class="line"></span><br><span class="line">        s[_sign(xmult(p[(i+1)%n],q,p[i]))]=0;</span><br><span class="line"></span><br><span class="line">    return s[1]|s[2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//判点严格在凸多边形内返回1,在边上或者严格在外返回0**</span><br><span class="line"></span><br><span class="line">int inside_convex_v2(point q,int n,point* p)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i,s[3]=&#123;1,1,1&#125;;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n&amp;&amp;s[0]&amp;&amp;s[1]|s[2];i++)</span><br><span class="line"></span><br><span class="line">        s[_sign(xmult(p[(i+1)%n],q,p[i]))]=0;</span><br><span class="line"></span><br><span class="line">    return s[0]&amp;&amp;s[1]|s[2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//判点在任意多边形内,顶点按顺时针或逆时针给出**</span><br><span class="line"></span><br><span class="line">**//on_edge表示点在多边形边上时的返回值, offset为多边形坐标上限,严格在内返回1，严格在外返回0**</span><br><span class="line"></span><br><span class="line">int inside_polygon(point q,int n,point* p,int on_edge=2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point q2;</span><br><span class="line"></span><br><span class="line">    int i=0,count;</span><br><span class="line"></span><br><span class="line">    while (i&lt;n)</span><br><span class="line"></span><br><span class="line">        for (count=i=0,q2.x=rand()+offset,q2.y=rand()+offset;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (zero(xmult(q,p[i],p[(i+1)%n]))&amp;&amp;(p[i].x-q.x)*(p[(i+1)%n].x-q.x)&lt;eps</span><br><span class="line"></span><br><span class="line">                &amp;&amp;(p[i].y-q.y)*(p[(i+1)%n].y-q.y)&lt;eps)</span><br><span class="line"></span><br><span class="line">                return on_edge;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            else if (zero(xmult(q,q2,p[i])))</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            else if (xmult(q,p[i],q2)*xmult(q,p[(i+1)%n],q2)&lt;-eps&amp;&amp;</span><br><span class="line"></span><br><span class="line">                xmult(p[i],q,p[(i+1)%n])*xmult(p[i],q2,p[(i+1)%n])&lt;-eps)</span><br><span class="line"></span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return count&amp;1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判定一条线段是否在一个任意多边形内"><a href="#判定一条线段是否在一个任意多边形内" class="headerlink" title="判定一条线段是否在一个任意多边形内"></a><strong>判定一条线段是否在一个任意多边形内</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">**//预备函数**</span><br><span class="line"></span><br><span class="line">inline int opposite_side(point p1,point p2,point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return xmult(l1,p1,l2)*xmult(l1,p2,l2)&lt;-eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int dot_online_in(point p,point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return zero(xmult(p,l1,l2))&amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps&amp;&amp;(l1.y-p.y)*(l2.y-p.y)&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//判线段在任意多边形内,顶点按顺时针或逆时针给出,与边界相交返回1**</span><br><span class="line"></span><br><span class="line">int inside_polygon(point l1,point l2,int n,point* p)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point t[MAXN],tt;</span><br><span class="line"></span><br><span class="line">    int i,j,k=0;</span><br><span class="line"></span><br><span class="line">    if (!inside_polygon(l1,n,p)||!inside_polygon(l2,n,p))</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (opposite_side(l1,l2,p[i],p[(i+1)%n])&amp;&amp;opposite_side(p[i],p[(i+1)%n],l1,l2))</span><br><span class="line"></span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        else if (dot_online_in(l1,p[i],p[(i+1)%n]))</span><br><span class="line"></span><br><span class="line">            t[k++]=l1;</span><br><span class="line"></span><br><span class="line">        else if (dot_online_in(l2,p[i],p[(i+1)%n]))</span><br><span class="line"></span><br><span class="line">            t[k++]=l2;</span><br><span class="line"></span><br><span class="line">        else if (dot_online_in(p[i],l1,l2))</span><br><span class="line"></span><br><span class="line">            t[k++]=p[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;k;i++)</span><br><span class="line"></span><br><span class="line">        for (j=i+1;j&lt;k;j++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tt.x=(t[i].x+t[j].x)/2;</span><br><span class="line"></span><br><span class="line">            tt.y=(t[i].y+t[j].y)/2;</span><br><span class="line"></span><br><span class="line">            if (!inside_polygon(tt,n,p))</span><br><span class="line"></span><br><span class="line">                return 0;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三角形-1"><a href="#三角形-1" class="headerlink" title="三角形"></a><strong>三角形</strong></h3><h4 id="预备函数-1"><a href="#预备函数-1" class="headerlink" title="预备函数"></a><strong>预备函数</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">**//定义点**</span><br><span class="line"></span><br><span class="line">struct point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x,y;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct point point;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//定义直线**</span><br><span class="line"></span><br><span class="line">struct line</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point a,b;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct line line;</span><br><span class="line"></span><br><span class="line">**//两点距离**</span><br><span class="line"></span><br><span class="line">double distance(point p1,point p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//两直线求交点**</span><br><span class="line"></span><br><span class="line">point intersection(line u,line v)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	point ret=u.a;</span><br><span class="line"></span><br><span class="line">	double t=((u.a.x-v.a.x)*(v.a.y-v.b.y)-(u.a.y-v.a.y)*(v.a.x-v.b.x))</span><br><span class="line"></span><br><span class="line">			/((u.a.x-u.b.x)*(v.a.y-v.b.y)-(u.a.y-u.b.y)*(v.a.x-v.b.x));</span><br><span class="line"></span><br><span class="line">	ret.x+=(u.b.x-u.a.x)*t;</span><br><span class="line"></span><br><span class="line">	ret.y+=(u.b.y-u.a.y)*t;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="求三角形的外心"><a href="#求三角形的外心" class="headerlink" title="求三角形的外心"></a><strong>求三角形的外心</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">point circumcenter(point a,point b,point c)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	line u,v;</span><br><span class="line"></span><br><span class="line">	u.a.x=(a.x+b.x)/2;</span><br><span class="line"></span><br><span class="line">	u.a.y=(a.y+b.y)/2;</span><br><span class="line"></span><br><span class="line">	u.b.x=u.a.x-a.y+b.y;</span><br><span class="line"></span><br><span class="line">	u.b.y=u.a.y+a.x-b.x;</span><br><span class="line"></span><br><span class="line">	v.a.x=(a.x+c.x)/2;</span><br><span class="line"></span><br><span class="line">	v.a.y=(a.y+c.y)/2;</span><br><span class="line"></span><br><span class="line">	v.b.x=v.a.x-a.y+c.y;</span><br><span class="line"></span><br><span class="line">	v.b.y=v.a.y+a.x-c.x;</span><br><span class="line"></span><br><span class="line">	return intersection(u,v);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="求三角形内心"><a href="#求三角形内心" class="headerlink" title="求三角形内心"></a><strong>求三角形内心</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">point incenter(point a,point b,point c)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	line u,v;</span><br><span class="line"></span><br><span class="line">	double m,n;</span><br><span class="line"></span><br><span class="line">	u.a=a;</span><br><span class="line"></span><br><span class="line">	m=atan2(b.y-a.y,b.x-a.x);</span><br><span class="line"></span><br><span class="line">	n=atan2(c.y-a.y,c.x-a.x);</span><br><span class="line"></span><br><span class="line">	u.b.x=u.a.x+cos((m+n)/2);</span><br><span class="line"></span><br><span class="line">	u.b.y=u.a.y+sin((m+n)/2);</span><br><span class="line"></span><br><span class="line">	v.a=b;</span><br><span class="line"></span><br><span class="line">	m=atan2(a.y-b.y,a.x-b.x);</span><br><span class="line"></span><br><span class="line">	n=atan2(c.y-b.y,c.x-b.x);</span><br><span class="line"></span><br><span class="line">	v.b.x=v.a.x+cos((m+n)/2);</span><br><span class="line"></span><br><span class="line">	v.b.y=v.a.y+sin((m+n)/2);</span><br><span class="line"></span><br><span class="line">	return intersection(u,v);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="求三角形垂心"><a href="#求三角形垂心" class="headerlink" title="求三角形垂心"></a><strong>求三角形垂心</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">point perpencenter(point a,point b,point c)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	line u,v;</span><br><span class="line"></span><br><span class="line">	u.a=c;</span><br><span class="line"></span><br><span class="line">	u.b.x=u.a.x-a.y+b.y;</span><br><span class="line"></span><br><span class="line">	u.b.y=u.a.y+a.x-b.x;</span><br><span class="line"></span><br><span class="line">	v.a=b;</span><br><span class="line"></span><br><span class="line">	v.b.x=v.a.x-a.y+c.y;</span><br><span class="line"></span><br><span class="line">	v.b.y=v.a.y+a.x-c.x;</span><br><span class="line"></span><br><span class="line">	return intersection(u,v);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="圆-1"><a href="#圆-1" class="headerlink" title="圆"></a><strong>圆</strong></h3><h4 id="预备函数-2"><a href="#预备函数-2" class="headerlink" title="预备函数"></a><strong>预备函数</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#define eps 1e-8</span><br><span class="line"></span><br><span class="line">struct point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x,y;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct point point;</span><br><span class="line"></span><br><span class="line">double xmult(point p1,point p2,point p0)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double distance(point p1,point p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//点到直线的距离**</span><br><span class="line"></span><br><span class="line">double disptoline(point p,point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return fabs(xmult(p,l1,l2))/distance(l1,l2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//求两直线交点**</span><br><span class="line"></span><br><span class="line">point intersection(point u1,point u2,point v1,point v2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point ret=u1;</span><br><span class="line"></span><br><span class="line">    double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))</span><br><span class="line"></span><br><span class="line">             /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));</span><br><span class="line"></span><br><span class="line">    ret.x+=(u2.x-u1.x)*t;</span><br><span class="line"></span><br><span class="line">    ret.y+=(u2.y-u1.y)*t;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判定直线是否与圆相交"><a href="#判定直线是否与圆相交" class="headerlink" title="判定直线是否与圆相交"></a><strong>判定直线是否与圆相交</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//判直线和圆相交,包括相切</span><br><span class="line"></span><br><span class="line">int intersect_line_circle(point c,double r,point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return disptoline(c,l1,l2)&lt;r+eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判定线段与圆相交"><a href="#判定线段与圆相交" class="headerlink" title="判定线段与圆相交"></a><strong>判定线段与圆相交</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int intersect_seg_circle(point c,double r, point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double t1=distance(c,l1)-r,t2=distance(c,l2)-r;</span><br><span class="line"></span><br><span class="line">    point t=c;</span><br><span class="line"></span><br><span class="line">    if (t1&lt;eps||t2&lt;eps)</span><br><span class="line"></span><br><span class="line">        return t1&gt;-eps||t2&gt;-eps;</span><br><span class="line"></span><br><span class="line">    t.x+=l1.y-l2.y;</span><br><span class="line"></span><br><span class="line">    t.y+=l2.x-l1.x;</span><br><span class="line"></span><br><span class="line">    return xmult(l1,c,t)*xmult(l2,c,t)&lt;eps&amp;&amp;disptoline(c,l1,l2)-r&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判圆和圆相交"><a href="#判圆和圆相交" class="headerlink" title="判圆和圆相交"></a><strong>判圆和圆相交</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int intersect_circle_circle(point c1,double r1,point c2,double r2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return distance(c1,c2)&lt;r1+r2+eps&amp;&amp;distance(c1,c2)&gt;fabs(r1-r2)-eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算圆上到点p最近点"><a href="#计算圆上到点p最近点" class="headerlink" title="计算圆上到点p最近点"></a><strong>计算圆上到点p最近点</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">**//当p为圆心时，返回圆心本身**</span><br><span class="line"></span><br><span class="line">point dot_to_circle(point c,double r,point p)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point u,v;</span><br><span class="line"></span><br><span class="line">    if (distance(p,c)&lt;eps)</span><br><span class="line"></span><br><span class="line">        return p;</span><br><span class="line"></span><br><span class="line">    u.x=c.x+r*fabs(c.x-p.x)/distance(c,p);</span><br><span class="line"></span><br><span class="line">    u.y=c.y+r*fabs(c.y-p.y)/distance(c,p)*((c.x-p.x)*(c.y-p.y)&lt;0?-1:1);</span><br><span class="line"></span><br><span class="line">    v.x=c.x-r*fabs(c.x-p.x)/distance(c,p);</span><br><span class="line"></span><br><span class="line">    v.y=c.y-r*fabs(c.y-p.y)/distance(c,p)*((c.x-p.x)*(c.y-p.y)&lt;0?-1:1);</span><br><span class="line"></span><br><span class="line">    return distance(u,p)&lt;distance(v,p)?u:v;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算直线与圆的交点"><a href="#计算直线与圆的交点" class="headerlink" title="计算直线与圆的交点"></a><strong>计算直线与圆的交点</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">**//计算直线与圆的交点,保证直线与圆有交点**</span><br><span class="line"></span><br><span class="line">**//计算线段与圆的交点可用这个函数后判点是否在线段上**</span><br><span class="line"></span><br><span class="line">void intersection_line_circle(point c,double r,point l1,point l2,point&amp; p1,point&amp; p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point p=c;</span><br><span class="line"></span><br><span class="line">    double t;</span><br><span class="line"></span><br><span class="line">    p.x+=l1.y-l2.y;</span><br><span class="line"></span><br><span class="line">    p.y+=l2.x-l1.x;</span><br><span class="line"></span><br><span class="line">    p=intersection(p,c,l1,l2);</span><br><span class="line"></span><br><span class="line">    t=sqrt(r*r-distance(p,c)*distance(p,c))/distance(l1,l2);</span><br><span class="line"></span><br><span class="line">    p1.x=p.x+(l2.x-l1.x)*t;</span><br><span class="line"></span><br><span class="line">    p1.y=p.y+(l2.y-l1.y)*t;</span><br><span class="line"></span><br><span class="line">    p2.x=p.x-(l2.x-l1.x)*t;</span><br><span class="line"></span><br><span class="line">    p2.y=p.y-(l2.y-l1.y)*t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算两个圆的交点"><a href="#计算两个圆的交点" class="headerlink" title="计算两个圆的交点"></a><strong>计算两个圆的交点</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">**//计算圆与圆的交点,保证圆与圆有交点,圆心不重合**</span><br><span class="line"></span><br><span class="line">void intersection_circle_circle(point c1,double r1,point c2,double r2,point&amp; p1,point&amp; p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point u,v;</span><br><span class="line"></span><br><span class="line">    double t;</span><br><span class="line"></span><br><span class="line">    t=(1+(r1*r1-r2*r2)/distance(c1,c2)/distance(c1,c2))/2;</span><br><span class="line"></span><br><span class="line">    u.x=c1.x+(c2.x-c1.x)*t;</span><br><span class="line"></span><br><span class="line">    u.y=c1.y+(c2.y-c1.y)*t;</span><br><span class="line"></span><br><span class="line">    v.x=u.x+c1.y-c2.y;</span><br><span class="line"></span><br><span class="line">    v.y=u.y-c1.x+c2.x;</span><br><span class="line"></span><br><span class="line">    intersection_line_circle(c1,r1,u,v,p1,p2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="球面"><a href="#球面" class="headerlink" title="球面"></a><strong>球面</strong></h3><h4 id="给出地球经度纬度，计算圆心角"><a href="#给出地球经度纬度，计算圆心角" class="headerlink" title="给出地球经度纬度，计算圆心角"></a><strong>给出地球经度纬度，计算圆心角</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">const double pi=acos(-1);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//计算圆心角lat表示纬度,-90&lt;=w&lt;=90,lng表示经度**</span><br><span class="line"></span><br><span class="line">**//返回两点所在大圆劣弧对应圆心角,0&lt;=angle&lt;=pi**</span><br><span class="line"></span><br><span class="line">double angle(double lng1,double lat1,double lng2,double lat2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double dlng=fabs(lng1-lng2)*pi/180;</span><br><span class="line"></span><br><span class="line">    while (dlng&gt;=pi+pi)</span><br><span class="line"></span><br><span class="line">        dlng-=pi+pi;</span><br><span class="line"></span><br><span class="line">    if (dlng&gt;pi)</span><br><span class="line"></span><br><span class="line">        dlng=pi+pi-dlng;</span><br><span class="line"></span><br><span class="line">    lat1*=pi/180,lat2*=pi/180;</span><br><span class="line"></span><br><span class="line">    return acos(cos(lat1)*cos(lat2)*cos(dlng)+sin(lat1)*sin(lat2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="已知经纬度，计算地球上两点直线距离"><a href="#已知经纬度，计算地球上两点直线距离" class="headerlink" title="已知经纬度，计算地球上两点直线距离"></a><strong>已知经纬度，计算地球上两点直线距离</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">**//计算距离,r为球半径**</span><br><span class="line"></span><br><span class="line">double line_dist(double r,double lng1,double lat1,double lng2,double lat2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double dlng=fabs(lng1-lng2)*pi/180;</span><br><span class="line"></span><br><span class="line">    while (dlng&gt;=pi+pi)</span><br><span class="line"></span><br><span class="line">        dlng-=pi+pi;</span><br><span class="line"></span><br><span class="line">    if (dlng&gt;pi)</span><br><span class="line"></span><br><span class="line">        dlng=pi+pi-dlng;</span><br><span class="line"></span><br><span class="line">    lat1*=pi/180,lat2*=pi/180;</span><br><span class="line"></span><br><span class="line">    return r*sqrt(2-2*(cos(lat1)*cos(lat2)*cos(dlng)+sin(lat1)*sin(lat2)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="已知经纬度，计算地球上两点球面距离"><a href="#已知经纬度，计算地球上两点球面距离" class="headerlink" title="已知经纬度，计算地球上两点球面距离"></a><strong>已知经纬度，计算地球上两点球面距离</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**//计算球面距离,r为球半径**</span><br><span class="line"></span><br><span class="line">inline double sphere_dist(double r,double lng1,double lat1,double lng2,double lat2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return r*angle(lng1,lat1,lng2,lat2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三维几何的若干模板"><a href="#三维几何的若干模板" class="headerlink" title="三维几何的若干模板"></a><strong>三维几何的若干模板</strong></h3><h4 id="预备函数-3"><a href="#预备函数-3" class="headerlink" title="预备函数"></a><strong>预备函数</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">**//三维几何函数库**</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#define eps 1e-8</span><br><span class="line"></span><br><span class="line">\#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)</span><br><span class="line"></span><br><span class="line">struct point3&#123;double x,y,z;&#125;;</span><br><span class="line"></span><br><span class="line">struct line3&#123;point3 a,b;&#125;;</span><br><span class="line"></span><br><span class="line">struct plane3&#123;point3 a,b,c;&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//计算cross product U x V**</span><br><span class="line"></span><br><span class="line">point3 xmult(point3 u,point3 v)&#123;</span><br><span class="line"></span><br><span class="line">	point3 ret;</span><br><span class="line"></span><br><span class="line">	ret.x=u.y*v.z-v.y*u.z;</span><br><span class="line"></span><br><span class="line">	ret.y=u.z*v.x-u.x*v.z;</span><br><span class="line"></span><br><span class="line">	ret.z=u.x*v.y-u.y*v.x;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//计算dot product U . V**</span><br><span class="line"></span><br><span class="line">double dmult(point3 u,point3 v)&#123;</span><br><span class="line"></span><br><span class="line">	return u.x*v.x+u.y*v.y+u.z*v.z;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//矢量差 U - V**</span><br><span class="line"></span><br><span class="line">point3 subt(point3 u,point3 v)&#123;</span><br><span class="line"></span><br><span class="line">	point3 ret;</span><br><span class="line"></span><br><span class="line">	ret.x=u.x-v.x;</span><br><span class="line"></span><br><span class="line">	ret.y=u.y-v.y;</span><br><span class="line"></span><br><span class="line">	ret.z=u.z-v.z;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//取平面法向量**</span><br><span class="line"></span><br><span class="line">point3 pvec(plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return xmult(subt(s.a,s.b),subt(s.b,s.c));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">point3 pvec(point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return xmult(subt(s1,s2),subt(s2,s3));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//两点距离,单参数取向量大小**</span><br><span class="line"></span><br><span class="line">double distance(point3 p1,point3 p2)&#123;</span><br><span class="line"></span><br><span class="line">	return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y)+(p1.z-p2.z)*(p1.z-p2.z));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//向量大小**</span><br><span class="line"></span><br><span class="line">double vlen(point3 p)&#123;</span><br><span class="line"></span><br><span class="line">	return sqrt(p.x*p.x+p.y*p.y+p.z*p.z);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判定三点是否共线"><a href="#判定三点是否共线" class="headerlink" title="判定三点是否共线"></a><strong>判定三点是否共线</strong></h4><p><strong>//判三点共线</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int dots_inline(point3 p1,point3 p2,point3 p3)&#123;</span><br><span class="line"></span><br><span class="line">	return vlen(xmult(subt(p1,p2),subt(p2,p3)))&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判定四点是否共面"><a href="#判定四点是否共面" class="headerlink" title="判定四点是否共面"></a><strong>判定四点是否共面</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**//判四点共面**</span><br><span class="line"></span><br><span class="line">int dots_onplane(point3 a,point3 b,point3 c,point3 d)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(dmult(pvec(a,b,c),subt(d,a)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判定点是否在线段上"><a href="#判定点是否在线段上" class="headerlink" title="判定点是否在线段上"></a><strong>判定点是否在线段上</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">**//判点是否在线段上,包括端点和共线**</span><br><span class="line"></span><br><span class="line">int dot_online_in(point3 p,line3 l)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(vlen(xmult(subt(p,l.a),subt(p,l.b))))&amp;&amp;(l.a.x-p.x)*(l.b.x-p.x)&lt;eps&amp;&amp;</span><br><span class="line"></span><br><span class="line">		(l.a.y-p.y)*(l.b.y-p.y)&lt;eps&amp;&amp;(l.a.z-p.z)*(l.b.z-p.z)&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dot_online_in(point3 p,point3 l1,point3 l2)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(vlen(xmult(subt(p,l1),subt(p,l2))))&amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps&amp;&amp;</span><br><span class="line"></span><br><span class="line">		(l1.y-p.y)*(l2.y-p.y)&lt;eps&amp;&amp;(l1.z-p.z)*(l2.z-p.z)&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//判点是否在线段上,不包括端点**</span><br><span class="line"></span><br><span class="line">int dot_online_ex(point3 p,line3 l)&#123;</span><br><span class="line"></span><br><span class="line">	return dot_online_in(p,l)&amp;&amp;(!zero(p.x-l.a.x)||!zero(p.y-l.a.y)||!zero(p.z-l.a.z))&amp;&amp;</span><br><span class="line"></span><br><span class="line">		(!zero(p.x-l.b.x)||!zero(p.y-l.b.y)||!zero(p.z-l.b.z));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dot_online_ex(point3 p,point3 l1,point3 l2)&#123;</span><br><span class="line"></span><br><span class="line">	return dot_online_in(p,l1,l2)&amp;&amp;(!zero(p.x-l1.x)||!zero(p.y-l1.y)||!zero(p.z-l1.z))&amp;&amp;</span><br><span class="line"></span><br><span class="line">		(!zero(p.x-l2.x)||!zero(p.y-l2.y)||!zero(p.z-l2.z));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断点是否在空间三角形上"><a href="#判断点是否在空间三角形上" class="headerlink" title="判断点是否在空间三角形上"></a><strong>判断点是否在空间三角形上</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">**//判点是否在空间三角形上,包括边界,三点共线无意义**</span><br><span class="line"></span><br><span class="line">int dot_inplane_in(point3 p,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(vlen(xmult(subt(s.a,s.b),subt(s.a,s.c)))-vlen(xmult(subt(p,s.a),subt(p,s.b)))-</span><br><span class="line"></span><br><span class="line">		vlen(xmult(subt(p,s.b),subt(p,s.c)))-vlen(xmult(subt(p,s.c),subt(p,s.a))));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dot_inplane_in(point3 p,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(vlen(xmult(subt(s1,s2),subt(s1,s3)))-vlen(xmult(subt(p,s1),subt(p,s2)))-</span><br><span class="line"></span><br><span class="line">		vlen(xmult(subt(p,s2),subt(p,s3)))-vlen(xmult(subt(p,s3),subt(p,s1))));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//判点是否在空间三角形上,不包括边界,三点共线无意义**</span><br><span class="line"></span><br><span class="line">int dot_inplane_ex(point3 p,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return dot_inplane_in(p,s)&amp;&amp;vlen(xmult(subt(p,s.a),subt(p,s.b)))&gt;eps&amp;&amp;</span><br><span class="line"></span><br><span class="line">		vlen(xmult(subt(p,s.b),subt(p,s.c)))&gt;eps&amp;&amp;vlen(xmult(subt(p,s.c),subt(p,s.a)))&gt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dot_inplane_ex(point3 p,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return dot_inplane_in(p,s1,s2,s3)&amp;&amp;vlen(xmult(subt(p,s1),subt(p,s2)))&gt;eps&amp;&amp;</span><br><span class="line"></span><br><span class="line">		vlen(xmult(subt(p,s2),subt(p,s3)))&gt;eps&amp;&amp;vlen(xmult(subt(p,s3),subt(p,s1)))&gt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两点是否在线段同侧"><a href="#判断两点是否在线段同侧" class="headerlink" title="判断两点是否在线段同侧"></a><strong>判断两点是否在线段同侧</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**//判两点在线段同侧,点在线段上返回0,不共面无意义**</span><br><span class="line"></span><br><span class="line">int same_side(point3 p1,point3 p2,line3 l)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(xmult(subt(l.a,l.b),subt(p1,l.b)),xmult(subt(l.a,l.b),subt(p2,l.b)))&gt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int same_side(point3 p1,point3 p2,point3 l1,point3 l2)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(xmult(subt(l1,l2),subt(p1,l2)),xmult(subt(l1,l2),subt(p2,l2)))&gt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两点是否在线段异侧"><a href="#判断两点是否在线段异侧" class="headerlink" title="判断两点是否在线段异侧"></a><strong>判断两点是否在线段异侧</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**//判两点在线段异侧,点在线段上返回0,不共面无意义**</span><br><span class="line"></span><br><span class="line">int opposite_side(point3 p1,point3 p2,line3 l)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(xmult(subt(l.a,l.b),subt(p1,l.b)),xmult(subt(l.a,l.b),subt(p2,l.b)))&lt;-eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int opposite_side(point3 p1,point3 p2,point3 l1,point3 l2)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(xmult(subt(l1,l2),subt(p1,l2)),xmult(subt(l1,l2),subt(p2,l2)))&lt;-eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两点是否在平面同侧"><a href="#判断两点是否在平面同侧" class="headerlink" title="判断两点是否在平面同侧"></a><strong>判断两点是否在平面同侧</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**//判两点在平面同侧,点在平面上返回0**</span><br><span class="line"></span><br><span class="line">int same_side(point3 p1,point3 p2,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(pvec(s),subt(p1,s.a))*dmult(pvec(s),subt(p2,s.a))&gt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int same_side(point3 p1,point3 p2,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(pvec(s1,s2,s3),subt(p1,s1))*dmult(pvec(s1,s2,s3),subt(p2,s1))&gt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两点是否在平面异侧"><a href="#判断两点是否在平面异侧" class="headerlink" title="判断两点是否在平面异侧"></a><strong>判断两点是否在平面异侧</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**//判两点在平面异侧,点在平面上返回0**</span><br><span class="line"></span><br><span class="line">int opposite_side(point3 p1,point3 p2,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(pvec(s),subt(p1,s.a))*dmult(pvec(s),subt(p2,s.a))&lt;-eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int opposite_side(point3 p1,point3 p2,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(pvec(s1,s2,s3),subt(p1,s1))*dmult(pvec(s1,s2,s3),subt(p2,s1))&lt;-eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两空间直线是否平行"><a href="#判断两空间直线是否平行" class="headerlink" title="判断两空间直线是否平行"></a><strong>判断两空间直线是否平行</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**//判两直线平行**</span><br><span class="line"></span><br><span class="line">int parallel(line3 u,line3 v)&#123;</span><br><span class="line"></span><br><span class="line">	return vlen(xmult(subt(u.a,u.b),subt(v.a,v.b)))&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int parallel(point3 u1,point3 u2,point3 v1,point3 v2)&#123;</span><br><span class="line"></span><br><span class="line">	return vlen(xmult(subt(u1,u2),subt(v1,v2)))&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两平面是否平行"><a href="#判断两平面是否平行" class="headerlink" title="判断两平面是否平行"></a><strong>判断两平面是否平行</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**//判两平面平行**</span><br><span class="line"></span><br><span class="line">int parallel(plane3 u,plane3 v)&#123;</span><br><span class="line"></span><br><span class="line">	return vlen(xmult(pvec(u),pvec(v)))&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int parallel(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3)&#123;</span><br><span class="line"></span><br><span class="line">	return vlen(xmult(pvec(u1,u2,u3),pvec(v1,v2,v3)))&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断直线是否与平面平行"><a href="#判断直线是否与平面平行" class="headerlink" title="判断直线是否与平面平行"></a><strong>判断直线是否与平面平行</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**//判直线与平面平行**</span><br><span class="line"></span><br><span class="line">int parallel(line3 l,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(dmult(subt(l.a,l.b),pvec(s)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int parallel(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(dmult(subt(l1,l2),pvec(s1,s2,s3)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两直线是否垂直"><a href="#判断两直线是否垂直" class="headerlink" title="判断两直线是否垂直"></a><strong>判断两直线是否垂直</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**//判两直线垂直**</span><br><span class="line"></span><br><span class="line">int perpendicular(line3 u,line3 v)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(dmult(subt(u.a,u.b),subt(v.a,v.b)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int perpendicular(point3 u1,point3 u2,point3 v1,point3 v2)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(dmult(subt(u1,u2),subt(v1,v2)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两平面是否垂直"><a href="#判断两平面是否垂直" class="headerlink" title="判断两平面是否垂直"></a><strong>判断两平面是否垂直</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//判两平面垂直</span><br><span class="line"></span><br><span class="line">int perpendicular(plane3 u,plane3 v)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(dmult(pvec(u),pvec(v)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int perpendicular(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(dmult(pvec(u1,u2,u3),pvec(v1,v2,v3)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两条空间线段是否相交"><a href="#判断两条空间线段是否相交" class="headerlink" title="判断两条空间线段是否相交"></a><strong>判断两条空间线段是否相交</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">**//判两线段相交,包括端点和部分重合**</span><br><span class="line"></span><br><span class="line">int intersect_in(line3 u,line3 v)&#123;</span><br><span class="line"></span><br><span class="line">	if (!dots_onplane(u.a,u.b,v.a,v.b))</span><br><span class="line"></span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	if (!dots_inline(u.a,u.b,v.a)||!dots_inline(u.a,u.b,v.b))</span><br><span class="line"></span><br><span class="line">		return !same_side(u.a,u.b,v)&amp;&amp;!same_side(v.a,v.b,u);</span><br><span class="line"></span><br><span class="line">	return dot_online_in(u.a,v)||dot_online_in(u.b,v)||dot_online_in(v.a,u)||dot_online_in(v.b,u);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int intersect_in(point3 u1,point3 u2,point3 v1,point3 v2)&#123;</span><br><span class="line"></span><br><span class="line">	if (!dots_onplane(u1,u2,v1,v2))</span><br><span class="line"></span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	if (!dots_inline(u1,u2,v1)||!dots_inline(u1,u2,v2))</span><br><span class="line"></span><br><span class="line">		return !same_side(u1,u2,v1,v2)&amp;&amp;!same_side(v1,v2,u1,u2);</span><br><span class="line"></span><br><span class="line">	return dot_online_in(u1,v1,v2)||dot_online_in(u2,v1,v2)||dot_online_in(v1,u1,u2)||dot_online_in(v2,u1,u2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//判两线段相交,不包括端点和部分重合**</span><br><span class="line"></span><br><span class="line">int intersect_ex(line3 u,line3 v)&#123;</span><br><span class="line"></span><br><span class="line">	return dots_onplane(u.a,u.b,v.a,v.b)&amp;&amp;opposite_side(u.a,u.b,v)&amp;&amp;opposite_side(v.a,v.b,u);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int intersect_ex(point3 u1,point3 u2,point3 v1,point3 v2)&#123;</span><br><span class="line"></span><br><span class="line">	return dots_onplane(u1,u2,v1,v2)&amp;&amp;opposite_side(u1,u2,v1,v2)&amp;&amp;opposite_side(v1,v2,u1,u2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断线段是否与空间三角形相交"><a href="#判断线段是否与空间三角形相交" class="headerlink" title="判断线段是否与空间三角形相交"></a><strong>判断线段是否与空间三角形相交</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">**//判线段与空间三角形相交,包括交于边界和(部分)包含**</span><br><span class="line"></span><br><span class="line">int intersect_in(line3 l,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return !same_side(l.a,l.b,s)&amp;&amp;!same_side(s.a,s.b,l.a,l.b,s.c)&amp;&amp;</span><br><span class="line"></span><br><span class="line">		!same_side(s.b,s.c,l.a,l.b,s.a)&amp;&amp;!same_side(s.c,s.a,l.a,l.b,s.b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int intersect_in(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return !same_side(l1,l2,s1,s2,s3)&amp;&amp;!same_side(s1,s2,l1,l2,s3)&amp;&amp;</span><br><span class="line"></span><br><span class="line">		!same_side(s2,s3,l1,l2,s1)&amp;&amp;!same_side(s3,s1,l1,l2,s2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//判线段与空间三角形相交,不包括交于边界和(部分)包含**</span><br><span class="line"></span><br><span class="line">int intersect_ex(line3 l,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return opposite_side(l.a,l.b,s)&amp;&amp;opposite_side(s.a,s.b,l.a,l.b,s.c)&amp;&amp;</span><br><span class="line"></span><br><span class="line">		opposite_side(s.b,s.c,l.a,l.b,s.a)&amp;&amp;opposite_side(s.c,s.a,l.a,l.b,s.b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int intersect_ex(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return opposite_side(l1,l2,s1,s2,s3)&amp;&amp;opposite_side(s1,s2,l1,l2,s3)&amp;&amp;</span><br><span class="line"></span><br><span class="line">		opposite_side(s2,s3,l1,l2,s1)&amp;&amp;opposite_side(s3,s1,l1,l2,s2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算两条直线的交点"><a href="#计算两条直线的交点" class="headerlink" title="计算两条直线的交点"></a><strong>计算两条直线的交点</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">**//计算两直线交点,注意事先判断直线是否共面和平行!**</span><br><span class="line"></span><br><span class="line">**//线段交点请另外判线段相交(同时还是要判断是否平行!)**</span><br><span class="line"></span><br><span class="line">point3 intersection(line3 u,line3 v)&#123;</span><br><span class="line"></span><br><span class="line">	point3 ret=u.a;</span><br><span class="line"></span><br><span class="line">	double t=((u.a.x-v.a.x)*(v.a.y-v.b.y)-(u.a.y-v.a.y)*(v.a.x-v.b.x))</span><br><span class="line"></span><br><span class="line">			/((u.a.x-u.b.x)*(v.a.y-v.b.y)-(u.a.y-u.b.y)*(v.a.x-v.b.x));</span><br><span class="line"></span><br><span class="line">	ret.x+=(u.b.x-u.a.x)*t;</span><br><span class="line"></span><br><span class="line">	ret.y+=(u.b.y-u.a.y)*t;</span><br><span class="line"></span><br><span class="line">	ret.z+=(u.b.z-u.a.z)*t;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">point3 intersection(point3 u1,point3 u2,point3 v1,point3 v2)&#123;</span><br><span class="line"></span><br><span class="line">	point3 ret=u1;</span><br><span class="line"></span><br><span class="line">	double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))</span><br><span class="line"></span><br><span class="line">			/((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));</span><br><span class="line"></span><br><span class="line">	ret.x+=(u2.x-u1.x)*t;</span><br><span class="line"></span><br><span class="line">	ret.y+=(u2.y-u1.y)*t;</span><br><span class="line"></span><br><span class="line">	ret.z+=(u2.z-u1.z)*t;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算直线与平面的交点"><a href="#计算直线与平面的交点" class="headerlink" title="计算直线与平面的交点"></a><strong>计算直线与平面的交点</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">**//计算直线与平面交点,注意事先判断是否平行,并保证三点不共线!**</span><br><span class="line"></span><br><span class="line">**//线段和空间三角形交点请另外判断**</span><br><span class="line"></span><br><span class="line">point3 intersection(line3 l,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	point3 ret=pvec(s);</span><br><span class="line"></span><br><span class="line">	double t=(ret.x*(s.a.x-l.a.x)+ret.y*(s.a.y-l.a.y)+ret.z*(s.a.z-l.a.z))/</span><br><span class="line"></span><br><span class="line">		(ret.x*(l.b.x-l.a.x)+ret.y*(l.b.y-l.a.y)+ret.z*(l.b.z-l.a.z));</span><br><span class="line"></span><br><span class="line">	ret.x=l.a.x+(l.b.x-l.a.x)*t;</span><br><span class="line"></span><br><span class="line">	ret.y=l.a.y+(l.b.y-l.a.y)*t;</span><br><span class="line"></span><br><span class="line">	ret.z=l.a.z+(l.b.z-l.a.z)*t;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">point3 intersection(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	point3 ret=pvec(s1,s2,s3);</span><br><span class="line"></span><br><span class="line">	double t=(ret.x*(s1.x-l1.x)+ret.y*(s1.y-l1.y)+ret.z*(s1.z-l1.z))/</span><br><span class="line"></span><br><span class="line">		(ret.x*(l2.x-l1.x)+ret.y*(l2.y-l1.y)+ret.z*(l2.z-l1.z));</span><br><span class="line"></span><br><span class="line">	ret.x=l1.x+(l2.x-l1.x)*t;</span><br><span class="line"></span><br><span class="line">	ret.y=l1.y+(l2.y-l1.y)*t;</span><br><span class="line"></span><br><span class="line">	ret.z=l1.z+(l2.z-l1.z)*t;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算两平面的交线"><a href="#计算两平面的交线" class="headerlink" title="计算两平面的交线"></a><strong>计算两平面的交线</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">**//计算两平面交线,注意事先判断是否平行,并保证三点不共线!**</span><br><span class="line"></span><br><span class="line">line3 intersection(plane3 u,plane3 v)&#123;</span><br><span class="line"></span><br><span class="line">	line3 ret;</span><br><span class="line"></span><br><span class="line">	ret.a=parallel(v.a,v.b,u.a,u.b,u.c)?intersection(v.b,v.c,u.a,u.b,u.c):intersection(v.a,v.b,u.a,u.b,u.c);</span><br><span class="line"></span><br><span class="line">	ret.b=parallel(v.c,v.a,u.a,u.b,u.c)?intersection(v.b,v.c,u.a,u.b,u.c):intersection(v.c,v.a,u.a,u.b,u.c);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">line3 intersection(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3)&#123;</span><br><span class="line"></span><br><span class="line">	line3 ret;</span><br><span class="line"></span><br><span class="line">	ret.a=parallel(v1,v2,u1,u2,u3)?intersection(v2,v3,u1,u2,u3):intersection(v1,v2,u1,u2,u3);</span><br><span class="line"></span><br><span class="line">	ret.b=parallel(v3,v1,u1,u2,u3)?intersection(v2,v3,u1,u2,u3):intersection(v3,v1,u1,u2,u3);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="点到直线的距离"><a href="#点到直线的距离" class="headerlink" title="点到直线的距离"></a><strong>点到直线的距离</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**//点到直线距离**</span><br><span class="line"></span><br><span class="line">double ptoline(point3 p,line3 l)&#123;</span><br><span class="line"></span><br><span class="line">	return vlen(xmult(subt(p,l.a),subt(l.b,l.a)))/distance(l.a,l.b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double ptoline(point3 p,point3 l1,point3 l2)&#123;</span><br><span class="line"></span><br><span class="line">	return vlen(xmult(subt(p,l1),subt(l2,l1)))/distance(l1,l2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算点到平面的距离"><a href="#计算点到平面的距离" class="headerlink" title="计算点到平面的距离"></a><strong>计算点到平面的距离</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**//点到平面距离**</span><br><span class="line"></span><br><span class="line">double ptoplane(point3 p,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return fabs(dmult(pvec(s),subt(p,s.a)))/vlen(pvec(s));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double ptoplane(point3 p,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return fabs(dmult(pvec(s1,s2,s3),subt(p,s1)))/vlen(pvec(s1,s2,s3));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算直线到直线的距离"><a href="#计算直线到直线的距离" class="headerlink" title="计算直线到直线的距离"></a><strong>计算直线到直线的距离</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">**//直线到直线距离**</span><br><span class="line"></span><br><span class="line">double linetoline(line3 u,line3 v)&#123;</span><br><span class="line"></span><br><span class="line">	point3 n=xmult(subt(u.a,u.b),subt(v.a,v.b));</span><br><span class="line"></span><br><span class="line">	return fabs(dmult(subt(u.a,v.a),n))/vlen(n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double linetoline(point3 u1,point3 u2,point3 v1,point3 v2)&#123;</span><br><span class="line"></span><br><span class="line">	point3 n=xmult(subt(u1,u2),subt(v1,v2));</span><br><span class="line"></span><br><span class="line">	return fabs(dmult(subt(u1,v1),n))/vlen(n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="空间两直线夹角的cos值"><a href="#空间两直线夹角的cos值" class="headerlink" title="空间两直线夹角的cos值"></a><strong>空间两直线夹角的cos值</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**//两直线夹角cos值**</span><br><span class="line"></span><br><span class="line">double angle_cos(line3 u,line3 v)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(subt(u.a,u.b),subt(v.a,v.b))/vlen(subt(u.a,u.b))/vlen(subt(v.a,v.b));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double angle_cos(point3 u1,point3 u2,point3 v1,point3 v2)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(subt(u1,u2),subt(v1,v2))/vlen(subt(u1,u2))/vlen(subt(v1,v2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两平面夹角的cos值"><a href="#两平面夹角的cos值" class="headerlink" title="两平面夹角的cos值"></a><strong>两平面夹角的cos值</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**//两平面夹角cos值**</span><br><span class="line"></span><br><span class="line">double angle_cos(plane3 u,plane3 v)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(pvec(u),pvec(v))/vlen(pvec(u))/vlen(pvec(v));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double angle_cos(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(pvec(u1,u2,u3),pvec(v1,v2,v3))/vlen(pvec(u1,u2,u3))/vlen(pvec(v1,v2,v3));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="直线与平面夹角sin值"><a href="#直线与平面夹角sin值" class="headerlink" title="直线与平面夹角sin值"></a><strong>直线与平面夹角sin值</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//直线平面夹角sin值</span><br><span class="line"></span><br><span class="line">double angle_sin(line3 l,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(subt(l.a,l.b),pvec(s))/vlen(subt(l.a,l.b))/vlen(pvec(s));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double angle_sin(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(subt(l1,l2),pvec(s1,s2,s3))/vlen(subt(l1,l2))/vlen(pvec(s1,s2,s3));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高级计算几何"><a href="#高级计算几何" class="headerlink" title="高级计算几何"></a>高级计算几何</h2><h3 id="最远曼哈顿距离"><a href="#最远曼哈顿距离" class="headerlink" title="最远曼哈顿距离"></a><strong>最远曼哈顿距离</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#define INF 9999999999999.0</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x[5];</span><br><span class="line"></span><br><span class="line">&#125;pt[100005];</span><br><span class="line"></span><br><span class="line">double dis[32][100005], coe[5], minx[32], maxx[32];</span><br><span class="line"></span><br><span class="line">**//去掉绝对值后有2^D种可能**</span><br><span class="line"></span><br><span class="line">void GetD(int N, int D)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int s, i, j, tot=(1&lt;&lt;D);</span><br><span class="line"></span><br><span class="line">    for (s=0;s&lt;tot;s++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for (i=0;i&lt;D;i++)</span><br><span class="line"></span><br><span class="line">            if (s&amp;(1&lt;&lt;i))</span><br><span class="line"></span><br><span class="line">                coe[i]=-1.0;</span><br><span class="line"></span><br><span class="line">            else coe[i]=1.0;</span><br><span class="line"></span><br><span class="line">        for (i=0;i&lt;N;i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            dis[s][i]=0.0;</span><br><span class="line"></span><br><span class="line">            for (j=0;j&lt;D;j++)</span><br><span class="line"></span><br><span class="line">                dis[s][i]=dis[s][i]+coe[j]*pt[i].x[j];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//取每种可能中的最大差距**</span><br><span class="line"></span><br><span class="line">void Solve(int N, int D)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int s, i, tot=(1&lt;&lt;D);</span><br><span class="line"></span><br><span class="line">    double tmp, ans;</span><br><span class="line"></span><br><span class="line">    for (s=0;s&lt;tot;s++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        minx[s]=INF;</span><br><span class="line"></span><br><span class="line">        maxx[s]=-INF;</span><br><span class="line"></span><br><span class="line">        for (i=0; i&lt;N; i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (minx[s]&gt;dis[s][i]) minx[s]=dis[s][i];</span><br><span class="line"></span><br><span class="line">            if (maxx[s]&lt;dis[s][i]) maxx[s]=dis[s][i];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans=0.0;</span><br><span class="line"></span><br><span class="line">    for (s=0; s&lt;tot; s++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        tmp=maxx[s]-minx[s];</span><br><span class="line"></span><br><span class="line">        if (tmp&gt;ans) ans=tmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%.2lf\n&quot;, ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n, i;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d&quot;,&amp;n)==1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for (i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">          scanf(&quot;%lf%lf%lf%lf%lf&quot;,&amp;pt[i].x[0],&amp;pt[i].x[1],&amp;pt[i].x[2],&amp;pt[i].x[3],&amp;pt[i].x[4]);</span><br><span class="line"></span><br><span class="line">        GetD(n, 5);</span><br><span class="line"></span><br><span class="line">        Solve(n, 5);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最近点对"><a href="#最近点对" class="headerlink" title="最近点对"></a><strong>最近点对</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#define Max(x,y) (x)&gt;(y)?(x):(y)</span><br><span class="line"></span><br><span class="line">struct Q</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x, y;</span><br><span class="line"></span><br><span class="line">&#125;q[100001], sl[10], sr[10];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">int cntl, cntr, lm, rm;</span><br><span class="line"></span><br><span class="line">double ans;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">int cmp(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Q*a1=(struct Q*)p1;</span><br><span class="line"></span><br><span class="line">    struct Q*a2=(struct Q*)p2;</span><br><span class="line"></span><br><span class="line">    if (a1-&gt;x&lt;a2-&gt;x)return -1;</span><br><span class="line"></span><br><span class="line">    else if (a1-&gt;x==a2-&gt;x)return 0;</span><br><span class="line"></span><br><span class="line">    else return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">double CalDis(double x1, double y1, double x2, double y2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">void MinDis(int l, int r)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (l==r) return;</span><br><span class="line"></span><br><span class="line">    double dis;</span><br><span class="line"></span><br><span class="line">    if (l+1==r)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        dis=CalDis(q[l].x,q[l].y,q[r].x,q[r].y);</span><br><span class="line"></span><br><span class="line">        if (ans&gt;dis) ans=dis;</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int mid=(l+r)&gt;&gt;1, i, j;</span><br><span class="line"></span><br><span class="line">    MinDis(l,mid);</span><br><span class="line"></span><br><span class="line">    MinDis(mid+1,r);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    lm=mid+1-5;</span><br><span class="line"></span><br><span class="line">    if (lm&lt;l) lm=l;</span><br><span class="line"></span><br><span class="line">    rm=mid+5;</span><br><span class="line"></span><br><span class="line">    if (rm&gt;r) rm=r;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    cntl=cntr=0;</span><br><span class="line"></span><br><span class="line">    for (i=mid;i&gt;=lm;i--)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (q[mid+1].x-q[i].x&gt;=ans)break;</span><br><span class="line"></span><br><span class="line">        sl[++cntl]=q[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i=mid+1;i&lt;=rm;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (q[i].x-q[mid].x&gt;=ans)break;</span><br><span class="line"></span><br><span class="line">        sr[++cntr]=q[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    for (i=1;i&lt;=cntl;i++)</span><br><span class="line"></span><br><span class="line">        for (j=1;j&lt;=cntr;j++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            dis=CalDis(sl[i].x,sl[i].y,sr[j].x,sr[j].y);</span><br><span class="line"></span><br><span class="line">            if (dis&lt;ans) ans=dis;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n, i;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d&quot;,&amp;n)==1&amp;&amp;n)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;=n;i++)</span><br><span class="line"></span><br><span class="line">            scanf(&quot;%lf %lf&quot;, &amp;q[i].x,&amp;q[i].y);</span><br><span class="line"></span><br><span class="line">        qsort(q+1,n,sizeof(struct Q),cmp);</span><br><span class="line"></span><br><span class="line">        ans=CalDis(q[1].x,q[1].y,q[2].x,q[2].y);</span><br><span class="line"></span><br><span class="line">        MinDis(1,n);</span><br><span class="line"></span><br><span class="line">        printf(&quot;%.2lf\n&quot;,ans/2.0);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小包围圆"><a href="#最小包围圆" class="headerlink" title="最小包围圆"></a><strong>最小包围圆</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line">\#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x;</span><br><span class="line"></span><br><span class="line">    double y;</span><br><span class="line"></span><br><span class="line">&#125;pt[1005];</span><br><span class="line"></span><br><span class="line">struct Traingle</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Point p[3];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Circle</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Point center;</span><br><span class="line"></span><br><span class="line">    double r;</span><br><span class="line"></span><br><span class="line">&#125;ans;</span><br><span class="line"></span><br><span class="line">**//计算两点距离**</span><br><span class="line"></span><br><span class="line">double Dis(struct Point p, struct Point q)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double dx=p.x-q.x;</span><br><span class="line"></span><br><span class="line">    double dy=p.y-q.y;</span><br><span class="line"></span><br><span class="line">    return sqrt(dx*dx+dy*dy);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//计算三角形面积**</span><br><span class="line"></span><br><span class="line">double Area(struct Traingle ct)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return fabs((ct.p[1].x-ct.p[0].x)*(ct.p[2].y-ct.p[0].y)-(ct.p[2].x-ct.p[0].x)*(ct.p[1].y-ct.p[0].y))/2.0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//求三角形的外接圆，返回圆心和半径(存在结构体&quot;圆&quot;中)**</span><br><span class="line"></span><br><span class="line">struct Circle CircumCircle(struct Traingle t)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Circle tmp;</span><br><span class="line"></span><br><span class="line">    double a, b, c, c1, c2;</span><br><span class="line"></span><br><span class="line">    double xA, yA, xB, yB, xC, yC;</span><br><span class="line"></span><br><span class="line">    a = Dis(t.p[0], t.p[1]);</span><br><span class="line"></span><br><span class="line">    b = Dis(t.p[1], t.p[2]);</span><br><span class="line"></span><br><span class="line">    c = Dis(t.p[2], t.p[0]);</span><br><span class="line"></span><br><span class="line">    //根据S = a * b * c / R / 4;求半径R</span><br><span class="line"></span><br><span class="line">    tmp.r = (a*b*c)/(Area(t)*4.0);</span><br><span class="line"></span><br><span class="line">    xA = t.p[0].x;</span><br><span class="line"></span><br><span class="line">    yA = t.p[0].y;</span><br><span class="line"></span><br><span class="line">    xB = t.p[1].x;</span><br><span class="line"></span><br><span class="line">    yB = t.p[1].y;</span><br><span class="line"></span><br><span class="line">    xC = t.p[2].x;</span><br><span class="line"></span><br><span class="line">    yC = t.p[2].y;</span><br><span class="line"></span><br><span class="line">    c1 = (xA*xA+yA*yA - xB*xB-yB*yB) / 2;</span><br><span class="line"></span><br><span class="line">    c2 = (xA*xA+yA*yA - xC*xC-yC*yC) / 2;</span><br><span class="line"></span><br><span class="line">    tmp.center.x = (c1*(yA - yC)-c2*(yA - yB)) / ((xA - xB)*(yA - yC)-(xA - xC)*(yA - yB));</span><br><span class="line"></span><br><span class="line">    tmp.center.y = (c1*(xA - xC)-c2*(xA - xB)) / ((yA - yB)*(xA - xC)-(yA - yC)*(xA - xB));</span><br><span class="line"></span><br><span class="line">    return tmp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//确定最小包围圆**</span><br><span class="line"></span><br><span class="line">struct Circle MinCircle(int num, struct Traingle ct)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Circle ret;</span><br><span class="line"></span><br><span class="line">    if (num==0) ret.r = 0.0;</span><br><span class="line"></span><br><span class="line">    else if (num==1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        ret.center = ct.p[0];</span><br><span class="line"></span><br><span class="line">        ret.r = 0.0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else if (num==2)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        ret.center.x = (ct.p[0].x+ct.p[1].x)/2.0;</span><br><span class="line"></span><br><span class="line">        ret.center.y = (ct.p[0].y+ct.p[1].y)/2.0;</span><br><span class="line"></span><br><span class="line">        ret.r = Dis(ct.p[0], ct.p[1])/2.0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else if(num==3) ret = CircumCircle(ct);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//递归实现增量算法**</span><br><span class="line"></span><br><span class="line">void Dfs(int x, int num, struct Traingle ct)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">    struct Point tmp;</span><br><span class="line"></span><br><span class="line">    ans = MinCircle(num, ct);</span><br><span class="line"></span><br><span class="line">    if (num==3) return;</span><br><span class="line"></span><br><span class="line">    for (i=1; i&lt;=x; i++)</span><br><span class="line"></span><br><span class="line">        if (Dis(pt[i], ans.center)&gt;ans.r)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ct.p[num]=pt[i];</span><br><span class="line"></span><br><span class="line">            Dfs(i-1, num+1, ct);</span><br><span class="line"></span><br><span class="line">            tmp=pt[i];</span><br><span class="line"></span><br><span class="line">            for (j=i;j&gt;=2;j--)</span><br><span class="line"></span><br><span class="line">                pt[j]=pt[j-1];</span><br><span class="line"></span><br><span class="line">            pt[1]=tmp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Solve(int n)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Traingle ct;</span><br><span class="line"></span><br><span class="line">    Dfs(n, 0, ct);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n, i;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n)!=EOF &amp;&amp; n)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;=n;i++)</span><br><span class="line"></span><br><span class="line">            scanf(&quot;%lf %lf&quot;, &amp;pt[i].x, &amp;pt[i].y);</span><br><span class="line"></span><br><span class="line">        Solve(n);</span><br><span class="line"></span><br><span class="line">        printf(&quot;%.2lf %.2lf %.2lf\n&quot;, ans.center.x, ans.center.y, ans.r);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求两个圆的交点"><a href="#求两个圆的交点" class="headerlink" title="求两个圆的交点"></a><strong>求两个圆的交点</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">\#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">const double eps = 1e-8;</span><br><span class="line"></span><br><span class="line">const double PI = acos(-1.0);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x;</span><br><span class="line"></span><br><span class="line">    double y;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct Point point;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">struct Line</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double s, t;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct Line Line;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">struct Circle</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Point center;</span><br><span class="line"></span><br><span class="line">    double r;</span><br><span class="line"></span><br><span class="line">    Line line[505];</span><br><span class="line"></span><br><span class="line">    int cnt;</span><br><span class="line"></span><br><span class="line">    bool covered;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;circle[105];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">double distance(point p1, point p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double dx = p1.x-p2.x;</span><br><span class="line"></span><br><span class="line">    double dy = p1.y-p2.y;</span><br><span class="line"></span><br><span class="line">    return sqrt(dx*dx + dy*dy);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">point intersection(point u1,point u2, point v1,point v2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point ret = u1;</span><br><span class="line"></span><br><span class="line">    double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x)) /</span><br><span class="line"></span><br><span class="line">             ((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));</span><br><span class="line"></span><br><span class="line">    ret.x += (u2.x-u1.x)*t;</span><br><span class="line"></span><br><span class="line">    ret.y += (u2.y-u1.y)*t;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">void intersection_line_circle(point c,double r,point l1,point l2,point&amp; p1,point&amp; p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point p=c;</span><br><span class="line"></span><br><span class="line">    double t;</span><br><span class="line"></span><br><span class="line">    p.x+=l1.y-l2.y;</span><br><span class="line"></span><br><span class="line">    p.y+=l2.x-l1.x;</span><br><span class="line"></span><br><span class="line">    p=intersection(p,c,l1,l2);</span><br><span class="line"></span><br><span class="line">    t=sqrt(r*r-distance(p,c)*distance(p,c))/distance(l1,l2);</span><br><span class="line"></span><br><span class="line">    p1.x=p.x+(l2.x-l1.x)*t;</span><br><span class="line"></span><br><span class="line">    p1.y=p.y+(l2.y-l1.y)*t;</span><br><span class="line"></span><br><span class="line">    p2.x=p.x-(l2.x-l1.x)*t;</span><br><span class="line"></span><br><span class="line">    p2.y=p.y-(l2.y-l1.y)*t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//计算圆与圆的交点,保证圆与圆有交点,圆心不重合**</span><br><span class="line"></span><br><span class="line">void intersection_circle_circle(point c1,double r1,point c2,double r2,point&amp; p1,point&amp; p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point u,v;</span><br><span class="line"></span><br><span class="line">    double t;</span><br><span class="line"></span><br><span class="line">    t=(1+(r1*r1-r2*r2)/distance(c1,c2)/distance(c1,c2))/2;</span><br><span class="line"></span><br><span class="line">    u.x=c1.x+(c2.x-c1.x)*t;</span><br><span class="line"></span><br><span class="line">    u.y=c1.y+(c2.y-c1.y)*t;</span><br><span class="line"></span><br><span class="line">    v.x=u.x+c1.y-c2.y;</span><br><span class="line"></span><br><span class="line">    v.y=u.y-c1.x+c2.x;</span><br><span class="line"></span><br><span class="line">    intersection_line_circle(c1,r1,u,v,p1,p2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求三角形外接圆圆心"><a href="#求三角形外接圆圆心" class="headerlink" title="求三角形外接圆圆心"></a><strong>求三角形外接圆圆心</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x;</span><br><span class="line"></span><br><span class="line">    double y;</span><br><span class="line"></span><br><span class="line">&#125;pt[1005];</span><br><span class="line"></span><br><span class="line">struct Traingle</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Point p[3];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Circle</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Point center;</span><br><span class="line"></span><br><span class="line">    double r;</span><br><span class="line"></span><br><span class="line">**&#125;**ans;</span><br><span class="line"></span><br><span class="line">**//计算两点距离**</span><br><span class="line"></span><br><span class="line">double Dis(struct Point p, struct Point q)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double dx=p.x-q.x;</span><br><span class="line"></span><br><span class="line">    double dy=p.y-q.y;</span><br><span class="line"></span><br><span class="line">    return sqrt(dx*dx+dy*dy);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//计算三角形面积**</span><br><span class="line"></span><br><span class="line">double Area(struct Traingle ct)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return fabs((ct.p[1].x-ct.p[0].x)*(ct.p[2].y-ct.p[0].y)-(ct.p[2].x-ct.p[0].x)*(ct.p[1].y-ct.p[0].y))/2.0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//求三角形的外接圆，返回圆心和半径(存在结构体&quot;圆&quot;中)**</span><br><span class="line"></span><br><span class="line">struct Circle CircumCircle(struct Traingle t)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Circle tmp;</span><br><span class="line"></span><br><span class="line">    double a, b, c, c1, c2;</span><br><span class="line"></span><br><span class="line">    double xA, yA, xB, yB, xC, yC;</span><br><span class="line"></span><br><span class="line">    a = Dis(t.p[0], t.p[1]);</span><br><span class="line"></span><br><span class="line">    b = Dis(t.p[1], t.p[2]);</span><br><span class="line"></span><br><span class="line">    c = Dis(t.p[2], t.p[0]);</span><br><span class="line"></span><br><span class="line">    //根据S = a * b * c / R / 4;求半径R</span><br><span class="line"></span><br><span class="line">    tmp.r = (a*b*c)/(Area(t)*4.0);</span><br><span class="line"></span><br><span class="line">    xA = t.p[0].x;</span><br><span class="line"></span><br><span class="line">    yA = t.p[0].y;</span><br><span class="line"></span><br><span class="line">    xB = t.p[1].x;</span><br><span class="line"></span><br><span class="line">    yB = t.p[1].y;</span><br><span class="line"></span><br><span class="line">    xC = t.p[2].x;</span><br><span class="line"></span><br><span class="line">    yC = t.p[2].y;</span><br><span class="line"></span><br><span class="line">    c1 = (xA*xA+yA*yA - xB*xB-yB*yB) / 2;</span><br><span class="line"></span><br><span class="line">    c2 = (xA*xA+yA*yA - xC*xC-yC*yC) / 2;</span><br><span class="line"></span><br><span class="line">    tmp.center.x = (c1*(yA - yC)-c2*(yA - yB)) / ((xA - xB)*(yA - yC)-(xA - xC)*(yA - yB));</span><br><span class="line"></span><br><span class="line">    tmp.center.y = (c1*(xA - xC)-c2*(xA - xB)) / ((yA - yB)*(xA - xC)-(yA - yC)*(xA - xB));</span><br><span class="line"></span><br><span class="line">    return tmp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求凸包"><a href="#求凸包" class="headerlink" title="求凸包"></a><strong>求凸包</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#define INF 999999999.9</span><br><span class="line"></span><br><span class="line">\#define PI acos(-1.0)</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x, y, dis;</span><br><span class="line"></span><br><span class="line">&#125;pt[1005], stack[1005], p0;</span><br><span class="line"></span><br><span class="line">int top, tot;</span><br><span class="line"></span><br><span class="line">**//计算几何距离**</span><br><span class="line"></span><br><span class="line">double Dis(double x1, double y1, double x2, double y2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//极角比较， 返回-1: p0p1在p0p2的右侧，返回0:p0,p1,p2共线**</span><br><span class="line"></span><br><span class="line">int Cmp_PolarAngel(struct Point p1, struct Point p2, struct Point pb)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double delta=(p1.x-pb.x)*(p2.y-pb.y)-(p2.x-pb.x)*(p1.y-pb.y);</span><br><span class="line"></span><br><span class="line">    if (delta&lt;0.0) return 1;</span><br><span class="line"></span><br><span class="line">    else if (delta==0.0) return 0;</span><br><span class="line"></span><br><span class="line">    else return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**// 判断向量p2p3是否对p1p2构成左旋**</span><br><span class="line"></span><br><span class="line">bool Is_LeftTurn(struct Point p3, struct Point p2, struct Point p1)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int type=Cmp_PolarAngel(p3, p1, p2);</span><br><span class="line"></span><br><span class="line">    if (type&lt;0) return true;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//先按极角排，再按距离由小到大排**</span><br><span class="line"></span><br><span class="line">int Cmp(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Point*a1=(struct Point*)p1;</span><br><span class="line"></span><br><span class="line">    struct Point*a2=(struct Point*)p2;</span><br><span class="line"></span><br><span class="line">    int type=Cmp_PolarAngel(*a1, *a2, p0);</span><br><span class="line"></span><br><span class="line">    if (type&lt;0) return -1;</span><br><span class="line"></span><br><span class="line">    else if (type==0)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (a1-&gt;dis&lt;a2-&gt;dis) return -1;</span><br><span class="line"></span><br><span class="line">        else if (a1-&gt;dis==a2-&gt;dis) return 0;</span><br><span class="line"></span><br><span class="line">        else return 1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//求凸包**</span><br><span class="line"></span><br><span class="line">void Solve(int n)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i, k;</span><br><span class="line"></span><br><span class="line">    p0.x=p0.y=INF;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        scanf(&quot;%lf %lf&quot;,&amp;pt[i].x, &amp;pt[i].y);</span><br><span class="line"></span><br><span class="line">        if (pt[i].y &lt; p0.y)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            p0.y=pt[i].y;</span><br><span class="line"></span><br><span class="line">            p0.x=pt[i].x;</span><br><span class="line"></span><br><span class="line">            k=i;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else if (pt[i].y==p0.y)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (pt[i].x&lt;p0.x)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                p0.x=pt[i].x;</span><br><span class="line"></span><br><span class="line">                k=i;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pt[k]=pt[0];</span><br><span class="line"></span><br><span class="line">    pt[0]=p0;</span><br><span class="line"></span><br><span class="line">    for (i=1;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">        pt[i].dis=Dis(pt[i].x,pt[i].y, p0.x,p0.y);</span><br><span class="line"></span><br><span class="line">    qsort(pt+1, n-1, sizeof(struct Point), Cmp);</span><br><span class="line"></span><br><span class="line">    **//去掉极角相同的点**</span><br><span class="line"></span><br><span class="line">    tot=1;</span><br><span class="line"></span><br><span class="line">    for (i=2;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">        if (Cmp_PolarAngel(pt[i], pt[i-1], p0))</span><br><span class="line"></span><br><span class="line">            pt[tot++]=pt[i-1];</span><br><span class="line"></span><br><span class="line">    pt[tot++]=pt[n-1];</span><br><span class="line"></span><br><span class="line">    **//求凸包**</span><br><span class="line"></span><br><span class="line">    top=1;</span><br><span class="line"></span><br><span class="line">    stack[0]=pt[0];</span><br><span class="line"></span><br><span class="line">    stack[1]=pt[1];</span><br><span class="line"></span><br><span class="line">    for (i=2;i&lt;tot;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        while (top&gt;=1 &amp;&amp; Is_LeftTurn(pt[i], stack[top], stack[top-1])==false)</span><br><span class="line"></span><br><span class="line">            top--;</span><br><span class="line"></span><br><span class="line">        stack[++top]=pt[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d&quot;,&amp;n)==2)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Solve(n);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="凸包卡壳旋转求出所有对踵点、最远点对"><a href="#凸包卡壳旋转求出所有对踵点、最远点对" class="headerlink" title="凸包卡壳旋转求出所有对踵点、最远点对"></a><strong>凸包卡壳旋转求出所有对踵点、最远点对</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#define INF 999999999.9</span><br><span class="line"></span><br><span class="line">\#define PI acos(-1.0)</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x, y, dis;</span><br><span class="line"></span><br><span class="line">&#125;pt[6005], stack[6005], p0;</span><br><span class="line"></span><br><span class="line">int top, tot;</span><br><span class="line"></span><br><span class="line">**//计算几何距离**</span><br><span class="line"></span><br><span class="line">double Dis(double x1, double y1, double x2, double y2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//极角比较， 返回-1: p0p1在p0p2的右侧，返回0:p0,p1,p2共线**</span><br><span class="line"></span><br><span class="line">int Cmp_PolarAngel(struct Point p1, struct Point p2, struct Point pb)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double delta=(p1.x-pb.x)*(p2.y-pb.y)-(p2.x-pb.x)*(p1.y-pb.y);</span><br><span class="line"></span><br><span class="line">    if (delta&lt;0.0) return 1;</span><br><span class="line"></span><br><span class="line">    else if (delta==0.0) return 0;</span><br><span class="line"></span><br><span class="line">    else return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**// 判断向量p2p3是否对p1p2构成左旋**</span><br><span class="line"></span><br><span class="line">bool Is_LeftTurn(struct Point p3, struct Point p2, struct Point p1)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int type=Cmp_PolarAngel(p3, p1, p2);</span><br><span class="line"></span><br><span class="line">    if (type&lt;0) return true;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//先按极角排，再按距离由小到大排**</span><br><span class="line"></span><br><span class="line">int Cmp(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Point*a1=(struct Point*)p1;</span><br><span class="line"></span><br><span class="line">    struct Point*a2=(struct Point*)p2;</span><br><span class="line"></span><br><span class="line">    int type=Cmp_PolarAngel(*a1, *a2, p0);</span><br><span class="line"></span><br><span class="line">    if (type&lt;0) return -1;</span><br><span class="line"></span><br><span class="line">    else if (type==0)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (a1-&gt;dis&lt;a2-&gt;dis) return -1;</span><br><span class="line"></span><br><span class="line">        else if (a1-&gt;dis==a2-&gt;dis) return 0;</span><br><span class="line"></span><br><span class="line">        else return 1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//求凸包**</span><br><span class="line"></span><br><span class="line">void Hull(int n)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i, k;</span><br><span class="line"></span><br><span class="line">    p0.x=p0.y=INF;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        scanf(&quot;%lf %lf&quot;,&amp;pt[i].x, &amp;pt[i].y);</span><br><span class="line"></span><br><span class="line">        if (pt[i].y &lt; p0.y)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            p0.y=pt[i].y;</span><br><span class="line"></span><br><span class="line">            p0.x=pt[i].x;</span><br><span class="line"></span><br><span class="line">            k=i;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else if (pt[i].y==p0.y)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (pt[i].x&lt;p0.x)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                p0.x=pt[i].x;</span><br><span class="line"></span><br><span class="line">                k=i;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pt[k]=pt[0];</span><br><span class="line"></span><br><span class="line">    pt[0]=p0;</span><br><span class="line"></span><br><span class="line">    for (i=1;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">        pt[i].dis=Dis(pt[i].x,pt[i].y, p0.x,p0.y);</span><br><span class="line"></span><br><span class="line">    qsort(pt+1, n-1, sizeof(struct Point), Cmp);</span><br><span class="line"></span><br><span class="line">    **//去掉极角相同的点**</span><br><span class="line"></span><br><span class="line">    tot=1;</span><br><span class="line"></span><br><span class="line">    for (i=2;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">        if (Cmp_PolarAngel(pt[i], pt[i-1], p0))</span><br><span class="line"></span><br><span class="line">            pt[tot++]=pt[i-1];</span><br><span class="line"></span><br><span class="line">    pt[tot++]=pt[n-1];</span><br><span class="line"></span><br><span class="line">    **//求凸包**</span><br><span class="line"></span><br><span class="line">    top=1;</span><br><span class="line"></span><br><span class="line">    stack[0]=pt[0];</span><br><span class="line"></span><br><span class="line">    stack[1]=pt[1];</span><br><span class="line"></span><br><span class="line">    for (i=2;i&lt;tot;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        while (top&gt;=1 &amp;&amp; Is_LeftTurn(pt[i], stack[top], stack[top-1])==false)</span><br><span class="line"></span><br><span class="line">            top--;</span><br><span class="line"></span><br><span class="line">        stack[++top]=pt[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//计算叉积**</span><br><span class="line"></span><br><span class="line">double CrossProduct(struct Point p1, struct Point p2, struct Point p3)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return (p1.x-p3.x)*(p2.y-p3.y)-(p2.x-p3.x)*(p1.y-p3.y);</span><br><span class="line"></span><br><span class="line">**&#125;**</span><br><span class="line"></span><br><span class="line">**//卡壳旋转，求出凸多边形所有对踵点**</span><br><span class="line"></span><br><span class="line">void Rotate(struct Point*ch, int n)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i, p=1;</span><br><span class="line"></span><br><span class="line">    double t1, t2, ans=0.0, dif;</span><br><span class="line"></span><br><span class="line">    ch[n]=ch[0];</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        **//如果下一个点与当前边构成的三角形的面积更大，则说明此时不构成对踵点**</span><br><span class="line"></span><br><span class="line">        while (fabs(CrossProduct(ch[i],ch[i+1],ch[p+1])) &gt; fabs(CrossProduct(ch[i],ch[i+1],ch[p])))</span><br><span class="line"></span><br><span class="line">            p=(p+1)%n;</span><br><span class="line"></span><br><span class="line">        dif=fabs(CrossProduct(ch[i],ch[i+1],ch[p+1])) - fabs(CrossProduct(ch[i],ch[i+1],ch[p]));</span><br><span class="line"></span><br><span class="line">        **//如果当前点和下一个点分别构成的三角形面积相等，则说明两条边即为平行线，对角线两端都可能是对踵点**</span><br><span class="line"></span><br><span class="line">        if (dif==0.0)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            t1=Dis(ch[p].x, ch[p].y, ch[i].x, ch[i].y);</span><br><span class="line"></span><br><span class="line">            t2=Dis(ch[p+1].x, ch[p+1].y, ch[i+1].x, ch[i+1].y);</span><br><span class="line"></span><br><span class="line">            if (t1&gt;ans)ans=t1;</span><br><span class="line"></span><br><span class="line">            if (t2&gt;ans)ans=t2;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        **//说明p，i是对踵点**</span><br><span class="line"></span><br><span class="line">        else if (dif&lt;0.0)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            t1=Dis(ch[p].x, ch[p].y, ch[i].x, ch[i].y);</span><br><span class="line"></span><br><span class="line">            if (t1&gt;ans)ans=t1;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%.2lf\n&quot;,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d&quot;,&amp;n)==1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Hull(n);</span><br><span class="line"></span><br><span class="line">        Rotate(stack, top+1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="凸包-旋转卡壳求平面面积最大三角"><a href="#凸包-旋转卡壳求平面面积最大三角" class="headerlink" title="凸包+旋转卡壳求平面面积最大三角"></a><strong>凸包+旋转卡壳求平面面积最大三角</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#define INF 99999999999.9</span><br><span class="line"></span><br><span class="line">\#define PI acos(-1.0)</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x, y, dis;</span><br><span class="line"></span><br><span class="line">&#125;pt[50005], stack[50005], p0;</span><br><span class="line"></span><br><span class="line">int top, tot;</span><br><span class="line"></span><br><span class="line">double Dis(double x1, double y1, double x2, double y2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Cmp_PolarAngel(struct Point p1, struct Point p2, struct Point pb)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double delta=(p1.x-pb.x)*(p2.y-pb.y)-(p2.x-pb.x)*(p1.y-pb.y);</span><br><span class="line"></span><br><span class="line">    if (delta&lt;0.0) return 1;</span><br><span class="line"></span><br><span class="line">    else if (delta==0.0) return 0;</span><br><span class="line"></span><br><span class="line">    else return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Is_LeftTurn(struct Point p3, struct Point p2, struct Point p1)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int type=Cmp_PolarAngel(p3, p1, p2);</span><br><span class="line"></span><br><span class="line">    if (type&lt;0) return true;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Cmp(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Point*a1=(struct Point*)p1;</span><br><span class="line"></span><br><span class="line">    struct Point*a2=(struct Point*)p2;</span><br><span class="line"></span><br><span class="line">    int type=Cmp_PolarAngel(*a1, *a2, p0);</span><br><span class="line"></span><br><span class="line">    if (type&lt;0) return -1;</span><br><span class="line"></span><br><span class="line">    else if (type==0)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (a1-&gt;dis&lt;a2-&gt;dis) return -1;</span><br><span class="line"></span><br><span class="line">        else if (a1-&gt;dis==a2-&gt;dis) return 0;</span><br><span class="line"></span><br><span class="line">        else return 1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Hull(int n)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i, k;</span><br><span class="line"></span><br><span class="line">    p0.x=p0.y=INF;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        scanf(&quot;%lf %lf&quot;,&amp;pt[i].x, &amp;pt[i].y);</span><br><span class="line"></span><br><span class="line">        if (pt[i].y &lt; p0.y)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            p0.y=pt[i].y;</span><br><span class="line"></span><br><span class="line">            p0.x=pt[i].x;</span><br><span class="line"></span><br><span class="line">            k=i;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else if (pt[i].y==p0.y)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (pt[i].x&lt;p0.x)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                p0.x=pt[i].x;</span><br><span class="line"></span><br><span class="line">                k=i;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pt[k]=pt[0];</span><br><span class="line"></span><br><span class="line">    pt[0]=p0;</span><br><span class="line"></span><br><span class="line">    for (i=1;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">        pt[i].dis=Dis(pt[i].x,pt[i].y, p0.x,p0.y);</span><br><span class="line"></span><br><span class="line">    qsort(pt+1, n-1, sizeof(struct Point), Cmp);</span><br><span class="line"></span><br><span class="line">    tot=1;</span><br><span class="line"></span><br><span class="line">    for (i=2;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">        if (Cmp_PolarAngel(pt[i], pt[i-1], p0))</span><br><span class="line"></span><br><span class="line">            pt[tot++]=pt[i-1];</span><br><span class="line"></span><br><span class="line">    pt[tot++]=pt[n-1];</span><br><span class="line"></span><br><span class="line">    top=1;</span><br><span class="line"></span><br><span class="line">    stack[0]=pt[0];</span><br><span class="line"></span><br><span class="line">    stack[1]=pt[1];</span><br><span class="line"></span><br><span class="line">    for (i=2;i&lt;tot;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        while (top&gt;=1 &amp;&amp; Is_LeftTurn(pt[i], stack[top], stack[top-1])==false)</span><br><span class="line"></span><br><span class="line">            top--;</span><br><span class="line"></span><br><span class="line">        stack[++top]=pt[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double TArea(struct Point p1, struct Point p2, struct Point p3)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return fabs((p1.x-p3.x)*(p2.y-p3.y)-(p2.x-p3.x)*(p1.y-p3.y));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Rotate(struct Point*ch, int n)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (n&lt;3)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        printf(&quot;0.00\n&quot;);</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int i, j, k;</span><br><span class="line"></span><br><span class="line">    double ans=0.0, tmp;</span><br><span class="line"></span><br><span class="line">    ch[n]=ch[0];</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        j=(i+1)%n;</span><br><span class="line"></span><br><span class="line">        k=(j+1)%n;</span><br><span class="line"></span><br><span class="line">        while ((j!=k) &amp;&amp; (k!=i))</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            while (TArea(ch[i],ch[j],ch[k+1])&gt;TArea(ch[i],ch[j],ch[k]))</span><br><span class="line"></span><br><span class="line">                k=(k+1)%n;</span><br><span class="line"></span><br><span class="line">            tmp=TArea(ch[i],ch[j], ch[k]);</span><br><span class="line"></span><br><span class="line">            if (tmp&gt;ans) ans=tmp;</span><br><span class="line"></span><br><span class="line">            j=(j+1)%n;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%.2lf\n&quot;,ans/2.0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d&quot;,&amp;n)==1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (n==-1)break;</span><br><span class="line"></span><br><span class="line">        Hull(n);</span><br><span class="line"></span><br><span class="line">        Rotate(stack, top+1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Pick定理"><a href="#Pick定理" class="headerlink" title="Pick定理"></a><strong>Pick定理</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">**// Pick定理求整点多边形内部整点数目**</span><br><span class="line"></span><br><span class="line">**// (1) 给定顶点座标均是整点（或正方形格点）的简单多边形，皮克定理说明了其面积A和内部格点数目i、边上格点数目b的关系：A = i + b/2 - 1；**</span><br><span class="line"></span><br><span class="line">**// (2) 在两点（x1，y1），（x2，y2）连线之间的整点个数（包含一个端点）为：gcd（|x1－x2|，|y1－y2|）；**</span><br><span class="line"></span><br><span class="line">**// (3) 求三角形面积用叉乘**</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">\#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">long long x[3], y[3], area, b;</span><br><span class="line"></span><br><span class="line">long long My_Abs(long long t)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (t&lt;0) return -t;</span><br><span class="line"></span><br><span class="line">    return t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long Gcd(long long x, long long y)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (y==0) return x;</span><br><span class="line"></span><br><span class="line">    long long mod=x%y;</span><br><span class="line"></span><br><span class="line">    while (mod)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        x=y;</span><br><span class="line"></span><br><span class="line">        y=mod;</span><br><span class="line"></span><br><span class="line">        mod=x%y;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    while (1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for (i = 0;i &lt; 3;i ++)</span><br><span class="line"></span><br><span class="line">            scanf(&quot;%lld %lld&quot;, &amp;x[i], &amp;y[i]);</span><br><span class="line"></span><br><span class="line">        if(x[0]==0&amp;&amp;y[0]==0&amp;&amp;x[1]==0&amp;&amp;y[1]==0&amp;&amp;x[2]==0&amp;&amp;y[2]==0) break;</span><br><span class="line"></span><br><span class="line">        area = (x[1]-x[0])*(y[2]-y[0])-(x[2]-x[0])*(y[1]-y[0]);</span><br><span class="line"></span><br><span class="line">        area = My_Abs(area);</span><br><span class="line"></span><br><span class="line">        b=0;</span><br><span class="line"></span><br><span class="line">        b=Gcd(My_Abs(x[1]-x[0]), My_Abs(y[1]-y[0])) + Gcd(My_Abs(x[2]-x[0]), My_Abs(y[2]-y[0])) + Gcd(My_Abs(x[1]-x[2]), My_Abs(y[1]-y[2]));</span><br><span class="line"></span><br><span class="line">        printf(&quot;%lld\n&quot;, (area-b+2)/2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求多边形面积和重心"><a href="#求多边形面积和重心" class="headerlink" title="求多边形面积和重心"></a><strong>求多边形面积和重心</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">int x[1000003], y[1000003];</span><br><span class="line"></span><br><span class="line">double A, tx, ty, tmp;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int cases, n, i;</span><br><span class="line"></span><br><span class="line">    scanf (&quot;%d&quot;, &amp;cases);</span><br><span class="line"></span><br><span class="line">    while (cases --)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        scanf (&quot;%d&quot;, &amp;n);</span><br><span class="line"></span><br><span class="line">        A = 0.0;</span><br><span class="line"></span><br><span class="line">        x[0] = y[0] = 0;</span><br><span class="line"></span><br><span class="line">        for (i = 1; i &lt;= n; i ++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            scanf (&quot;%d %d&quot;, &amp;x[i], &amp;y[i]);</span><br><span class="line"></span><br><span class="line">            A += (x[i-1]*y[i] - x[i]*y[i-1]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        A += x[n]*y[1] - x[1]*y[n];</span><br><span class="line"></span><br><span class="line">        A = A / 2.0;</span><br><span class="line"></span><br><span class="line">        tx = ty = 0.0;</span><br><span class="line"></span><br><span class="line">        for (i = 1; i &lt; n; i ++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tmp = x[i]*y[i+1] - x[i+1]*y[i];</span><br><span class="line"></span><br><span class="line">            tx += (x[i]+x[i+1]) * tmp;</span><br><span class="line"></span><br><span class="line">            ty += (y[i]+y[i+1]) * tmp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp = x[n]*y[1] - x[1]*y[n];</span><br><span class="line"></span><br><span class="line">        tx += (x[n]+x[1])*tmp;</span><br><span class="line"></span><br><span class="line">        ty += (y[n]+y[1])*tmp;</span><br><span class="line"></span><br><span class="line">        printf (&quot;%.2lf %.2lf\n&quot;, tx/(6.0*A), ty/(6.0*A));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断一个简单多边形是否有核"><a href="#判断一个简单多边形是否有核" class="headerlink" title="判断一个简单多边形是否有核"></a><strong>判断一个简单多边形是否有核</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">const int INF = (1&lt;&lt;30);</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int x, y;</span><br><span class="line"></span><br><span class="line">&#125;pt[150];</span><br><span class="line"></span><br><span class="line">typedef struct Point Point;</span><br><span class="line"></span><br><span class="line">bool turn_right[150];</span><br><span class="line"></span><br><span class="line">int det(Point s1, Point t1, Point s2, Point t2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int d1x = t1.x-s1.x;</span><br><span class="line"></span><br><span class="line">    int d1y = t1.y-s1.y;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    int d2x = t2.x-s2.x;</span><br><span class="line"></span><br><span class="line">    int d2y = t2.y-s2.y;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    return d1x*d2y - d2x*d1y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Swap(int &amp;a, int &amp;b)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (a&gt;b)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int t=a;</span><br><span class="line"></span><br><span class="line">        a=b;</span><br><span class="line"></span><br><span class="line">        b=t;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n, i, cross, maxx, minx, maxy, miny, maxn, minn, countn=0;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n)==1&amp;&amp;n)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        maxx=maxy=-INF;</span><br><span class="line"></span><br><span class="line">        minx=miny=INF;</span><br><span class="line"></span><br><span class="line">        **//点按顺时针给出**</span><br><span class="line"></span><br><span class="line">        for (i=1; i&lt;=n; i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            scanf(&quot;%d %d&quot;, &amp;pt[i].x, &amp;pt[i].y);</span><br><span class="line"></span><br><span class="line">            if (maxx&lt;pt[i].x) maxx=pt[i].x;</span><br><span class="line"></span><br><span class="line">            if (maxy&lt;pt[i].y) maxy=pt[i].y;</span><br><span class="line"></span><br><span class="line">            if (minx&gt;pt[i].x) minx=pt[i].x;</span><br><span class="line"></span><br><span class="line">            if (miny&gt;pt[i].y) miny=pt[i].y;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pt[n+1]=pt[1];</span><br><span class="line"></span><br><span class="line">        pt[n+2]=pt[2];</span><br><span class="line"></span><br><span class="line">        pt[n+3]=pt[3];</span><br><span class="line"></span><br><span class="line">        pt[n+4]=pt[4];</span><br><span class="line"></span><br><span class="line">        **//求每条线段的转向**</span><br><span class="line"></span><br><span class="line">        for (i=1; i&lt;=n+1; i ++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            cross = det(pt[i],pt[i+1], pt[i+1], pt[i+2]);</span><br><span class="line"></span><br><span class="line">            if (cross&lt;0)</span><br><span class="line"></span><br><span class="line">                turn_right[i+1]=true;</span><br><span class="line"></span><br><span class="line">            else turn_right[i+1]=false;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        **//两条边连续右转的为凸处，只有此时才可影响“核”肯恩存在的范围**</span><br><span class="line"></span><br><span class="line">        for (i=2; i&lt;= n+1; i++)</span><br><span class="line"></span><br><span class="line">            if (turn_right[i] &amp;&amp; turn_right[i+1])</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                if (pt[i].x==pt[i+1].x)</span><br><span class="line"></span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    minn=pt[i].y;</span><br><span class="line"></span><br><span class="line">                    maxn=pt[i+1].y;</span><br><span class="line"></span><br><span class="line">                    Swap(minn, maxn);</span><br><span class="line"></span><br><span class="line">                    if (minn&gt;miny) miny=minn;</span><br><span class="line"></span><br><span class="line">                    if (maxn&lt;maxy) maxy=maxn;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                else</span><br><span class="line"></span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    minn=pt[i].x;</span><br><span class="line"></span><br><span class="line">                    maxn=pt[i+1].x;</span><br><span class="line"></span><br><span class="line">                    Swap(minn, maxn);</span><br><span class="line"></span><br><span class="line">                    if (minn&gt;minx) minx=minn;</span><br><span class="line"></span><br><span class="line">                    if (maxn&lt;maxx) maxx=maxn;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        if (minx&lt;=maxx &amp;&amp; miny&lt;=maxy)</span><br><span class="line"></span><br><span class="line">            printf(&quot;Floor #%d\nSurveillance is possible.\n\n&quot;, ++countn);</span><br><span class="line"></span><br><span class="line">        else printf(&quot;Floor #%d\nSurveillance is impossible.\n\n&quot;, ++countn);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a><strong>模拟退火</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#define Lim 0.999999</span><br><span class="line"></span><br><span class="line">\#define EPS 1e-2</span><br><span class="line"></span><br><span class="line">\#define PI acos(-1.0)</span><br><span class="line"></span><br><span class="line">double Temp, maxx, minx, maxy, miny, lx, ly, dif;</span><br><span class="line"></span><br><span class="line">int nt, ns, nc;</span><br><span class="line"></span><br><span class="line">struct Target</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x, y;</span><br><span class="line"></span><br><span class="line">&#125;T[105];</span><br><span class="line"></span><br><span class="line">struct Solution</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x, y;</span><br><span class="line"></span><br><span class="line">    double f;</span><br><span class="line"></span><br><span class="line">&#125;S[25], P, A;</span><br><span class="line"></span><br><span class="line">double Dis(double x1, double y1, double x2, double y2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Seed(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;ns;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        S[i].x=minx+((double)(rand()%1000+1)/1000.0)*lx;</span><br><span class="line"></span><br><span class="line">        S[i].y=miny+((double)(rand()%1000+1)/1000.0)*ly;</span><br><span class="line"></span><br><span class="line">        S[i].f=0.0;</span><br><span class="line"></span><br><span class="line">        for (j=0;j&lt;nt;j++)</span><br><span class="line"></span><br><span class="line">            S[i].f=S[i].f+Dis(S[i].x,S[i].y, T[j].x, T[j].y);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Trans(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i, j, k;</span><br><span class="line"></span><br><span class="line">    double theta;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;ns;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        P=S[i];</span><br><span class="line"></span><br><span class="line">        for (j=0;j&lt;nc;j++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            theta=(((double)(rand()%1000+1))/1000.0)*2.0*PI;</span><br><span class="line"></span><br><span class="line">            A.x=P.x+Temp*cos(theta);</span><br><span class="line"></span><br><span class="line">            A.y=P.y+Temp*sin(theta);</span><br><span class="line"></span><br><span class="line">            if (A.x&lt;minx||A.x&gt;maxx||A.y&lt;miny||A.y&gt;maxy)</span><br><span class="line"></span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            A.f=0.0;</span><br><span class="line"></span><br><span class="line">            for (k=0;k&lt;nt;k++)</span><br><span class="line"></span><br><span class="line">                A.f=A.f+Dis(A.x,A.y,T[k].x,T[k].y);</span><br><span class="line"></span><br><span class="line">            dif=A.f-S[i].f;</span><br><span class="line"></span><br><span class="line">            if (dif&lt;0.0)S[i]=A;</span><br><span class="line"></span><br><span class="line">            else</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                dif=exp(-dif/Temp);</span><br><span class="line"></span><br><span class="line">                if (dif&gt;Lim) S[i]=A;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i, k;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d&quot;,&amp;nt)==1&amp;&amp;nt)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        maxx=maxy=0;</span><br><span class="line"></span><br><span class="line">        minx=miny=(1&lt;&lt;20);</span><br><span class="line"></span><br><span class="line">        for (i=0;i&lt;nt;i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            scanf(&quot;%lf %lf&quot;,&amp;T[i].x,&amp;T[i].y);</span><br><span class="line"></span><br><span class="line">            if (maxx&lt;T[i].x)maxx=T[i].x;</span><br><span class="line"></span><br><span class="line">            if (minx&gt;T[i].x)minx=T[i].x;</span><br><span class="line"></span><br><span class="line">            if (maxy&lt;T[i].y)maxy=T[i].y;</span><br><span class="line"></span><br><span class="line">            if (miny&gt;T[i].y)miny=T[i].y;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lx=maxx-minx;</span><br><span class="line"></span><br><span class="line">        ly=maxy-miny;</span><br><span class="line"></span><br><span class="line">        Temp=sqrt(lx*lx+ly*ly)/3.0;</span><br><span class="line"></span><br><span class="line">        ns=5, nc=10;</span><br><span class="line"></span><br><span class="line">        Seed();</span><br><span class="line"></span><br><span class="line">        while (Temp&gt;EPS)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            Trans();</span><br><span class="line"></span><br><span class="line">            Temp=Temp*0.40;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        k=0;</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;ns;i++)</span><br><span class="line"></span><br><span class="line">            if (S[k].f&gt;S[i].f)</span><br><span class="line"></span><br><span class="line">                k=i;</span><br><span class="line"></span><br><span class="line">        printf (&quot;%.0lf\n&quot;, S[k].f);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六边形坐标系"><a href="#六边形坐标系" class="headerlink" title="六边形坐标系"></a><strong>六边形坐标系</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br></pre></td><td class="code"><pre><span class="line">**//第一种六边形坐标系**</span><br><span class="line"></span><br><span class="line">\#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">double Dis(double x1, double y1, double x2, double y2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    double dx=x1-x2;</span><br><span class="line"></span><br><span class="line">​    double dy=y1-y2;</span><br><span class="line"></span><br><span class="line">​    return sqrt(dx*dx+dy*dy);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Get_KL(double L, double x, double y, int &amp;k, int &amp;l, double &amp;cd)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    k=floor((2.0*x)/(3.0*L));</span><br><span class="line"></span><br><span class="line">​    l=floor((2.0*y)/(sqrt(3.0)*L));</span><br><span class="line"></span><br><span class="line">​    double d1, d2, x1, y1, x2, y2;</span><br><span class="line"></span><br><span class="line">​    if ((k+l)&amp;1)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        x1=k*L*1.5;</span><br><span class="line"></span><br><span class="line">​        y1=(l+1.0)*L*sqrt(3.0)*0.5;</span><br><span class="line"></span><br><span class="line">​        x2=(k+1.0)*L*1.5;</span><br><span class="line"></span><br><span class="line">​        y2=l*L*sqrt(3.0)*0.5;</span><br><span class="line"></span><br><span class="line">​        d1=Dis(x1,y1, x,y);</span><br><span class="line"></span><br><span class="line">​        d2=Dis(x2,y2, x,y);</span><br><span class="line"></span><br><span class="line">​        if (d1&gt;d2)</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​            k++;</span><br><span class="line"></span><br><span class="line">​            cd=d2;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        else</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​            l++;</span><br><span class="line"></span><br><span class="line">​            cd=d1;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    else</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        x1=k*L*1.5;</span><br><span class="line"></span><br><span class="line">​        y1=l*L*sqrt(3.0)*0.5;</span><br><span class="line"></span><br><span class="line">​        x2=(k+1.0)*L*1.5;</span><br><span class="line"></span><br><span class="line">​        y2=(l+1.0)*L*sqrt(3.0)*0.5;</span><br><span class="line"></span><br><span class="line">​        d1=Dis(x1,y1, x,y);</span><br><span class="line"></span><br><span class="line">​        d2=Dis(x2,y2, x,y);</span><br><span class="line"></span><br><span class="line">​        if (d1&gt;d2)</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​            k++,l++;</span><br><span class="line"></span><br><span class="line">​            cd=d2;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        else cd=d1;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int My_Abs(int x)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    if (x&lt;0) return -x;</span><br><span class="line"></span><br><span class="line">​    return x;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    double L, x1, y1, x2, y2, ans, cd1, cd2;</span><br><span class="line"></span><br><span class="line">​    int k1, l1, k2, l2;</span><br><span class="line"></span><br><span class="line">​    while (scanf(&quot;%lf %lf %lf %lf %lf&quot;,&amp;L,&amp;x1,&amp;y1,&amp;x2,&amp;y2)==5)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        if (L==0.0&amp;&amp;x1==0.0&amp;&amp;y1==0.0&amp;&amp;x2==0.0&amp;&amp;y2==0.0) break;</span><br><span class="line"></span><br><span class="line">​        Get_KL(L, x1, y1, k1, l1, cd1);</span><br><span class="line"></span><br><span class="line">​        Get_KL(L, x2, y2, k2, l2, cd2);</span><br><span class="line"></span><br><span class="line">​        if (k1==k2&amp;&amp;l1==l2) printf(&quot;%.3lf\n&quot;, Dis(x1,y1, x2,y2));</span><br><span class="line"></span><br><span class="line">​        else</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​            ans=cd1+cd2;</span><br><span class="line"></span><br><span class="line">​            if (My_Abs(k1-k2) &gt; My_Abs(l1-l2))</span><br><span class="line"></span><br><span class="line">​                ans=ans+sqrt(3.0)*L*My_Abs(k1-k2);</span><br><span class="line"></span><br><span class="line">​            else ans=ans+sqrt(3.0)*L*My_Abs(k1-k2)+sqrt(3.0)*L*(double)(My_Abs(l1-l2)-My_Abs(k1-k2))/2.0;</span><br><span class="line"></span><br><span class="line">​            printf(&quot;%.3lf\n&quot;, ans);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//第二种六边形坐标系**</span><br><span class="line"></span><br><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">struct A</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    int x, y, num;</span><br><span class="line"></span><br><span class="line">&#125;a[10001];</span><br><span class="line"></span><br><span class="line">const int dec[6][2] = &#123;&#123;-1,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;1,-1&#125;,&#123;1,0&#125;,&#123;0,1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">bool adj(int x1, int y1, int x2, int y2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    if (x1 == x2 &amp;&amp; abs(y1-y2) == 1) return true;</span><br><span class="line"></span><br><span class="line">​    if (y1 == y2 &amp;&amp; abs(x1-x2) == 1) return true;</span><br><span class="line"></span><br><span class="line">​    if (x1 == x2 + 1 &amp;&amp; y1 == y2 -1) return true;</span><br><span class="line"></span><br><span class="line">​    if (x1 == x2 - 1 &amp;&amp; y1 == y2 +1) return true;</span><br><span class="line"></span><br><span class="line">​    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool flag[10001];</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    int i, j, k, x, u, v, cut, minn, cnt[6];</span><br><span class="line"></span><br><span class="line">​    memset(cnt, 0, sizeof(cnt));</span><br><span class="line"></span><br><span class="line">​    a[1].num = 1, cnt[1] = 1;</span><br><span class="line"></span><br><span class="line">​    a[1].x = a[1].y = 0;</span><br><span class="line"></span><br><span class="line">​    for (i = 2; i &lt; 10001; i ++)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        k = (int)((3.0+sqrt(12.0*i - 3.0))/6.0+0.0000001);</span><br><span class="line"></span><br><span class="line">​        if (i == 3*(k-1)*(k-1)+3*(k-1)+1) k  --;</span><br><span class="line"></span><br><span class="line">​        j = i - (3*(k-1)*(k-1)+3*(k-1)+1);</span><br><span class="line"></span><br><span class="line">​        **// 当前的六边形是第k层的第j个六边形**</span><br><span class="line"></span><br><span class="line">​        if (j == 1) a[i].x = a[i-1].x, a[i].y = a[i-1].y + 1;</span><br><span class="line"></span><br><span class="line">​        else</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​            x = (j-1) / k;</span><br><span class="line"></span><br><span class="line">​            a[i].x = a[i-1].x + dec[x][0], a[i].y = a[i-1].y + dec[x][1];</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        memset(flag, false, sizeof(flag));</span><br><span class="line"></span><br><span class="line">​        x = 12*k-6, cut = 0;</span><br><span class="line"></span><br><span class="line">​        for (u = i-1, v = 0; u&gt;=1&amp;&amp;v&lt;x; u --, v ++)</span><br><span class="line"></span><br><span class="line">​            if (adj(a[u].x, a[u].y, a[i].x, a[i].y))</span><br><span class="line"></span><br><span class="line">​            &#123;</span><br><span class="line"></span><br><span class="line">​                cut ++;</span><br><span class="line"></span><br><span class="line">​                flag[a[u].num] = true;</span><br><span class="line"></span><br><span class="line">​                if (cut == 3) break;</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​        minn = 10001;</span><br><span class="line"></span><br><span class="line">​        for (u = 1; u &lt; 6; u ++)</span><br><span class="line"></span><br><span class="line">​            if ((!flag[u])&amp;&amp;minn &gt; cnt[u])</span><br><span class="line"></span><br><span class="line">​            &#123;</span><br><span class="line"></span><br><span class="line">​                minn = cnt[u];</span><br><span class="line"></span><br><span class="line">​                x = u;</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​        a[i].num = x;</span><br><span class="line"></span><br><span class="line">​        cnt[x] ++;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    scanf (&quot;%d&quot;, &amp;x);</span><br><span class="line"></span><br><span class="line">​    while (x --)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        scanf (&quot;%d&quot;, &amp;i);</span><br><span class="line"></span><br><span class="line">​        printf (&quot;%d\n&quot;, a[i].num);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用一个给定半径的圆覆盖最多的点"><a href="#用一个给定半径的圆覆盖最多的点" class="headerlink" title="用一个给定半径的圆覆盖最多的点"></a><strong>用一个给定半径的圆覆盖最多的点</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">**//同半径圆的圆弧表示**</span><br><span class="line"></span><br><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#define PI acos(-1.0)</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x, y;</span><br><span class="line"></span><br><span class="line">&#125;pt[2005];</span><br><span class="line"></span><br><span class="line">double dis[2005][2005];</span><br><span class="line"></span><br><span class="line">struct List</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double a;</span><br><span class="line"></span><br><span class="line">    bool flag;</span><br><span class="line"></span><br><span class="line">    int id;</span><br><span class="line"></span><br><span class="line">&#125;list[8005];</span><br><span class="line"></span><br><span class="line">int cnt;</span><br><span class="line"></span><br><span class="line">double Dis(int i, int j)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double dx=pt[i].x-pt[j].x;</span><br><span class="line"></span><br><span class="line">    double dy=pt[i].y-pt[j].y;</span><br><span class="line"></span><br><span class="line">    return sqrt(dx*dx+dy*dy);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Cmp(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct List*a1=(struct List*)p1;</span><br><span class="line"></span><br><span class="line">    struct List*a2=(struct List*)p2;</span><br><span class="line"></span><br><span class="line">    if (a1-&gt;a&lt;a2-&gt;a)return -1;</span><br><span class="line"></span><br><span class="line">    else if (a1-&gt;a==a2-&gt;a) return a1-&gt;id-a2-&gt;id;</span><br><span class="line"></span><br><span class="line">    else return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n, i, j, ans, num;</span><br><span class="line"></span><br><span class="line">    double r, theta, delta, a1, a2;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d %lf&quot;,&amp;n,&amp;r)==2)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (n==0&amp;&amp;r==0.0) break;</span><br><span class="line"></span><br><span class="line">        r=r+0.001;</span><br><span class="line"></span><br><span class="line">        r=r*2.0;</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;=n;i++)</span><br><span class="line"></span><br><span class="line">            scanf(&quot;%lf %lf&quot;, &amp;pt[i].x, &amp;pt[i].y);</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">            for (j=i+1;j&lt;=n;j++)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                dis[i][j]=Dis(i, j);</span><br><span class="line"></span><br><span class="line">                dis[j][i]=dis[i][j];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ans=0;</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;=n;i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            cnt=0;</span><br><span class="line"></span><br><span class="line">            for (j=1;j&lt;=n;j++)</span><br><span class="line"></span><br><span class="line">                if ((j!=i)&amp;&amp;(dis[i][j]&lt;=r))</span><br><span class="line"></span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    theta=atan2(pt[j].y-pt[i].y, pt[j].x-pt[i].x);</span><br><span class="line"></span><br><span class="line">                    if (theta&lt;0.0) theta=theta+2.0*PI;</span><br><span class="line"></span><br><span class="line">                    delta=acos(dis[i][j]/r);</span><br><span class="line"></span><br><span class="line">                    a1=theta-delta;</span><br><span class="line"></span><br><span class="line">                    a2=theta+delta;</span><br><span class="line"></span><br><span class="line">                    list[++cnt].a=a1;</span><br><span class="line"></span><br><span class="line">                    list[cnt].flag=true;</span><br><span class="line"></span><br><span class="line">                    list[cnt].id=cnt;</span><br><span class="line"></span><br><span class="line">                    list[++cnt].a=a2;</span><br><span class="line"></span><br><span class="line">                    list[cnt].flag=false;</span><br><span class="line"></span><br><span class="line">                    list[cnt].id=cnt;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            qsort(list+1,cnt,sizeof(struct List),Cmp);</span><br><span class="line"></span><br><span class="line">            num=0;</span><br><span class="line"></span><br><span class="line">            for (j=1;j&lt;=cnt;j++)</span><br><span class="line"></span><br><span class="line">                if (list[j].flag)</span><br><span class="line"></span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    num++;</span><br><span class="line"></span><br><span class="line">                    if (num&gt;ans) ans=num;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                else num--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;It is possible to cover %d points.\n&quot;, ans+1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不等大的圆的圆弧表示"><a href="#不等大的圆的圆弧表示" class="headerlink" title="不等大的圆的圆弧表示"></a><strong>不等大的圆的圆弧表示</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">intersection_circle_circle(circle[i].center, circle[i].r, circle[j].center, circle[j].r, p1, p2);</span><br><span class="line"></span><br><span class="line">                    a1= atan2(p1.y-circle[j].center.y, p1.x-circle[j].center.x);</span><br><span class="line"></span><br><span class="line">                    if (a1&lt;0.0) a1=a1+2.0*PI;</span><br><span class="line"></span><br><span class="line">                    a2= atan2(p2.y-circle[j].center.y, p2.x-circle[j].center.x);</span><br><span class="line"></span><br><span class="line">                    if (a2&lt;0.0) a2=a2+2.0*PI;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">                    if (a1&gt;a2)</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        tmp=a1;</span><br><span class="line"></span><br><span class="line">                        a1=a2;</span><br><span class="line"></span><br><span class="line">                        a2=tmp;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    mid=(a1+a2)/2.0;</span><br><span class="line"></span><br><span class="line">                    xtest = circle[j].center.x +circle[j].r*cos(mid);</span><br><span class="line"></span><br><span class="line">                    ytest = circle[j].center.y +circle[j].r*sin(mid);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">                    if (!point_in_circle(xtest, ytest, i))</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        circle[j].cnt++;</span><br><span class="line"></span><br><span class="line">                        circle[j].line[circle[j].cnt].s=0;</span><br><span class="line"></span><br><span class="line">                        circle[j].line[circle[j].cnt].t=a1;</span><br><span class="line"></span><br><span class="line">                        circle[j].cnt++;</span><br><span class="line"></span><br><span class="line">                        circle[j].line[circle[j].cnt].s=a2;</span><br><span class="line"></span><br><span class="line">                        circle[j].line[circle[j].cnt].t=2.0*PI;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    else</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        circle[j].cnt++;</span><br><span class="line"></span><br><span class="line">                        circle[j].line[circle[j].cnt].s=a1;</span><br><span class="line"></span><br><span class="line">                        circle[j].line[circle[j].cnt].t=a2;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩形面积并"><a href="#矩形面积并" class="headerlink" title="矩形面积并"></a><strong>矩形面积并</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line">\#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int l, r, cnt;</span><br><span class="line"></span><br><span class="line">    double cover;</span><br><span class="line"></span><br><span class="line">&#125;node[80005];</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x;</span><br><span class="line"></span><br><span class="line">    double y1, y2;</span><br><span class="line"></span><br><span class="line">    int id_y1, id_y2, id_x;</span><br><span class="line"></span><br><span class="line">    bool flag;</span><br><span class="line"></span><br><span class="line">&#125;pt[20005];</span><br><span class="line"></span><br><span class="line">double y[20005];</span><br><span class="line"></span><br><span class="line">int total, cnty;</span><br><span class="line"></span><br><span class="line">int cmp1(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double*a1=(double*)p1;</span><br><span class="line"></span><br><span class="line">    double*a2=(double*)p2;</span><br><span class="line"></span><br><span class="line">    if (*a1&lt;*a2) return -1;</span><br><span class="line"></span><br><span class="line">    else if (*a1==*a2) return 0;</span><br><span class="line"></span><br><span class="line">    else return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cmp2(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Point*a1=(struct Point*)p1;</span><br><span class="line"></span><br><span class="line">    struct Point*a2=(struct Point*)p2;</span><br><span class="line"></span><br><span class="line">    if (a1-&gt;x&lt;a2-&gt;x) return -1;</span><br><span class="line"></span><br><span class="line">    else if (a1-&gt;x==a2-&gt;x)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (a1-&gt;id_x&lt;a2-&gt;id_x) return -1;</span><br><span class="line"></span><br><span class="line">        else if (a1-&gt;id_x==a2-&gt;id_x) return 0;</span><br><span class="line"></span><br><span class="line">        else return 1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int find(double target)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int head=1, tail=cnty, mid;</span><br><span class="line"></span><br><span class="line">    while (head&lt;=tail)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        mid=(head+tail)&gt;&gt;1;</span><br><span class="line"></span><br><span class="line">        if (y[mid]==target) return mid;</span><br><span class="line"></span><br><span class="line">        else if (y[mid]&lt;target) head=mid+1;</span><br><span class="line"></span><br><span class="line">        else tail=mid-1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Build(int l, int r, int s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    node[s].l=l;</span><br><span class="line"></span><br><span class="line">    node[s].r=r;</span><br><span class="line"></span><br><span class="line">    node[s].cnt=0;</span><br><span class="line"></span><br><span class="line">    node[s].cover=0.0;</span><br><span class="line"></span><br><span class="line">    if (l+1&lt;r)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int mid=(l+r)&gt;&gt;1;</span><br><span class="line"></span><br><span class="line">        Build(l,mid,s&lt;&lt;1);</span><br><span class="line"></span><br><span class="line">        Build(mid,r,(s&lt;&lt;1)+1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Update(int s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (node[s].cnt&gt;0)</span><br><span class="line"></span><br><span class="line">        node[s].cover=y[node[s].r]-y[node[s].l];</span><br><span class="line"></span><br><span class="line">    else if(node[s].l+1==node[s].r)</span><br><span class="line"></span><br><span class="line">        node[s].cover=0.0;</span><br><span class="line"></span><br><span class="line">    else node[s].cover=node[s&lt;&lt;1].cover+node[(s&lt;&lt;1)+1].cover;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Insert(int l, int r, int s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (l&lt;=node[s].l&amp;&amp;node[s].r&lt;=r)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        node[s].cnt++;</span><br><span class="line"></span><br><span class="line">        Update(s);</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (node[s].l+1&lt;node[s].r)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int mid=(node[s].l+node[s].r)&gt;&gt;1;</span><br><span class="line"></span><br><span class="line">        if (l&lt;mid) Insert(l,r,s&lt;&lt;1);</span><br><span class="line"></span><br><span class="line">        if (r&gt;mid) Insert(l,r,(s&lt;&lt;1)+1);</span><br><span class="line"></span><br><span class="line">        Update(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Delete(int l, int r, int s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (l&lt;=node[s].l&amp;&amp;node[s].r&lt;=r)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (node[s].cnt&gt;0)</span><br><span class="line"></span><br><span class="line">            node[s].cnt--;</span><br><span class="line"></span><br><span class="line">        Update(s);</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (node[s].l+1&lt;node[s].r)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int mid=(node[s].l+node[s].r)&gt;&gt;1;</span><br><span class="line"></span><br><span class="line">        if (l&lt;mid) Delete(l,r,s&lt;&lt;1);</span><br><span class="line"></span><br><span class="line">        if (r&gt;mid) Delete(l,r,(s&lt;&lt;1)+1);</span><br><span class="line"></span><br><span class="line">        Update(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n, i, j, countn=0;</span><br><span class="line"></span><br><span class="line">    double ans;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n)==1 &amp;&amp; n)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        cnty=total=0;</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;=n;i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            total++;</span><br><span class="line"></span><br><span class="line">            scanf(&quot;%lf %lf&quot;, &amp;pt[total].x, &amp;pt[total].y1);</span><br><span class="line"></span><br><span class="line">            pt[total].flag=true;</span><br><span class="line"></span><br><span class="line">            pt[total].id_x=total;</span><br><span class="line"></span><br><span class="line">            y[++cnty]=pt[total].y1;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            total++;</span><br><span class="line"></span><br><span class="line">            scanf(&quot;%lf %lf&quot;, &amp;pt[total].x, &amp;pt[total].y2);</span><br><span class="line"></span><br><span class="line">            pt[total].flag=false;</span><br><span class="line"></span><br><span class="line">            pt[total].id_x=total;</span><br><span class="line"></span><br><span class="line">            y[++cnty]=pt[total].y2;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            pt[total].y1=pt[total-1].y1;</span><br><span class="line"></span><br><span class="line">            pt[total-1].y2=pt[total].y2;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qsort(y+1, cnty, sizeof(double), cmp1);</span><br><span class="line"></span><br><span class="line">        j=cnty;</span><br><span class="line"></span><br><span class="line">        cnty=1;</span><br><span class="line"></span><br><span class="line">        for (i=2;i&lt;=j;i++)</span><br><span class="line"></span><br><span class="line">            if (y[i]!=y[i-1])</span><br><span class="line"></span><br><span class="line">                y[++cnty]=y[i];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;=total;i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            pt[i].id_y1=find(pt[i].y1);</span><br><span class="line"></span><br><span class="line">            pt[i].id_y2=find(pt[i].y2);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qsort(pt+1, total, sizeof(struct Point), cmp2);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        ans=0.0;</span><br><span class="line"></span><br><span class="line">        Build(1,cnty,1);</span><br><span class="line"></span><br><span class="line">        Insert(pt[1].id_y1, pt[1].id_y2, 1);</span><br><span class="line"></span><br><span class="line">        for (i=2;i&lt;=total;i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ans=ans+(pt[i].x-pt[i-1].x)*node[1].cover;</span><br><span class="line"></span><br><span class="line">            if (pt[i].flag) Insert(pt[i].id_y1, pt[i].id_y2, 1);</span><br><span class="line"></span><br><span class="line">            else Delete(pt[i].id_y1, pt[i].id_y2, 1);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;%.0lf\n&quot;, ans+1e-10);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩形的周长并"><a href="#矩形的周长并" class="headerlink" title="矩形的周长并"></a><strong>矩形的周长并</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int x, y;</span><br><span class="line"></span><br><span class="line">&#125;plist[10001];</span><br><span class="line"></span><br><span class="line">struct Line</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int x, b, e, flag;</span><br><span class="line"></span><br><span class="line">&#125;llist[10001];</span><br><span class="line"></span><br><span class="line">struct Item</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int y, id, idx;</span><br><span class="line"></span><br><span class="line">&#125;ilist[10001];</span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int l, r, c, m, line;</span><br><span class="line"></span><br><span class="line">    bool lf, rf;</span><br><span class="line"></span><br><span class="line">&#125;node[40005];</span><br><span class="line"></span><br><span class="line">int ys[10001];</span><br><span class="line"></span><br><span class="line">int cmp1(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Item *a1 = (struct Item*)p1;</span><br><span class="line"></span><br><span class="line">    struct Item *a2 = (struct Item*)p2;</span><br><span class="line"></span><br><span class="line">    return a1-&gt;y - a2-&gt;y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cmp2(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Item *a1 = (struct Item*)p1;</span><br><span class="line"></span><br><span class="line">    struct Item *a2 = (struct Item*)p2;</span><br><span class="line"></span><br><span class="line">    return a1-&gt;id - a2-&gt;id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cmp3(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Line *a1 = (struct Line*)p1;</span><br><span class="line"></span><br><span class="line">    struct Line *a2 = (struct Line*)p2;</span><br><span class="line"></span><br><span class="line">    return a1-&gt;x - a2-&gt;x;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getm(int s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (node[s].c &gt; 0)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        node[s].m = ys[node[s].r-1] - ys[node[s].l-1];</span><br><span class="line"></span><br><span class="line">        node[s].line = 1;</span><br><span class="line"></span><br><span class="line">        node[s].rf = node[s].lf = true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else if (node[s].r - node[s].l &lt;= 1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        node[s].m = node[s].line = 0;</span><br><span class="line"></span><br><span class="line">        node[s].rf = node[s].lf = false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        node[s].m = node[s&lt;&lt;1].m + node[(s&lt;&lt;1)+1].m;</span><br><span class="line"></span><br><span class="line">        node[s].line = node[s&lt;&lt;1].line + node[(s&lt;&lt;1)+1].line;</span><br><span class="line"></span><br><span class="line">        if (node[s&lt;&lt;1].rf &amp;&amp; node[(s&lt;&lt;1)+1].lf) node[s].line --;</span><br><span class="line"></span><br><span class="line">        node[s].lf = node[s&lt;&lt;1].lf;</span><br><span class="line"></span><br><span class="line">        node[s].rf = node[(s&lt;&lt;1)+1].rf;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void build(int l, int r, int s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    node[s].l = l;</span><br><span class="line"></span><br><span class="line">    node[s].r = r;</span><br><span class="line"></span><br><span class="line">    node[s].c = node[s].m = node[s].line;</span><br><span class="line"></span><br><span class="line">    if (node[s].r - node[s].l &gt; 1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int mid = (node[s].l + node[s].r)&gt;&gt;1;</span><br><span class="line"></span><br><span class="line">        build(l,mid,s&lt;&lt;1);</span><br><span class="line"></span><br><span class="line">        build(mid,r,(s&lt;&lt;1)+1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(int l, int r, int s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (l &lt;= node[s].l &amp;&amp; node[s].r &lt;= r)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        node[s].c ++;</span><br><span class="line"></span><br><span class="line">        getm(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (node[s].r - node[s].l &gt; 1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int mid = (node[s].l + node[s].r)&gt;&gt;1;</span><br><span class="line"></span><br><span class="line">        if (l &lt; mid) insert(l, r, s&lt;&lt;1);</span><br><span class="line"></span><br><span class="line">        if (mid &lt; r) insert(l, r, (s&lt;&lt;1)+1);</span><br><span class="line"></span><br><span class="line">        getm(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void delet(int l, int r, int s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (l &lt;= node[s].l &amp;&amp; node[s].r &lt;= r)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        node[s].c --;</span><br><span class="line"></span><br><span class="line">        getm(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (node[s].r - node[s].l &gt; 1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int mid = (node[s].l + node[s].r)&gt;&gt;1;</span><br><span class="line"></span><br><span class="line">        if (l &lt; mid) delet(l, r, s&lt;&lt;1);</span><br><span class="line"></span><br><span class="line">        if (mid &lt; r) delet(l, r, (s&lt;&lt;1)+1);</span><br><span class="line"></span><br><span class="line">        getm(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n, i, j, l, r, x1, y1, x2, y2, tot, p, ans;</span><br><span class="line"></span><br><span class="line">    while (scanf (&quot;%d&quot;, &amp;n) == 1 &amp;&amp; n)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; n; i ++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            scanf (&quot;%d %d %d %d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line"></span><br><span class="line">            l = 2*i;</span><br><span class="line"></span><br><span class="line">            r = l + 1;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            plist[l].x = x1;</span><br><span class="line"></span><br><span class="line">            plist[l].y = y1;</span><br><span class="line"></span><br><span class="line">            plist[r].x = x2;</span><br><span class="line"></span><br><span class="line">            plist[r].y = y2;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            ilist[l].y = y1;</span><br><span class="line"></span><br><span class="line">            ilist[l].id = l;</span><br><span class="line"></span><br><span class="line">            ilist[r].y = y2;</span><br><span class="line"></span><br><span class="line">            ilist[r].id = r;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tot = 2*n;</span><br><span class="line"></span><br><span class="line">        qsort(ilist, tot, sizeof(struct Item), cmp1);</span><br><span class="line"></span><br><span class="line">        ys[0] = ilist[0].y;</span><br><span class="line"></span><br><span class="line">        ilist[0].idx = 0;</span><br><span class="line"></span><br><span class="line">        j = 0;</span><br><span class="line"></span><br><span class="line">        for (i = 1; i &lt; tot; i ++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (ilist[i].y != ilist[i-1].y)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                j ++;</span><br><span class="line"></span><br><span class="line">                ys[j] = ilist[i].y;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ilist[i].idx = j;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = j + 1;</span><br><span class="line"></span><br><span class="line">        qsort(ilist, tot, sizeof(struct Item), cmp2);</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; n; i ++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            l = 2*i;</span><br><span class="line"></span><br><span class="line">            r = l + 1;</span><br><span class="line"></span><br><span class="line">            llist[l].x = plist[l].x;</span><br><span class="line"></span><br><span class="line">            llist[l].b = ilist[l].idx;</span><br><span class="line"></span><br><span class="line">            llist[l].e = ilist[r].idx;</span><br><span class="line"></span><br><span class="line">            llist[l].flag = 1;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            llist[r].x = plist[r].x;</span><br><span class="line"></span><br><span class="line">            llist[r].b = ilist[l].idx;</span><br><span class="line"></span><br><span class="line">            llist[r].e = ilist[r].idx;</span><br><span class="line"></span><br><span class="line">            llist[r].flag = 0;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qsort(llist, tot, sizeof(struct Line), cmp3);</span><br><span class="line"></span><br><span class="line">        build(1,p,1);</span><br><span class="line"></span><br><span class="line">        insert(llist[0].b+1, llist[0].e+1,1);</span><br><span class="line"></span><br><span class="line">        int now_m = node[1].m, now_line = node[1].line;</span><br><span class="line"></span><br><span class="line">        ans = now_m;</span><br><span class="line"></span><br><span class="line">        for (i = 1; i &lt; tot; i ++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (llist[i].flag) insert(llist[i].b+1, llist[i].e+1, 1);</span><br><span class="line"></span><br><span class="line">            else delet(llist[i].b+1, llist[i].e+1, 1);</span><br><span class="line"></span><br><span class="line">            ans += (abs(node[1].m - now_m) + 2*(llist[i].x - llist[i-1].x)*now_line);</span><br><span class="line"></span><br><span class="line">            now_m = node[1].m;</span><br><span class="line"></span><br><span class="line">            now_line = node[1].line;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf (&quot;%d\n&quot;, ans);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最近圆对"><a href="#最近圆对" class="headerlink" title="最近圆对"></a><strong>最近圆对</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br></pre></td><td class="code"><pre><span class="line">\#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;set&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">set &lt;int&gt;tree;</span><br><span class="line"></span><br><span class="line">set &lt;int&gt;::iterator iter;</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x;</span><br><span class="line"></span><br><span class="line">    int id, flag;</span><br><span class="line"></span><br><span class="line">&#125;p1[100001], p2[100001];</span><br><span class="line"></span><br><span class="line">int tot1, tot2;</span><br><span class="line"></span><br><span class="line">struct Q</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x,y, r;</span><br><span class="line"></span><br><span class="line">&#125;q[50001];</span><br><span class="line"></span><br><span class="line">int cmp(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Point*a1=(struct Point*)p1;</span><br><span class="line"></span><br><span class="line">    struct Point*a2=(struct Point*)p2;</span><br><span class="line"></span><br><span class="line">    if (a1-&gt;x&lt;a2-&gt;x) return -1;</span><br><span class="line"></span><br><span class="line">    else if (a1-&gt;x==a2-&gt;x) return a2-&gt;flag-a1-&gt;flag;</span><br><span class="line"></span><br><span class="line">    else return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cmp1(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Q*a1=(struct Q*)p1;</span><br><span class="line"></span><br><span class="line">    struct Q*a2=(struct Q*)p2;</span><br><span class="line"></span><br><span class="line">    if (a1-&gt;y&lt;a2-&gt;y)return -1;</span><br><span class="line"></span><br><span class="line">    else if (a1-&gt;y==a2-&gt;y)return 0;</span><br><span class="line"></span><br><span class="line">    else return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double dis(double x1, double y1, double x2, double y2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool judge(int i, int j, double d)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (dis(q[i].x, q[i].y, q[j].x, q[j].y)&lt;=q[i].r+q[j].r+2.0*d)</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool insert(int v,double d)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    iter = tree.insert(v).first;</span><br><span class="line"></span><br><span class="line">    if (iter != tree.begin())</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (judge(v, *--iter,d))</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++iter;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (++iter != tree.end())</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (judge(v, *iter,d))</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool remove(int v,double d)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    iter = tree.find(v);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    if (iter != tree.begin() &amp;&amp; iter != --tree.end())</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int a = *--iter;</span><br><span class="line"></span><br><span class="line">        ++iter;</span><br><span class="line"></span><br><span class="line">        int b = *++iter;</span><br><span class="line"></span><br><span class="line">        if (judge(a, b,d))</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tree.erase(v);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool check(double d)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i=1, j=1;</span><br><span class="line"></span><br><span class="line">    while (i&lt;=tot1&amp;&amp;j&lt;=tot2)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (p1[i].x-d&lt;=p2[j].x+d)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (insert(p1[i++].id, d))</span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (remove(p2[j++].id, d))</span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (i&lt;=tot1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (insert(p1[i++].id, d))</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (j&lt;=tot2)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (remove(p2[j++].id, d))</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int cases, n, i;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;,&amp;cases);</span><br><span class="line"></span><br><span class="line">    while (cases--)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"></span><br><span class="line">        tot1=tot2=0;</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;=n;i++)</span><br><span class="line"></span><br><span class="line">            scanf(&quot;%lf %lf %lf&quot;,&amp;q[i].x,&amp;q[i].y, &amp;q[i].r);</span><br><span class="line"></span><br><span class="line">        qsort(q+1,n,sizeof(struct Q),cmp1);</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;=n;i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tot1++;</span><br><span class="line"></span><br><span class="line">            p1[tot1].x=q[i].x-q[i].r;</span><br><span class="line"></span><br><span class="line">            p1[tot1].id=i;</span><br><span class="line"></span><br><span class="line">            p1[tot1].flag=1;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            tot2++;</span><br><span class="line"></span><br><span class="line">            p2[tot2].x=q[i].x+q[i].r;</span><br><span class="line"></span><br><span class="line">            p2[tot2].id=i;</span><br><span class="line"></span><br><span class="line">            p2[tot2].flag=-1;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qsort(p1+1,tot1,sizeof(struct Point),cmp);</span><br><span class="line"></span><br><span class="line">        qsort(p2+1,tot2,sizeof(struct Point),cmp);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        double head=0.0, tail=dis(q[1].x,q[1].y,q[2].x,q[2].y)+1.0, mid;</span><br><span class="line"></span><br><span class="line">        while (tail-head&gt;1e-8)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tree.clear();</span><br><span class="line"></span><br><span class="line">            mid=(head+tail)/2.0;</span><br><span class="line"></span><br><span class="line">            if (check(mid))</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                tail=mid;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            else head=mid;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf (&quot;%.6lf\n&quot;,2.0*head);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求两个圆的面积交"><a href="#求两个圆的面积交" class="headerlink" title="求两个圆的面积交"></a><strong>求两个圆的面积交</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">double area_of_overlap(point c1, double r1, point c2, double r2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double a = distance(c1, c2), b = r1, c = r2;</span><br><span class="line"></span><br><span class="line">double cta1 = acos((a * a + b * b - c * c) / 2 / (a * b)), </span><br><span class="line"></span><br><span class="line">      cta2 = acos((a * a + c * c - b * b) / 2 / (a * c));</span><br><span class="line"></span><br><span class="line">    double s1 = r1*r1*cta1 - r1*r1*sin(cta1)*(a * a + b * b - c * c) / 2 / (a * b);</span><br><span class="line"></span><br><span class="line">    double s2 = r2*r2*cta2 - r2*r2*sin(cta2)*(a * a + c * c - b * b) / 2 / (a * c);</span><br><span class="line"></span><br><span class="line">    return s1 + s2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><h2 id="Nim博弈"><a href="#Nim博弈" class="headerlink" title="Nim博弈"></a>Nim博弈</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;cstring&gt;  </span><br><span class="line">#include &lt;cstdio&gt;  </span><br><span class="line">#define LL long long  </span><br><span class="line">#define mod 1000000007  </span><br><span class="line">#define sz 100005  </span><br><span class="line">using namespace std;  </span><br><span class="line">int sg[sz];  </span><br><span class="line">bool vis[sz];  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    //´ò±í³ÌÐò  </span><br><span class="line">    /*int tmp; </span><br><span class="line">    sg[0]=0; </span><br><span class="line">    for(int i=1;i&lt;=50;i++) </span><br><span class="line">    &#123; </span><br><span class="line">        memset(vis,0,sizeof(vis)); </span><br><span class="line">        for(int j=0;j&lt;i;j++) </span><br><span class="line">            vis[sg[j]]=1; </span><br><span class="line">        for(int k=1;k&lt;i;k++) </span><br><span class="line">        &#123; </span><br><span class="line">            for(int m=1;m&lt;i;m++) </span><br><span class="line">            &#123; </span><br><span class="line">                int u=i-k-m; </span><br><span class="line">                if(u&gt;0) </span><br><span class="line">                &#123; </span><br><span class="line">                    tmp=sg[k]^sg[m]^sg[u]; </span><br><span class="line">                    vis[tmp]=1; </span><br><span class="line">                &#125; </span><br><span class="line">                else </span><br><span class="line">                    break; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        for(int x=0;;x++) </span><br><span class="line">            if(!vis[x]) </span><br><span class="line">            &#123; </span><br><span class="line">                sg[i]=x; </span><br><span class="line">                printf(&quot;sg[%d]: %d\n&quot;,i,x); </span><br><span class="line">                break; </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;*/  </span><br><span class="line">    int t,n,tmp,s;  </span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);  </span><br><span class="line">    while(t--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        s=0;  </span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);  </span><br><span class="line">        while(n--)  </span><br><span class="line">        &#123;  </span><br><span class="line">            scanf(&quot;%d&quot;,&amp;tmp);  </span><br><span class="line">            if(tmp%8==7)  </span><br><span class="line">                s^=(tmp+1);  </span><br><span class="line">            else if(tmp%8==0)  </span><br><span class="line">                s^=(tmp-1);  </span><br><span class="line">            else  </span><br><span class="line">                s^=tmp;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(s)  </span><br><span class="line">            printf(&quot;First player wins.\n&quot;);  </span><br><span class="line">        else  </span><br><span class="line">            printf(&quot;Second player wins.\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int wzf(int a,int b)&#123;</span><br><span class="line">        if(a&lt;b)&#123;</span><br><span class="line">            a^=b;</span><br><span class="line">            b^=a;</span><br><span class="line">            a^=b;</span><br><span class="line">        &#125;</span><br><span class="line">        int k=a-b;</span><br><span class="line">        a=(int)(k*(1+sqrt(5))/2.0);</span><br><span class="line">        if(a==b)</span><br><span class="line">            return 1;</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	for(int i=1;i&lt;100;i++)</span><br><span class="line">		for(int j=1;j&lt;100;j++)</span><br><span class="line">		if(wzf(i,j)) printf(&quot;(%d,%d) %d\n&quot;,i,j,i-j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int d[1000][10], n, k;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"> </span><br><span class="line">	d[0][0] = 1;</span><br><span class="line"> </span><br><span class="line">	for (int i = 1; i &lt;= n; i++)</span><br><span class="line">		d[i][1] = 1;</span><br><span class="line"> </span><br><span class="line">	for (int i = 1; i &lt;= n; i++)</span><br><span class="line"> </span><br><span class="line">		for (int j = 1; j &lt;= k; j++)</span><br><span class="line"> </span><br><span class="line">			if (i &gt;= j)</span><br><span class="line"> </span><br><span class="line">				d[i][j] = d[i - j][j] + d[i - 1][j - 1];</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; d[n][k]&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间K大数"><a href="#区间K大数" class="headerlink" title="区间K大数"></a>区间K大数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#define MAXN 10010</span><br><span class="line">#define MAXE 100010</span><br><span class="line">using namespace std;</span><br><span class="line">int head[MAXN],tot1,tot2;</span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int u,v,next;</span><br><span class="line">&#125; e1[MAXE],e2[MAXN];</span><br><span class="line">void addEdge(int u,int v,Edge* edge,int&amp; tol)</span><br><span class="line">&#123;</span><br><span class="line">    edge[tol].u=u;</span><br><span class="line">    edge[tol].v=v;</span><br><span class="line">    edge[tol].next=head[u];</span><br><span class="line">    head[u]=tol++;</span><br><span class="line">&#125;</span><br><span class="line">int n,m;</span><br><span class="line">int low[MAXN],dfn[MAXN],stack[MAXN],belong[MAXN],num[MAXN];</span><br><span class="line">bool instack[MAXN];</span><br><span class="line">int scc,top,INDEX;</span><br><span class="line">void Tarjan(int u)</span><br><span class="line">&#123;</span><br><span class="line">    int v;</span><br><span class="line">    low[u]=dfn[u]=++INDEX;</span><br><span class="line">    stack[top++]=u;</span><br><span class="line">    instack[u]=true;</span><br><span class="line">    for(int i=head[u]; i!=-1; i=e1[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        v=e1[i].v;</span><br><span class="line">        if(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            Tarjan(v);</span><br><span class="line">            if(low[u]&gt;low[v])</span><br><span class="line">                low[u]=low[v];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(instack[v]&amp;&amp;low[u]&gt;dfn[v])</span><br><span class="line">            low[u]=dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line">    if(low[u]==dfn[u])</span><br><span class="line">    &#123;</span><br><span class="line">        ++scc;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            v=stack[--top];</span><br><span class="line">            instack[v]=false;</span><br><span class="line">            belong[v]=scc;</span><br><span class="line">            num[scc]++;</span><br><span class="line">        &#125;</span><br><span class="line">        while(u!=v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int inde[MAXN],outde[MAXN];</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">    memset(dfn,0,sizeof(dfn));</span><br><span class="line">    memset(instack,false,sizeof(instack));</span><br><span class="line">    memset(num,0,sizeof(num));</span><br><span class="line">    scc=top=INDEX=0;</span><br><span class="line">    for(int i=1; i&lt;=n; ++i)</span><br><span class="line">        if(!dfn[i])</span><br><span class="line">            Tarjan(i);</span><br><span class="line">    tot2=0;</span><br><span class="line">    memset(head,-1,sizeof(head));</span><br><span class="line">    memset(inde,0,sizeof(inde));</span><br><span class="line">    memset(outde,0,sizeof(outde));</span><br><span class="line">    int u,v;</span><br><span class="line">    for(int i=0; i&lt;m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        u=belong[e1[i].u];</span><br><span class="line">        v=belong[e1[i].v];</span><br><span class="line">        if(u!=v)</span><br><span class="line">        &#123;</span><br><span class="line">            addEdge(u,v,e2,tot2);</span><br><span class="line">            inde[v]++;</span><br><span class="line">            outde[u]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int a=0,b=0;</span><br><span class="line">    for(int i=1; i&lt;=scc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!inde[i])</span><br><span class="line">            a++;</span><br><span class="line">        if(!outde[i])</span><br><span class="line">            b++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(scc==1)</span><br><span class="line">        printf(&quot;0\n&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;%d\n&quot;,max(a,b));</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int zushu;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;zushu);</span><br><span class="line">    while(zushu--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        tot1=0;</span><br><span class="line">        memset(head,-1,sizeof(head));</span><br><span class="line">        int u,v;</span><br><span class="line">        for(int i=0; i&lt;m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">            addEdge(u,v,e1,tot1);</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">22. 22. 22. 22. 区间 KKKK 大数</span><br><span class="line">//POJ 2104</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int NMAX = 100000;</span><br><span class="line">const int LOGNMAX = 17 +1;</span><br><span class="line">int sortseq[LOGNMAX][NMAX];</span><br><span class="line">int num[NMAX];</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int l,r,d;</span><br><span class="line">    node * pl,* pr;</span><br><span class="line">&#125; mem[(NMAX&lt;&lt;1)+100];</span><br><span class="line">int mempos,n,m;</span><br><span class="line">node * root;</span><br><span class="line">node * make_tree(int l,int r,int d)</span><br><span class="line">&#123;</span><br><span class="line">    node * rt = mem+(mempos ++);</span><br><span class="line">    rt-&gt;l = l;</span><br><span class="line">    rt-&gt;r = r;</span><br><span class="line">    rt-&gt;d = d;</span><br><span class="line">    if (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        sortseq[d][l] = num[l];</span><br><span class="line">        return rt;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (l+r) &gt;&gt; 1;</span><br><span class="line">    rt-&gt;pl = make_tree(l,mid,d+1);</span><br><span class="line">    rt-&gt;pr = make_tree(mid+1,r,d+1);</span><br><span class="line">    int i=l,j=mid+1,k=l;</span><br><span class="line">    while (i&lt;=mid &amp;&amp; j&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        if (sortseq[d+1][i] &lt; sortseq[d+1][j])</span><br><span class="line">            sortseq[d][k++] =</span><br><span class="line">                sortseq[d+1][i++];</span><br><span class="line">        else</span><br><span class="line">            sortseq[d][k++] = sortseq[d+1][j++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (i&lt;=mid)</span><br><span class="line">        sortseq[d][k++] = sortseq[d+1][i++];</span><br><span class="line">    while (j&lt;=r)</span><br><span class="line">        sortseq[d][k++] = sortseq[d+1][j++];</span><br><span class="line">    return rt;</span><br><span class="line">&#125;</span><br><span class="line">int s,t,rank;</span><br><span class="line">int query(node * rt,int val)</span><br><span class="line">&#123;</span><br><span class="line">    int i,mid,ret;</span><br><span class="line">    if (s &lt;= rt-&gt;l &amp;&amp; rt-&gt;r &lt;= t)</span><br><span class="line">    &#123;</span><br><span class="line">        if (val &lt;= sortseq[rt-&gt;d][rt-&gt;l])</span><br><span class="line">            return 0;</span><br><span class="line">        else if (sortseq[rt-&gt;d][rt-&gt;r] &lt; val)</span><br><span class="line">            return rt-&gt;r - rt-&gt;l +1;</span><br><span class="line">        else if (sortseq[rt-&gt;d][rt-&gt;r] == val)</span><br><span class="line">            return rt-&gt;r - rt-&gt;l;</span><br><span class="line">        int l = rt-&gt;l, r = rt-&gt;r, mid;</span><br><span class="line">        while (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l+r) &gt;&gt; 1;</span><br><span class="line">            if (val &lt;= sortseq[rt-&gt;d][mid])</span><br><span class="line">                r = mid-1;</span><br><span class="line">            else</span><br><span class="line">                l = mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        return l - rt-&gt;l;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ret = 0;</span><br><span class="line">        mid = (rt-&gt;l+rt-&gt;r) &gt;&gt; 1;</span><br><span class="line">        if (s &lt;= mid)</span><br><span class="line">            ret += query(rt-&gt;pl,val);</span><br><span class="line">        if (mid+1 &lt;= t)</span><br><span class="line">            ret += query(rt-&gt;pr,val);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 二分查找时遇到相同值的处理非常重要</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,l,r;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for (i=0; i&lt;n; i++)</span><br><span class="line">        scanf(&quot;%d&quot;,num+i);</span><br><span class="line">    mempos = 0;</span><br><span class="line">    root = make_tree(0,n-1,0);</span><br><span class="line">    while (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        s = get_val()-1;</span><br><span class="line">        t = get_val()-1;</span><br><span class="line">        rank = get_val()-1;</span><br><span class="line">        l = 0, r = n-1;</span><br><span class="line">        while (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid = (l+r) &gt;&gt; 1;</span><br><span class="line">// 二分查找sortseq[0][mid]在区间[s,t]中的排名</span><br><span class="line">            int pos = query(root,sortseq[0][mid]);</span><br><span class="line">            if (rank &lt; pos)</span><br><span class="line">                r = mid-1;</span><br><span class="line">            else</span><br><span class="line">                l = mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,sortseq[0][r]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int getid(int x)&#123;</span><br><span class="line">	return lower_bound(v.begin(),v.end(),x) - v.begin() + 1;</span><br><span class="line">&#125;</span><br><span class="line">	for(int i = 1;i&lt;=n;++i)&#123;</span><br><span class="line">    	scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    	v.push_back(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">	sort(v.begin(),v.end()), v.erase(unique(v.begin(),v.end()),v.end());</span><br></pre></td></tr></table></figure>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="统计1的个数"><a href="#统计1的个数" class="headerlink" title="统计1的个数"></a>统计1的个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int NumberOfOne(int n) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while(n) &#123;</span><br><span class="line">    	n &amp;= (n-1);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="strtok-和-sscanf-结合输入"><a href="#strtok-和-sscanf-结合输入" class="headerlink" title="strtok 和 sscanf 结合输入"></a>strtok 和 sscanf 结合输入</h2><p>空格作为分隔输入，读取一行的整数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gets(buf);</span><br><span class="line">int v;</span><br><span class="line">char *p = strtok(buf,&quot; &quot;);</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">    sscanf(p,&quot;%d&quot;,&amp;v);</span><br><span class="line">    p = strtok(NULL,&quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输入输出挂"><a href="#输入输出挂" class="headerlink" title="输入输出挂"></a>输入输出挂</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//适用于正负整数</span><br><span class="line">template &lt;class T&gt;inline bool scan_d(T &amp;ret)</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    int sgn;</span><br><span class="line">    if(c=getchar(),c==EOF)</span><br><span class="line">        return 0; //EOF</span><br><span class="line">    while(c!=&apos;−&apos;&amp;&amp;(c&lt;&apos;0&apos;||c&gt;&apos;9&apos;))</span><br><span class="line">        c=getchar();</span><br><span class="line">    sgn=(c==&apos;−&apos;)?−1:1;</span><br><span class="line">    ret=(c==&apos;−&apos;)?0:(c−&apos;0&apos;);</span><br><span class="line">    while(c=getchar(),c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;)</span><br><span class="line">        ret=ret*10+(c−&apos;0&apos;);</span><br><span class="line">    ret*=sgn;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">inline void out(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x&gt;9)</span><br><span class="line">        out(x/10);</span><br><span class="line">    putchar(x%10+&apos;0&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    
	
	  <div>
    
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;"><hr>文章结束了，但我们的故事还在继续</div>
    
</div>
    
	  </div>

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechat-reward-image.png" alt="王骏 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay-reward-image.jpg" alt="王骏 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/字符串/" rel="tag"><i class="fa fa-tag"></i> 字符串</a>
          
            <a href="/tags/算法/" rel="tag"><i class="fa fa-tag"></i> 算法</a>
          
            <a href="/tags/数据结构/" rel="tag"><i class="fa fa-tag"></i> 数据结构</a>
          
            <a href="/tags/博弈论/" rel="tag"><i class="fa fa-tag"></i> 博弈论</a>
          
            <a href="/tags/图论/" rel="tag"><i class="fa fa-tag"></i> 图论</a>
          
            <a href="/tags/数论/" rel="tag"><i class="fa fa-tag"></i> 数论</a>
          
            <a href="/tags/计算几何/" rel="tag"><i class="fa fa-tag"></i> 计算几何</a>
          
            <a href="/tags/动态规划/" rel="tag"><i class="fa fa-tag"></i> 动态规划</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/02/2018-10-02/" rel="next" title="NAIPC2016-F.Mountain Scenes">
                <i class="fa fa-chevron-left"></i> NAIPC2016-F.Mountain Scenes
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/08/2018-10-08/" rel="prev" title="强连通图经典算法——Tarjan算法">
                强连通图经典算法——Tarjan算法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNjA4NC8xMjYxOQ=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/blog-logo.jpg" alt="王骏">
            
              <p class="site-author-name" itemprop="name">王骏</p>
              <p class="site-description motion-element" itemprop="description">浪打浮沉惊白昼，沧海一笑浅悠悠。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">177</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">150</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/qian-youyou" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.15249144478@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://vjudge.net/user/15249144478" target="_blank" title="vjduge">
                      
                        <i class="fa fa-fw fa-globe"></i>vjduge</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/5264080143/profile?topnav=1&wvr=6&is_all=1" target="_blank" title="weibo">
                      
                        <i class="fa fa-fw fa-globe"></i>weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.baidu.com/" target="_blank" title="baidu">
                      
                        <i class="fa fa-fw fa-globe"></i>baidu</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/qian_youyou" target="_blank" title="csdn">
                      
                        <i class="fa fa-fw fa-globe"></i>csdn</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/qian_youyou" title="浅悠悠CSDN" target="_blank">浅悠悠CSDN</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://my.csdn.net/por_una_cabze" title="渣渣灰CSDN" target="_blank">渣渣灰CSDN</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://my.csdn.net/messhiro" title="赵神CSDN" target="_blank">赵神CSDN</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.matrix67.com/" title="matrix67博客" target="_blank">matrix67博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://amon1997.com/" title="曹静的博客" target="_blank">曹静的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/sophia__yu" title="杨祥钰CSDN" target="_blank">杨祥钰CSDN</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>
	  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=38592976&auto=1&height=66"></iframe>
	  
      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构"><span class="nav-number">1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础"><span class="nav-number">1.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并查集"><span class="nav-number">1.1.1.</span> <span class="nav-text">并查集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并查集路径压缩按雉合并"><span class="nav-number">1.1.2.</span> <span class="nav-text">并查集路径压缩按雉合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加权并查集"><span class="nav-number">1.1.3.</span> <span class="nav-text">加权并查集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单调队列"><span class="nav-number">1.1.4.</span> <span class="nav-text">单调队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链式前向星"><span class="nav-number">1.1.5.</span> <span class="nav-text">链式前向星</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树结构"><span class="nav-number">1.2.</span> <span class="nav-text">树结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#树状数组"><span class="nav-number">1.2.1.</span> <span class="nav-text">树状数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线段树"><span class="nav-number">1.2.2.</span> <span class="nav-text">线段树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主席树"><span class="nav-number">1.2.3.</span> <span class="nav-text">主席树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#划分树"><span class="nav-number">1.2.4.</span> <span class="nav-text">划分树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Trie树"><span class="nav-number">1.2.5.</span> <span class="nav-text">Trie树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伸展树"><span class="nav-number">1.2.6.</span> <span class="nav-text">伸展树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LCA-Tarjan"><span class="nav-number">1.2.7.</span> <span class="nav-text">LCA(Tarjan)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RMQ"><span class="nav-number">1.3.</span> <span class="nav-text">RMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ST表"><span class="nav-number">1.3.1.</span> <span class="nav-text">ST表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#普通莫队"><span class="nav-number">1.3.2.</span> <span class="nav-text">普通莫队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#莫队"><span class="nav-number">1.3.3.</span> <span class="nav-text">莫队</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态规划"><span class="nav-number">2.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#背包"><span class="nav-number">2.1.</span> <span class="nav-text">背包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最长上升子序列"><span class="nav-number">2.2.</span> <span class="nav-text">最长上升子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最长公共子序列"><span class="nav-number">2.3.</span> <span class="nav-text">最长公共子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概率dp"><span class="nav-number">2.4.</span> <span class="nav-text">概率dp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#轮廓线dp"><span class="nav-number">2.5.</span> <span class="nav-text">轮廓线dp</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#图论"><span class="nav-number">3.</span> <span class="nav-text">图论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#最短路"><span class="nav-number">3.1.</span> <span class="nav-text">最短路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra-邻接矩阵"><span class="nav-number">3.1.1.</span> <span class="nav-text">Dijkstra(邻接矩阵)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra"><span class="nav-number">3.1.2.</span> <span class="nav-text">Dijkstra</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra-heap"><span class="nav-number">3.1.3.</span> <span class="nav-text">Dijkstra+heap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPFA"><span class="nav-number">3.1.4.</span> <span class="nav-text">SPFA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPFA-SLF优化"><span class="nav-number">3.1.5.</span> <span class="nav-text">SPFA+SLF优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Floyd"><span class="nav-number">3.1.6.</span> <span class="nav-text">Floyd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#K短路"><span class="nav-number">3.1.7.</span> <span class="nav-text">K短路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生成树"><span class="nav-number">3.2.</span> <span class="nav-text">生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Kruskal"><span class="nav-number">3.2.1.</span> <span class="nav-text">Kruskal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prim"><span class="nav-number">3.2.2.</span> <span class="nav-text">Prim</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#次小生成树"><span class="nav-number">3.2.3.</span> <span class="nav-text">次小生成树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拓扑排序"><span class="nav-number">3.3.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络流"><span class="nav-number">3.4.</span> <span class="nav-text">网络流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FF"><span class="nav-number">3.4.1.</span> <span class="nav-text">FF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EK"><span class="nav-number">3.4.2.</span> <span class="nav-text">EK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DINIC"><span class="nav-number">3.4.3.</span> <span class="nav-text">DINIC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DINIC优化"><span class="nav-number">3.4.4.</span> <span class="nav-text">DINIC优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DINIC-邻接矩阵"><span class="nav-number">3.4.5.</span> <span class="nav-text">DINIC(邻接矩阵)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ISAP"><span class="nav-number">3.4.6.</span> <span class="nav-text">ISAP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MCMF"><span class="nav-number">3.4.7.</span> <span class="nav-text">MCMF</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匹配"><span class="nav-number">3.5.</span> <span class="nav-text">匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#匈牙利算法-邻接矩阵"><span class="nav-number">3.5.1.</span> <span class="nav-text">匈牙利算法(邻接矩阵)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匈牙利算法"><span class="nav-number">3.5.2.</span> <span class="nav-text">匈牙利算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KM算法"><span class="nav-number">3.5.3.</span> <span class="nav-text">KM算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KM算法最小权匹配"><span class="nav-number">3.5.4.</span> <span class="nav-text">KM算法最小权匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KM算法最小权匹配优化版"><span class="nav-number">3.5.5.</span> <span class="nav-text">KM算法最小权匹配优化版</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#强连通"><span class="nav-number">3.6.</span> <span class="nav-text">强连通</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Tarjan"><span class="nav-number">3.6.1.</span> <span class="nav-text">Tarjan</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tarjan缩点"><span class="nav-number">3.6.2.</span> <span class="nav-text">Tarjan缩点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-SAT"><span class="nav-number">3.7.</span> <span class="nav-text">2-SAT</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数学"><span class="nav-number">4.</span> <span class="nav-text">数学</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数论"><span class="nav-number">4.1.</span> <span class="nav-text">数论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gcd"><span class="nav-number">4.1.1.</span> <span class="nav-text">gcd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exgcd"><span class="nav-number">4.1.2.</span> <span class="nav-text">exgcd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中国剩余定理"><span class="nav-number">4.1.3.</span> <span class="nav-text">中国剩余定理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#欧拉函数"><span class="nav-number">4.1.4.</span> <span class="nav-text">欧拉函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#欧拉筛"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">欧拉筛</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#卡特兰数"><span class="nav-number">4.1.5.</span> <span class="nav-text">卡特兰数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#卡特兰数打表"><span class="nav-number">4.1.5.1.</span> <span class="nav-text">卡特兰数打表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#卡特兰数表"><span class="nav-number">4.1.5.2.</span> <span class="nav-text">卡特兰数表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#斯特林数"><span class="nav-number">4.1.6.</span> <span class="nav-text">斯特林数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一类斯特林数"><span class="nav-number">4.1.6.1.</span> <span class="nav-text">第一类斯特林数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二类斯特林数"><span class="nav-number">4.1.6.2.</span> <span class="nav-text">第二类斯特林数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逆元"><span class="nav-number">4.1.7.</span> <span class="nav-text">逆元</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#扩展欧几里得算法"><span class="nav-number">4.1.7.1.</span> <span class="nav-text">扩展欧几里得算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#费马小定理-欧拉定理"><span class="nav-number">4.1.7.2.</span> <span class="nav-text">费马小定理/欧拉定理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递推求逆元"><span class="nav-number">4.1.7.3.</span> <span class="nav-text">递推求逆元</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#miller-rabin，Pollard-rho算法"><span class="nav-number">4.1.8.</span> <span class="nav-text">miller-rabin，Pollard_rho算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#大素数判断和素因子分解"><span class="nav-number">4.1.8.1.</span> <span class="nav-text">大素数判断和素因子分解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合数学"><span class="nav-number">4.2.</span> <span class="nav-text">组合数学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lucas定理"><span class="nav-number">4.2.1.</span> <span class="nav-text">Lucas定理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#费马小定理实现"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">费马小定理实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exgcd实现"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">exgcd实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全排列全组合"><span class="nav-number">4.2.2.</span> <span class="nav-text">全排列全组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#母函数"><span class="nav-number">4.2.3.</span> <span class="nav-text">母函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容斥原理"><span class="nav-number">4.2.4.</span> <span class="nav-text">容斥原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#莫比乌斯反演"><span class="nav-number">4.2.5.</span> <span class="nav-text">莫比乌斯反演</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#莫比乌斯Euler打表"><span class="nav-number">4.2.6.</span> <span class="nav-text">莫比乌斯Euler打表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#离散对数"><span class="nav-number">4.2.7.</span> <span class="nav-text">离散对数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自适应-simpson-积分"><span class="nav-number">4.2.8.</span> <span class="nav-text">自适应 simpson 积分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线性代数"><span class="nav-number">4.3.</span> <span class="nav-text">线性代数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#快速幂"><span class="nav-number">4.3.1.</span> <span class="nav-text">快速幂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵快速幂"><span class="nav-number">4.3.2.</span> <span class="nav-text">矩阵快速幂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速乘"><span class="nav-number">4.3.3.</span> <span class="nav-text">快速乘</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#O-logn-快速乘"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">O(logn)快速乘</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#O-1-快速乘"><span class="nav-number">4.3.3.2.</span> <span class="nav-text">O(1)快速乘</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#模板"><span class="nav-number">4.3.3.2.1.</span> <span class="nav-text">模板</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高斯消元"><span class="nav-number">4.3.4.</span> <span class="nav-text">高斯消元</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串"><span class="nav-number">5.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串hash"><span class="nav-number">5.1.</span> <span class="nav-text">字符串hash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串和数值hash"><span class="nav-number">5.2.</span> <span class="nav-text">字符串和数值hash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM"><span class="nav-number">5.3.</span> <span class="nav-text">BM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KMP"><span class="nav-number">5.4.</span> <span class="nav-text">KMP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AC自动机"><span class="nav-number">5.5.</span> <span class="nav-text">AC自动机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后缀自动机"><span class="nav-number">5.6.</span> <span class="nav-text">后缀自动机</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#计算几何"><span class="nav-number">6.</span> <span class="nav-text">计算几何</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础计算几何"><span class="nav-number">6.1.</span> <span class="nav-text">基础计算几何</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#几何公式"><span class="nav-number">6.1.1.</span> <span class="nav-text">几何公式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三角形"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">三角形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四边形"><span class="nav-number">6.1.1.2.</span> <span class="nav-text">四边形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#正n边形"><span class="nav-number">6.1.1.3.</span> <span class="nav-text">正n边形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#圆"><span class="nav-number">6.1.1.4.</span> <span class="nav-text">圆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#棱柱"><span class="nav-number">6.1.1.5.</span> <span class="nav-text">棱柱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#棱锥"><span class="nav-number">6.1.1.6.</span> <span class="nav-text">棱锥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#棱台"><span class="nav-number">6.1.1.7.</span> <span class="nav-text">棱台</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#圆柱"><span class="nav-number">6.1.1.8.</span> <span class="nav-text">圆柱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#圆锥"><span class="nav-number">6.1.1.9.</span> <span class="nav-text">圆锥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#圆台"><span class="nav-number">6.1.1.10.</span> <span class="nav-text">圆台</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#球"><span class="nav-number">6.1.1.11.</span> <span class="nav-text">球</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#球台"><span class="nav-number">6.1.1.12.</span> <span class="nav-text">球台</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#球扇形"><span class="nav-number">6.1.1.13.</span> <span class="nav-text">球扇形</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直线与线段"><span class="nav-number">6.1.2.</span> <span class="nav-text">直线与线段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#预备函数"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">预备函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判三点是否共线"><span class="nav-number">6.1.2.2.</span> <span class="nav-text">判三点是否共线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判点是否在线段上"><span class="nav-number">6.1.2.3.</span> <span class="nav-text">判点是否在线段上</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断两点在线段的同一侧"><span class="nav-number">6.1.2.4.</span> <span class="nav-text">判断两点在线段的同一侧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断两点是否在线段的异侧"><span class="nav-number">6.1.2.5.</span> <span class="nav-text">判断两点是否在线段的异侧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#求点关于直线的对称点"><span class="nav-number">6.1.2.6.</span> <span class="nav-text">求点关于直线的对称点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断两线段是否相交"><span class="nav-number">6.1.2.7.</span> <span class="nav-text">判断两线段是否相交</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常用版"><span class="nav-number">6.1.2.7.1.</span> <span class="nav-text">常用版</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#不常用版"><span class="nav-number">6.1.2.7.2.</span> <span class="nav-text">不常用版</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#求两条直线的交点"><span class="nav-number">6.1.2.8.</span> <span class="nav-text">求两条直线的交点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#点到直线的最近距离"><span class="nav-number">6.1.2.9.</span> <span class="nav-text">点到直线的最近距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#点到线段的最近距离"><span class="nav-number">6.1.2.10.</span> <span class="nav-text">点到线段的最近距离</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多边形"><span class="nav-number">6.1.3.</span> <span class="nav-text">多边形</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#预备浮点函数"><span class="nav-number">6.1.3.1.</span> <span class="nav-text">预备浮点函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判定是否是凸多边形"><span class="nav-number">6.1.3.2.</span> <span class="nav-text">判定是否是凸多边形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判定点是否在多边形内"><span class="nav-number">6.1.3.3.</span> <span class="nav-text">判定点是否在多边形内</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判定一条线段是否在一个任意多边形内"><span class="nav-number">6.1.3.4.</span> <span class="nav-text">判定一条线段是否在一个任意多边形内</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三角形-1"><span class="nav-number">6.1.4.</span> <span class="nav-text">三角形</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#预备函数-1"><span class="nav-number">6.1.4.1.</span> <span class="nav-text">预备函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#求三角形的外心"><span class="nav-number">6.1.4.2.</span> <span class="nav-text">求三角形的外心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#求三角形内心"><span class="nav-number">6.1.4.3.</span> <span class="nav-text">求三角形内心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#求三角形垂心"><span class="nav-number">6.1.4.4.</span> <span class="nav-text">求三角形垂心</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#圆-1"><span class="nav-number">6.1.5.</span> <span class="nav-text">圆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#预备函数-2"><span class="nav-number">6.1.5.1.</span> <span class="nav-text">预备函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判定直线是否与圆相交"><span class="nav-number">6.1.5.2.</span> <span class="nav-text">判定直线是否与圆相交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判定线段与圆相交"><span class="nav-number">6.1.5.3.</span> <span class="nav-text">判定线段与圆相交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判圆和圆相交"><span class="nav-number">6.1.5.4.</span> <span class="nav-text">判圆和圆相交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算圆上到点p最近点"><span class="nav-number">6.1.5.5.</span> <span class="nav-text">计算圆上到点p最近点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算直线与圆的交点"><span class="nav-number">6.1.5.6.</span> <span class="nav-text">计算直线与圆的交点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算两个圆的交点"><span class="nav-number">6.1.5.7.</span> <span class="nav-text">计算两个圆的交点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#球面"><span class="nav-number">6.1.6.</span> <span class="nav-text">球面</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#给出地球经度纬度，计算圆心角"><span class="nav-number">6.1.6.1.</span> <span class="nav-text">给出地球经度纬度，计算圆心角</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#已知经纬度，计算地球上两点直线距离"><span class="nav-number">6.1.6.2.</span> <span class="nav-text">已知经纬度，计算地球上两点直线距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#已知经纬度，计算地球上两点球面距离"><span class="nav-number">6.1.6.3.</span> <span class="nav-text">已知经纬度，计算地球上两点球面距离</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三维几何的若干模板"><span class="nav-number">6.1.7.</span> <span class="nav-text">三维几何的若干模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#预备函数-3"><span class="nav-number">6.1.7.1.</span> <span class="nav-text">预备函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判定三点是否共线"><span class="nav-number">6.1.7.2.</span> <span class="nav-text">判定三点是否共线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判定四点是否共面"><span class="nav-number">6.1.7.3.</span> <span class="nav-text">判定四点是否共面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判定点是否在线段上"><span class="nav-number">6.1.7.4.</span> <span class="nav-text">判定点是否在线段上</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断点是否在空间三角形上"><span class="nav-number">6.1.7.5.</span> <span class="nav-text">判断点是否在空间三角形上</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断两点是否在线段同侧"><span class="nav-number">6.1.7.6.</span> <span class="nav-text">判断两点是否在线段同侧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断两点是否在线段异侧"><span class="nav-number">6.1.7.7.</span> <span class="nav-text">判断两点是否在线段异侧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断两点是否在平面同侧"><span class="nav-number">6.1.7.8.</span> <span class="nav-text">判断两点是否在平面同侧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断两点是否在平面异侧"><span class="nav-number">6.1.7.9.</span> <span class="nav-text">判断两点是否在平面异侧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断两空间直线是否平行"><span class="nav-number">6.1.7.10.</span> <span class="nav-text">判断两空间直线是否平行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断两平面是否平行"><span class="nav-number">6.1.7.11.</span> <span class="nav-text">判断两平面是否平行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断直线是否与平面平行"><span class="nav-number">6.1.7.12.</span> <span class="nav-text">判断直线是否与平面平行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断两直线是否垂直"><span class="nav-number">6.1.7.13.</span> <span class="nav-text">判断两直线是否垂直</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断两平面是否垂直"><span class="nav-number">6.1.7.14.</span> <span class="nav-text">判断两平面是否垂直</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断两条空间线段是否相交"><span class="nav-number">6.1.7.15.</span> <span class="nav-text">判断两条空间线段是否相交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断线段是否与空间三角形相交"><span class="nav-number">6.1.7.16.</span> <span class="nav-text">判断线段是否与空间三角形相交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算两条直线的交点"><span class="nav-number">6.1.7.17.</span> <span class="nav-text">计算两条直线的交点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算直线与平面的交点"><span class="nav-number">6.1.7.18.</span> <span class="nav-text">计算直线与平面的交点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算两平面的交线"><span class="nav-number">6.1.7.19.</span> <span class="nav-text">计算两平面的交线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#点到直线的距离"><span class="nav-number">6.1.7.20.</span> <span class="nav-text">点到直线的距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算点到平面的距离"><span class="nav-number">6.1.7.21.</span> <span class="nav-text">计算点到平面的距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算直线到直线的距离"><span class="nav-number">6.1.7.22.</span> <span class="nav-text">计算直线到直线的距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间两直线夹角的cos值"><span class="nav-number">6.1.7.23.</span> <span class="nav-text">空间两直线夹角的cos值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#两平面夹角的cos值"><span class="nav-number">6.1.7.24.</span> <span class="nav-text">两平面夹角的cos值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#直线与平面夹角sin值"><span class="nav-number">6.1.7.25.</span> <span class="nav-text">直线与平面夹角sin值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级计算几何"><span class="nav-number">6.2.</span> <span class="nav-text">高级计算几何</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最远曼哈顿距离"><span class="nav-number">6.2.1.</span> <span class="nav-text">最远曼哈顿距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最近点对"><span class="nav-number">6.2.2.</span> <span class="nav-text">最近点对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最小包围圆"><span class="nav-number">6.2.3.</span> <span class="nav-text">最小包围圆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求两个圆的交点"><span class="nav-number">6.2.4.</span> <span class="nav-text">求两个圆的交点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求三角形外接圆圆心"><span class="nav-number">6.2.5.</span> <span class="nav-text">求三角形外接圆圆心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求凸包"><span class="nav-number">6.2.6.</span> <span class="nav-text">求凸包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#凸包卡壳旋转求出所有对踵点、最远点对"><span class="nav-number">6.2.7.</span> <span class="nav-text">凸包卡壳旋转求出所有对踵点、最远点对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#凸包-旋转卡壳求平面面积最大三角"><span class="nav-number">6.2.8.</span> <span class="nav-text">凸包+旋转卡壳求平面面积最大三角</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pick定理"><span class="nav-number">6.2.9.</span> <span class="nav-text">Pick定理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求多边形面积和重心"><span class="nav-number">6.2.10.</span> <span class="nav-text">求多边形面积和重心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断一个简单多边形是否有核"><span class="nav-number">6.2.11.</span> <span class="nav-text">判断一个简单多边形是否有核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模拟退火"><span class="nav-number">6.2.12.</span> <span class="nav-text">模拟退火</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六边形坐标系"><span class="nav-number">6.2.13.</span> <span class="nav-text">六边形坐标系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用一个给定半径的圆覆盖最多的点"><span class="nav-number">6.2.14.</span> <span class="nav-text">用一个给定半径的圆覆盖最多的点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不等大的圆的圆弧表示"><span class="nav-number">6.2.15.</span> <span class="nav-text">不等大的圆的圆弧表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矩形面积并"><span class="nav-number">6.2.16.</span> <span class="nav-text">矩形面积并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矩形的周长并"><span class="nav-number">6.2.17.</span> <span class="nav-text">矩形的周长并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最近圆对"><span class="nav-number">6.2.18.</span> <span class="nav-text">最近圆对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求两个圆的面积交"><span class="nav-number">6.2.19.</span> <span class="nav-text">求两个圆的面积交</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#博弈论"><span class="nav-number">7.</span> <span class="nav-text">博弈论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Nim博弈"><span class="nav-number">7.1.</span> <span class="nav-text">Nim博弈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#威佐夫博弈"><span class="nav-number">7.2.</span> <span class="nav-text">威佐夫博弈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其他"><span class="nav-number">8.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#整数划分"><span class="nav-number">8.1.</span> <span class="nav-text">整数划分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区间K大数"><span class="nav-number">8.2.</span> <span class="nav-text">区间K大数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#离散化"><span class="nav-number">8.3.</span> <span class="nav-text">离散化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位运算"><span class="nav-number">8.4.</span> <span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#统计1的个数"><span class="nav-number">8.4.1.</span> <span class="nav-text">统计1的个数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#strtok-和-sscanf-结合输入"><span class="nav-number">8.5.</span> <span class="nav-text">strtok 和 sscanf 结合输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入输出挂"><span class="nav-number">8.6.</span> <span class="nav-text">输入输出挂</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王骏</span>

  
</div>


  <div class="powered-by">
版权由 <a class="theme-link" target="_blank" href="https://qian-youyou.github.io">王骏</a> 所有</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/qian-youyou">wj.Mist.5.2.0</a></div>



<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 光顾人数：前世
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      次回眸
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 浏览次数：今生
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次邂逅
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.2.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.2.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.2.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.2.0"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "middleRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  

  

  

  
  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>


</body>
</html>
<script type="text/javascript" src="/js/src/love.js"></script>