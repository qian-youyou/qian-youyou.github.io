<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ACM算法专用模板(持续更新中)</title>
    <url>/2018/10/05/2018-10-05/</url>
    <content><![CDATA[<p>标签：位运算，gcd，exgcd，欧拉筛，快速乘，矩阵快速幂，中国剩余定理，欧拉函数，逆元，高斯消元，母函数，斯特林数，卡特兰数，莫比乌斯反演，SG函数与Nim博弈，奇异函数与Wythoff博弈，并查集，线段树，主席树，树状数组，ST表，LCA，BM算法，KMP，Trie树，AC自动机，匈牙利算法，KM算法，Floyd，dijkstra，dijkstra+heap优化，SPFA及LLL与SLF优化，Dinic，MCMF，Kruscal，Prim等等。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int fa[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    for(int i = 0; i &lt; maxn; i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int root(int x)&#123;</span><br><span class="line">    return x==fa[x] ? x : x=root(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">void Union(int px, int py)&#123;</span><br><span class="line">    px = root(px);</span><br><span class="line">    py = root(py);</span><br><span class="line">    if(px != py)&#123;</span><br><span class="line">        fa[py] = px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并查集路径压缩按雉合并"><a href="#并查集路径压缩按雉合并" class="headerlink" title="并查集路径压缩按雉合并"></a>并查集路径压缩按雉合并</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn=1e5+7;</span><br><span class="line">int fa[maxn],r[maxn];</span><br><span class="line">int a[maxn];</span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    for(int i=0;i&lt;=n;i++)&#123;</span><br><span class="line">        fa[i]=i;</span><br><span class="line">        r[i]=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Find(int x)&#123;</span><br><span class="line">    return x==fa[x]?x:Find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Merge(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int t1=Find(x),t2=Find(y);</span><br><span class="line">    if(t1==t2) return ;//已合并返回</span><br><span class="line">    if(r[t1]&gt;r[t2]) fa[t2]=t1;  //把y的祖先t2和并到x的祖先t1上。因以t1为根的树更高</span><br><span class="line">    else &#123;</span><br><span class="line">        fa[t1]=t2;</span><br><span class="line">        if(r[t1]==r[t2]) r[t2]++; //若两树一样高，那么合并后，高度加一。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int sum[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    init();</span><br><span class="line">    memset(sum,0,sizeof(sum));</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int flag,x,y,z;</span><br><span class="line">        cin&gt;&gt;flag;</span><br><span class="line">        if(flag==1)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">            int cnt=0;</span><br><span class="line">            for(int j=y+1;j&lt;=z;j++)&#123;</span><br><span class="line">                Merge(j,j-1);</span><br><span class="line">                cnt+=a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            Merge(x,y);</span><br><span class="line">            cnt+=a[y];</span><br><span class="line">            sum[fa[x]]+=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            sum[fa[x]]=sum[fa[x]]-a[x]+y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int minn=0x3f3f3f3f;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(fa[i]==i)&#123;</span><br><span class="line">            minn=min(minn,sum[fa[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;minn&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加权并查集"><a href="#加权并查集" class="headerlink" title="加权并查集"></a>加权并查集</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">int n,m,s[N],p[N],ans;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    ans=0;</span><br><span class="line">    memset(s,0,sizeof(s));</span><br><span class="line">    for(int i=0;i&lt;N;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fd(int x) &#123; ///此时find不单有查找任务，还有更新距离任务</span><br><span class="line">    if(x==p[x]) return x;</span><br><span class="line">    int t=p[x];</span><br><span class="line">    p[x]=fd(p[x]);</span><br><span class="line">    s[x]+=s[t]; ///记录到根节点的距离，一定要有一个思想，根节点是一个区间的一个端点而不是一个区间，输入的区间被合并成了两个点</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Union(int a,int b,int num) &#123;</span><br><span class="line">    int x=fd(a),y=fd(b);</span><br><span class="line">    if(x==y) &#123;</span><br><span class="line">        if(s[b]!=s[a]+num) ans++;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        p[y]=x;</span><br><span class="line">        s[y]=s[a]+num-s[b]; ///y到x的距离等于a到x的距离+b到a的距离-b到y的距离</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m) &#123;</span><br><span class="line">        init();</span><br><span class="line">        for(int i=0;i&lt;m;i++) &#123;</span><br><span class="line">            int a,b,c;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            Union(a-1,b,c);</span><br><span class="line">            ///等价于Union(a,b+1,c);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e6+7;</span><br><span class="line">int a[maxn];</span><br><span class="line">int maxq[maxn];</span><br><span class="line">int minq[maxn];</span><br><span class="line">int q[maxn];</span><br><span class="line">int n,k;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;k)&#123;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        int head,tail,t;</span><br><span class="line">        memset(q,0,sizeof(q));</span><br><span class="line">        head=1,tail=1;</span><br><span class="line">        q[tail]=1;</span><br><span class="line">        minq[1]=a[1];</span><br><span class="line">        for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">            while(head&lt;=tail&amp;&amp;a[i]&lt;a[q[tail]])</span><br><span class="line">                tail--;</span><br><span class="line">            q[++tail]=i;</span><br><span class="line">            if(head&lt;=tail&amp;&amp;q[head]&lt;i-k+1)</span><br><span class="line">                head++;</span><br><span class="line">            minq[i]=a[q[head]];</span><br><span class="line">        &#125;</span><br><span class="line">        memset(q,0,sizeof(q));</span><br><span class="line">        head=1,tail=1;</span><br><span class="line">        q[tail]=1;</span><br><span class="line">        maxq[1]=a[1];</span><br><span class="line">        for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">            while(head&lt;=tail&amp;&amp;a[i]&gt;a[q[tail]])</span><br><span class="line">                tail--;</span><br><span class="line">            q[++tail]=i;</span><br><span class="line">            if(head&lt;=tail&amp;&amp;q[head]&lt;i-k+1)</span><br><span class="line">                head++;</span><br><span class="line">            maxq[i]=a[q[head]];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=k;i&lt;n;i++)</span><br><span class="line">            cout&lt;&lt;minq[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;minq[n]&lt;&lt;endl;</span><br><span class="line">        for(int i=k;i&lt;n;i++)</span><br><span class="line">            cout&lt;&lt;maxq[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;maxq[n]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int head[maxn], cnt;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, u, w;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    //memset(edge, 0, sizeof(edge));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h2><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,i,num[100001],t[200001],l,r;//num:原数组；t：树状数组</span><br><span class="line">int lowbit(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line">void change(int x,int p)//将第x个数加p</span><br><span class="line">&#123;</span><br><span class="line">    while(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=p;</span><br><span class="line">        x+=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int sum(int k)//前k个数的和</span><br><span class="line">&#123;</span><br><span class="line">    int ans=0;</span><br><span class="line">    while(k&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[k];</span><br><span class="line">        k-=lowbit(k);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int ask(int l,int r)//求l-r区间和</span><br><span class="line">&#123;</span><br><span class="line">    return sum(r)-sum(l-1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">        change(i,num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=1;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        cout&lt;&lt;ask(l,r)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define MAXN 100010</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">    int l,r;//区间[l,r]</span><br><span class="line">    int add;//区间的延时标记</span><br><span class="line">    int sum;//区间和</span><br><span class="line">    int mx; //区间最大值</span><br><span class="line">    int mn; //区间最小值</span><br><span class="line">&#125;tree[MAXN&lt;&lt;2];//一定要开到4倍多的空间</span><br><span class="line"></span><br><span class="line">void pushup(int index)&#123;</span><br><span class="line">    tree[index].sum = tree[index&lt;&lt;1].sum+tree[index&lt;&lt;1|1].sum;</span><br><span class="line">    tree[index].mx = max(tree[index&lt;&lt;1].mx,tree[index&lt;&lt;1|1].mx);</span><br><span class="line">    tree[index].mn = min(tree[index&lt;&lt;1].mn,tree[index&lt;&lt;1|1].mn);</span><br><span class="line">&#125;</span><br><span class="line">void pushdown(int index)&#123;</span><br><span class="line">    //说明该区间之前更新过</span><br><span class="line">    //要想更新该区间下面的子区间，就要把上次更新该区间的值向下更新</span><br><span class="line">    if(tree[index].add)&#123;</span><br><span class="line">        //替换原来的值</span><br><span class="line">        /*</span><br><span class="line">        tree[index&lt;&lt;1].sum = (tree[index&lt;&lt;1].r-tree[index&lt;&lt;1].l+1)*tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].sum = (tree[index&lt;&lt;1|1].r-tree[index&lt;&lt;1|1].l+1)*tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1].mx = tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].mx = tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1].mn = tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].mn = tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1].add = tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].add = tree[index].add;</span><br><span class="line">        tree[index].add = 0;*/</span><br><span class="line">        //在原来的值的基础上加上val</span><br><span class="line"></span><br><span class="line">        tree[index&lt;&lt;1].sum += (tree[index&lt;&lt;1].r-tree[index&lt;&lt;1].l+1)*tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].sum +=(tree[index&lt;&lt;1|1].r-tree[index&lt;&lt;1|1].l+1)*tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1].mx += tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].mx += tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1].mn += tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].mn += tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1].add += tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].add += tree[index].add;</span><br><span class="line">        tree[index].add = 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void build(int l,int r,int index)&#123;</span><br><span class="line">    tree[index].l = l;</span><br><span class="line">    tree[index].r = r;</span><br><span class="line">    tree[index].add = 0;//刚开始一定要清0</span><br><span class="line">    if(l == r)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;tree[index].sum);</span><br><span class="line">        tree[index].mn = tree[index].mx = tree[index].sum;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (l+r)&gt;&gt;1;</span><br><span class="line">    build(l,mid,index&lt;&lt;1);</span><br><span class="line">    build(mid+1,r,index&lt;&lt;1|1);</span><br><span class="line">    pushup(index);</span><br><span class="line">&#125;</span><br><span class="line">void updata(int l,int r,int index,int val)&#123;</span><br><span class="line">    if(l &lt;= tree[index].l &amp;&amp; r &gt;= tree[index].r)&#123;</span><br><span class="line">        /*把原来的值替换成val,因为该区间有tree[index].r-tree[index].l+1</span><br><span class="line">        个数，所以区间和 以及 最值为：</span><br><span class="line">        */</span><br><span class="line">        /*tree[index].sum = (tree[index].r-tree[index].l+1)*val;</span><br><span class="line">        tree[index].mn = val;</span><br><span class="line">        tree[index].mx = val;</span><br><span class="line">        tree[index].add = val;//延时标记*/</span><br><span class="line">        //在原来的值的基础上加上val,因为该区间有tree[index].r-tree[index].l+1</span><br><span class="line">        //个数，所以区间和 以及 最值为：</span><br><span class="line">        tree[index].sum += (tree[index].r-tree[index].l+1)*val;</span><br><span class="line">        tree[index].mn += val;</span><br><span class="line">        tree[index].mx += val;</span><br><span class="line">        tree[index].add += val;//延时标记</span><br><span class="line"></span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(index);</span><br><span class="line">    int mid = (tree[index].l+tree[index].r)&gt;&gt;1;</span><br><span class="line">    if(l &lt;= mid)&#123;</span><br><span class="line">        updata(l,r,index&lt;&lt;1,val);</span><br><span class="line">    &#125;</span><br><span class="line">    if(r &gt; mid)&#123;</span><br><span class="line">        updata(l,r,index&lt;&lt;1|1,val);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(index);</span><br><span class="line">&#125;</span><br><span class="line">int query(int l,int r,int index)&#123;</span><br><span class="line">    if(l &lt;= tree[index].l &amp;&amp; r &gt;= tree[index].r)&#123;</span><br><span class="line">        //return tree[index].sum;</span><br><span class="line">        return tree[index].mx;</span><br><span class="line">        //return tree[index].mn;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(index);</span><br><span class="line">    int mid = (tree[index].l+tree[index].r)&gt;&gt;1;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    int Max = 0;</span><br><span class="line">    int Min = inf;</span><br><span class="line">    if(l &lt;= mid)&#123;</span><br><span class="line">        ans += query(l,r,index&lt;&lt;1);</span><br><span class="line">        Max = max(query(l,r,index&lt;&lt;1),Max);</span><br><span class="line">        Min = min(query(l,r,index&lt;&lt;1),Min);</span><br><span class="line">    &#125;</span><br><span class="line">    if(r &gt; mid)&#123;</span><br><span class="line">        ans += query(l,r,index&lt;&lt;1|1);</span><br><span class="line">        Max = max(query(l,r,index&lt;&lt;1|1),Max);</span><br><span class="line">        Min = min(query(l,r,index&lt;&lt;1|1),Min);</span><br><span class="line">    &#125;</span><br><span class="line">    //return ans;</span><br><span class="line">    return Max;</span><br><span class="line">    //return Min;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,q,x,y,z;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">        build(1,n,1);</span><br><span class="line">        while(m--)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">            if(q == 1)&#123;</span><br><span class="line">                cout&lt;&lt;&quot;查询:(x,y)&quot;&lt;&lt;endl;</span><br><span class="line">                scanf(&quot;%d %d&quot;,&amp;x,&amp;y);</span><br><span class="line">                cout&lt;&lt;query(x,y,1)&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                cout&lt;&lt;&quot;更新(x,y)为z：&quot;&lt;&lt;endl;</span><br><span class="line">                scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z);</span><br><span class="line">                updata(x,y,1,z);</span><br><span class="line">                for(int i = 1; i &lt;= n; ++i)&#123;</span><br><span class="line">                    printf(&quot;a[%d] = %d\n&quot;,i,query(i,i,1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// luogu-judger-enable-o2</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[100010],hash[101000],tot,root[201000],cnt,n,m,tt,qll[200100],qrr[20000];</span><br><span class="line">int q1,q2,id[201000],b[201000];</span><br><span class="line">struct TREE</span><br><span class="line">&#123;</span><br><span class="line">    int ln,rn,zhi;</span><br><span class="line">&#125;t[10010000];</span><br><span class="line">struct NODE</span><br><span class="line">&#123;</span><br><span class="line">    int l,r,k,flag;</span><br><span class="line">&#125;q[100100];</span><br><span class="line">int lowbit(int x) &#123;return (x)&amp;(-x);&#125;</span><br><span class="line">void gai(int &amp;node,int l,int r,int hs,int v)</span><br><span class="line">&#123;</span><br><span class="line">    if(!node) node=++tot;</span><br><span class="line">    t[node].zhi+=v;</span><br><span class="line">    if(l==r) return;</span><br><span class="line">    int mid=(l+r)/2;</span><br><span class="line">    if(hs&lt;=mid) gai(t[node].ln,l,mid,hs,v);</span><br><span class="line">    else gai(t[node].rn,mid+1,r,hs,v);</span><br><span class="line">&#125;</span><br><span class="line">void add(int p,int v)</span><br><span class="line">&#123;</span><br><span class="line">    hash[p]=lower_bound(a+1,a+1+tt,hash[p])-a;</span><br><span class="line">    //cout&lt;&lt;hash[p]&lt;&lt;endl;</span><br><span class="line">    for(int i=p;i&lt;=n;i+=lowbit(i)) gai(root[i],1,tt,hash[p],v);</span><br><span class="line">&#125;</span><br><span class="line">char s[2];</span><br><span class="line">int SUM()</span><br><span class="line">&#123;</span><br><span class="line">    int ans1=0,ans2=0;</span><br><span class="line">    for(int i=1;i&lt;=q1;i++) ans1+=t[t[qrr[i]].ln].zhi;</span><br><span class="line">    for(int i=1;i&lt;=q2;i++) ans2+=t[t[qll[i]].ln].zhi;</span><br><span class="line">    return ans1-ans2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int cha(int qr,int ql,int l,int r,int k)</span><br><span class="line">&#123;</span><br><span class="line">    q1=0,q2=0;</span><br><span class="line">    for(int i=qr;i&gt;=1;i-=lowbit(i)) qrr[++q1]=root[i];</span><br><span class="line">    for(int i=ql;i&gt;=1;i-=lowbit(i)) qll[++q2]=root[i];</span><br><span class="line">    while(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        int lsiz=SUM(),mid=(l+r)/2;</span><br><span class="line">        if(k&lt;=lsiz) </span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=1;i&lt;=q1;i++) qrr[i]=t[qrr[i]].ln;</span><br><span class="line">            for(int i=1;i&lt;=q2;i++) qll[i]=t[qll[i]].ln;</span><br><span class="line">            r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=1;i&lt;=q1;i++) qrr[i]=t[qrr[i]].rn;</span><br><span class="line">            for(int i=1;i&lt;=q2;i++) qll[i]=t[qll[i]].rn;</span><br><span class="line">            l=mid+1;k-=lsiz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int x,y,z;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);b[i]=a[i];</span><br><span class="line">        hash[++cnt]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%s&quot;,s);</span><br><span class="line">        if(s[0]==&apos;Q&apos;)</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;q[i].l,&amp;q[i].r,&amp;q[i].k),q[i].flag=1;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r);</span><br><span class="line">            a[++cnt]=q[i].r;hash[cnt]=a[cnt];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+1,a+1+cnt);</span><br><span class="line">    tt=unique(a+1,a+1+cnt)-a-1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    add(i,1);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(q[i].flag==1)</span><br><span class="line">        printf(&quot;%d\n&quot;,a[cha(q[i].r,q[i].l-1,1,tt,q[i].k)]);</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            hash[q[i].l]=b[q[i].l];</span><br><span class="line">            add(q[i].l,-1);</span><br><span class="line">            hash[q[i].l]=q[i].r;</span><br><span class="line">            b[q[i].l]=q[i].r;</span><br><span class="line">            add(q[i].l,1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="划分树"><a href="#划分树" class="headerlink" title="划分树"></a>划分树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** 划分树（查询区间第 k 大）*/</span><br><span class="line">const int MAXN = 100010;</span><br><span class="line">int tree[20][MAXN];//表示每层每个位置的值</span><br><span class="line">int sorted[MAXN];//已经排序好的数</span><br><span class="line">int toleft[20][MAXN];//toleft[p][i] 表示第 i 层从 1 到 i 有数分入左边</span><br><span class="line">void build(int l,int r,int dep)</span><br><span class="line">&#123;</span><br><span class="line">    if(l == r)</span><br><span class="line">        return;</span><br><span class="line">    int mid = (l+r)&gt;&gt;1;</span><br><span class="line">    int same = mid − l + 1;//表示等于中间值而且被分入左边的个数</span><br><span class="line">    for(int i = l; i &lt;= r; i++) //注意是 l, 不是 one</span><br><span class="line">        if(tree[dep][i] &lt; sorted[mid])</span><br><span class="line">            same−−;</span><br><span class="line">    int lpos = l;</span><br><span class="line">    int rpos = mid+1;</span><br><span class="line">    for(int i = l; i &lt;= r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(tree[dep][i] &lt; sorted[mid])</span><br><span class="line">            tree[dep+1][lpos++] = tree[dep][i];</span><br><span class="line">        else if(tree[dep][i] == sorted[mid] &amp;&amp; same &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            tree[dep+1][lpos++] = tree[dep][i];</span><br><span class="line">            same−−;</span><br><span class="line">        &#125;</span><br><span class="line">        elsetree[dep+1][rpos++] = tree[dep][i];</span><br><span class="line">        toleft[dep][i] = toleft[dep][l−1] + lpos − l</span><br><span class="line">    &#125;</span><br><span class="line">    build(l,mid,dep+1);</span><br><span class="line">    build(mid+1,r,dep+1);</span><br><span class="line">&#125;</span><br><span class="line">//查询区间第 k 大的数,[L,R] 是大区间，[l,r] 是要查询的小区间</span><br><span class="line">int query(int L,int R,int l,int r,int dep,int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(l == r)</span><br><span class="line">        return tree[dep][l];</span><br><span class="line">    int mid = (L+R)&gt;&gt;1;</span><br><span class="line">    int cnt = toleft[dep][r] − toleft[dep][l−1];</span><br><span class="line">    if(cnt &gt;= k)</span><br><span class="line">    &#123;</span><br><span class="line">        int newl = L + toleft[dep][l−1] − toleft[dep][L−1];</span><br><span class="line">        int newr = newl + cnt − 1;</span><br><span class="line">        return query(L,mid,newl,newr,dep+1,k);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        int newr = r + toleft[dep][R] − toleft[dep][r];</span><br><span class="line">        int newl = newr − (r−l−cnt);</span><br><span class="line">        return query(mid+1,R,newl,newr,dep+1,k−cnt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)==2)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(tree,0,sizeof(tree));</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;tree[0][i]);</span><br><span class="line">            sorted[i] = tree[0][i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(sorted+1,sorted+n+1);</span><br><span class="line">        build(1,n,0);</span><br><span class="line">        int s,t,k;</span><br><span class="line">        while(m−−)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;,&amp;s,&amp;t,&amp;k);</span><br><span class="line">            printf(&quot;%d\n&quot;,query(1,n,s,t,0,k));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+7;</span><br><span class="line">char s[maxn];</span><br><span class="line">int n,m;</span><br><span class="line">bool p;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int count;</span><br><span class="line">    node * next[26];</span><br><span class="line">&#125;*root;</span><br><span class="line">node * build()</span><br><span class="line">&#123;</span><br><span class="line">    node * k=new(node);</span><br><span class="line">    k-&gt;count=0;</span><br><span class="line">    memset(k-&gt;next,0,sizeof(k-&gt;next));</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br><span class="line">void insert()</span><br><span class="line">&#123;</span><br><span class="line">    node * r=root;</span><br><span class="line">    char * word=s;</span><br><span class="line">     while(*word)</span><br><span class="line">    &#123;</span><br><span class="line">        int id=*word-&apos;a&apos;;</span><br><span class="line">        if(r-&gt;next[id]==NULL) r-&gt;next[id]=build();</span><br><span class="line">        r=r-&gt;next[id];</span><br><span class="line">        r-&gt;count++;</span><br><span class="line">        word++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int search()</span><br><span class="line">&#123;</span><br><span class="line">    node * r=root;</span><br><span class="line">    char * word=s;</span><br><span class="line">    while(*word)</span><br><span class="line">    &#123;</span><br><span class="line">        int id=*word-&apos;a&apos;;</span><br><span class="line">        r=r-&gt;next[id];</span><br><span class="line">        if(r==NULL) return 0;</span><br><span class="line">        word++;</span><br><span class="line">    &#125;</span><br><span class="line">    return r-&gt;count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	char str[11];</span><br><span class="line">	int i,j;</span><br><span class="line">	root=(struct dictree*)malloc(sizeof(struct dictree));</span><br><span class="line">	for(i=0;i&lt;26;i++)</span><br><span class="line">	root-&gt;child[i]=0;</span><br><span class="line">	root-&gt;n=2;</span><br><span class="line">	while(gets(str),strcmp(str,&quot;&quot;)!=0)&#123;</span><br><span class="line">		insert(str);</span><br><span class="line">	&#125;</span><br><span class="line">	while(scanf(&quot;%s&quot;,str)!=EOF)&#123;</span><br><span class="line">		printf(&quot;%d\n&quot;,find(str));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> /*</span><br><span class="line">                 An implementation of top-down splaying</span><br><span class="line">                     D. Sleator &lt;sleator@cs.cmu.edu&gt;</span><br><span class="line">                              March 1992</span><br><span class="line">  */</span><br><span class="line"> #include &lt;stdlib.h&gt;</span><br><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line">  int size;  /* number of nodes in the tree */</span><br><span class="line">            /* Not actually needed for any of the operations */</span><br><span class="line"> typedef struct tree_node Tree;</span><br><span class="line">  struct tree_node</span><br><span class="line"> &#123;</span><br><span class="line">     Tree * left, * right;</span><br><span class="line">     int item;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> Tree * splay (int i, Tree * t)</span><br><span class="line"> &#123;</span><br><span class="line">  /* Simple top down splay, not requiring i to be in the tree t.  */</span><br><span class="line">  /* What it does is described above.                             */</span><br><span class="line">     Tree N, *l, *r, *y;</span><br><span class="line">     if (t == NULL)</span><br><span class="line">         return t;</span><br><span class="line">     N.left = N.right = NULL;</span><br><span class="line">     l = r = &amp;N;</span><br><span class="line">     for (;;)</span><br><span class="line">     &#123;</span><br><span class="line">         if (i &lt; t-&gt;item)</span><br><span class="line">         &#123;</span><br><span class="line">             if (t-&gt;left == NULL)</span><br><span class="line">             &#123;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">             if (i &lt; t-&gt;left-&gt;item)</span><br><span class="line">             &#123;</span><br><span class="line">                 y = t-&gt;left;                           /* rotate right */</span><br><span class="line">                 t-&gt;left = y-&gt;right;</span><br><span class="line">                 y-&gt;right = t;</span><br><span class="line">                 t = y;</span><br><span class="line">                 if (t-&gt;left == NULL)</span><br><span class="line">                 &#123;</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             r-&gt;left = t;                               /* link right */</span><br><span class="line">             r = t;</span><br><span class="line">             t = t-&gt;left;</span><br><span class="line">         &#125;     </span><br><span class="line">         else if (i &gt; t-&gt;item)</span><br><span class="line">         &#123;    </span><br><span class="line">             if (t-&gt;right == NULL)</span><br><span class="line">             &#123;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">             if (i &gt; t-&gt;right-&gt;item)</span><br><span class="line">             &#123;</span><br><span class="line">                 y = t-&gt;right;                          /* rotate left */</span><br><span class="line">                 t-&gt;right = y-&gt;left;</span><br><span class="line">                 y-&gt;left = t;</span><br><span class="line">                 t = y;</span><br><span class="line">                 if (t-&gt;right == NULL)</span><br><span class="line">                 &#123;</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             l-&gt;right = t;                              /* link left */</span><br><span class="line">             l = t;</span><br><span class="line">             t = t-&gt;right;</span><br><span class="line">         &#125;     </span><br><span class="line">         else    </span><br><span class="line">         &#123;</span><br><span class="line">             break;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     l-&gt;right = t-&gt;left;                                /* assemble */</span><br><span class="line">     r-&gt;left = t-&gt;right;</span><br><span class="line">     t-&gt;left = N.right;</span><br><span class="line">     t-&gt;right = N.left;</span><br><span class="line">     return t;</span><br><span class="line"> &#125;</span><br><span class="line">  /* Here is how sedgewick would have written this.                    */</span><br><span class="line"> /* It does the same thing.                                           */</span><br><span class="line"> Tree * sedgewickized_splay (int i, Tree * t)</span><br><span class="line"> &#123;</span><br><span class="line">     Tree N, *l, *r, *y;</span><br><span class="line">     if (t == NULL)</span><br><span class="line">     &#123;</span><br><span class="line">         return t;</span><br><span class="line">     &#125;</span><br><span class="line">     N.left = N.right = NULL;</span><br><span class="line">     l = r = &amp;N;</span><br><span class="line">     for (;;)</span><br><span class="line">     &#123;</span><br><span class="line">         if (i &lt; t-&gt;item)</span><br><span class="line">         &#123;</span><br><span class="line">             if (t-&gt;left != NULL &amp;&amp; i &lt; t-&gt;left-&gt;item)</span><br><span class="line">             &#123;</span><br><span class="line">                 y = t-&gt;left;</span><br><span class="line">                 t-&gt;left = y-&gt;right;</span><br><span class="line">                 y-&gt;right = t;</span><br><span class="line">                 t = y;</span><br><span class="line">             &#125;</span><br><span class="line">             if (t-&gt;left == NULL)</span><br><span class="line">             &#123;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">             r-&gt;left = t;</span><br><span class="line">             r = t;</span><br><span class="line">             t = t-&gt;left;</span><br><span class="line">         &#125;</span><br><span class="line">         else if (i &gt; t-&gt;item)</span><br><span class="line">         &#123;</span><br><span class="line">             if (t-&gt;right != NULL &amp;&amp; i &gt; t-&gt;right-&gt;item)</span><br><span class="line">             &#123;</span><br><span class="line">                 y = t-&gt;right;</span><br><span class="line">                 t-&gt;right = y-&gt;left;</span><br><span class="line">                 y-&gt;left = t;</span><br><span class="line">                 t = y;</span><br><span class="line">             &#125;</span><br><span class="line">             if (t-&gt;right == NULL)</span><br><span class="line">             &#123;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">             l-&gt;right = t;</span><br><span class="line">             l = t;</span><br><span class="line">             t = t-&gt;right;</span><br><span class="line">         &#125;</span><br><span class="line">         else</span><br><span class="line">         &#123;</span><br><span class="line">             break;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     l-&gt;right=t-&gt;left;</span><br><span class="line">     r-&gt;left=t-&gt;right;</span><br><span class="line">     t-&gt;left=N.right;</span><br><span class="line">     t-&gt;right=N.left;</span><br><span class="line">     return t;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> Tree * insert(int i, Tree * t)</span><br><span class="line"> &#123;</span><br><span class="line"> /* Insert i into the tree t, unless it&apos;s already there.    */</span><br><span class="line"> /* Return a pointer to the resulting tree.                 */</span><br><span class="line">     Tree * new;</span><br><span class="line">     </span><br><span class="line">     new = (Tree *) malloc (sizeof (Tree));</span><br><span class="line">     if (new == NULL)</span><br><span class="line">     &#123;</span><br><span class="line">         printf(&quot;Ran out of space\n&quot;);</span><br><span class="line">         exit(1);</span><br><span class="line">     &#125;</span><br><span class="line">     new-&gt;item = i;</span><br><span class="line">     if (t == NULL)</span><br><span class="line">     &#123;</span><br><span class="line">         new-&gt;left = new-&gt;right = NULL;</span><br><span class="line">         size = 1;</span><br><span class="line">         return new;</span><br><span class="line">     &#125;</span><br><span class="line">     t = splay(i,t);</span><br><span class="line">     if (i &lt; t-&gt;item)</span><br><span class="line">     &#123;</span><br><span class="line">         new-&gt;left = t-&gt;left;</span><br><span class="line">         new-&gt;right = t;</span><br><span class="line">         t-&gt;left = NULL;</span><br><span class="line">         size ++;</span><br><span class="line">         return new;</span><br><span class="line">     &#125;</span><br><span class="line">     else if (i &gt; t-&gt;item)</span><br><span class="line">     &#123;</span><br><span class="line">         new-&gt;right = t-&gt;right;</span><br><span class="line">         new-&gt;left = t;</span><br><span class="line">         t-&gt;right = NULL;</span><br><span class="line">         size++;</span><br><span class="line">         return new;</span><br><span class="line">     &#125;</span><br><span class="line">     else</span><br><span class="line">     &#123;</span><br><span class="line">         /* We get here if it&apos;s already in the tree */</span><br><span class="line">         /* Don&apos;t add it again                      */</span><br><span class="line">         free(new);</span><br><span class="line">         return t;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree * delete(int i, Tree * t)</span><br><span class="line">&#123;</span><br><span class="line">/* Deletes i from the tree if it&apos;s there.               */</span><br><span class="line">/* Return a pointer to the resulting tree.              */</span><br><span class="line">    Tree * x;</span><br><span class="line">    if (t==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    t = splay(i,t);</span><br><span class="line">    if (i == t-&gt;item)</span><br><span class="line">    &#123;               /* found it */</span><br><span class="line">        if (t-&gt;left == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            x = t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            x = splay(i, t-&gt;left);</span><br><span class="line">            x-&gt;right = t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        free(t);</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;                         /* It wasn&apos;t there */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argv, char *argc[])</span><br><span class="line">&#123;</span><br><span class="line">/* A sample use of these functions.  Start with the empty tree,         */</span><br><span class="line">/* insert some stuff into it, and then delete it                        */</span><br><span class="line">    Tree * root;</span><br><span class="line">    int i;</span><br><span class="line">    root = NULL;              /* the empty tree */</span><br><span class="line">    size = 0;</span><br><span class="line">    for (i = 0; i &lt; 1024; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        root = insert((541*i) &amp; (1023), root);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;size = %d\n&quot;, size);</span><br><span class="line">    for (i = 0; i &lt; 1024; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        root = delete((541*i) &amp; (1023), root);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;size = %d\n&quot;, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LCA-Tarjan"><a href="#LCA-Tarjan" class="headerlink" title="LCA(Tarjan)"></a>LCA(Tarjan)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e4 + 7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, head[maxn], fa[maxn], head_2[maxn], cnt, cnt_2, sx;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, u;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line">struct QUERY&#123;</span><br><span class="line">    int next, to, u, lca;</span><br><span class="line">&#125;query[maxn];</span><br><span class="line">void add_edge(int u, int v)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add_query(int u, int v)&#123;</span><br><span class="line">    query[cnt_2].next = head_2[u];</span><br><span class="line">    query[cnt_2].to = v;</span><br><span class="line">    query[cnt_2].u = u;</span><br><span class="line">    head_2[u] = cnt_2++;</span><br><span class="line">    query[cnt_2].next = head_2[v];</span><br><span class="line">    query[cnt_2].to = u;</span><br><span class="line">    query[cnt_2].u = v;</span><br><span class="line">    head_2[v] = cnt_2++;</span><br><span class="line">&#125;</span><br><span class="line">void init_edge()&#123;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">void init_query()&#123;</span><br><span class="line">    memset(head_2, -1, sizeof(head_2));</span><br><span class="line">    cnt_2 = 0;</span><br><span class="line">&#125;</span><br><span class="line">int root(int x)&#123;</span><br><span class="line">    return x = x == fa[x] ? x : root(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">void tarjan(int x) &#123;</span><br><span class="line">    fa[x] = x;</span><br><span class="line">    for (int i = head[x]; i != -1; i = edge[i].next) &#123;</span><br><span class="line">        int v = edge[i].to;</span><br><span class="line">        tarjan(v);</span><br><span class="line">        fa[root(v)] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = true;</span><br><span class="line">    for (int i = head_2[x]; i != -1; i = query[i].next) &#123;</span><br><span class="line">        int v = query[i].to;</span><br><span class="line">        if (vis[v]) &#123;</span><br><span class="line">            query[i].lca = query[i^1].lca = root(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    for(int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</span><br><span class="line">        add_edge(u, v);</span><br><span class="line">        vis[v] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i&lt;=n; i++)&#123;</span><br><span class="line">        if(!vis[i])&#123;</span><br><span class="line">            sx = i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</span><br><span class="line">    add_query(u, v);</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    tarjan(sx);</span><br><span class="line">    for(int i = 0; i &lt; cnt_2; i+=2)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, query[i].lca);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        init_edge();</span><br><span class="line">        init_query();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">2</span><br><span class="line">16</span><br><span class="line">1 14</span><br><span class="line">8 5</span><br><span class="line">10 16</span><br><span class="line">5 9</span><br><span class="line">4 6</span><br><span class="line">8 4</span><br><span class="line">4 10</span><br><span class="line">1 13</span><br><span class="line">6 15</span><br><span class="line">10 11</span><br><span class="line">6 7</span><br><span class="line">10 2</span><br><span class="line">16 3</span><br><span class="line">8 1</span><br><span class="line">16 12</span><br><span class="line">16 7</span><br><span class="line">5</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">3 1</span><br><span class="line">1 5</span><br><span class="line">3 5</span><br><span class="line">*/</span><br><span class="line">//4 3</span><br></pre></td></tr></table></figure>
<h2 id="RMQ"><a href="#RMQ" class="headerlink" title="RMQ"></a>RMQ</h2><h3 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn=1e5+7;</span><br><span class="line">int stmax[maxn][30];</span><br><span class="line">int stmin[maxn][30];</span><br><span class="line">int a[maxn];</span><br><span class="line"></span><br><span class="line">void rmq_st(int n)&#123;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        stmax[i][0]=stmin[i][0]=a[i];</span><br><span class="line">    int m=(int)(double(log(n))/log(2.0));</span><br><span class="line">    for(int j=1;j&lt;=m;j++)</span><br><span class="line">    for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++)&#123;</span><br><span class="line">        stmax[i][j]=max(stmax[i][j-1],stmax[i+(1&lt;&lt;j-1)][j-1]);</span><br><span class="line">        stmin[i][j]=min(stmin[i][j-1],stmin[i+(1&lt;&lt;j-1)][j-1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void rmq_query(int l,int r)&#123;</span><br><span class="line">    int k=(int)((double)log(r-l+1)/log(2.0));</span><br><span class="line">    cout&lt;&lt;&quot;Max is : &quot;&lt;&lt;max(stmax[l][k],stmax[r-(1&lt;&lt;k)+1][k])&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;Min is : &quot;&lt;&lt;min(stmin[l][k],stmin[r-(1&lt;&lt;k)+1][k])&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    rmq_st(n);</span><br><span class="line">    int l,r;</span><br><span class="line">    while(cin&gt;&gt;l&gt;&gt;r)&#123;</span><br><span class="line">        rmq_query(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*	解释：</span><br><span class="line">		belong[x]x属于分块后的哪一块，Q[i]每个询问</span><br><span class="line">		modify(p,t)对p位置进行t修改，一般只有增加或者缩减这两种操作，具体问题具体分析</span><br><span class="line">	注意：</span><br><span class="line">		最后也可以不对询问id排序，直接保存到一个数组里面输出即可</span><br><span class="line">*/</span><br><span class="line">int a[nmax], belong[nmax];</span><br><span class="line">ll ans = 0;</span><br><span class="line">struct node &#123;int l, r, id;ll ans;&#125; Q[nmax];</span><br><span class="line">bool cmp(node a, node b) &#123;</span><br><span class="line">	if (belong[a.l] != belong[b.l]) return a.l &lt; b.l;</span><br><span class="line">	else return a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line">bool cmpid(node a, node b) &#123;return a.id &lt; b.id;&#125;</span><br><span class="line">void modify(int pos, int tag) &#123;</span><br><span class="line">	// ......... 增删操作</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);</span><br><span class="line">	int sz = sqrt(n);</span><br><span class="line">	for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">	for (int i = 1; i &lt;= m; ++i) &#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i;</span><br><span class="line">		belong[i] = (i - 1) / sz + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(Q + 1, Q + 1 + m, cmp);</span><br><span class="line">	int l = 1, r = 0;</span><br><span class="line">	for (int i = 1; i &lt;= m; ++i) &#123;</span><br><span class="line">		while (l &lt; Q[i].l) modify(l++, -1);</span><br><span class="line">		while (l &gt; Q[i].l) modify(--l, 1);</span><br><span class="line">		while (r &gt; Q[i].r) modify(r--, -1);</span><br><span class="line">		while (r &lt; Q[i].r) modify(++r, 1);</span><br><span class="line">		Q[i].ans = ans;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(Q + 1, Q + 1 + m, cmpid);</span><br><span class="line">	for (int i = 1; i &lt;= m; ++i) printf(&quot;%I64d\n&quot;, Q[i].ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=3e5+5;//区间范围</span><br><span class="line">const int MAX=1e6+5;//最大数字</span><br><span class="line">int unit,cnt[MAX],arr[N],res[N],ans=0;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">    int l,r,id;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line">bool cmp(node a,node b)&#123;</span><br><span class="line">    return a.l/unit!=b.l/unit?a.l/unit&lt;b.l/unit:a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int pos)&#123;</span><br><span class="line">    cnt[arr[pos]]++;</span><br><span class="line">    if(cnt[arr[pos]]==1)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void remove(int pos)&#123;</span><br><span class="line">    cnt[arr[pos]]--;</span><br><span class="line">    if(cnt[arr[pos]]==0)&#123;</span><br><span class="line">        ans--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    unit=sqrt(n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    int m;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r);</span><br><span class="line">        q[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(q+1,q+m+1,cmp);</span><br><span class="line"></span><br><span class="line">    int L=q[1].l,R=L-1;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        while(L&gt;q[i].l)</span><br><span class="line">            add(--L);</span><br><span class="line">        while(L&lt;q[i].l)</span><br><span class="line">            remove(L++);</span><br><span class="line">        while(R&gt;q[i].r)</span><br><span class="line">            remove(R--);</span><br><span class="line">        while(R&lt;q[i].r)</span><br><span class="line">            add(++R);</span><br><span class="line">        res[q[i].id]=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int nValue,nKind;</span><br><span class="line">//0-1 背包，代价为 cost, 获得的价值为 weight</span><br><span class="line">void ZeroOnePack(int cost,int weight)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=nValue; i&gt;=cost; i−−)</span><br><span class="line">        dp[i]=max(dp[i],dp[i−cost]+weight);</span><br><span class="line">&#125;</span><br><span class="line">//完全背包，代价为 cost, 获得的价值为 weight</span><br><span class="line">void CompletePack(int cost,int weight)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=cost; i&lt;=nValue; i++)</span><br><span class="line">        dp[i]=max(dp[i],dp[i−cost]+weight);</span><br><span class="line">&#125;</span><br><span class="line">//多重背包</span><br><span class="line">void MultiplePack(int cost,int weight,int amount)</span><br><span class="line">&#123;</span><br><span class="line">    if(cost*amount&gt;=nValue)</span><br><span class="line">        CompletePack(cost,weight);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        int k=1;</span><br><span class="line">        while(k&lt;amount)</span><br><span class="line">        &#123;</span><br><span class="line">            ZeroOnePack(k*cost,k*weight);</span><br><span class="line">            amount−=k;</span><br><span class="line">            k&lt;&lt;=1;</span><br><span class="line">        &#125;</span><br><span class="line">        ZeroOnePack(amount*cost,amount*weight);//这个不要忘记了，经常掉了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//分组背包：</span><br><span class="line">for k = 1 to K</span><br><span class="line">for v = V to 0</span><br><span class="line">for item i in group k</span><br><span class="line">F[v] = maxF[v],F[v-Ci]+Wi</span><br></pre></td></tr></table></figure>
<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int MAXN=500010;</span><br><span class="line">int a[MAXN],b[MAXN]//用二分查找的方法找到一个位置，使得 num&gt;b[i-1] 并且 num&lt;b[i], 并用 num 代替</span><br><span class="line">b[i]int Search(int num,int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">    int mid;</span><br><span class="line">    while(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(low+high)/2;</span><br><span class="line">        if(num&gt;=b[mid])</span><br><span class="line">            low=mid+1;</span><br><span class="line">        else</span><br><span class="line">            high=mid−1;</span><br><span class="line">    &#125;</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br><span class="line">int DP(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,len,pos;</span><br><span class="line">    b[1]=a[1];</span><br><span class="line">    len=1;</span><br><span class="line">    for(i=2; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]&gt;=b[len])//如果 a[i] 比 b[] 数组中最大还大直接插入到后面即可</span><br><span class="line">        &#123;</span><br><span class="line">            len=len+1;</span><br><span class="line">            b[len]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        else //用二分的方法在 b[] 数组中找出第一个比 a[i] 大的位置并且让a[i] 替代这个位置</span><br><span class="line">        &#123;</span><br><span class="line">            pos=Search(a[i],1,len);</span><br><span class="line">            b[pos]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">const int MAXN = 1005;</span><br><span class="line"> </span><br><span class="line">int DP[MAXN][MAXN];</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	string a;</span><br><span class="line">	string b;</span><br><span class="line">	while(cin &gt;&gt; a &gt;&gt; b)</span><br><span class="line">	&#123;</span><br><span class="line">		int l1 = a.size();</span><br><span class="line">		int l2 = b.size();</span><br><span class="line">		memset(DP, 0, sizeof(DP)); </span><br><span class="line">		for(int i = 1; i &lt;= l1; i++)</span><br><span class="line">			for(int j = 1; j &lt;= l2; j++)</span><br><span class="line">				if(a[i - 1] == b[j - 1])</span><br><span class="line">					DP[i][j] = max(DP[i][j], DP[i - 1][j - 1] + 1);</span><br><span class="line">				else</span><br><span class="line">					DP[i][j] = max(DP[i][j - 1], DP[i - 1][j]);</span><br><span class="line">		printf(&quot;%d\n&quot;, DP[l1][l2]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="概率dp"><a href="#概率dp" class="headerlink" title="概率dp"></a>概率dp</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POJ 2096</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">POJ 2096</span><br><span class="line">概率DP</span><br><span class="line"></span><br><span class="line">dp求期望</span><br><span class="line">逆着递推求解</span><br><span class="line">题意：（题意看题目确实比较难道，n和s都要找半天才能找到）</span><br><span class="line">   一个软件有s个子系统，会产生n种bug</span><br><span class="line">   某人一天发现一个bug,这个bug属于一个子系统，属于一个分类</span><br><span class="line">   每个bug属于某个子系统的概率是1/s,属于某种分类的概率是1/n</span><br><span class="line">   问发现n种bug,每个子系统都发现bug的天数的期望。</span><br><span class="line"></span><br><span class="line">求解：</span><br><span class="line">         dp[i][j]表示已经找到i种bug,j个系统的bug，达到目标状态的天数的期望</span><br><span class="line">         dp[n][s]=0;要求的答案是dp[0][0];</span><br><span class="line">         dp[i][j]可以转化成以下四种状态:</span><br><span class="line">              dp[i][j],发现一个bug属于已经有的i个分类和j个系统。概率为(i/n)*(j/s);</span><br><span class="line">              dp[i][j+1],发现一个bug属于已有的分类，不属于已有的系统.概率为 (i/n)*(1-j/s);</span><br><span class="line">              dp[i+1][j],发现一个bug属于已有的系统，不属于已有的分类,概率为 (1-i/n)*(j/s);</span><br><span class="line">              dp[i+1][j+1],发现一个bug不属于已有的系统，不属于已有的分类,概率为 (1-i/n)*(1-j/s);</span><br><span class="line">        整理便得到转移方程</span><br><span class="line">*/</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1010;</span><br><span class="line">double dp[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,s;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;s)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[n][s]=0;</span><br><span class="line">        for(int i=n;i&gt;=0;i--)</span><br><span class="line">          for(int j=s;j&gt;=0;j--)</span><br><span class="line">          &#123;</span><br><span class="line">              if(i==n&amp;&amp;j==s)continue;</span><br><span class="line">              dp[i][j]=(i*(s-j)*dp[i][j+1]+(n-i)*j*dp[i+1][j]+(n-i)*(s-j)*dp[i+1][j+1]+n*s)/(n*s-i*j);</span><br><span class="line">          &#125;</span><br><span class="line">        printf(&quot;%.4lf\n&quot;,dp[0][0]);//POJ上G++要改成%.4f</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="轮廓线dp"><a href="#轮廓线dp" class="headerlink" title="轮廓线dp"></a>轮廓线dp</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">HDU 4285</span><br><span class="line">要形成刚好 K 条回路的方法数要避免环套环的情况。</span><br><span class="line">所以形成回路时，要保证两边的插头数是偶数</span><br><span class="line">G++ 11265ms 11820K</span><br><span class="line">C++ 10656ms 11764K</span><br><span class="line">*/</span><br><span class="line">const int MAXD=15;</span><br><span class="line">const int STATE=1000010;</span><br><span class="line">const int HASH=300007;//这个大一点可以防止 TLE, 但是容易 MLE</span><br><span class="line">const int MOD=1000000007;</span><br><span class="line">int N,M,K;</span><br><span class="line">int maze[MAXD][MAXD];</span><br><span class="line">int code[MAXD];</span><br><span class="line">int ch[MAXD];</span><br><span class="line">int num;//圈的个数</span><br><span class="line">struct HASHMAP</span><br><span class="line">&#123;</span><br><span class="line">    int head[HASH],next[STATE],size;</span><br><span class="line">    long long state[STATE];</span><br><span class="line">    int f[STATE];</span><br><span class="line">    void init()</span><br><span class="line">    &#123;</span><br><span class="line">        size=0;</span><br><span class="line">        memset(head,−1,sizeof(head));</span><br><span class="line">    &#125; void push(long long st,int ans)</span><br><span class="line">    &#123;</span><br><span class="line">        int i;</span><br><span class="line">        int h=st%HASH;</span><br><span class="line">        for(i=head[h]; i!=−1; i=next[i])</span><br><span class="line">            if(state[i]==st)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i]+=ans;</span><br><span class="line">                f[i]%=MOD;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        state[size]=st;</span><br><span class="line">        f[size]=ans;</span><br><span class="line">        next[size]=head[h];</span><br><span class="line">        head[h]=size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; hm[2];</span><br><span class="line">void decode(int *code,int m,long long st)</span><br><span class="line">&#123;</span><br><span class="line">    num=st&amp;63;</span><br><span class="line">    st&gt;&gt;=6;</span><br><span class="line">    for(int i=m; i&gt;=0; i−−)</span><br><span class="line">    &#123;</span><br><span class="line">        code[i]=st&amp;7;</span><br><span class="line">        st&gt;&gt;=3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">long long encode(int *code,int m)//最小表示法</span><br><span class="line">&#123;</span><br><span class="line">    int cnt=1;</span><br><span class="line">    memset(ch,−1,sizeof(ch));</span><br><span class="line">    ch[0]=0;</span><br><span class="line">    long long st=0;</span><br><span class="line">    for(int i=0; i&lt;=m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(ch[code[i]]==−1)</span><br><span class="line">            ch[code[i]]=cnt++;</span><br><span class="line">        code[i]=ch[code[i]];</span><br><span class="line">        st&lt;&lt;=3;</span><br><span class="line">        st|=code[i];</span><br><span class="line">    &#125;</span><br><span class="line">    st&lt;&lt;=6;</span><br><span class="line">    st|=num;</span><br><span class="line">    return st;</span><br><span class="line">&#125;</span><br><span class="line">void shift(int *code,int m)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=m; i&gt;0; i−−)</span><br><span class="line">        code[i]=code[i−1];</span><br><span class="line">    code[0]=0;</span><br><span class="line">&#125;</span><br><span class="line">void dpblank(int i,int j,int cur)</span><br><span class="line">&#123;</span><br><span class="line">    int k,left,up;</span><br><span class="line">    for(k=0; k&lt;hm[cur].size; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        decode(code,M,hm[cur].state[k]);</span><br><span class="line">        left=code[j−1];</span><br><span class="line">        up=code[j];</span><br><span class="line">        if(left&amp;&amp;up)</span><br><span class="line">        &#123;</span><br><span class="line">            if(left==up)</span><br><span class="line">            &#123;</span><br><span class="line">                if(num&gt;=K)</span><br><span class="line">                    continue;</span><br><span class="line">                int t=0;//要避免环套环的情况，需要两边插头数为偶数</span><br><span class="line">                for(int p=0; p&lt;j−1; p++)</span><br><span class="line">                    if(code[p])</span><br><span class="line">                        t++;</span><br><span class="line">                if(t&amp;1)</span><br><span class="line">                    continue;</span><br><span class="line">                if(num&lt;K)</span><br><span class="line">                &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    code[j−1]=code[j]=0;</span><br><span class="line">                    hm[cur^1].push(encode(code,j==M?M−1:M),hm[cur].f[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                code[j−1]=code[j]=0;</span><br><span class="line">                for(int t=0; t&lt;=M; t++)</span><br><span class="line">                    if(code[t]==up)</span><br><span class="line">                        code[t]=left;</span><br><span class="line">                hm[cur^1].push(encode(code,j==M?M−1:M),hm[cur].f[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(left||up)</span><br><span class="line">        &#123;</span><br><span class="line">            int t;</span><br><span class="line">            if(left)</span><br><span class="line">                t=left;</span><br><span class="line">            else</span><br><span class="line">                t=up;</span><br><span class="line">            if(maze[i][j+1])</span><br><span class="line">            &#123;</span><br><span class="line">                code[j−1]=0;</span><br><span class="line">                code[j]=t;</span><br><span class="line">                hm[cur^1].push(encode(code,M),hm[cur].f[k]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(maze[i+1][j])</span><br><span class="line">            &#123;</span><br><span class="line">                code[j]=0;</span><br><span class="line">                code[j−1]=t;</span><br><span class="line">                hm[cur^1].push(encode(code,j==M?M−1:M),hm[cur].f[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(maze[i][j+1]&amp;&amp;maze[i+1][j])</span><br><span class="line">            &#123;</span><br><span class="line">                code[j−1]=code[j]=13;</span><br><span class="line">                hm[cur^1].push(encode(code,j==M?M−1:M),hm[cur].f[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dpblock(int i,int j,int cur)</span><br><span class="line">&#123;</span><br><span class="line">    int k;</span><br><span class="line">    for(k=0; k&lt;hm[cur].size; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        decode(code,M,hm[cur].state[k]);</span><br><span class="line">        code[j−1]=code[j]=0;</span><br><span class="line">        hm[cur^1].push(encode(code,j==M?M−1:M),hm[cur].f[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">char str[20];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;N,&amp;M,&amp;K);</span><br><span class="line">    memset(maze,0,sizeof(maze));</span><br><span class="line">    for(int i=1; i&lt;=N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%s&quot;,&amp;str);</span><br><span class="line">        for(int j=1; j&lt;=M; j++)</span><br><span class="line">            if(str[j−1]==&apos;.&apos;)</span><br><span class="line">                maze[i][j]=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,cur=0;</span><br><span class="line">    hm[cur].init();</span><br><span class="line">    hm[cur].push(0,1);</span><br><span class="line">    for(i=1; i&lt;=N; i++)</span><br><span class="line">        for(j=1; j&lt;=M; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            hm[cur^1].init();</span><br><span class="line">            if(maze[i][j])</span><br><span class="line">                dpblank(i,j,cur);</span><br><span class="line">            else</span><br><span class="line">                dpblock(i,j,cur);</span><br><span class="line">            cur^=1;</span><br><span class="line">        &#125;</span><br><span class="line">    int ans=0;</span><br><span class="line">    for(i=0; i&lt;hm[cur].size; i++)</span><br><span class="line">        if(hm[cur].state[i]==K)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=hm[cur].f[i];</span><br><span class="line">            ans%=MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T−−)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">Sample Input</span><br><span class="line"> 4 4 1</span><br><span class="line"> **..</span><br><span class="line"> ....</span><br><span class="line"> ....</span><br><span class="line"> ....</span><br><span class="line"> 4 1</span><br><span class="line"> ....</span><br><span class="line"> ....</span><br><span class="line"> ....</span><br><span class="line"> ....</span><br><span class="line">Sample Output</span><br><span class="line"> 6</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="Dijkstra-邻接矩阵"><a href="#Dijkstra-邻接矩阵" class="headerlink" title="Dijkstra(邻接矩阵)"></a>Dijkstra(邻接矩阵)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 3007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int road[maxn][maxn];</span><br><span class="line">int dis[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(road, inf, sizeof(road));</span><br><span class="line">&#125;</span><br><span class="line">int dijkstra(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    for(int u = 1; u&lt;=n; u++)&#123;</span><br><span class="line">        int minD = inf, k = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i] &amp;&amp; dis[i] &lt; minD)&#123;</span><br><span class="line">                k = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //if(k == ex)</span><br><span class="line">        //    return dis[ex];</span><br><span class="line">        vis[k] = true;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i] &amp;&amp; dis[k] + road[k][i] &lt; dis[i])&#123;</span><br><span class="line">                dis[i] = dis[k] + road[k][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v, w;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        road[u][v] = min(road[u][v], w);</span><br><span class="line">        //road[v][u] = min(road[v][u], w);  //双向边</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, dijkstra(sx, ex));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 3007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;4];</span><br><span class="line">int head[maxn], dis[maxn], cnt;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">int dijkstra(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    for(int cas = 1; cas&lt;=n; cas++)&#123;</span><br><span class="line">        int minD = inf, kk = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i] &amp;&amp; dis[i] &lt; minD)&#123;</span><br><span class="line">                kk = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //if(kk == ex)</span><br><span class="line">        //    return dis[ex];</span><br><span class="line">        vis[kk] = true;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            int v = edge[i].to;</span><br><span class="line">            if(!vis[v] &amp;&amp; dis[kk] + edge[i].w &lt; dis[v])&#123;</span><br><span class="line">                dis[v] = dis[kk] + edge[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v, w;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        //add(v, u, w);  //双向边</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, dijkstra(sx, ex));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dijkstra-heap"><a href="#Dijkstra-heap" class="headerlink" title="Dijkstra+heap"></a>Dijkstra+heap</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 3007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;4];</span><br><span class="line">int head[maxn], dis[maxn], cnt;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int u;</span><br><span class="line">    int dis;</span><br><span class="line">    NODE()&#123;&#125;</span><br><span class="line">    NODE(int x, int y) : u(x), dis(y)&#123;&#125;</span><br><span class="line">    bool operator &lt;(const NODE &amp;a)const&#123;</span><br><span class="line">		return dis&gt;a.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">int dijkstra(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    priority_queue&lt;NODE&gt;que;</span><br><span class="line">    que.push(NODE(sx, 0));</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        NODE tmp = que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        int kk = tmp.u;</span><br><span class="line">        if(vis[kk])&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[kk] = true;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            int v = edge[i].to;</span><br><span class="line">            if(!vis[v] &amp;&amp; dis[kk] + edge[i].w &lt; dis[v])&#123;</span><br><span class="line">                dis[v] = dis[kk] + edge[i].w;</span><br><span class="line">                que.push(NODE(v, dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    int u, v, w;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        add(v, u, w);  //双向边</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, dijkstra(sx, ex));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">const int maxn = 1e3+7;</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">int head[maxn], dis[maxn], cnt;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, w, u;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">int SPFA(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[kk] = false;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            int v = edge[i].to;</span><br><span class="line">            if(dis[v] &gt; dis[kk] + edge[i].w)&#123;</span><br><span class="line">                dis[v] = dis[kk] + edge[i].w;</span><br><span class="line">                if(!vis[v])&#123;</span><br><span class="line">                    vis[v] = true;</span><br><span class="line">                    que.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        sx = 1, ex = n;</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            add(u, v, w);</span><br><span class="line">            //add(v, u, w);   //双向边</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, SPFA(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SPFA-SLF优化"><a href="#SPFA-SLF优化" class="headerlink" title="SPFA+SLF优化"></a>SPFA+SLF优化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN=1e2;</span><br><span class="line"></span><br><span class="line">int phi[MAXN],n,tot;</span><br><span class="line">int pri[MAXN];</span><br><span class="line">bool mark[MAXN];</span><br><span class="line"></span><br><span class="line">void getphi()&#123;</span><br><span class="line">    phi[1]=1;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!mark[i])&#123;</span><br><span class="line">            phi[i]=i-1;</span><br><span class="line">            pri[++tot]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=1;j&lt;=tot;j++)&#123;</span><br><span class="line">            int x=pri[j];</span><br><span class="line">            if(i*x&gt;n) break;</span><br><span class="line">            mark[i*x]=1;</span><br><span class="line">            if(i%x==0)&#123;</span><br><span class="line">                phi[i*x]=phi[i]*x;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else phi[i*x]=phi[i]*phi[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">        tot=0;</span><br><span class="line">        getphi();</span><br><span class="line"></span><br><span class="line">            printf(&quot;%d\n&quot;,phi[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(k=1; k&lt;=n; k++)</span><br><span class="line">    for(i=1; i&lt;=n; i++)</span><br><span class="line">        for(j=1; j&lt;=n; j++)</span><br><span class="line">            if(e[i][j]&gt;e[i][k]+e[k][j])</span><br><span class="line">                e[i][j]=e[i][k]+e[k][j];</span><br></pre></td></tr></table></figure>
<h3 id="K短路"><a href="#K短路" class="headerlink" title="K短路"></a>K短路</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * poj</span><br><span class="line"> * Problem#2449</span><br><span class="line"> * Accepted</span><br><span class="line"> * Time: 438ms</span><br><span class="line"> * Memory: 15196k </span><br><span class="line"> */</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef bool boolean;</span><br><span class="line"></span><br><span class="line">#define pii pair&lt;int, int&gt;</span><br><span class="line">#define fi first</span><br><span class="line">#define sc second</span><br><span class="line"></span><br><span class="line">typedef class Node &#123;</span><br><span class="line">    public:</span><br><span class="line">        int val, ed;</span><br><span class="line">        Node *l, *r;</span><br><span class="line">        </span><br><span class="line">        Node()    &#123;        &#125;</span><br><span class="line">        Node(int val, int ed, Node *l, Node *r):val(val), ed(ed), l(l), r(r) &#123;        &#125;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">#define Limit 1000000</span><br><span class="line"></span><br><span class="line">Node pool[Limit];</span><br><span class="line">Node* top = pool;</span><br><span class="line"></span><br><span class="line">Node* newnode(int val, int ed) &#123;</span><br><span class="line">    if(top &gt;= pool + Limit)</span><br><span class="line">        return new Node(val, ed, NULL, NULL);</span><br><span class="line">    top-&gt;val = val, top-&gt;ed = ed, top-&gt;l = top-&gt;r = NULL;</span><br><span class="line">    return top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* merge(Node* a, Node* b) &#123;</span><br><span class="line">    if (!a)    return b;</span><br><span class="line">    if (!b)    return a;</span><br><span class="line">    if (a-&gt;val &gt; b-&gt;val)    swap(a, b);</span><br><span class="line">    Node* p = newnode(a-&gt;val, a-&gt;ed);</span><br><span class="line">    p-&gt;l = a-&gt;l, p-&gt;r = a-&gt;r;</span><br><span class="line">    p-&gt;r = merge(p-&gt;r, b);</span><br><span class="line">    swap(p-&gt;l, p-&gt;r);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef class Status &#123;</span><br><span class="line">    public:</span><br><span class="line">        int dist;</span><br><span class="line">        Node* p;</span><br><span class="line">        </span><br><span class="line">        Status(int dist = 0, Node* p = NULL):dist(dist), p(p) &#123;        &#125;</span><br><span class="line"></span><br><span class="line">        boolean operator &lt; (Status b) const &#123;</span><br><span class="line">            return dist &gt; b.dist;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;Status;</span><br><span class="line"></span><br><span class="line">typedef class Edge &#123;</span><br><span class="line">    public:</span><br><span class="line">        int end, next, w;</span><br><span class="line">        </span><br><span class="line">        Edge(int end = 0, int next = 0, int w = 0):end(end), next(next), w(w) &#123;        &#125;</span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line">typedef class MapManager &#123;</span><br><span class="line">    public:</span><br><span class="line">        int ce;</span><br><span class="line">        int* h;</span><br><span class="line">        Edge* es;</span><br><span class="line">        </span><br><span class="line">        MapManager() &#123;            &#125;</span><br><span class="line">        MapManager(int n, int m):ce(0) &#123;</span><br><span class="line">            h = new int[(n + 1)];</span><br><span class="line">            es = new Edge[(m + 5)];</span><br><span class="line">            memset(h, 0, sizeof(int) * (n + 1));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        void addEdge(int u, int v, int w) &#123;</span><br><span class="line">            es[++ce] = Edge(v, h[u], w);</span><br><span class="line">            h[u] = ce;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Edge&amp; operator [] (int pos) &#123;</span><br><span class="line">            return es[pos];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;MapManager;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int s, t, k;</span><br><span class="line">MapManager g;</span><br><span class="line">MapManager rg;</span><br><span class="line">boolean *vis;</span><br><span class="line">int* f, *lase;</span><br><span class="line"></span><br><span class="line">inline void init() &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    g = MapManager(n, m);</span><br><span class="line">    rg = MapManager(n, m);</span><br><span class="line">    for (int i = 1, u, v, w; i &lt;= m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        g.addEdge(u, v, w);</span><br><span class="line">        rg.addEdge(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;, &amp;s, &amp;t, &amp;k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt; que;</span><br><span class="line">void spfa(MapManager&amp; g, int s) &#123;</span><br><span class="line">    vis = new boolean[(n + 1)];</span><br><span class="line">    f = new int[(n + 1)];</span><br><span class="line">    lase = new int[(n + 1)];</span><br><span class="line">    memset(f, 0x7f, sizeof(int) * (n + 1));</span><br><span class="line">    memset(vis, false, sizeof(boolean) * (n + 1));</span><br><span class="line">    que.push(s);</span><br><span class="line">    f[s] = 0, lase[s] = 0;</span><br><span class="line">    while (!que.empty()) &#123;</span><br><span class="line">        int e = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[e] = false;</span><br><span class="line">        for (int i = g.h[e]; i; i = g[i].next) &#123;</span><br><span class="line">            int eu = g[i].end, w = g[i].w;</span><br><span class="line">            if (f[e] + w &lt; f[eu]) &#123;</span><br><span class="line">                f[eu] = f[e] + w, lase[eu] = i;</span><br><span class="line">                if (!vis[eu]) &#123;</span><br><span class="line">                    vis[eu] = true;</span><br><span class="line">                    que.push(eu); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">Node** hs;</span><br><span class="line">inline void rebuild() &#123;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">        for (int j = g.h[i]; j; j = g[j].next) &#123;</span><br><span class="line">            int e = g[j].end;</span><br><span class="line">            if (lase[i] != j)</span><br><span class="line">                g[j].w += f[e] - f[i];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    hs = new Node*[(n + 1)];</span><br><span class="line">    que.push(t);</span><br><span class="line">    hs[t] = NULL;</span><br><span class="line">    while (!que.empty()) &#123;</span><br><span class="line">        int e = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        if (lase[e])</span><br><span class="line">            hs[e] = hs[g[lase[e]].end];</span><br><span class="line">        for (int i = g.h[e]; i; i = g[i].next)</span><br><span class="line">            if (lase[e] != i &amp;&amp; f[g[i].end] != 0x7f7f7f7f)</span><br><span class="line">                hs[e] = merge(hs[e], new Node(g[i].w, g[i].end, NULL, NULL));</span><br><span class="line">        for (int i = rg.h[e]; i; i = rg[i].next) &#123;</span><br><span class="line">            int eu = rg[i].end;</span><br><span class="line">            if (lase[eu] == i)</span><br><span class="line">                que.push(eu);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int kthpath(int k) &#123;</span><br><span class="line">    if (s == t)</span><br><span class="line">        k++;</span><br><span class="line">    if (f[s] == 0x7f7f7f7f)</span><br><span class="line">        return -1;</span><br><span class="line">    if (k == 1)</span><br><span class="line">        return f[s];</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;Status&gt; q;</span><br><span class="line">    if (!hs[s])</span><br><span class="line">        return -1;</span><br><span class="line">        </span><br><span class="line">    q.push(Status(hs[s]-&gt;val, hs[s]));</span><br><span class="line">    while (--k &amp;&amp; !q.empty()) &#123;</span><br><span class="line">        Status e = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        if(k == 1)</span><br><span class="line">            return e.dist + f[s];</span><br><span class="line">        </span><br><span class="line">        int eu = e.p-&gt;ed;</span><br><span class="line">        if (hs[eu])</span><br><span class="line">            q.push(Status(e.dist + hs[eu]-&gt;val, hs[eu]));</span><br><span class="line">        if (e.p-&gt;l)</span><br><span class="line">            q.push(Status(e.dist - e.p-&gt;val + e.p-&gt;l-&gt;val, e.p-&gt;l));</span><br><span class="line">        if (e.p-&gt;r)</span><br><span class="line">            q.push(Status(e.dist - e.p-&gt;val + e.p-&gt;r-&gt;val, e.p-&gt;r));</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void solve() &#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, kthpath(k));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    spfa(rg, t);</span><br><span class="line">    rebuild();</span><br><span class="line">    solve();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//最短路算法+可持久化堆</span><br></pre></td></tr></table></figure>
<h2 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h2><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//并查集实现最小生成树</span><br><span class="line">vector&lt;int&gt; u, v, weights, w_r, father;</span><br><span class="line">int mycmp(int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    return weights[i] &lt; weights[j];</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return father[x] == x ? x : father[x] = find(father[x]);</span><br><span class="line">&#125;</span><br><span class="line">void kruskal_test()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; A(n, vector&lt;int&gt;(n));</span><br><span class="line">    for(int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int edges = 0;</span><br><span class="line">    // 共计n*(n - 1)/2条边</span><br><span class="line">    for (int i = 0; i &lt; n - 1; ++i) &#123;</span><br><span class="line">        for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class="line">            u.push_back(i);</span><br><span class="line">            v.push_back(j);</span><br><span class="line">            weights.push_back(A[i][j]);</span><br><span class="line">            w_r.push_back(edges++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        father.push_back(i);    // 记录n个节点的根节点，初始化为各自本身</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(w_r.begin(), w_r.end(), mycmp); //以weight的大小来对索引值进行排序</span><br><span class="line"></span><br><span class="line">    int min_tree = 0, cnt = 0;</span><br><span class="line">    for (int i = 0; i &lt; edges; ++i) &#123;</span><br><span class="line">        int e = w_r[i];    //e代表排序后的权值的索引</span><br><span class="line">        int x = find(u[e]), y = find(v[e]);</span><br><span class="line">        //x不等于y表示u[e]和v[e]两个节点没有公共根节点，可以合并</span><br><span class="line">        if (x != y) &#123;</span><br><span class="line">            min_tree += weights[e];</span><br><span class="line">            father[x] = y;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (cnt &lt; n - 1) min_tree = 0;</span><br><span class="line">    cout &lt;&lt; min_tree &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    kruskal_test();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//Prim算法实现</span><br><span class="line">void prim_test()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; A(n, vector&lt;int&gt;(n));</span><br><span class="line">    for(int i = 0; i &lt; n ; ++i) &#123;</span><br><span class="line">        for(int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pos, minimum;</span><br><span class="line">    int min_tree = 0;</span><br><span class="line">    //lowcost数组记录每2个点间最小权值，visited数组标记某点是否已访问</span><br><span class="line">    vector&lt;int&gt; visited, lowcost;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        visited.push_back(0);    //初始化为0，表示都没加入</span><br><span class="line">    &#125;</span><br><span class="line">    visited[0] = 1;   //最小生成树从第一个顶点开始</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        lowcost.push_back(A[0][i]);    //权值初始化为0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;    //枚举n个顶点</span><br><span class="line">        minimum = max_int;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;    //找到最小权边对应顶点</span><br><span class="line">            if(!visited[j] &amp;&amp; minimum &gt; lowcost[j]) &#123;</span><br><span class="line">                minimum = lowcost[j];</span><br><span class="line">                pos = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (minimum == max_int)    //如果min = max_int表示已经不再有点可以加入最小生成树中</span><br><span class="line">            break;</span><br><span class="line">        min_tree += minimum;</span><br><span class="line">        visited[pos] = 1;     //加入最小生成树中</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            if(!visited[j] &amp;&amp; lowcost[j] &gt; A[pos][j]) lowcost[j] = A[pos][j];   //更新可更新边的权值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; min_tree &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    prim_test();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line">const int MAXN = 500;</span><br><span class="line">const int MAXE = 500 * 500;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">int pre[MAXN + 7];</span><br><span class="line"></span><br><span class="line">void initPre(int n)&#123; for(int i = 0; i &lt;= n; i++) pre[i] = i; &#125;</span><br><span class="line"></span><br><span class="line">//并查集</span><br><span class="line">int Find(int x)&#123; return x == pre[x] ? x : pre[x] = Find(pre[x]); &#125;</span><br><span class="line"></span><br><span class="line">void merge(int x, int y)&#123; int fx = Find(x), fy = Find(y); if(fx != fy) pre[fx] = fy; &#125;</span><br><span class="line"></span><br><span class="line">struct Edge&#123; //前向星存边</span><br><span class="line">    int u, v; //起点  终点 </span><br><span class="line">    int w;</span><br><span class="line">    bool select;</span><br><span class="line">&#125;edge[MAXE + 7];</span><br><span class="line"></span><br><span class="line">bool cmp(Edge a, Edge b)&#123;</span><br><span class="line">    if(a.w != b.w) return a.w &lt; b.w;</span><br><span class="line">    if(a.u != b.u) return a.u &lt; b.u;</span><br><span class="line">    return a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Node&#123;//链式前向星 用于存储每个集合里面的边</span><br><span class="line">    int to;</span><br><span class="line">    int next;</span><br><span class="line">&#125;link[MAXN + 7];</span><br><span class="line"></span><br><span class="line">int head[MAXN + 7];//邻接表的头结点的位置</span><br><span class="line">int End[MAXN + 7];//邻接表的尾节点的位置</span><br><span class="line">int length[MAXN + 7][MAXN + 7];//最小生成树中任意两点路径上的最长边 </span><br><span class="line"></span><br><span class="line">int kruskal(int n, int m)&#123;</span><br><span class="line">    //初始化邻接表,对于每一个顶点添加一个指向自身的边,表示以i为代表元的集合中只有点i</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">        link[i].to = i, link[i].next = head[i];</span><br><span class="line">        End[i] = i, head[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(edge + 1, edge + 1 + m, cmp);</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for(int i = 1; i &lt;= m; i++)&#123;</span><br><span class="line">        if(cnt == n - 1) break;//当找到的边数等于节点数-1,说明mst已经找到</span><br><span class="line">        int fx = Find(edge[i].u);</span><br><span class="line">        int fy = Find(edge[i].v);</span><br><span class="line">        if(fx != fy)&#123;</span><br><span class="line">            for(int j = head[fx]; j != -1; j = link[j].next)//修改length数组 </span><br><span class="line">                for(int k = head[fy]; k != -1; k = link[k].next)</span><br><span class="line">                //每次合并两个等价类的之后,分别属于两个等价类的两个节点之间的最长边一定是当前加入的边</span><br><span class="line">                    length[link[j].to][link[k].to] = length[link[k].to][link[j].to] = edge[i].w;</span><br><span class="line">            //合并邻接表</span><br><span class="line">            link[End[fy]].next = head[fx];</span><br><span class="line">            End[fy] = End[fx];</span><br><span class="line">            merge(fx, fy);</span><br><span class="line">            cnt++;</span><br><span class="line">            edge[i].select = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cnt &lt; n - 1) return -1;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //初始化建图后执行以下操作</span><br><span class="line">    int flag = kruskal(n, m);</span><br><span class="line">    int mst = 0;</span><br><span class="line">    for(int i = 1; i &lt;= m; i++) if(edge[i].select) mst += edge[i].w;//计算出最小生成树</span><br><span class="line">    int secmst = INF;</span><br><span class="line">    //在 T/(u,v) + (x, y)中寻得次小生成树</span><br><span class="line">    for(int i = 1; i &lt;= m; i++) if(!edge[i].select) secmst = min(secmst, mst + edge[i].w - length[edge[i].u][edge[i].v]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*hdu1285--采用二维数组记录两者之间的关系*/</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int map[510][510];//前驱数量 </span><br><span class="line">int indegree[510];</span><br><span class="line">int queue[510];//保存拓扑序列 </span><br><span class="line">void topo(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,m,t=0;</span><br><span class="line">    for(j=1;j&lt;=n;j++)&#123;</span><br><span class="line">        for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(indegree[i]==0)&#123;//找出前驱数量为零的的点即每次找到第一名 </span><br><span class="line">                m=i;break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[t++]=m;indegree[m]=-1;//将第一名的前驱数量设为-1 </span><br><span class="line">        for(i=1;i&lt;=n;++i)&#123;//第二步将前驱中含有第一名的点前驱数量减1 </span><br><span class="line">            if(map[m][i])indegree[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,queue[0]);//输出拓扑序列 </span><br><span class="line">    for(i=1;i&lt;n;++i)&#123;</span><br><span class="line">        printf(&quot; %d&quot;,queue[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,i,j,a,b;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">        memset(indegree,0,sizeof(indegree));//初始化 </span><br><span class="line">        memset(map,0,sizeof(map));</span><br><span class="line">        for(i=0;i&lt;m;++i)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">            if(map[a][b]==0)&#123; //避免重复的数据输入 </span><br><span class="line">                map[a][b]=1;indegree[b]++;//第一步记录关系和点的前驱数量 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        topo(n);//调用拓扑排序 </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><h3 id="FF"><a href="#FF" class="headerlink" title="FF"></a>FF</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#define maxn 1200</span><br><span class="line">#define INF 2e9</span><br><span class="line">using namespace std;</span><br><span class="line">int i,j,k,n,m,h,t,tot,ans,st,en;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int c,f;</span><br><span class="line">&#125;edge[maxn][maxn];</span><br><span class="line">int flag[maxn],pre[maxn],alpha[maxn],q[maxn],v;</span><br><span class="line">int read()&#123;</span><br><span class="line">    char c;int x;while(c=getchar(),c&lt;&apos;0&apos;||c&gt;&apos;9&apos;);x=c-&apos;0&apos;;</span><br><span class="line">    while(c=getchar(),c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;) x=x*10+c-&apos;0&apos;;return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bfs()&#123;</span><br><span class="line">    memset(flag,0xff,sizeof(flag));memset(pre,0xff,sizeof(pre));memset(alpha,0xff,sizeof(alpha));</span><br><span class="line">    flag[st]=0;pre[st]=0;alpha[st]=INF;h=0,t=1;q[t]=st;</span><br><span class="line">    while(h&lt;t)&#123;</span><br><span class="line">        h++;v=q[h];</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(flag[i]==-1)&#123;</span><br><span class="line">                if(edge[v][i].c&lt;INF&amp;&amp;edge[v][i].f&lt;edge[v][i].c)&#123;</span><br><span class="line">                    flag[i]=0;pre[i]=v;alpha[i]=min(alpha[v],edge[v][i].c-edge[v][i].f);q[++t]=i;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(edge[i][v].c&lt;INF&amp;&amp;edge[i][v].f&gt;0)&#123;</span><br><span class="line">                    flag[i]=0;pre[i]=-v;alpha[i]=min(alpha[v],edge[i][v].f);q[++t]=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[v]=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Ford_Fulkerson()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        bfs();</span><br><span class="line">        if(alpha[en]==0||flag[en]==-1)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        int k1=en,k2=abs(pre[k1]);int a=alpha[en];</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            if(edge[k2][k1].c&lt;INF) edge[k2][k1].f+=a;</span><br><span class="line">            else if(edge[k1][k2].c&lt;INF) edge[k1][k2].f-=a;</span><br><span class="line">            if(k2==st) break;</span><br><span class="line">            k1=k2;k2=abs(pre[k1]);</span><br><span class="line">        &#125;</span><br><span class="line">        alpha[en]=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void flow()&#123;</span><br><span class="line">    int maxflow=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">      for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">        if(i==st&amp;&amp;edge[i][j].f&lt;INF) maxflow+=edge[i][j].f;</span><br><span class="line">      &#125;</span><br><span class="line">    printf(&quot;%d&quot;,maxflow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int u,v,c,f;</span><br><span class="line">    n=read();m=read();st=read();en=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">      for(int j=1;j&lt;=n;j++) edge[i][j].c=INF,edge[i][j].f=0;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        u=read();v=read();c=read();</span><br><span class="line">        edge[u][v].c=c;</span><br><span class="line">    &#125;</span><br><span class="line">    Ford_Fulkerson();</span><br><span class="line">    flow();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EK"><a href="#EK" class="headerlink" title="EK"></a>EK</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">#define maxn 10005</span><br><span class="line"></span><br><span class="line">int n, m, st, en, flow[maxn][maxn], pre[maxn];</span><br><span class="line">int q[maxn], curr_pos, st_pos, end_pos;</span><br><span class="line">bool wh[maxn];</span><br><span class="line">int max_flow;</span><br><span class="line"></span><br><span class="line">void Init()//初始化</span><br><span class="line">&#123;</span><br><span class="line">    int i, a, b, c;</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;st, &amp;en);</span><br><span class="line">    for(i = 0; i != m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        flow[a][b] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Bfs(int st, int en)//广搜找源点</span><br><span class="line">&#123;</span><br><span class="line">    st_pos = -1, end_pos = 0;</span><br><span class="line">    memset(wh, 0, sizeof wh);</span><br><span class="line">    wh[st] = 1;</span><br><span class="line">    q[0] = st;</span><br><span class="line">    while(st_pos != end_pos)</span><br><span class="line">    &#123;</span><br><span class="line">        curr_pos = q[++st_pos];</span><br><span class="line">        for(int i = 1; i != n+1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!wh[i] &amp;&amp; flow[curr_pos][i] &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                wh[i] = 1;</span><br><span class="line">                pre[i] = curr_pos;</span><br><span class="line">                if(i == en)</span><br><span class="line">                &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                q[++end_pos] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int EK(int start_pos, int end_pos)</span><br><span class="line">&#123;</span><br><span class="line">    int i, minn;</span><br><span class="line">    while(Bfs(start_pos, end_pos))//回溯</span><br><span class="line">    &#123;</span><br><span class="line">        minn = INF;</span><br><span class="line"></span><br><span class="line">        for(i = end_pos; i != start_pos; i = pre[i])</span><br><span class="line">        &#123;</span><br><span class="line">            minn = min(minn, flow[pre[i]][i]);</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        for(i = end_pos; i != start_pos; i = pre[i])</span><br><span class="line">        &#123;</span><br><span class="line">            flow[pre[i]][i] -= minn;</span><br><span class="line">            flow[i][pre[i]] += minn;//反向弧加上该值（具体原因下文详解）</span><br><span class="line">        &#125; </span><br><span class="line">        max_flow += minn;</span><br><span class="line">    &#125;</span><br><span class="line">    return max_flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    //freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line"></span><br><span class="line">    Init();</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d&quot;, EK(st, en));</span><br><span class="line"></span><br><span class="line">    //fclose(stdin);</span><br><span class="line">    //fclose(stdout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DINIC"><a href="#DINIC" class="headerlink" title="DINIC"></a>DINIC</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m, sx, ex, cnt;</span><br><span class="line">int head[maxn], pre[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int u, next, to, c;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void add_edge(int u, int v, int c)&#123;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].c = c&lt;=inf ? c : inf;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int c)&#123;</span><br><span class="line">    add_edge(u, v, c);</span><br><span class="line">    add_edge(v, u, 0);//双向边容量为c</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    //memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        int u, v, w;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool BFS(int sx, int ex)&#123;</span><br><span class="line">    memset(pre, 0, sizeof(pre));</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    pre[sx] = 1;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">                int v = edge[i].to;</span><br><span class="line">            if(!pre[v]&amp;&amp;edge[i].c)&#123;</span><br><span class="line">                pre[v] = pre[kk] + 1;</span><br><span class="line">                que.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex] != 0;</span><br><span class="line">&#125;</span><br><span class="line">int DFS(int pos, int flow)&#123;</span><br><span class="line">    if(pos == ex || flow == 0)</span><br><span class="line">        return flow;</span><br><span class="line">    int f = flow;</span><br><span class="line">    for(int i = head[pos]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">        int tmp, v = edge[i].to;</span><br><span class="line">        if(edge[i].c &amp;&amp; pre[pos] + 1 == pre[v] &amp;&amp; (tmp = DFS(v, min(edge[i].c, flow)))&gt;0)&#123;</span><br><span class="line">            edge[i].c -= tmp;</span><br><span class="line">            edge[i^1].c += tmp;</span><br><span class="line">            flow -= tmp;</span><br><span class="line">            if(flow == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f - flow;</span><br><span class="line">&#125;</span><br><span class="line">int Dinic(int sx, int ex)&#123;</span><br><span class="line">    int flow = 0;</span><br><span class="line">    while(BFS(sx, ex))&#123;</span><br><span class="line">        flow += DFS(sx, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;m, &amp;n))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;, Dinic(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DINIC优化"><a href="#DINIC优化" class="headerlink" title="DINIC优化"></a>DINIC优化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m, sx, ex, cnt;</span><br><span class="line">int head[maxn], pre[maxn], cur[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int u, next, to, c;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void add_edge(int u, int v, int c)&#123;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].c = c&lt;=inf ? c : inf;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int c)&#123;</span><br><span class="line">    add_edge(u, v, c);</span><br><span class="line">    add_edge(v, u, 0);//双向边容量为c</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    //memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        int u, v, w;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool BFS(int sx, int ex)&#123;</span><br><span class="line">    memset(pre, 0, sizeof(pre));</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    pre[sx] = 1;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int&amp; i = cur[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">                int v = edge[i].to;</span><br><span class="line">            if(!pre[v]&amp;&amp;edge[i].c)&#123;</span><br><span class="line">                pre[v] = pre[kk] + 1;</span><br><span class="line">                que.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex] != 0;</span><br><span class="line">&#125;</span><br><span class="line">int DFS(int pos, int flow)&#123;</span><br><span class="line">    if(pos == ex || flow == 0)</span><br><span class="line">        return flow;</span><br><span class="line">    int f = flow;</span><br><span class="line">    for(int i = head[pos]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">        int tmp, v = edge[i].to;</span><br><span class="line">        if(edge[i].c &amp;&amp; pre[pos] + 1 == pre[v] &amp;&amp; (tmp = DFS(v, min(edge[i].c, flow)))&gt;0)&#123;</span><br><span class="line">            edge[i].c -= tmp;</span><br><span class="line">            edge[i^1].c += tmp;</span><br><span class="line">            flow -= tmp;</span><br><span class="line">            if(flow == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f - flow;</span><br><span class="line">&#125;</span><br><span class="line">int Dinic(int sx, int ex)&#123;</span><br><span class="line">    int flow = 0;</span><br><span class="line">    while(BFS(sx, ex))&#123;</span><br><span class="line">        memcpy(cur, head, sizeof(head));</span><br><span class="line">        flow += DFS(sx, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;m, &amp;n))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;, Dinic(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DINIC-邻接矩阵"><a href="#DINIC-邻接矩阵" class="headerlink" title="DINIC(邻接矩阵)"></a>DINIC(邻接矩阵)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">const int maxn = 307;</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int c;</span><br><span class="line">    int f;</span><br><span class="line">&#125;;</span><br><span class="line">int sx,ex;</span><br><span class="line">int pre[maxn];</span><br><span class="line">NODE road[maxn][maxn];</span><br><span class="line">int n, m, N;</span><br><span class="line">bool BFS()&#123;</span><br><span class="line">    memset(pre,0,sizeof(pre));</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    q.push(sx);</span><br><span class="line">    pre[sx] = 1;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int d = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i = 1;i&lt;=N;i++)&#123;</span><br><span class="line">            if(!pre[i]&amp;&amp;road[d][i].c-road[d][i].f)&#123;</span><br><span class="line">                pre[i] = pre[d] + 1;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex]!=0;</span><br><span class="line">&#125;</span><br><span class="line">int dfs(int pos, int flow)&#123;</span><br><span class="line">    int f = flow;</span><br><span class="line">    if(pos==ex)</span><br><span class="line">        return flow;</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        if(road[pos][i].c - road[pos][i].f &amp;&amp; pre[pos] + 1 == pre[i])&#123;</span><br><span class="line">            int a = road[pos][i].c - road[pos][i].f;</span><br><span class="line">            int t = dfs(i, min(a, flow));</span><br><span class="line">            road[pos][i].f += t;</span><br><span class="line">            road[i][pos].f -= t;</span><br><span class="line">            flow -= t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f - flow;</span><br><span class="line">&#125;</span><br><span class="line">int dinic()&#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    while(BFS())&#123;</span><br><span class="line">        sum+=dfs(sx,inf);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    N = n;</span><br><span class="line">    sx = 0;</span><br><span class="line">    ex = N;</span><br><span class="line">    memset(road,0,sizeof(road));</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u,v,w;</span><br><span class="line">    for(int i = 1;i&lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        road[u][v].c+=w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;m,&amp;n))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;,dinic());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ISAP"><a href="#ISAP" class="headerlink" title="ISAP"></a>ISAP</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int read() &#123;</span><br><span class="line">    int x=0,f=1;</span><br><span class="line">    char c=getchar();</span><br><span class="line">    for (;!isdigit(c);c=getchar()) if (c==&apos;-&apos;) f=-1;</span><br><span class="line">    for (;isdigit(c);c=getchar()) x=x*10+c-&apos;0&apos;;</span><br><span class="line">    return x*f;</span><br><span class="line">&#125;</span><br><span class="line">const int maxn=205;</span><br><span class="line">const int maxm=205;</span><br><span class="line">const int inf=2e9+7;</span><br><span class="line">struct edge &#123;</span><br><span class="line">    int v,w,nxt;</span><br><span class="line">&#125; e[maxm&lt;&lt;1];</span><br><span class="line">int h[maxn],tot,n,m,gap[maxn],last[maxn],d[maxn],que[maxn],ql,qr;</span><br><span class="line">vector&lt;int&gt; inv[maxn];</span><br><span class="line">void add(int u,int v,int w) &#123;</span><br><span class="line">    e[++tot]=(edge)&#123;v,w,h[u]&#125;;</span><br><span class="line">    h[u]=tot;</span><br><span class="line">    e[++tot]=(edge)&#123;u,0,h[v]&#125;;</span><br><span class="line">    h[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void init(int s,int t) &#123;</span><br><span class="line">    memset(gap,0,sizeof gap),memset(d,0,sizeof d),++gap[d[t]=1];</span><br><span class="line">    for (int i=1;i&lt;=n;++i) last[i]=h[i];</span><br><span class="line">    que[ql=qr=1]=t;</span><br><span class="line">    while (ql&lt;=qr) &#123;</span><br><span class="line">        int x=que[ql++];</span><br><span class="line">        for (int i=h[x],v=e[i].v;i;i=e[i].nxt,v=e[i].v) if (!d[v]) ++gap[d[v]=d[x]+1],que[++qr]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int aug(int x,int s,int t,int mi) &#123;</span><br><span class="line">    if (x==t) return mi;</span><br><span class="line">    int flow=0;</span><br><span class="line">    for (int &amp;i=last[x],v=e[i].v;i;i=e[i].nxt,v=e[i].v) if (d[x]==d[v]+1) &#123;</span><br><span class="line">        int tmp=aug(v,s,t,min(mi,e[i].w));</span><br><span class="line">        flow+=tmp,mi-=tmp,e[i].w-=tmp,e[i^1].w+=tmp;</span><br><span class="line">        if (!mi) return flow;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(--gap[d[x]])) d[s]=n+1;</span><br><span class="line">    ++gap[++d[x]],last[x]=h[x];</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int maxflow(int s,int t) &#123;</span><br><span class="line">    init(s,t);</span><br><span class="line">    int ret=aug(s,s,t,inf);</span><br><span class="line">    while (d[s]&lt;=n) ret+=aug(s,s,t,inf);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">#ifndef ONLINE_JUDGE</span><br><span class="line">    freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">#endif</span><br><span class="line">    while (~scanf(&quot;%d%d&quot;,&amp;m,&amp;n)) &#123;</span><br><span class="line">        tot=1,memset(h,0,sizeof h);</span><br><span class="line">        for (int i=1;i&lt;=n;++i) inv[i].clear();</span><br><span class="line">        for (int i=1;i&lt;=m;++i) &#123;</span><br><span class="line">            int u=read(),v=read(),w=read();</span><br><span class="line">            add(u,v,w);</span><br><span class="line">            if (w) inv[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        int ans=maxflow(1,n);</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MCMF"><a href="#MCMF" class="headerlink" title="MCMF"></a>MCMF</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxm = 1e5+7;</span><br><span class="line">const int maxn = 1e4+7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m, cnt, sx, ex;</span><br><span class="line">int head[maxn], pre[maxn], dis[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next;</span><br><span class="line">    int to;</span><br><span class="line">    int w;</span><br><span class="line">    int c;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line">void init()&#123;</span><br><span class="line">    sx = 0;</span><br><span class="line">    ex = 1;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">void add_edge(int u, int v, int c, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].c = c&lt;=inf ? c : inf;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int c, int w)&#123;</span><br><span class="line">    add_edge(u, v, c, w);</span><br><span class="line">    add_edge(v, u, 0, -w);</span><br><span class="line">&#125;</span><br><span class="line">bool SPFA(int sx, int ex)&#123;</span><br><span class="line">    memset(pre, -1, sizeof(pre));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[kk] = false;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            EDGE tmp = edge[i];</span><br><span class="line">            if(tmp.c &amp;&amp; dis[tmp.to]&gt;dis[kk]+tmp.w)&#123;</span><br><span class="line">                dis[tmp.to] = dis[kk] + tmp.w;</span><br><span class="line">                pre[tmp.to] = i;</span><br><span class="line">                if(!vis[tmp.to])&#123;</span><br><span class="line">                    vis[tmp.to] = true;</span><br><span class="line">                    que.push(tmp.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex] != -1;</span><br><span class="line">&#125;</span><br><span class="line">int MCMF(int sx, int ex)&#123;</span><br><span class="line">    int flow = 0, cost = 0;</span><br><span class="line">    while(SPFA(sx, ex))&#123;</span><br><span class="line">    	int min_flow = inf;</span><br><span class="line">        for(int i = pre[ex]; i != -1; i = pre[edge[i^1].to])&#123;</span><br><span class="line">            min_flow = min(min_flow, edge[i].c);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = pre[ex]; i != -1; i = pre[edge[i^1].to])&#123;</span><br><span class="line">            edge[i].c -= min_flow;</span><br><span class="line">            edge[i^1].c += min_flow;</span><br><span class="line">            cost += min_flow * edge[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        flow += min_flow;</span><br><span class="line">    &#125;</span><br><span class="line">    return cost;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v, c, w;</span><br><span class="line">    ex = n+1;</span><br><span class="line">    for(int i = 0;i&lt;m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d&quot;,&amp;u,&amp;v,&amp;c,&amp;w);</span><br><span class="line">        add(u,v,c, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">        if(n+m==0)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;,MCMF(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><h3 id="匈牙利算法-邻接矩阵"><a href="#匈牙利算法-邻接矩阵" class="headerlink" title="匈牙利算法(邻接矩阵)"></a>匈牙利算法(邻接矩阵)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 107;</span><br><span class="line">int N, K;</span><br><span class="line">int edge[maxn][maxn], head[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, 0, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">bool find_edge(int x) &#123;</span><br><span class="line">	for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">		if (edge[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">			vis[i] = true;</span><br><span class="line">			if (!head[i] || find_edge(head[i])) &#123;</span><br><span class="line">				head[i] = x;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int Magyar(int N)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        memset(vis, false, sizeof(vis));</span><br><span class="line">        if (find_edge(i)) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (cin &gt;&gt; N &gt;&gt; K) &#123;</span><br><span class="line">		int x, y;</span><br><span class="line">		for (int i = 1; i &lt;= K; i++)&#123;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			edge[x][y] = 1;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; Magyar(N) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 107;</span><br><span class="line">int T, N, m;</span><br><span class="line">int head[maxn], link[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int cnt;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, u, to, w;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(link, 0, sizeof(link));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">bool find_edge(int x)&#123;</span><br><span class="line">    for(int i = head[x]; i!= -1; i = edge[i].next)&#123;</span><br><span class="line">        int v = edge[i].to;</span><br><span class="line">        if(!vis[v])&#123;</span><br><span class="line">            vis[v] = true;</span><br><span class="line">            if (!link[v] || find_edge(link[v])) &#123;</span><br><span class="line">				link[v] = x;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int Magyar(int N)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        memset(vis, false, sizeof(vis));</span><br><span class="line">        if (find_edge(i)) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int solve()&#123;</span><br><span class="line">    int ans = Magyar(N);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;N, &amp;m);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int x, y;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;x, &amp;y);</span><br><span class="line">        add(x, y, 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;, solve());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 207;</span><br><span class="line">const int maxm = 30007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int minD, cntx, cnty, edge[maxn][maxn];</span><br><span class="line">bool visx[maxn], visy[maxn];</span><br><span class="line">int linkx[maxn], link[maxn], wx[maxn], wy[maxn];</span><br><span class="line">bool dfs(int x)&#123; //匈牙利算法找增广路径</span><br><span class="line">    visx[x] = true;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i++)&#123;</span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            int t = wx[x] + wy[i] - edge[x][i];</span><br><span class="line">            if(t == 0) &#123;</span><br><span class="line">                visy[i] = true;</span><br><span class="line">                if(link[i] == 0 || dfs(link[i]))&#123;</span><br><span class="line">                    linkx[x] = i;</span><br><span class="line">                    link[i] = x;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t &gt; 0)&#123;  //找出边权与顶标和的最小的差值</span><br><span class="line">                if(t &lt; minD)&#123;</span><br><span class="line">                    minD = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int km()&#123;</span><br><span class="line">    memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点</span><br><span class="line">    memset(link, 0, sizeof link);</span><br><span class="line">    memset(wy, 0, sizeof(wy));</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        wx[i] = -inf;</span><br><span class="line">        for(int j = 1; j &lt;= cnty; j++)&#123;</span><br><span class="line">            if(wx[i] &lt; edge[i][j])&#123;</span><br><span class="line">                wx[i] = edge[i][j];//初始化为权值最大的边的权值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            minD = inf;</span><br><span class="line">            memset(visx, false, sizeof visx);</span><br><span class="line">            memset(visy, false, sizeof visy);</span><br><span class="line">            if(dfs(i))&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cntx; j++)&#123;  //将交错树中X部的点的顶标减去minz</span><br><span class="line">                if(visx[j])&#123;</span><br><span class="line">                    wx[j] -= minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz</span><br><span class="line">                if(visy[j])&#123;</span><br><span class="line">                    wy[j] += minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i ++)&#123;</span><br><span class="line">        if(link[i]!=0)&#123;</span><br><span class="line">            ans += edge[link[i]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        cntx = cnty = n;</span><br><span class="line">        memset(edge, 0, sizeof(edge));</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            edge[u][v] = max(edge[u][v], w);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, km());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KM算法最小权匹配"><a href="#KM算法最小权匹配" class="headerlink" title="KM算法最小权匹配"></a>KM算法最小权匹配</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 207;</span><br><span class="line">const int maxm = 30007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int minD, cntx, cnty, edge[maxn][maxn];</span><br><span class="line">bool visx[maxn], visy[maxn];</span><br><span class="line">int linkx[maxn], link[maxn], wx[maxn], wy[maxn];</span><br><span class="line">bool dfs(int x)&#123; //匈牙利算法找增广路径</span><br><span class="line">    visx[x] = true;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i++)&#123;</span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            int t = wx[x] + wy[i] - edge[x][i];</span><br><span class="line">            if(t == 0) &#123;</span><br><span class="line">                visy[i] = true;</span><br><span class="line">                if(link[i] == 0 || dfs(link[i]))&#123;</span><br><span class="line">                    linkx[x] = i;</span><br><span class="line">                    link[i] = x;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t &gt; 0)&#123;  //找出边权与顶标和的最小的差值</span><br><span class="line">                if(t &lt; minD)&#123;</span><br><span class="line">                    minD = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int km()&#123;</span><br><span class="line">    memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点</span><br><span class="line">    memset(link, 0, sizeof link);</span><br><span class="line">    memset(wy, 0, sizeof(wy));</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        wx[i] = -inf;</span><br><span class="line">        for(int j = 1; j &lt;= cnty; j++)&#123;</span><br><span class="line">            if(wx[i] &lt; edge[i][j])&#123;</span><br><span class="line">                wx[i] = edge[i][j];//初始化为权值最大的边的权值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            minD = inf;</span><br><span class="line">            memset(visx, false, sizeof visx);</span><br><span class="line">            memset(visy, false, sizeof visy);</span><br><span class="line">            if(dfs(i))&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cntx; j++)&#123;  //将交错树中X部的点的顶标减去minz</span><br><span class="line">                if(visx[j])&#123;</span><br><span class="line">                    wx[j] -= minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz</span><br><span class="line">                if(visy[j])&#123;</span><br><span class="line">                    wy[j] += minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i ++)&#123;</span><br><span class="line">        if(link[i]!=0&amp;&amp;edge[link[i]][i]!=-inf)&#123;</span><br><span class="line">            ans += edge[link[i]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        cntx = cnty = n;</span><br><span class="line">        for(int i = 0; i &lt;= cntx; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt;= cnty; j++)&#123;</span><br><span class="line">                edge[i][j] = -inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            edge[u][v] = max(edge[u][v], -w);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, km());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KM算法最小权匹配优化版"><a href="#KM算法最小权匹配优化版" class="headerlink" title="KM算法最小权匹配优化版"></a>KM算法最小权匹配优化版</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 207;</span><br><span class="line">const int maxm = 30007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int minD, cntx, cnty, edge[maxn][maxn];</span><br><span class="line">bool visx[maxn], visy[maxn];</span><br><span class="line">int linkx[maxn], link[maxn], wx[maxn], wy[maxn];</span><br><span class="line">bool dfs(int x)&#123; //匈牙利算法找增广路径</span><br><span class="line">    visx[x] = true;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i++)&#123;</span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            int t = wx[x] + wy[i] - edge[x][i];</span><br><span class="line">            if(t == 0) &#123;</span><br><span class="line">                visy[i] = true;</span><br><span class="line">                if(link[i] == 0 || dfs(link[i]))&#123;</span><br><span class="line">                    linkx[x] = i;</span><br><span class="line">                    link[i] = x;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t &gt; 0)&#123;  //找出边权与顶标和的最小的差值</span><br><span class="line">                if(t &lt; minD)&#123;</span><br><span class="line">                    minD = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int km()&#123;</span><br><span class="line">    memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点</span><br><span class="line">    memset(link, 0, sizeof link);</span><br><span class="line">    memset(wy, 0, sizeof(wy));</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        wx[i] = -inf;</span><br><span class="line">        for(int j = 1; j &lt;= cnty; j++)&#123;</span><br><span class="line">            if(wx[i] &lt; edge[i][j])&#123;</span><br><span class="line">                wx[i] = edge[i][j];//初始化为权值最大的边的权值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            minD = inf;</span><br><span class="line">            memset(visx, false, sizeof visx);</span><br><span class="line">            memset(visy, false, sizeof visy);</span><br><span class="line">            if(dfs(i))&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cntx; j++)&#123;  //将交错树中X部的点的顶标减去minz</span><br><span class="line">                if(visx[j])&#123;</span><br><span class="line">                    wx[j] -= minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz</span><br><span class="line">                if(visy[j])&#123;</span><br><span class="line">                    wy[j] += minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i ++)&#123;</span><br><span class="line">        if(link[i]!=0&amp;&amp;edge[link[i]][i]!=-inf)&#123;</span><br><span class="line">            ans += edge[link[i]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        cntx = cnty = n;</span><br><span class="line">        for(int i = 0; i &lt;= cntx; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt;= cnty; j++)&#123;</span><br><span class="line">                edge[i][j] = -inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            edge[u][v] = max(edge[u][v], -w);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, km());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="强连通"><a href="#强连通" class="headerlink" title="强连通"></a>强连通</h2><h3 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5 + 7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int head[maxn], cnt, top, dfs_num, col_num;</span><br><span class="line">int dfn[maxn], low[maxn], Stack[maxn], color[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, u;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void add(int u, int v)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void Tarjan(int x)&#123;</span><br><span class="line">    dfn[x] = ++dfs_num;</span><br><span class="line">    low[x] = dfs_num;</span><br><span class="line">    vis[x] = true;  //是否在栈中</span><br><span class="line">    Stack[++top] = x;</span><br><span class="line">    for(int i = head[x]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">        int v = edge[i].to;</span><br><span class="line">        if(!dfn[v])&#123;</span><br><span class="line">            Tarjan(v);</span><br><span class="line">            low[x] = min(low[x], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(vis[v])&#123;</span><br><span class="line">            low[x] = min(low[x], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(dfn[x] == low[x])&#123;   //构成强连通分量</span><br><span class="line">        vis[x] = false;</span><br><span class="line">        color[x] = ++col_num;   //染色</span><br><span class="line">        while(Stack[top] != x)&#123; //清空</span><br><span class="line">            color[Stack[top]] = col_num;</span><br><span class="line">            vis [ Stack[ top-- ] ] = false ;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    top = dfs_num = col_num = cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    memset(dfn, 0, sizeof(dfn));</span><br><span class="line">    memset(low, 0, sizeof(low));</span><br><span class="line">    memset(color, 0, sizeof(color));</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</span><br><span class="line">        add(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">        if(!color[i])&#123;</span><br><span class="line">            Tarjan(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(col_num != 1)&#123;</span><br><span class="line">        printf(&quot;No\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;Yes\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &amp;&amp; n+m)&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tarjan缩点"><a href="#Tarjan缩点" class="headerlink" title="Tarjan缩点"></a>Tarjan缩点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#define MAXN 10010</span><br><span class="line">#define MAXE 100010</span><br><span class="line">using namespace std;</span><br><span class="line">int head[MAXN],tot1,tot2;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">    int u,v,next;</span><br><span class="line">&#125;e1[MAXE],e2[MAXN];</span><br><span class="line">void addEdge(int u,int v,Edge* edge,int&amp; tol)&#123;</span><br><span class="line">    edge[tol].u=u;edge[tol].v=v;</span><br><span class="line">    edge[tol].next=head[u];head[u]=tol++;</span><br><span class="line">&#125;</span><br><span class="line">int n,m;</span><br><span class="line">int low[MAXN],dfn[MAXN],stack[MAXN],belong[MAXN],num[MAXN];</span><br><span class="line">bool instack[MAXN];</span><br><span class="line">int scc,top,INDEX;</span><br><span class="line">void Tarjan(int u)&#123;</span><br><span class="line">    int v;</span><br><span class="line">    low[u]=dfn[u]=++INDEX;</span><br><span class="line">    stack[top++]=u;</span><br><span class="line">    instack[u]=true;</span><br><span class="line">    for(int i=head[u];i!=-1;i=e1[i].next)&#123;</span><br><span class="line">        v=e1[i].v;</span><br><span class="line">        if(!dfn[v])&#123;</span><br><span class="line">            Tarjan(v);</span><br><span class="line">            if(low[u]&gt;low[v]) low[u]=low[v];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(instack[v]&amp;&amp;low[u]&gt;dfn[v])</span><br><span class="line">            low[u]=dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line">    if(low[u]==dfn[u])&#123;</span><br><span class="line">        ++scc;</span><br><span class="line">        do&#123;</span><br><span class="line">            v=stack[--top];</span><br><span class="line">            instack[v]=false;</span><br><span class="line">            belong[v]=scc;</span><br><span class="line">            num[scc]++;</span><br><span class="line">        &#125;while(u!=v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int inde[MAXN],outde[MAXN];</span><br><span class="line">void solve()&#123;</span><br><span class="line">    memset(dfn,0,sizeof(dfn));</span><br><span class="line">    memset(instack,false,sizeof(instack));</span><br><span class="line">    memset(num,0,sizeof(num));</span><br><span class="line">    scc=top=INDEX=0;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)</span><br><span class="line">        if(!dfn[i]) Tarjan(i);</span><br><span class="line">    tot2=0;memset(head,-1,sizeof(head));</span><br><span class="line">    memset(inde,0,sizeof(inde));</span><br><span class="line">    memset(outde,0,sizeof(outde));</span><br><span class="line">    int u,v;</span><br><span class="line">    for(int i=0;i&lt;m;++i)&#123;</span><br><span class="line">        u=belong[e1[i].u];</span><br><span class="line">        v=belong[e1[i].v];</span><br><span class="line">        if(u!=v)&#123;</span><br><span class="line">            addEdge(u,v,e2,tot2);</span><br><span class="line">            inde[v]++;</span><br><span class="line">            outde[u]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int a=0,b=0;</span><br><span class="line">    for(int i=1;i&lt;=scc;++i)&#123;</span><br><span class="line">        if(!inde[i]) a++;</span><br><span class="line">        if(!outde[i]) b++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(scc==1)printf(&quot;0\n&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;%d\n&quot;,max(a,b));</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;   int zushu;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;zushu);</span><br><span class="line">    while(zushu--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        tot1=0;memset(head,-1,sizeof(head));</span><br><span class="line">        int u,v;</span><br><span class="line">        for(int i=0;i&lt;m;++i)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">            addEdge(u,v,e1,tot1);</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HDU 3622</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">HDU 3622</span><br><span class="line">题意:给n对炸弹可以放置的位置(每个位置为一个二维平面上的点),</span><br><span class="line">每次放置炸弹是时只能选择这一对中的其中一个点,每个炸弹爆炸</span><br><span class="line">的范围半径都一样,控制爆炸的半径使得所有的爆炸范围都不相</span><br><span class="line">交(可以相切),求解这个最大半径.</span><br><span class="line">     首先二分最大半径值,然后2-sat构图判断其可行性,对于每</span><br><span class="line">     两队位置(u,uu)和(v,vv),如果u和v之间的距离小于2*id,也就</span><br><span class="line">     是说位置u和位置v处不能同时防止炸弹(两范围相交),所以连边(u,vv)</span><br><span class="line">     和(v,uu),求解强连通分量判断可行性.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意精度问题</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=210;</span><br><span class="line">const int MAXM=40005;//边的最大数</span><br><span class="line">const double eps=1e-5;</span><br><span class="line"></span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int to,next;</span><br><span class="line">&#125;edge1[MAXM],edge2[MAXM];</span><br><span class="line">int head1[MAXN];</span><br><span class="line">int head2[MAXN];</span><br><span class="line">int tol1,tol2;</span><br><span class="line">bool vis1[MAXN],vis2[MAXN];</span><br><span class="line">int Belong[MAXN];//连通分量标记</span><br><span class="line">int T[MAXN];//dfs结点结束时间</span><br><span class="line">int Bcnt,Tcnt;</span><br><span class="line">void add(int a,int b)//原图和逆图都要添加</span><br><span class="line">&#123;</span><br><span class="line">    edge1[tol1].to=b;</span><br><span class="line">    edge1[tol1].next=head1[a];</span><br><span class="line">    head1[a]=tol1++;</span><br><span class="line">    edge2[tol2].to=a;</span><br><span class="line">    edge2[tol2].next=head2[b];</span><br><span class="line">    head2[b]=tol2++;</span><br><span class="line">&#125;</span><br><span class="line">void init()//建图前初始化</span><br><span class="line">&#123;</span><br><span class="line">    memset(head1,-1,sizeof(head1));</span><br><span class="line">    memset(head2,-1,sizeof(head2));</span><br><span class="line">    memset(vis1,false,sizeof(vis1));</span><br><span class="line">    memset(vis2,false,sizeof(vis2));</span><br><span class="line">    tol1=tol2=0;</span><br><span class="line">    Bcnt=Tcnt=0;</span><br><span class="line">&#125;</span><br><span class="line">void dfs1(int x)//对原图进行dfs,算出每个结点的结束时间，哪个点开始无所谓</span><br><span class="line">&#123;</span><br><span class="line">    vis1[x]=true;</span><br><span class="line">    int j;</span><br><span class="line">    for(int j=head1[x];j!=-1;j=edge1[j].next)</span><br><span class="line">      if(!vis1[edge1[j].to])</span><br><span class="line">        dfs1(edge1[j].to);</span><br><span class="line">    T[Tcnt++]=x;</span><br><span class="line">&#125;</span><br><span class="line">void dfs2(int x)</span><br><span class="line">&#123;</span><br><span class="line">    vis2[x]=true;</span><br><span class="line">    Belong[x]=Bcnt;</span><br><span class="line">    int j;</span><br><span class="line">    for(j=head2[x];j!=-1;j=edge2[j].next)</span><br><span class="line">       if(!vis2[edge2[j].to])</span><br><span class="line">         dfs2(edge2[j].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">&#125;s[MAXN];</span><br><span class="line">double dist(Point a,Point b)</span><br><span class="line">&#123;</span><br><span class="line">    return sqrt((double)(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool ok(int n)//判断可行性</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;2*n;i++)</span><br><span class="line">      if(!vis1[i])</span><br><span class="line">        dfs1(i);</span><br><span class="line">    for(int i=Tcnt-1;i&gt;=0;i--)</span><br><span class="line">      if(!vis2[T[i]])//这个别写错，是vis2[T[i]]</span><br><span class="line">      &#123;</span><br><span class="line">          dfs2(T[i]);</span><br><span class="line">          Bcnt++;</span><br><span class="line">      &#125;</span><br><span class="line">    for(int i=0;i&lt;=2*n-2;i+=2)</span><br><span class="line">      if(Belong[i]==Belong[i+1])</span><br><span class="line">        return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    int n;</span><br><span class="line">    double left,right,mid;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">          scanf(&quot;%d%d%d%d&quot;,&amp;s[2*i].x,&amp;s[2*i].y,&amp;s[2*i+1].x,&amp;s[2*i+1].y);</span><br><span class="line">        left=0;</span><br><span class="line">        right=40000.0;</span><br><span class="line">        while(right-left&gt;=eps)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(left+right)/2;</span><br><span class="line">            init();</span><br><span class="line">            for(int i=0;i&lt;2*n-2;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int t;</span><br><span class="line">                if(i%2==0)t=i+2;</span><br><span class="line">                else t=i+1;</span><br><span class="line">                for(int j=t;j&lt;2*n;j++)</span><br><span class="line">                   if(dist(s[i],s[j])&lt;2*mid)//冲突了</span><br><span class="line">                   &#123;</span><br><span class="line">                       add(i,j^1);</span><br><span class="line">                       add(j,i^1);//注意顺序不能变的</span><br><span class="line">                   &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(ok(n))left=mid;</span><br><span class="line">            else right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%.2lf\n&quot;,right);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int gcd(int a, int b)&#123;</span><br><span class="line">    return !b ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exgcd"><a href="#exgcd" class="headerlink" title="exgcd"></a>exgcd</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int exgcd(int a,int b,int &amp;x,int &amp;y)&#123;</span><br><span class="line">    if (b==0)&#123;</span><br><span class="line">        x=1,y=0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    int d=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int Extended_Euclid(int a,int b,int &amp;x,int &amp;y)    //扩展欧几里得算法</span><br><span class="line">&#123;</span><br><span class="line">	int d;</span><br><span class="line">	if(b==0)</span><br><span class="line">	&#123;</span><br><span class="line">		x=1;y=0;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">	d=Extended_Euclid(b,a%b,y,x);</span><br><span class="line">	y-=a/b*x;</span><br><span class="line">	return d;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int Chinese_Remainder(int a[],int w[],int len)    //中国剩余定理  a[]存放余数  w[]存放两两互质的数</span><br><span class="line">&#123;</span><br><span class="line">	int i,d,x,y,m,n,ret;</span><br><span class="line">	ret=0;</span><br><span class="line">	n=1;</span><br><span class="line">	for (i=0;i&lt;len;i++)</span><br><span class="line">		n*=w[i];</span><br><span class="line">	for (i=0;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m=n/w[i];</span><br><span class="line">		d=Extended_Euclid(w[i],m,x,y);</span><br><span class="line">		ret=(ret+y*m*a[i])%n;</span><br><span class="line">	&#125;</span><br><span class="line">	return (n+ret%n)%n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,i;</span><br><span class="line">	int w[15],b[15];</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n),n)   </span><br><span class="line">	&#123;</span><br><span class="line">		for (i=0;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;w[i],&amp;b[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d/n&quot;,Chinese_Remainder(b,w,n));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int oula(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int rea=n;</span><br><span class="line">    for(int i=2; i&lt;=n; i++)</span><br><span class="line">        if(n%i==0)//第一次找到的必为素因子</span><br><span class="line">        &#123;</span><br><span class="line">            rea=rea-rea/i;</span><br><span class="line">            do</span><br><span class="line">                n/=i;//把该素因子全部约掉</span><br><span class="line">            while(n%i==0);</span><br><span class="line">        &#125;</span><br><span class="line">    return rea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int prime[maxn];</span><br><span class="line">int visit[maxn];</span><br><span class="line">void Prime()&#123;</span><br><span class="line">    mem(visit,0);</span><br><span class="line">    mem(prime, 0);</span><br><span class="line">    for (int i = 2;i &lt;= maxn; i++) &#123;</span><br><span class="line">        cout&lt;&lt;&quot; i = &quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        if (!visit[i]) &#123;</span><br><span class="line">            prime[++prime[0]] = i;      //纪录素数， 这个prime[0] 相当于 cnt，用来计数</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;=prime[0] &amp;&amp; i*prime[j] &lt;= maxn; j++) &#123;</span><br><span class="line">            visit[i*prime[j]] = 1;</span><br><span class="line">            if (i % prime[j] == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><h4 id="卡特兰数打表"><a href="#卡特兰数打表" class="headerlink" title="卡特兰数打表"></a>卡特兰数打表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">unsigned long long ctl[34] = &#123;0,1&#125;;</span><br><span class="line">void calc()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 2; i &lt; 34; i ++)</span><br><span class="line">        ctl[i] = ctl[i-1]*(4*i-2)/(i+1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    calc();</span><br><span class="line">    for(i = 0; i &lt; 34; i ++)</span><br><span class="line">        printf(&quot;%d: %llu\n&quot;,i, ctl[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="卡特兰数表"><a href="#卡特兰数表" class="headerlink" title="卡特兰数表"></a>卡特兰数表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string catalan[]=</span><br><span class="line">&#123;</span><br><span class="line">    &quot;1&quot;,</span><br><span class="line">    &quot;2&quot;,</span><br><span class="line">    &quot;5&quot;,</span><br><span class="line">    &quot;14&quot;,</span><br><span class="line">    &quot;42&quot;,</span><br><span class="line">    &quot;132&quot;,</span><br><span class="line">    &quot;429&quot;,</span><br><span class="line">    &quot;1430&quot;,</span><br><span class="line">    &quot;4862&quot;,</span><br><span class="line">    &quot;16796&quot;,</span><br><span class="line">    &quot;58786&quot;,</span><br><span class="line">    &quot;208012&quot;,</span><br><span class="line">    &quot;742900&quot;,</span><br><span class="line">    &quot;2674440&quot;,</span><br><span class="line">    &quot;9694845&quot;,</span><br><span class="line">    &quot;35357670&quot;,</span><br><span class="line">    &quot;129644790&quot;,</span><br><span class="line">    &quot;477638700&quot;,</span><br><span class="line">    &quot;1767263190&quot;,</span><br><span class="line">    &quot;6564120420&quot;,</span><br><span class="line">    &quot;24466267020&quot;,</span><br><span class="line">    &quot;91482563640&quot;,</span><br><span class="line">    &quot;343059613650&quot;,</span><br><span class="line">    &quot;1289904147324&quot;,</span><br><span class="line">    &quot;4861946401452&quot;,</span><br><span class="line">    &quot;18367353072152&quot;,</span><br><span class="line">    &quot;69533550916004&quot;,</span><br><span class="line">    &quot;263747951750360&quot;,</span><br><span class="line">    &quot;1002242216651368&quot;,</span><br><span class="line">    &quot;3814986502092304&quot;,</span><br><span class="line">    &quot;14544636039226909&quot;,</span><br><span class="line">    &quot;55534064877048198&quot;,</span><br><span class="line">    &quot;212336130412243110&quot;,</span><br><span class="line">    &quot;812944042149730764&quot;,</span><br><span class="line">    &quot;3116285494907301262&quot;,</span><br><span class="line">    &quot;11959798385860453492&quot;,</span><br><span class="line">    &quot;45950804324621742364&quot;,</span><br><span class="line">    &quot;176733862787006701400&quot;,</span><br><span class="line">    &quot;680425371729975800390&quot;,</span><br><span class="line">    &quot;2622127042276492108820&quot;,</span><br><span class="line">    &quot;10113918591637898134020&quot;,</span><br><span class="line">    &quot;39044429911904443959240&quot;,</span><br><span class="line">    &quot;150853479205085351660700&quot;,</span><br><span class="line">    &quot;583300119592996693088040&quot;,</span><br><span class="line">    &quot;2257117854077248073253720&quot;,</span><br><span class="line">    &quot;8740328711533173390046320&quot;,</span><br><span class="line">    &quot;33868773757191046886429490&quot;,</span><br><span class="line">    &quot;131327898242169365477991900&quot;,</span><br><span class="line">    &quot;509552245179617138054608572&quot;,</span><br><span class="line">    &quot;1978261657756160653623774456&quot;,</span><br><span class="line">    &quot;7684785670514316385230816156&quot;,</span><br><span class="line">    &quot;29869166945772625950142417512&quot;,</span><br><span class="line">    &quot;116157871455782434250553845880&quot;,</span><br><span class="line">    &quot;451959718027953471447609509424&quot;,</span><br><span class="line">    &quot;1759414616608818870992479875972&quot;,</span><br><span class="line">    &quot;6852456927844873497549658464312&quot;,</span><br><span class="line">    &quot;26700952856774851904245220912664&quot;,</span><br><span class="line">    &quot;104088460289122304033498318812080&quot;,</span><br><span class="line">    &quot;405944995127576985730643443367112&quot;,</span><br><span class="line">    &quot;1583850964596120042686772779038896&quot;,</span><br><span class="line">    &quot;6182127958584855650487080847216336&quot;,</span><br><span class="line">    &quot;24139737743045626825711458546273312&quot;,</span><br><span class="line">    &quot;94295850558771979787935384946380125&quot;,</span><br><span class="line">    &quot;368479169875816659479009042713546950&quot;,</span><br><span class="line">    &quot;1440418573150919668872489894243865350&quot;,</span><br><span class="line">    &quot;5632681584560312734993915705849145100&quot;,</span><br><span class="line">    &quot;22033725021956517463358552614056949950&quot;,</span><br><span class="line">    &quot;86218923998960285726185640663701108500&quot;,</span><br><span class="line">    &quot;337485502510215975556783793455058624700&quot;,</span><br><span class="line">    &quot;1321422108420282270489942177190229544600&quot;,</span><br><span class="line">    &quot;5175569924646105559418940193995065716350&quot;,</span><br><span class="line">    &quot;20276890389709399862928998568254641025700&quot;,</span><br><span class="line">    &quot;79463489365077377841208237632349268884500&quot;,</span><br><span class="line">    &quot;311496878311103321137536291518809134027240&quot;,</span><br><span class="line">    &quot;1221395654430378811828760722007962130791020&quot;,</span><br><span class="line">    &quot;4790408930363303911328386208394864461024520&quot;,</span><br><span class="line">    &quot;18793142726809884575211361279087545193250040&quot;,</span><br><span class="line">    &quot;73745243611532458459690151854647329239335600&quot;,</span><br><span class="line">    &quot;289450081175264899454283846029490767264392230&quot;,</span><br><span class="line">    &quot;1136359577947336271931632877004667456667613940&quot;,</span><br><span class="line">    &quot;4462290049988320482463241297506133183499654740&quot;,</span><br><span class="line">    &quot;17526585015616776834735140517915655636396234280&quot;,</span><br><span class="line">    &quot;68854441132780194707888052034668647142985206100&quot;,</span><br><span class="line">    &quot;270557451039395118028642463289168566420671280440&quot;,</span><br><span class="line">    &quot;1063353702922273835973036658043476458723103404520&quot;,</span><br><span class="line">    &quot;4180080073556524734514695828170907458428751314320&quot;,</span><br><span class="line">    &quot;16435314834665426797069144960762886143367590394940&quot;,</span><br><span class="line">    &quot;64633260585762914370496637486146181462681535261000&quot;,</span><br><span class="line">    &quot;254224158304000796523953440778841647086547372026600&quot;,</span><br><span class="line">    &quot;1000134600800354781929399250536541864362461089950800&quot;,</span><br><span class="line">    &quot;3935312233584004685417853572763349509774031680023800&quot;,</span><br><span class="line">    &quot;15487357822491889407128326963778343232013931127835600&quot;,</span><br><span class="line">    &quot;60960876535340415751462563580829648891969728907438000&quot;,</span><br><span class="line">    &quot;239993345518077005168915776623476723006280827488229600&quot;,</span><br><span class="line">    &quot;944973797977428207852605870454939596837230758234904050&quot;,</span><br><span class="line">    &quot;3721443204405954385563870541379246659709506697378694300&quot;,</span><br><span class="line">    &quot;14657929356129575437016877846657032761712954950899755100&quot;,</span><br><span class="line">    &quot;57743358069601357782187700608042856334020731624756611000&quot;,</span><br><span class="line">    &quot;227508830794229349661819540395688853956041682601541047340&quot;,</span><br><span class="line">    &quot;896519947090131496687170070074100632420837521538745909320&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int i;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;i)!=EOF)&#123;</span><br><span class="line">		cout&lt;&lt;catalan[i-1]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="斯特林数"><a href="#斯特林数" class="headerlink" title="斯特林数"></a>斯特林数</h3><h4 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define RI register int</span><br><span class="line">const int N=200005,mod=998244353,G=3;</span><br><span class="line">int n,A,B,ans,a[18][N],rev[N];</span><br><span class="line">int ksm(int x,int y) &#123;</span><br><span class="line">	int re=1;</span><br><span class="line">	for(RI i=y;i;i&gt;&gt;=1,x=1LL*x*x%mod) if(i&amp;1) re=1LL*re*x%mod;</span><br><span class="line">	return re;</span><br><span class="line">&#125;</span><br><span class="line">void NTT(int *a,int n,int x) &#123;</span><br><span class="line">	for(RI i=0;i&lt;n;++i) if(rev[i]&gt;i) swap(a[i],a[rev[i]]);</span><br><span class="line">	for(RI i=1;i&lt;n;i&lt;&lt;=1) &#123;</span><br><span class="line">		int gn=ksm(G,(mod-1)/(i&lt;&lt;1));</span><br><span class="line">		for(RI j=0;j&lt;n;j+=(i&lt;&lt;1)) &#123;</span><br><span class="line">			int g=1,t1,t2;</span><br><span class="line">			for(RI k=0;k&lt;i;++k,g=1LL*g*gn%mod) &#123;</span><br><span class="line">				t1=a[j+k],t2=1LL*g*a[j+i+k]%mod;</span><br><span class="line">				a[j+k]=(t1+t2)%mod,a[j+i+k]=(t1-t2+mod)%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(x==1) return;</span><br><span class="line">	int inv=ksm(n,mod-2);reverse(a+1,a+n);//a+1!!!</span><br><span class="line">	for(RI i=0;i&lt;n;++i) a[i]=1LL*a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">void work(int s,int t,int d) &#123;</span><br><span class="line">	if(s==t) &#123;a[d][0]=s,a[d][1]=1;return;&#125;</span><br><span class="line">	int mid=(s+t)&gt;&gt;1,len=0,kn=1;</span><br><span class="line">	work(s,mid,d+1);</span><br><span class="line">	for(RI i=0;i&lt;=mid-s+1;++i) a[d][i]=a[d+1][i];</span><br><span class="line">	work(mid+1,t,d+1);</span><br><span class="line">	while(kn&lt;=t-s+1) kn&lt;&lt;=1,++len;</span><br><span class="line">	for(RI i=0;i&lt;kn;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(len-1));</span><br><span class="line">	for(RI i=mid-s+2;i&lt;kn;++i) a[d][i]=0;</span><br><span class="line">	for(RI i=t-mid+1;i&lt;kn;++i) a[d+1][i]=0;</span><br><span class="line">	NTT(a[d],kn,1),NTT(a[d+1],kn,1);</span><br><span class="line">	for(RI i=0;i&lt;kn;++i) a[d][i]=1LL*a[d][i]*a[d+1][i]%mod;</span><br><span class="line">	NTT(a[d],kn,-1);</span><br><span class="line">&#125;</span><br><span class="line">int C(int d,int u) &#123;</span><br><span class="line">	int k1=1,k2=1;</span><br><span class="line">	for(RI i=d-u+1;i&lt;=d;++i) k1=1LL*k1*i%mod;</span><br><span class="line">	for(RI i=1;i&lt;=u;++i) k2=1LL*k2*i%mod;</span><br><span class="line">	return 1LL*k1*ksm(k2,mod-2)%mod;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;A,&amp;B);</span><br><span class="line">	if(!A||!B||A+B-2&gt;n-1) &#123;puts(&quot;0&quot;);return 0;&#125;</span><br><span class="line">	if(n==1) &#123;puts(&quot;1&quot;);return 0;&#125;</span><br><span class="line">	work(0,n-2,0);</span><br><span class="line">	ans=1LL*a[0][A+B-2]*C(A+B-2,B-1)%mod;</span><br><span class="line">	printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define RI register int</span><br><span class="line">const int mod=998244353,G=3,N=262150;</span><br><span class="line">int n,kn,len,ans;</span><br><span class="line">int a[N],b[N],fac[N],ni[N],rev[N];</span><br><span class="line">int ksm(int x,int y) &#123;</span><br><span class="line">	int re=1;</span><br><span class="line">	for(;y;y&gt;&gt;=1,x=1LL*x*x%mod) if(y&amp;1) re=1LL*re*x%mod;</span><br><span class="line">	return re;</span><br><span class="line">&#125;</span><br><span class="line">void NTT(int *a,int n,int x) &#123;</span><br><span class="line">    for(RI i=0;i&lt;n;++i) if(rev[i]&gt;i) swap(a[i],a[rev[i]]);</span><br><span class="line">    for(RI i=1;i&lt;n;i&lt;&lt;=1) &#123;</span><br><span class="line">        int gn=ksm(G,(mod-1)/(i&lt;&lt;1));</span><br><span class="line">        for(RI j=0;j&lt;n;j+=(i&lt;&lt;1)) &#123;</span><br><span class="line">            int g=1,t1,t2;</span><br><span class="line">            for(RI k=0;k&lt;i;++k,g=1LL*g*gn%mod) &#123;</span><br><span class="line">                t1=a[j+k],t2=1LL*g*a[j+i+k]%mod;</span><br><span class="line">                a[j+k]=(t1+t2)%mod,a[j+i+k]=(t1-t2+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x==1) return;</span><br><span class="line">    int inv=ksm(n,mod-2);reverse(a+1,a+n);</span><br><span class="line">    for(RI i=0;i&lt;n;++i) a[i]=1LL*a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	fac[0]=1;for(RI i=1;i&lt;=n;++i) fac[i]=1LL*fac[i-1]*i%mod;</span><br><span class="line">	ni[n]=ksm(fac[n],mod-2);</span><br><span class="line">	for(RI i=n-1;i&gt;=0;--i) ni[i]=1LL*ni[i+1]*(i+1)%mod;</span><br><span class="line">	for(RI i=0;i&lt;=n;++i) &#123;</span><br><span class="line">		a[i]=1LL*(1-2*(i&amp;1)+mod)%mod*ni[i]%mod;</span><br><span class="line">		if(i!=1) b[i]=1LL*(ksm(i,n+1)-1+mod)%mod*ni[i]%mod*ksm(i-1+mod,mod-2)%mod;</span><br><span class="line">		else b[i]=n+1;</span><br><span class="line">	&#125;</span><br><span class="line">	kn=1;while(kn&lt;=n+n) kn&lt;&lt;=1,++len;</span><br><span class="line">	for(RI i=0;i&lt;kn;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(len-1));</span><br><span class="line">	NTT(a,kn,1),NTT(b,kn,1);</span><br><span class="line">	for(RI i=0;i&lt;kn;++i) a[i]=1LL*a[i]*b[i]%mod;</span><br><span class="line">	NTT(a,kn,-1);</span><br><span class="line">	for(RI i=0,j=1;i&lt;=n;++i,j=(j+j)%mod)</span><br><span class="line">		ans=(ans+1LL*j*fac[i]%mod*a[i]%mod)%mod;</span><br><span class="line">	printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>逆元(Inverse element)就是在mod意义下，不能直接除以一个数，而要乘以它的逆元。<br>比如a∗b≡1(modp)a∗b≡1(modp)，那么a，b互为模n意义下的逆元，比如你要算x/a，就可以改成x*b%p</p>
<p>观察a∗b≡1(modp)a∗b≡1(modp),变形为a∗b+k∗p=1a∗b+k∗p=1，就可以用扩展欧几里得算法求a了，同时这里也说明了a和p只有在互素的情况下才存在逆元。</p>
<p>注意<br>在下面所有的算法中，最好先把除数取个模再运算。</p>
<h4 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h4><p>原理<br>a∗b≡1(modp)a∗b≡1(modp)<br>a∗b+k∗p=1a∗b+k∗p=1<br>然后a就是我们要求的逆元，最终得到一个正数a的话就要对a mod p，因为a加上mp的时侯k减少mb可以使得等式依然成立。</p>
<p>如果你不想让逆元为正数，那么直接返回x也是可以正确的逆元</p>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y)//扩展欧几里得算法 </span><br><span class="line">&#123;</span><br><span class="line">    if(b==0)</span><br><span class="line">    &#123;</span><br><span class="line">        x=1,y=0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">LL getInv(int a,int mod)//求a在mod下的逆元，不存在逆元返回-1 </span><br><span class="line">&#123;</span><br><span class="line">    LL x,y;</span><br><span class="line">    LL d=exgcd(a,mod,x,y);</span><br><span class="line">    return d==1?(x%mod+mod)%mod:-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：返回的时候可以改成(x+mod)%mod，因为扩展欧几里得算法算出来的x应该不会太大.</p>
<p>性能分析:</p>
<p>时间复杂度:O(logn)（实际是斐波那契数列）<br>适用范围：只要存在逆元即可求，适用于个数不多但是mod很大的时候，也是最常见的一种求逆元的方法。</p>
<h4 id="费马小定理-欧拉定理"><a href="#费马小定理-欧拉定理" class="headerlink" title="费马小定理/欧拉定理"></a>费马小定理/欧拉定理</h4><p>原理<br>费马小定理：若p为素数，则有ap−1≡1(modp)ap−1≡1(modp)<br>ap−2∗a≡1(modp)ap−2∗a≡1(modp)<br>ap−2ap−2就是a在mod p意义下的逆元啦。</p>
<p>欧拉定理：若a、p互素，则有aφ(p)≡1(modp)aφ(p)≡1(modp)(费马小定理的一般形式)<br>aφ(p)∗a≡1(modp)aφ(p)∗a≡1(modp)<br>aφ(p)−1aφ(p)−1就是a在mod p意义下的逆元啦。</p>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LL qkpow(LL a,LL p,LL mod)</span><br><span class="line">&#123;</span><br><span class="line">    LL t=1,tt=a%mod;</span><br><span class="line">    while(p)</span><br><span class="line">    &#123;</span><br><span class="line">        if(p&amp;1)t=t*tt%mod;</span><br><span class="line">        tt=tt*tt%mod;</span><br><span class="line">        p&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line">LL getInv(LL a,LL mod)</span><br><span class="line">&#123;</span><br><span class="line">    return qkpow(a,mod-2,mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能分析：</p>
<p>O(logmod)<br>适用范围：一般在mod是个素数的时候用，比扩欧快一点而且好写。<br>但是如果是合数，相信一般没人无聊到去算个欧拉函数。</p>
<h4 id="递推求逆元"><a href="#递推求逆元" class="headerlink" title="递推求逆元"></a>递推求逆元</h4><p>原理<br>p是模数，i是待求的逆元，我们求的是i−1i−1在mod p意义下的值<br>p=k∗i+rp=k∗i+r令 r &lt; i,则k=p/i,r=p%i<br>k∗i+r≡0(modp)k∗i+r≡0(modp)<br>k∗r−1+i−1≡0(modp)k∗r−1+i−1≡0(modp)<br>i−1≡−k∗r−1(modp)i−1≡−k∗r−1(modp)<br>i−1≡−p/i∗inv[pmodi]i−1≡−p/i∗inv[pmodi]<br>嗯。。好难看的公式<br>说白了就是:inv[i]=-(mod/i)*inv[i%mod]<br>然后边界是inv[1]=1<br>这不仅为我们提供了一个线性求逆元的方法，也提供了一种O(logmod)求逆元的方法</p>
<p>代码<br>线性求逆元</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LL inv[mod+5];</span><br><span class="line">void getInv(LL mod)</span><br><span class="line">&#123;</span><br><span class="line">    inv[1]=1;</span><br><span class="line">    for(int i=2;i&lt;mod;i++)</span><br><span class="line">        inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>调用前要先预处理<br>调用的时候要先对除数取mod<br>性能分析：</p>
<p>时间复杂度O(n)<br>适用范围：mod数是不大的素数而且多次调用，比如卢卡斯定理。<br>递归求逆元</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LL inv(LL i)</span><br><span class="line">&#123;</span><br><span class="line">    if(i==1)return 1;</span><br><span class="line">    return (mod-mod/i)*inv(mod%i)%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能分析</p>
<p>时间复杂度:O(logmod)<br>好像找到了最简单的算法了！！</p>
<p>适用范围： mod数是素数，所以并不好用，比如中国剩余定理中就不好使，因为很多时候可能会忘记考虑mod数是不是素数。</p>
<h3 id="miller-rabin，Pollard-rho算法"><a href="#miller-rabin，Pollard-rho算法" class="headerlink" title="miller-rabin，Pollard_rho算法"></a>miller-rabin，Pollard_rho算法</h3><h4 id="大素数判断和素因子分解"><a href="#大素数判断和素因子分解" class="headerlink" title="大素数判断和素因子分解"></a>大素数判断和素因子分解</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//****************************************************************</span><br><span class="line">// Miller_Rabin 算法进行素数测试</span><br><span class="line">//速度快，而且可以判断 &lt;2^63的数</span><br><span class="line">//****************************************************************</span><br><span class="line">const int S=20;//随机算法判定次数，S越大，判错概率越小</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//计算 (a*b)%c.   a,b都是long long的数，直接相乘可能溢出的</span><br><span class="line">//  a,b,c &lt;2^63</span><br><span class="line">long long mult_mod(long long a,long long b,long long c)</span><br><span class="line">&#123;</span><br><span class="line">    a%=c;</span><br><span class="line">    b%=c;</span><br><span class="line">    long long ret=0;</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b&amp;1)&#123;ret+=a;ret%=c;&#125;</span><br><span class="line">        a&lt;&lt;=1;</span><br><span class="line">        if(a&gt;=c)a%=c;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//计算  x^n %c</span><br><span class="line">long long pow_mod(long long x,long long n,long long mod)//x^n%c</span><br><span class="line">&#123;</span><br><span class="line">    if(n==1)return x%mod;</span><br><span class="line">    x%=mod;</span><br><span class="line">    long long tmp=x;</span><br><span class="line">    long long ret=1;</span><br><span class="line">    while(n)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&amp;1) ret=mult_mod(ret,tmp,mod);</span><br><span class="line">        tmp=mult_mod(tmp,tmp,mod);</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//以a为基,n-1=x*2^t      a^(n-1)=1(mod n)  验证n是不是合数</span><br><span class="line">//一定是合数返回true,不一定返回false</span><br><span class="line">bool check(long long a,long long n,long long x,long long t)</span><br><span class="line">&#123;</span><br><span class="line">    long long ret=pow_mod(a,x,n);</span><br><span class="line">    long long last=ret;</span><br><span class="line">    for(int i=1;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret=mult_mod(ret,ret,n);</span><br><span class="line">        if(ret==1&amp;&amp;last!=1&amp;&amp;last!=n-1) return true;//合数</span><br><span class="line">        last=ret;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ret!=1) return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Miller_Rabin()算法素数判定</span><br><span class="line">//是素数返回true.(可能是伪素数，但概率极小)</span><br><span class="line">//合数返回false;</span><br><span class="line"></span><br><span class="line">bool Miller_Rabin(long long n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n&lt;2)return false;</span><br><span class="line">    if(n==2)return true;</span><br><span class="line">    if((n&amp;1)==0) return false;//偶数</span><br><span class="line">    long long x=n-1;</span><br><span class="line">    long long t=0;</span><br><span class="line">    while((x&amp;1)==0)&#123;x&gt;&gt;=1;t++;&#125;</span><br><span class="line">    for(int i=0;i&lt;S;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        long long a=rand()%(n-1)+1;//rand()需要stdlib.h头文件</span><br><span class="line">        if(check(a,n,x,t))</span><br><span class="line">            return false;//合数</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//************************************************</span><br><span class="line">//pollard_rho 算法进行质因数分解</span><br><span class="line">//************************************************</span><br><span class="line">long long factor[100];//质因数分解结果（刚返回时是无序的）</span><br><span class="line">int tol;//质因数的个数。数组小标从0开始</span><br><span class="line"></span><br><span class="line">long long gcd(long long a,long long b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a==0)return 1;//???????</span><br><span class="line">    if(a&lt;0) return gcd(-a,b);</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        long long t=a%b;</span><br><span class="line">        a=b;</span><br><span class="line">        b=t;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long Pollard_rho(long long x,long long c)</span><br><span class="line">&#123;</span><br><span class="line">    long long i=1,k=2;</span><br><span class="line">    long long x0=rand()%x;</span><br><span class="line">    long long y=x0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        x0=(mult_mod(x0,x0,x)+c)%x;</span><br><span class="line">        long long d=gcd(y-x0,x);</span><br><span class="line">        if(d!=1&amp;&amp;d!=x) return d;</span><br><span class="line">        if(y==x0) return x;</span><br><span class="line">        if(i==k)&#123;y=x0;k+=k;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//对n进行素因子分解</span><br><span class="line">void findfac(long long n)</span><br><span class="line">&#123;</span><br><span class="line">    if(Miller_Rabin(n))//素数</span><br><span class="line">    &#123;</span><br><span class="line">        factor[tol++]=n;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    long long p=n;</span><br><span class="line">    while(p&gt;=n)p=Pollard_rho(p,rand()%(n-1)+1);</span><br><span class="line">    findfac(p);</span><br><span class="line">    findfac(n/p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //srand(time(NULL));//需要time.h头文件//POJ上G++不能加这句话</span><br><span class="line">    long long n;</span><br><span class="line">    while(scanf(&quot;%I64d&quot;,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        tol=0;</span><br><span class="line">        findfac(n);</span><br><span class="line">        for(int i=0;i&lt;tol;i++)printf(&quot;%I64d &quot;,factor[i]);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        if(Miller_Rabin(n))printf(&quot;Yes\n&quot;);</span><br><span class="line">        else printf(&quot;No\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h2><h3 id="Lucas定理"><a href="#Lucas定理" class="headerlink" title="Lucas定理"></a>Lucas定理</h3><h4 id="费马小定理实现"><a href="#费马小定理实现" class="headerlink" title="费马小定理实现"></a>费马小定理实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">ll mulit(ll a,ll b,ll m)&#123;</span><br><span class="line">    ll ans=0;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) ans=(ans+a)%m;</span><br><span class="line">        a=(a&lt;&lt;1)%m;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll quick_mod(ll a,ll b,ll m)&#123;</span><br><span class="line">    ll ans=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans=mulit(ans,a,m);</span><br><span class="line">        &#125;</span><br><span class="line">        a=mulit(a,a,m);</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll comp(ll a,ll b,ll m)&#123;</span><br><span class="line">    if(a&lt;b) return 0;</span><br><span class="line">    if(a==b) return 1;</span><br><span class="line">    if(b&gt;a-b) b=a-b;</span><br><span class="line">    ll ans=1,ca=1,cb=1;</span><br><span class="line">    for(int i=0;i&lt;b;i++)&#123;</span><br><span class="line">        ca=ca*(a-i)%m;</span><br><span class="line">        cb=cb*(b-i)%m;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=ca*quick_mod(cb,m-2,m)%m;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll lucas(ll a,ll b,ll m)&#123;</span><br><span class="line">    ll ans=1;</span><br><span class="line">    while(a&amp;&amp;b)&#123;</span><br><span class="line">        ans=(ans*comp(a%m,b%m,m))%m;</span><br><span class="line">        a/=m;</span><br><span class="line">        b/=m;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll a,b,m;</span><br><span class="line">    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;m)&#123;</span><br><span class="line">        cout&lt;&lt;lucas(a,b,m)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="exgcd实现"><a href="#exgcd实现" class="headerlink" title="exgcd实现"></a>exgcd实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">ll exgcd(ll a,ll b,ll&amp; x,ll&amp; y)&#123;</span><br><span class="line">    if(a%b==0)&#123;</span><br><span class="line">        x=0,y=1;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">    ll r,tx,ty;</span><br><span class="line">    r=exgcd(b,a%b,tx,ty);</span><br><span class="line">    x=ty;</span><br><span class="line">    y=tx-a/b*ty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll comp(ll a,ll b,ll m)&#123;</span><br><span class="line">    if(a&lt;b) return 0;</span><br><span class="line">    if(a==b) return 1;</span><br><span class="line">    if(b&gt;a-b) b=a-b;</span><br><span class="line">    ll ans=1,ca=1,cb=1;</span><br><span class="line">    for(int i=0;i&lt;b;i++)&#123;</span><br><span class="line">        ca=ca*(a-i)%m;</span><br><span class="line">        cb=cb*(b-i)%m;</span><br><span class="line">    &#125;</span><br><span class="line">    ll x,y;</span><br><span class="line">    exgcd(cb,m,x,y);</span><br><span class="line">    x=(x%m+m)%m;</span><br><span class="line">    ans=ca*x%m;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll lucas(ll a,ll b,ll m)&#123;</span><br><span class="line">    ll ans=1;</span><br><span class="line">    while(a&amp;&amp;b)&#123;</span><br><span class="line">        ans=(ans*comp(a%m,b%m,m))%m;</span><br><span class="line">        a/=m;</span><br><span class="line">        b/=m;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll a,b,m;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;m;</span><br><span class="line">        cout&lt;&lt;lucas(a+b,b,m)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="全排列全组合"><a href="#全排列全组合" class="headerlink" title="全排列全组合"></a>全排列全组合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**** **** **** **** **** ****</span><br><span class="line">* Function Name : 全排列,全组合</span><br><span class="line">**** **** **** **** **** ****/</span><br><span class="line">void createper(int n) //全排列</span><br><span class="line">&#123;</span><br><span class="line">    int total,i,j,k,t,*a=new int[n],top;</span><br><span class="line">    total=1;</span><br><span class="line">    for(i=1; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=i;</span><br><span class="line">        total*=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=1; i&lt;n; i++)</span><br><span class="line">        printf(&quot;%d &quot;,a[i]);</span><br><span class="line">    printf(&quot;%d\n&quot;,a[n]);</span><br><span class="line">    for(i=1; i&lt;total; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j=n;</span><br><span class="line">        while(a[j]&lt;a[j-1])</span><br><span class="line">            j--;</span><br><span class="line">        k=n;</span><br><span class="line">        while(a[j-1]&gt;a[k])</span><br><span class="line">            k--;</span><br><span class="line">        t=a[j-1];</span><br><span class="line">        a[j-1]=a[k];</span><br><span class="line">        a[k]=t;</span><br><span class="line">        top=(j+n-1)/2;</span><br><span class="line">        for(k=j; k&lt;=top; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            t=a[k];</span><br><span class="line">            a[k]=a[n-k+j];</span><br><span class="line">            a[n-k+j]=t;</span><br><span class="line">        &#125;</span><br><span class="line">        for(j=1; j&lt;n; j++)</span><br><span class="line">            printf(&quot;%d &quot;,a[j]);</span><br><span class="line">        printf(&quot;%d\n&quot;,a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void createfab(int m,int n) //全组合</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,lcount,*a=new int[n+2];</span><br><span class="line">    for(i=1; i&lt;=n; i++)</span><br><span class="line">        a[i]=i;</span><br><span class="line">    a[n+1]=m+1;</span><br><span class="line">    for(j=1; j&lt;n; j++)</span><br><span class="line">        printf(&quot;%d &quot;,a[j]);</span><br><span class="line">    printf(&quot;%d\n&quot;,a[n]);</span><br><span class="line">    lcount=1;</span><br><span class="line">    while(a[1]&lt;m-n+1)</span><br><span class="line">    &#123;</span><br><span class="line">        for(i=n; i&gt;0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[i]&lt;a[i+1]-1)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i]++;</span><br><span class="line">                for(j=i; j&lt;n; j++)</span><br><span class="line">                    a[j+1]=a[j]+1;</span><br><span class="line">                for(j=1; j&lt;n; j++)</span><br><span class="line">                    printf(&quot;%d &quot;,a[j]);</span><br><span class="line">                printf(&quot;%d\n&quot;,a[n]);</span><br><span class="line">                lcount++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="母函数"><a href="#母函数" class="headerlink" title="母函数"></a>母函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// Author: Tanky Woo</span><br><span class="line">// www.wutianqi.com</span><br><span class="line">const int _max = 10001; </span><br><span class="line">// c1是保存各项质量砝码可以组合的数目</span><br><span class="line">// c2是中间量，保存每一次的情况</span><br><span class="line">int c1[_max], c2[_max];   </span><br><span class="line">int main()</span><br><span class="line">&#123;	//int n,i,j,k;</span><br><span class="line">	int nNum;   // </span><br><span class="line">	int i, j, k;</span><br><span class="line"> </span><br><span class="line">	while(cin &gt;&gt; nNum)</span><br><span class="line">	&#123;</span><br><span class="line">		for(i=0; i&lt;=nNum; ++i)   // ---- ①</span><br><span class="line">		&#123;</span><br><span class="line">			c1[i] = 1;</span><br><span class="line">			c2[i] = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		for(i=2; i&lt;=nNum; ++i)   // ----- ②</span><br><span class="line">		&#123;</span><br><span class="line"> </span><br><span class="line">			for(j=0; j&lt;=nNum; ++j)   // ----- ③</span><br><span class="line">				for(k=0; k+j&lt;=nNum; k+=i)  // ---- ④</span><br><span class="line">				&#123;</span><br><span class="line">					c2[j+k] += c1[j];</span><br><span class="line">				&#125;</span><br><span class="line">				for(j=0; j&lt;=nNum; ++j)     // ---- ⑤</span><br><span class="line">				&#123;</span><br><span class="line">					c1[j] = c2[j];</span><br><span class="line">					c2[j] = 0;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; c1[nNum] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int p[10]=&#123;0&#125;;</span><br><span class="line">int k;</span><br><span class="line">void getp(int n)</span><br><span class="line">&#123;</span><br><span class="line">	k=0;</span><br><span class="line">	for(int i=2;i*i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(n%i==0)</span><br><span class="line">		&#123;</span><br><span class="line">			p[k++]=i;	</span><br><span class="line">		&#125;</span><br><span class="line">		while(n%i==0)</span><br><span class="line">			n/=i;</span><br><span class="line">	&#125;</span><br><span class="line">	if(n&gt;1) p[k++]=n;</span><br><span class="line">&#125;</span><br><span class="line">int nop(int m)</span><br><span class="line">&#123;</span><br><span class="line">	int que[1000];</span><br><span class="line">	int top=0;</span><br><span class="line">	que[top++]=-1;</span><br><span class="line">	for(int i=0;i&lt;k;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int t=top;</span><br><span class="line">		for(int j=0;j&lt;t;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			que[top++]=que[j]*p[i]*(-1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int sum=0;</span><br><span class="line">	for(int i=1;i&lt;top;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=m/que[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">	getp(n);</span><br><span class="line">	printf(&quot;%d\n&quot;,m-nop(m));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int MAXN = 1000000;</span><br><span class="line">bool check[MAXN+10];</span><br><span class="line">int prime[MAXN+10];</span><br><span class="line">int mu[MAXN+10];</span><br><span class="line">void Moblus()</span><br><span class="line">&#123;</span><br><span class="line">    memset(check,false,sizeof(check));</span><br><span class="line">    mu[1] = 1;</span><br><span class="line">    int tot = 0;</span><br><span class="line">    for(int i = 2; i &lt;= MAXN; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if( !check[i] )</span><br><span class="line">        &#123;</span><br><span class="line">            prime[tot++] = i;</span><br><span class="line">            mu[i] = −1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 0; j &lt; tot; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i * prime[j] &gt; MAXN)</span><br><span class="line">                break;</span><br><span class="line">            check[i * prime[j]] = true;</span><br><span class="line">            if( i % prime[j] == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                mu[i * prime[j]] = 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                mu[i * prime[j]] = −mu[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="莫比乌斯Euler打表"><a href="#莫比乌斯Euler打表" class="headerlink" title="莫比乌斯Euler打表"></a>莫比乌斯Euler打表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN=1e2;</span><br><span class="line"></span><br><span class="line">int phi[MAXN],n,tot;</span><br><span class="line">int pri[MAXN];</span><br><span class="line">bool mark[MAXN];</span><br><span class="line"></span><br><span class="line">void getphi()&#123;</span><br><span class="line">    phi[1]=1;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!mark[i])&#123;</span><br><span class="line">            phi[i]=i-1;</span><br><span class="line">            pri[++tot]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=1;j&lt;=tot;j++)&#123;</span><br><span class="line">            int x=pri[j];</span><br><span class="line">            if(i*x&gt;n) break;</span><br><span class="line">            mark[i*x]=1;</span><br><span class="line">            if(i%x==0)&#123;</span><br><span class="line">                phi[i*x]=phi[i]*x;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else phi[i*x]=phi[i]*phi[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">        tot=0;</span><br><span class="line">        getphi();</span><br><span class="line"></span><br><span class="line">            printf(&quot;%d\n&quot;,phi[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long exgcd(long long a, long long b, long long &amp;x, long long &amp;y) &#123;</span><br><span class="line">    if (!b) &#123;x = 1; y = 0; return a;&#125;</span><br><span class="line">    long long d = exgcd(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long inv(long long a, long long n) &#123;</span><br><span class="line">    long long x, y;</span><br><span class="line">    exgcd(a, n, x, y);</span><br><span class="line">    return (x + n) % n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long pow_mod(long long x, long long k, long long n) &#123;</span><br><span class="line">    if (k == 0) return 1;</span><br><span class="line">    long long ans = pow_mod(x * x % n, k&gt;&gt;1, n);</span><br><span class="line">    if (k&amp;1)</span><br><span class="line">    ans = ans * x % n;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long log_mod(long long a, long long b, long long n) &#123;</span><br><span class="line">    long long m = (long long)sqrt(n + 0.5), v, e = 1, i;</span><br><span class="line">    v = inv(pow_mod(a, m, n), n);</span><br><span class="line">    map&lt;long long, long long&gt; x;</span><br><span class="line">    x[1] = 0;</span><br><span class="line">    for (long long i = 1; i &lt; m; i++) &#123;</span><br><span class="line">    e = e * a % n;</span><br><span class="line">    if (!x.count(e)) x[e] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    for (long long i = 0; i &lt; m; i++) &#123;</span><br><span class="line">    if (x.count(b)) return i * m + x[b];</span><br><span class="line">    b = b * v % n;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const long long MOD = 100000007;</span><br><span class="line">long long n, k, b, r, Max, x[505], y[505];</span><br><span class="line">typedef pair&lt;long long, long long&gt; pii;</span><br><span class="line"></span><br><span class="line">set&lt;pii&gt; beats;</span><br><span class="line"></span><br><span class="line">long long cal() &#123;</span><br><span class="line">    long long ans = 0;</span><br><span class="line">    for (long long i = 0; i &lt; b; i++) &#123;</span><br><span class="line">    if (x[i] != Max &amp;&amp; !beats.count(make_pair(x[i] + 1, y[i])))</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += n;</span><br><span class="line">    for (long long i = 0; i &lt; b; i++) if (x[i] == 1) ans--;</span><br><span class="line">    return pow_mod(k, ans,  MOD) * pow_mod(k - 1, Max * n - b - ans, MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long solve() &#123;</span><br><span class="line">    long long m = cal();</span><br><span class="line">    if (m == r) return Max;</span><br><span class="line">    long long tmp = n;</span><br><span class="line">    for (long long i = 0; i &lt; b; i++)</span><br><span class="line">    if (x[i] == Max) tmp--;</span><br><span class="line">    long long ans = pow_mod(k - 1, tmp, MOD) * pow_mod(k, n - tmp, MOD) % MOD;</span><br><span class="line">    m = m * ans % MOD;</span><br><span class="line">    if (m == r) return Max + 1;</span><br><span class="line">    return log_mod(pow_mod(k - 1, n, MOD), r * inv(m, MOD) % MOD, MOD) + Max + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    while (~scanf(&quot;%lld%lld%lld%lld&quot;, &amp;n, &amp;k, &amp;b, &amp;r)) &#123;</span><br><span class="line">    beats.clear();</span><br><span class="line">    Max = 1;</span><br><span class="line"></span><br><span class="line">    for (long long i = 0; i &lt; b; i++) &#123;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;, &amp;x[i], &amp;y[i]);</span><br><span class="line">        beats.insert(make_pair(x[i], y[i]));</span><br><span class="line">        Max = max(Max, x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,solve());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自适应-simpson-积分"><a href="#自适应-simpson-积分" class="headerlink" title="自适应 simpson 积分"></a>自适应 simpson 积分</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double simpson(double a,double b)</span><br><span class="line">&#123;</span><br><span class="line">    double c = a + (b−a)/2;</span><br><span class="line">    return (F(a) + 4*F(c) + F(b))*(b−a)/6</span><br><span class="line">&#125;</span><br><span class="line">double asr(double a,double b,double eps,double A)</span><br><span class="line">&#123;</span><br><span class="line">    double c = a + (b−a)/2;</span><br><span class="line">    double L = simpson(a,c), R = simpson(c,b);</span><br><span class="line">    if(fabs(L + R − A) &lt;= 15*eps)</span><br><span class="line">        return L + R + (L + R − A)/15.0;</span><br><span class="line">    return asr(a,c,eps/2,L) + asr(c,b,eps/2,R)</span><br><span class="line">&#125;</span><br><span class="line">double asr(double a,double b,double eps)return asr(a,b,eps,simpson(a,b));</span><br></pre></td></tr></table></figure>
<h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int pow_mod(int a, int n, int m)</span><br><span class="line">&#123;</span><br><span class="line">    long long ans = 1;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1)&#123;</span><br><span class="line">            ans = (ans * a) % m;</span><br><span class="line">        &#125;</span><br><span class="line">        a = (a * a) % m;</span><br><span class="line">        n &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, n, m;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; pow_mod(a, n, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int N=10;  </span><br><span class="line">int tmp[N][N];  </span><br><span class="line">void multi(int a[][N],int b[][N],int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(tmp,0,sizeof tmp);  </span><br><span class="line">    for(int i=0;i&lt;n;i++)  </span><br><span class="line">        for(int j=0;j&lt;n;j++)  </span><br><span class="line">        for(int k=0;k&lt;n;k++)  </span><br><span class="line">        tmp[i][j]+=a[i][k]*b[k][j];  </span><br><span class="line">    for(int i=0;i&lt;n;i++)  </span><br><span class="line">        for(int j=0;j&lt;n;j++)  </span><br><span class="line">        a[i][j]=tmp[i][j];  </span><br><span class="line">&#125;  </span><br><span class="line">int res[N][N];  </span><br><span class="line">void Pow(int a[][N],int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(res,0,sizeof res);//n是幂，N是矩阵大小  </span><br><span class="line">    for(int i=0;i&lt;N;i++) res[i][i]=1;  </span><br><span class="line">    while(n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if(n&amp;1)  </span><br><span class="line">            multi(res,a,N);//res=res*a;复制直接在multi里面实现了；  </span><br><span class="line">        multi(a,a,N);//a=a*a  </span><br><span class="line">        n&gt;&gt;=1;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h3><p>如果要求模的常数是一个64bit整数，那么在做乘法时，就没有扩展类型使用，必须手写一个高精度整数运算。</p>
<h4 id="O-logn-快速乘"><a href="#O-logn-快速乘" class="headerlink" title="O(logn)快速乘"></a>O(logn)快速乘</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline LL quick_mul(LL a,LL n,LL m)&#123;</span><br><span class="line">    LL ans=0;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) ans=(ans+a)%m;</span><br><span class="line">        a=(a&lt;&lt;1)%m;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="O-1-快速乘"><a href="#O-1-快速乘" class="headerlink" title="O(1)快速乘"></a>O(1)快速乘</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef long long ll;</span><br><span class="line">#define MOL 123456789012345LL</span><br><span class="line">inline ll mul_mod_ll(ll a,ll b)&#123;</span><br><span class="line">    ll d=(ll)floor(a*(long double)b/MOL+0.5);</span><br><span class="line">    ll ret=a*b-d*MOL;</span><br><span class="line">    if(ret&lt;0)   ret+=MOL;</span><br><span class="line">    return   ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，使用浮点数计算 a<em>b/MOL 的值，关键在于第二句，显然 a</em>b - d*MOL 两个乘法都可能溢出，不过没关系，因为可以预见，其差是一个64bit可以容纳的正整数，那么溢出部分的差仅可能是0或者1。最后一句符号的特判用来处理溢出部分差为1的情况。</p>
<p>考虑到计算 a*b/MOL 使用了浮点数计算，误差是不可避免的，故建议不要用太大的MOL使用这个方法。</p>
<h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline ll ksc(ll x,ll y,ll mod)&#123;</span><br><span class="line">    return (x*y-(ll)((long double)x/mod*y)*mod+mod)%mod;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为x,y都是mod意义下的，保证了x*y/mod不会爆long long。</p>
<h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**** **** **** **** **** ****</span><br><span class="line">* Function Name : 高斯消元法</span><br><span class="line">* Description : 求解线性方程组</span><br><span class="line">*</span><br><span class="line">* void exchange_col(int p1,int p2,int n)</span><br><span class="line">* 交换 p1 行和 p2 行的所有数据</span><br><span class="line">*</span><br><span class="line">* bool gauss(int n)</span><br><span class="line">* 求解系数矩阵为 n 的线性方程组，方程组无解返回 false，否则 true</span><br><span class="line">*</span><br><span class="line">* x1 = x0 - f(x0)/f&apos;(x0) 牛顿迭代法</span><br><span class="line">**** **** **** **** **** ****/</span><br><span class="line">const int num = 100;</span><br><span class="line">double matrix[num][num + 1]; //系数矩阵，从 0 开始</span><br><span class="line">double ans[num]; //结果数组</span><br><span class="line">void exchange_col(int p1,int p2,int n) //交换 p1 行和 p2 行的所有数据</span><br><span class="line">&#123;</span><br><span class="line">    double t;</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 0 ; i &lt;= n ; i++)</span><br><span class="line">        t = matrix[p1][i],matrix[p1][i] = matrix[p2][i],matrix[p2][i] = t;</span><br><span class="line">&#125;</span><br><span class="line">bool gauss(int n) //求解系数矩阵为 n 的线性方程组</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    int p;</span><br><span class="line">    double r;</span><br><span class="line">    for(i = 0 ; i &lt; n - 1 ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = i;</span><br><span class="line">        for(j = i + 1 ; j &lt; n ; j++)   //寻找 i 列绝对值最大值位置</span><br><span class="line">        &#123;</span><br><span class="line">            if(abs(matrix[j][i]) &gt; abs(matrix[p][i]))</span><br><span class="line">                p = j;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p != i)</span><br><span class="line">            exchange_col(i,p,n);</span><br><span class="line">        if(matrix[i][i] == 0)</span><br><span class="line">            return false;</span><br><span class="line">        for(j = i + 1 ; j &lt; n ; j++)   //剩余列进行消元</span><br><span class="line">        &#123;</span><br><span class="line">            r = matrix[j][i] / matrix[i][i];</span><br><span class="line">            for(k = i ; k &lt;= n ; k++)</span><br><span class="line">                matrix[j][k] -= r * matrix[i][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i = n - 1 ; i &gt;= 0 ; i--)   //获得结果</span><br><span class="line">    &#123;</span><br><span class="line">        ans[i] = matrix[i][n];</span><br><span class="line">        for(j = n - 1 ; j &gt; i ; j--)</span><br><span class="line">            ans[i] -= matrix[i][j] * ans[j];</span><br><span class="line">        if(matrix[i][i] == 0)</span><br><span class="line">            return false;</span><br><span class="line">        ans[i] /= matrix[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int HASH = 10007;</span><br><span class="line">const int MAXN = 2010;</span><br><span class="line">struct HASHMAP</span><br><span class="line">&#123;</span><br><span class="line">    int head[HASH],next[MAXN],size;</span><br><span class="line">    unsigned long long state[MAXN];</span><br><span class="line">    int f[MAXN];</span><br><span class="line">    void init()</span><br><span class="line">    &#123;</span><br><span class="line">        size = 0;</span><br><span class="line">        memset(head,−1,sizeof(head));</span><br><span class="line">    &#125; int insert(unsigned long long val,int _id)</span><br><span class="line">    &#123;</span><br><span class="line">        int h = val%HASH;</span><br><span class="line">        for(int i = head[h]; i != −1; i = next[i])</span><br><span class="line">            if(val == state[i])</span><br><span class="line">            &#123;</span><br><span class="line">                int tmp = f[i];</span><br><span class="line">                f[i] = _id;</span><br><span class="line">                return tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        f[size] = _id;</span><br><span class="line">        state[size] = val;</span><br><span class="line">        next[size] = head[h];</span><br><span class="line">        head[h] = size++;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; H;</span><br><span class="line">const int SEED = 13331;</span><br><span class="line">unsigned long long P[MAXN];</span><br><span class="line">unsigned long long S[MAXN];</span><br><span class="line">char str[MAXN];</span><br><span class="line">int ans[MAXN][MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    P[0] = 1;</span><br><span class="line">    for(int i = 1; i &lt; MAXN; i++)</span><br><span class="line">        P[i] = P[i−1] * SEED;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T−−)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%s&quot;,str);</span><br><span class="line">        int n = strlen(str);</span><br><span class="line">        S[0] = 0;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)</span><br><span class="line">            S[i] = S[i−1]*SEED + str[i−1];</span><br><span class="line">        memset(ans,0,sizeof(ans));</span><br><span class="line">        for(int L = 1; L &lt;= n; L++)</span><br><span class="line">        &#123;</span><br><span class="line">            H.init();</span><br><span class="line">            for(int i = 1; i + L − 1 &lt;= n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int l = H.insert(S[i+L−1] − S[i−1]*P[L],i);</span><br><span class="line">                ans[i][i+L−1] ++;</span><br><span class="line">                ans[l][i+L−1]−−;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = n; i &gt;= 0; i−−)</span><br><span class="line">            for(int j = i; j &lt;= n; j++)</span><br><span class="line">                ans[i][j] += ans[i+1][j] + ans[i][j−1] − ans[i−1];</span><br><span class="line">        int m,u,v;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">        while(m−−)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">            printf(&quot;%d\n&quot;,ans[u][v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串和数值hash"><a href="#字符串和数值hash" class="headerlink" title="字符串和数值hash"></a>字符串和数值hash</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 整数hash</span><br><span class="line">// 104729, 224737, 350377, 479909, 611953, 882377</span><br><span class="line">// 1020379, 1299709, 1583539, 1870667, 2015177</span><br><span class="line">// 4256233,5800079,7368787, 10570841, 15485863</span><br><span class="line">const int MOD = 20023;</span><br><span class="line">bool bhash[MOD];</span><br><span class="line">int vhash[MOD];</span><br><span class="line">int cnt[MOD];</span><br><span class="line">bool find_hash(int &amp; pos)</span><br><span class="line">&#123;</span><br><span class="line">    int val = pos;</span><br><span class="line">    pos %= MOD;</span><br><span class="line">    for (; bhash[pos]; pos=(pos+1)%MOD)</span><br><span class="line">    &#123;</span><br><span class="line">        if (vhash[pos] == val)</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int make_hash(int val)</span><br><span class="line">&#123;</span><br><span class="line">    int pos = val;</span><br><span class="line">    if (! find_hash(pos))</span><br><span class="line">    &#123;</span><br><span class="line">        bhash[pos] = true;</span><br><span class="line">        vhash[pos] = val;</span><br><span class="line">        cnt[pos] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[pos] ++;</span><br><span class="line">    return pos;</span><br><span class="line">&#125;</span><br><span class="line">//字符串hash</span><br><span class="line">const int MOD = 20023;</span><br><span class="line">bool bhash[MOD];</span><br><span class="line">char vhash[MOD][45];</span><br><span class="line">char str[45];</span><br><span class="line">int cal_str()</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, pos;</span><br><span class="line">    for (i=pos=0,j=1; str[i]; i++,j=(j*27)&amp;INT_MAX,pos&amp;=INT_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        int num = str[i] - &apos;a&apos;;</span><br><span class="line">        if (str[i] == &apos; &apos;)</span><br><span class="line">            num = 26;</span><br><span class="line">        pos += j*num;</span><br><span class="line">    &#125;</span><br><span class="line">    return pos % MOD;</span><br><span class="line">&#125;</span><br><span class="line">bool find_hash(int &amp; pos)</span><br><span class="line">&#123;</span><br><span class="line">    pos = cal_str();</span><br><span class="line">    for (; bhash[pos]; pos=(pos+1)%MOD)</span><br><span class="line">    &#123;</span><br><span class="line">        if (strcmp(vhash[pos], str) == 0)</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int make_hash()</span><br><span class="line">&#123;</span><br><span class="line">    int pos;</span><br><span class="line">    if (! find_hash(pos))</span><br><span class="line">    &#123;</span><br><span class="line">        bhash[pos] = true;</span><br><span class="line">        strcpy(vhash[pos], str);</span><br><span class="line">    &#125;</span><br><span class="line">    return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BM"><a href="#BM" class="headerlink" title="BM"></a>BM</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int* CreateBC(char* pattern, int len)</span><br><span class="line">&#123;</span><br><span class="line">	int* bc = new int[256];</span><br><span class="line"> </span><br><span class="line">	for(int i = 0; i &lt; 256; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		bc[i] = -1;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	for(int i = 0; i &lt; len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		bc[pattern[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	for(int i = 0; i &lt; 256; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		if(bc[i] != -1)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; &quot;bc[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; bc[i] &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return bc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int* CreateSuffix(char* pattern, int len)</span><br><span class="line">&#123;</span><br><span class="line">	int* suffix = new int[len];</span><br><span class="line">	suffix[len - 1] = len;</span><br><span class="line"> </span><br><span class="line">	for(int i = len - 2; i &gt;= 0; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		int j = i;</span><br><span class="line">		for(; pattern[j] == pattern[len - 1 - i + j] &amp;&amp; j &gt;= 0; --j);</span><br><span class="line">		suffix[i] = i - j;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	for(int i = 0; i &lt; len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;suffix[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; suffix[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return suffix;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int* CreateGS(char* pattern, int len)</span><br><span class="line">&#123;</span><br><span class="line">	int* suffix = CreateSuffix(pattern, len);</span><br><span class="line">	int* gs = new int[len];</span><br><span class="line">	/*</span><br><span class="line">	在计算gs数组时，从移动数最大的情况依次到移动数最少的情况赋值，</span><br><span class="line">	确保在合理的移动范围内，移动最少的距离，避免失配的情况。</span><br><span class="line">	*/</span><br><span class="line"> </span><br><span class="line">    //第三种情况</span><br><span class="line">	for(int i = 1; i &lt; len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		gs[i] = len;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    //第二种情况</span><br><span class="line">	for(int i = len - 1; i &gt;= 0; --i) //从右往左扫描，确保模式串移动最少。</span><br><span class="line">	&#123;</span><br><span class="line">		if(suffix[i] == i + 1) //是一个与好后缀匹配的最大前缀</span><br><span class="line">		&#123;</span><br><span class="line">			for(int j = 0; j &lt; len - 1 - i; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				if(gs[j] == len) //gs[j]初始值为len, 这样确保gs[j]只被修改一次</span><br><span class="line">				&#123;</span><br><span class="line">					gs[j] = len - 1 - i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    //第一种情况</span><br><span class="line">	for(int i = 0; i &lt; len - 1; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		gs[len - 1 - suffix[i]] = len - 1 - i;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return gs;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int bm_search(char* text, int text_len, char* pattern, int pattern_len)</span><br><span class="line">&#123;</span><br><span class="line">	int* bc = CreateBC(pattern, pattern_len);</span><br><span class="line">	int* gs = CreateGS(pattern, pattern_len);</span><br><span class="line"> </span><br><span class="line">	for(int i = 0; i &lt;= text_len - pattern_len; )</span><br><span class="line">	&#123;</span><br><span class="line">		int j = pattern_len - 1;</span><br><span class="line">		for(; j &gt;= 0 &amp;&amp; pattern[j] == text[i+j]; --j);</span><br><span class="line"> </span><br><span class="line">		if(j &lt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			return i;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		int bad_char_index = j;</span><br><span class="line">		char bad_char = text[i + j];</span><br><span class="line"> </span><br><span class="line">		int bc_move = bad_char_index - bc[bad_char];</span><br><span class="line">		if(bc_move &lt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			bc_move = bad_char_index + 1;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		int gs_move = gs[bad_char_index];</span><br><span class="line"> </span><br><span class="line">		int move = (bc_move &gt; gs_move ? bc_move : gs_move);</span><br><span class="line"> </span><br><span class="line">		i += move;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	if(bc != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		delete bc;</span><br><span class="line">		bc = NULL;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	if(gs != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		delete bc;</span><br><span class="line">		gs = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**** **** **** **** **** ****</span><br><span class="line">* Function Name : 字符串匹配(KMP 算法)</span><br><span class="line">* Description : O(N+M)</span><br><span class="line">**** **** **** **** **** ****/</span><br><span class="line">void get_nextval(const string &amp; s, int * p)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0,j = -1;</span><br><span class="line">    p[0] = -1;</span><br><span class="line">    while(i &lt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        if(j == -1 || s[i] == s[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i,++j;</span><br><span class="line">            if(s[i] != s[j])</span><br><span class="line">                p[i] = j;</span><br><span class="line">            else</span><br><span class="line">                p[i] = p[j];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            j = p[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int Index_KMP(const string &amp; s, const string &amp; s1, int pos)</span><br><span class="line">&#123;</span><br><span class="line">    int i = pos - 1,j = 0;</span><br><span class="line">    int * next = new int[s1.size()];</span><br><span class="line">    get_nextval(s1,next);</span><br><span class="line">    while(i &lt;= s.size() &amp;&amp; j &lt;= s1.size())</span><br><span class="line">    &#123;</span><br><span class="line">        if(j == -1 || s[i] == s1[j])</span><br><span class="line">            ++i,++j;</span><br><span class="line">        else</span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    if(j &gt; s1.size())</span><br><span class="line">        return i - s1.size();</span><br><span class="line">    else</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//该程序不能判别相同模式串，因此若模式串重复，答案会将相同模式串当做不同的处理，因此若需要可以用map去重或修改insert</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxm=500006;    //maxm是总结点数：约为字母数+++</span><br><span class="line"></span><br><span class="line">char s[1000005],word[55];</span><br><span class="line">int nxt[maxm][26],tail[maxm],f[maxm],size;    //nxt是结点指向不同字母的结点下标，tail是表示该结点为几个单词的词尾(可能需要计算重复的模式串情况),f是当不匹配时转跳到的结点下标,size是结点数</span><br><span class="line"></span><br><span class="line">int newnode()&#123;    //初始化整个trie或建立新的结点时，首先初始化当前结点所指向的26个字母的结点为0，表示暂时还没有指向的字母，然后暂定该结点不是单词尾结点，暂无失配时转跳位置（即转跳到根节点），返回结点标号</span><br><span class="line">    memset(nxt[size],0,sizeof(nxt[size]));</span><br><span class="line">    f[size]=tail[size]=0;</span><br><span class="line">    return size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(char s[])&#123;    //构造trie,p为当前结点的上一个结点标号，初始为0；x即为当前结点（上个结点标号指向当前字母的结点）标号,若此结点还未出现过，那么就建立这个结点；然后更新p为当前结点标号以便后续操作</span><br><span class="line">    int i,p=0;</span><br><span class="line">    for(i=0;s[i];i++)&#123;</span><br><span class="line">        int &amp;x=nxt[p][s[i]-&apos;a&apos;];</span><br><span class="line">        p=x?x:x=newnode();</span><br><span class="line">    &#125;</span><br><span class="line">    tail[p]++;    //此时仅将s串记录，即将s串结尾的结点加1，若无相同模式串，则此操作只会使所有串尾结点的tail值由0变为1，但有相同模式串，则会重复记录，需要去重可以用map或用tail[p]=1;语句来完成</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void makenxt()&#123;    //利用bfs来构造失配指针</span><br><span class="line">    int i;</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    f[0]=0;    //先将0结点挂的字母加入队列，失配指针指向0结点</span><br><span class="line">    for(i=0;i&lt;26;i++)&#123;</span><br><span class="line">        int v=nxt[0][i];</span><br><span class="line">        if(v)&#123;</span><br><span class="line">            f[v]=0;</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(i=0;i&lt;26;i++)&#123;</span><br><span class="line">            int v=nxt[u][i];</span><br><span class="line">            if(!v)nxt[u][i]=nxt[f[u]][i];    //当u结点没有i对应字母，则视为失配，将其指向失配后转跳到的结点所指向的i对应字母</span><br><span class="line">            else&#123;</span><br><span class="line">                q.push(v);    //u结点存在指向i的结点，则将所指向的结点下标加入队列</span><br><span class="line">                f[v]=nxt[f[u]][i];    //失配指针指向上个结点失配指针指向结点所挂当前字母的结点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(char s[])&#123;    //查询s串中模式串出现了多少种/次</span><br><span class="line">    int ans=0,v=0;</span><br><span class="line">    for(int i=0;s[i];i++)&#123;</span><br><span class="line">        while(v&amp;&amp;!nxt[v][s[i]-&apos;a&apos;])v=f[v];    //先匹配直到没有失配</span><br><span class="line">        v=nxt[v][s[i]-&apos;a&apos;];</span><br><span class="line">        int tmp=v;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            ans+=tail[tmp];</span><br><span class="line">            tail[tmp]=0;    //这里加这句是为了仅计算出现多少种模式链，而若不加这句则可以计算累计出现多少次</span><br><span class="line">            tmp=f[tmp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        int n;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        size=0,newnode();</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,word);</span><br><span class="line">            insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        makenxt();</span><br><span class="line">        scanf(&quot;%s&quot;,s);</span><br><span class="line">        printf(&quot;%d\n&quot;,query(s));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int CHAR = 26;</span><br><span class="line">const int MAXN = 250010;</span><br><span class="line">struct SAM_Node</span><br><span class="line">&#123;</span><br><span class="line">    SAM_Node *fa,*next[CHAR];</span><br><span class="line">    int len;</span><br><span class="line">    long long cnt;</span><br><span class="line">    void clear()</span><br><span class="line">    &#123;</span><br><span class="line">        fa = 0;</span><br><span class="line">        memset(next,0,sizeof(next));</span><br><span class="line">        cnt = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; pool[MAXN*2];</span><br><span class="line">SAM_Node *root,*tail;</span><br><span class="line">SAM_Node* newnode(int len)</span><br><span class="line">&#123;</span><br><span class="line">    SAM_Node* cur = tail++;</span><br><span class="line">    cur−&gt;clear();</span><br><span class="line">    cur−&gt;len = len;</span><br><span class="line">    return cur;</span><br><span class="line">&#125;</span><br><span class="line">void SAM_init()</span><br><span class="line">&#123;</span><br><span class="line">    tail = pool;</span><br><span class="line">    root = newnode(0);</span><br><span class="line">&#125;</span><br><span class="line">SAM_Node* extend(SAM_Node* last,int x)</span><br><span class="line">&#123;</span><br><span class="line">    SAM_Node *p = last, *np = newnode(p−&gt;len+1);</span><br><span class="line">    while(p &amp;&amp; !p−&gt;next[x])</span><br><span class="line">        p−&gt;next[x] = np, p = p−&gt;fa;</span><br><span class="line">    if(!p)</span><br><span class="line">        np−&gt;fa = root;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        SAM_Node* q = p−&gt;next[x];</span><br><span class="line">        if(q−&gt;len == p−&gt;len+1)</span><br><span class="line">            np−&gt;fa = q;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            SAM_Node* nq = newnode(p−&gt;len+1);</span><br><span class="line">            memcpy(nq−&gt;next,q−&gt;next,sizeof(q−&gt;nextnq−&gt;fa = q−&gt;fa; q−&gt;fa = np−&gt;fa = nq;</span><br><span class="line">                                               while(p &amp;&amp; p−&gt;next[x] == q)p−&gt;next[x] = nq, p = p−&gt;fa;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">return np;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><h2 id="基础计算几何"><a href="#基础计算几何" class="headerlink" title="基础计算几何"></a>基础计算几何</h2><h3 id="几何公式"><a href="#几何公式" class="headerlink" title="几何公式"></a><strong>几何公式</strong></h3><h4 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a><strong>三角形</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\1. 半周长 P=(a+b+c)/2</span><br><span class="line"></span><br><span class="line">\2. 面积 S=aHa/2=absin(C)/2=sqrt(P(P-a)(P-b)(P-c))</span><br><span class="line"></span><br><span class="line">\3. 中线 Ma=sqrt(2(b^2+c^2)-a^2)/2=sqrt(b^2+c^2+2bccos(A))/2</span><br><span class="line"></span><br><span class="line">\4. 角平分线 Ta=sqrt(bc((b+c)^2-a^2))/(b+c)=2bccos(A/2)/(b+c)</span><br><span class="line"></span><br><span class="line">\5. 高线 Ha=bsin(C)=csin(B)=sqrt(b^2-((a^2+b^2-c^2)/(2a))^2)</span><br><span class="line"></span><br><span class="line">\6. 内切圆半径 r=S/P=asin(B/2)sin(C/2)/sin((B+C)/2)</span><br><span class="line"></span><br><span class="line">               =4Rsin(A/2)sin(B/2)sin(C/2)=sqrt((P-a)(P-b)(P-c)/P)</span><br><span class="line"></span><br><span class="line">               =Ptan(A/2)tan(B/2)tan(C/2)</span><br><span class="line"></span><br><span class="line">\7. 外接圆半径 R=abc/(4S)=a/(2sin(A))=b/(2sin(B))=c/(2sin(C))</span><br></pre></td></tr></table></figure>
<h4 id="四边形"><a href="#四边形" class="headerlink" title="四边形"></a><strong>四边形</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D1,D2为对角线,M对角线中点连线,A为对角线夹角</span><br><span class="line"></span><br><span class="line">\1. a^2+b^2+c^2+d^2=D1^2+D2^2+4M^2</span><br><span class="line"></span><br><span class="line">\2. S=D1D2sin(A)/2</span><br><span class="line"></span><br><span class="line">(以下对圆的内接四边形)</span><br><span class="line"></span><br><span class="line">\3. ac+bd=D1D2</span><br><span class="line"></span><br><span class="line">\4. S=sqrt((P-a)(P-b)(P-c)(P-d)),P为半周长</span><br></pre></td></tr></table></figure>
<h4 id="正n边形"><a href="#正n边形" class="headerlink" title="正n边形"></a><strong>正n边形</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R为外接圆半径,r为内切圆半径</span><br><span class="line"></span><br><span class="line">\1. 中心角 A=2PI/n</span><br><span class="line"></span><br><span class="line">\2. 内角 C=(n-2)PI/n</span><br><span class="line"></span><br><span class="line">\3. 边长 a=2sqrt(R^2-r^2)=2Rsin(A/2)=2rtan(A/2)</span><br><span class="line"></span><br><span class="line">\4. 面积 S=nar/2=nr^2tan(A/2)=nR^2sin(A)/2=na^2/(4tan(A/2))</span><br></pre></td></tr></table></figure>
<h4 id="圆"><a href="#圆" class="headerlink" title="圆"></a><strong>圆</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\1. 弧长 l=rA</span><br><span class="line"></span><br><span class="line">\2. 弦长 a=2sqrt(2hr-h^2)=2rsin(A/2)</span><br><span class="line"></span><br><span class="line">\3. 弓形高 h=r-sqrt(r^2-a^2/4)=r(1-cos(A/2))=atan(A/4)/2</span><br><span class="line"></span><br><span class="line">\4. 扇形面积 S1=rl/2=r^2A/2</span><br><span class="line"></span><br><span class="line">\5. 弓形面积 S2=(rl-a(r-h))/2=r^2(A-sin(A))/2</span><br></pre></td></tr></table></figure>
<h4 id="棱柱"><a href="#棱柱" class="headerlink" title="棱柱"></a><strong>棱柱</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\1. 体积 V=Ah,A为底面积,h为高</span><br><span class="line"></span><br><span class="line">\2. 侧面积 S=lp,l为棱长,p为直截面周长</span><br><span class="line"></span><br><span class="line">\3. 全面积 T=S+2A</span><br></pre></td></tr></table></figure>
<h4 id="棱锥"><a href="#棱锥" class="headerlink" title="棱锥"></a><strong>棱锥</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\1. 体积 V=Ah/3,A为底面积,h为高</span><br><span class="line"></span><br><span class="line">(以下对正棱锥)</span><br><span class="line"></span><br><span class="line">\2. 侧面积 S=lp/2,l为斜高,p为底面周长</span><br><span class="line"></span><br><span class="line">\3. 全面积 T=S+A</span><br></pre></td></tr></table></figure>
<h4 id="棱台"><a href="#棱台" class="headerlink" title="棱台"></a><strong>棱台</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\1. 体积 V=(A1+A2+sqrt(A1A2))h/3,A1.A2为上下底面积,h为高</span><br><span class="line"></span><br><span class="line">(以下为正棱台)</span><br><span class="line"></span><br><span class="line">\2. 侧面积 S=(p1+p2)l/2,p1.p2为上下底面周长,l为斜高</span><br><span class="line"></span><br><span class="line">\3. 全面积 T=S+A1+A2</span><br></pre></td></tr></table></figure>
<h4 id="圆柱"><a href="#圆柱" class="headerlink" title="圆柱"></a><strong>圆柱</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\1. 侧面积 S=2PIrh</span><br><span class="line"></span><br><span class="line">\2. 全面积 T=2PIr(h+r)</span><br><span class="line"></span><br><span class="line">\3. 体积 V=PIr^2h</span><br></pre></td></tr></table></figure>
<h4 id="圆锥"><a href="#圆锥" class="headerlink" title="圆锥"></a><strong>圆锥</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\1. 母线 l=sqrt(h^2+r^2)</span><br><span class="line"></span><br><span class="line">\2. 侧面积 S=PIrl</span><br><span class="line"></span><br><span class="line">\3. 全面积 T=PIr(l+r)</span><br><span class="line"></span><br><span class="line">\4. 体积 V=PIr^2h/3</span><br></pre></td></tr></table></figure>
<h4 id="圆台"><a href="#圆台" class="headerlink" title="圆台"></a><strong>圆台</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\1. 母线 l=sqrt(h^2+(r1-r2)^2)</span><br><span class="line"></span><br><span class="line">\2. 侧面积 S=PI(r1+r2)l</span><br><span class="line"></span><br><span class="line">\3. 全面积 T=PIr1(l+r1)+PIr2(l+r2)</span><br><span class="line"></span><br><span class="line">\4. 体积 V=PI(r1^2+r2^2+r1r2)h/3</span><br></pre></td></tr></table></figure>
<h4 id="球"><a href="#球" class="headerlink" title="球"></a><strong>球</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\1. 全面积 T=4PIr^2</span><br><span class="line"></span><br><span class="line">\2. 体积 V=4PIr^3/3</span><br></pre></td></tr></table></figure>
<h4 id="球台"><a href="#球台" class="headerlink" title="球台"></a><strong>球台</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\1. 侧面积 S=2PIrh</span><br><span class="line"></span><br><span class="line">\2. 全面积 T=PI(2rh+r1^2+r2^2)</span><br><span class="line"></span><br><span class="line">\3. 体积 V=PIh(3(r1^2+r2^2)+h^2)/6</span><br></pre></td></tr></table></figure>
<h4 id="球扇形"><a href="#球扇形" class="headerlink" title="球扇形"></a><strong>球扇形</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\1. 全面积 T=PIr(2h+r0),h为球冠高,r0为球冠底面半径</span><br><span class="line"></span><br><span class="line">\2. 体积 V=2PIr^2h/3</span><br></pre></td></tr></table></figure>
<h3 id="直线与线段"><a href="#直线与线段" class="headerlink" title="直线与线段"></a><strong>直线与线段</strong></h3><h4 id="预备函数"><a href="#预备函数" class="headerlink" title="预备函数"></a><strong>预备函数</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//结构定义与宏定义**</span><br><span class="line"></span><br><span class="line">\#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#define eps 1e-8</span><br><span class="line"></span><br><span class="line">\#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)</span><br><span class="line"></span><br><span class="line">struct point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    double x,y;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct line</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    point a,b;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//计算cross product (P1-P0)x(P2-P0)**</span><br><span class="line"></span><br><span class="line">double xmult(point p1,point p2,point p0)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double xmult(double x1,double y1,double x2,double y2,double x0,double y0)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    return (x1-x0)*(y2-y0)-(x2-x0)*(y1-y0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//计算dot product (P1-P0).(P2-P0)**</span><br><span class="line"></span><br><span class="line">double dmult(point p1,point p2,point p0)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    return (p1.x-p0.x)*(p2.x-p0.x)+(p1.y-p0.y)*(p2.y-p0.y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double dmult(double x1,double y1,double x2,double y2,double x0,double y0)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    return (x1-x0)*(x2-x0)+(y1-y0)*(y2-y0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//两点距离**</span><br><span class="line"></span><br><span class="line">double distance(point p1,point p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double distance(double x1,double y1,double x2,double y2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判三点是否共线"><a href="#判三点是否共线" class="headerlink" title="判三点是否共线"></a><strong>判三点是否共线</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dots_inline(point p1,point p2,point p3)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return zero(xmult(p1,p2,p3));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判点是否在线段上"><a href="#判点是否在线段上" class="headerlink" title="判点是否在线段上"></a><strong>判点是否在线段上</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判点是否在线段上,包括端点（下面为两种接口模式）**</span><br><span class="line"></span><br><span class="line">int dot_online_in(point p,line l)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return zero(xmult(p,l.a,l.b))&amp;&amp;(l.a.x-p.x)*(l.b.x-p.x)&lt;eps&amp;&amp;(l.a.y-p.y)*(l.b.y-p.y)&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dot_online_in(point p,point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return zero(xmult(p,l1,l2))&amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps&amp;&amp;(l1.y-p.y)*(l2.y-p.y)&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//判点是否在线段上,不包括端点**</span><br><span class="line"></span><br><span class="line">int dot_online_ex(point p,line l)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return dot_online_in(p,l)&amp;&amp;(!zero(p.x-l.a.x)||!zero(p.y-l.a.y))</span><br><span class="line"></span><br><span class="line">           &amp;&amp;(!zero(p.x-l.b.x)||!zero(p.y-l.b.y));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两点在线段的同一侧"><a href="#判断两点在线段的同一侧" class="headerlink" title="判断两点在线段的同一侧"></a><strong>判断两点在线段的同一侧</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判两点在线段同侧,点在线段上返回0**</span><br><span class="line"></span><br><span class="line">int same_side(point p1,point p2,line l)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return xmult(l.a,p1,l.b)*xmult(l.a,p2,l.b)&gt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int same_side(point p1,point p2,point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return xmult(l1,p1,l2)*xmult(l1,p2,l2)&gt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两点是否在线段的异侧"><a href="#判断两点是否在线段的异侧" class="headerlink" title="判断两点是否在线段的异侧"></a><strong>判断两点是否在线段的异侧</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判两点在线段异侧,点在线段上返回0**</span><br><span class="line"></span><br><span class="line">int opposite_side(point p1,point p2,line l)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return xmult(l.a,p1,l.b)*xmult(l.a,p2,l.b)&lt;-eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int opposite_side(point p1,point p2,point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return xmult(l1,p1,l2)*xmult(l1,p2,l2)&lt;-eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="求点关于直线的对称点"><a href="#求点关于直线的对称点" class="headerlink" title="求点关于直线的对称点"></a><strong>求点关于直线的对称点</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**// 点关于直线的对称点 // by lyt**</span><br><span class="line"></span><br><span class="line">**// 缺点：用了斜率**</span><br><span class="line"></span><br><span class="line">**// 也可以利用&quot;点到直线上的最近点&quot;来做，避免使用斜率。**</span><br><span class="line"></span><br><span class="line">point symmetric_point(point p1, point l1, point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point ret;</span><br><span class="line"></span><br><span class="line">    if (l1.x &gt; l2.x - eps &amp;&amp; l1.x &lt; l2.x + eps)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        ret.x = (2 * l1.x - p1.x);</span><br><span class="line"></span><br><span class="line">        ret.y = p1.y;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        double k = (l1.y - l2.y ) / (l1.x - l2.x);</span><br><span class="line"></span><br><span class="line">        ret.x = (2*k*k*l1.x + 2*k*p1.y - 2*k*l1.y - k*k*p1.x + p1.x) / (1 + k*k);</span><br><span class="line"></span><br><span class="line">        ret.y = p1.y - (ret.x - p1.x ) / k;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两线段是否相交"><a href="#判断两线段是否相交" class="headerlink" title="判断两线段是否相交"></a><strong>判断两线段是否相交</strong></h4><h5 id="常用版"><a href="#常用版" class="headerlink" title="常用版"></a><strong>常用版</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//定义点</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x;</span><br><span class="line"></span><br><span class="line">    double y;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct Point point;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//叉积</span><br><span class="line"></span><br><span class="line">double multi(point p0, point p1, point p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return ( p1.x - p0.x )*( p2.y - p0.y )-( p2.x - p0.x )*( p1.y - p0.y );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//相交返回true,否则为false, 接口为两线段的端点</span><br><span class="line"></span><br><span class="line">bool isIntersected(point s1,point e1, point s2,point e2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return  (max(s1.x,e1.x) &gt;= min(s2.x,e2.x))  &amp;&amp;</span><br><span class="line"></span><br><span class="line">            (max(s2.x,e2.x) &gt;= min(s1.x,e1.x))  &amp;&amp;</span><br><span class="line"></span><br><span class="line">            (max(s1.y,e1.y) &gt;= min(s2.y,e2.y))  &amp;&amp;</span><br><span class="line"></span><br><span class="line">            (max(s2.y,e2.y) &gt;= min(s1.y,e1.y))  &amp;&amp;</span><br><span class="line"></span><br><span class="line">            (multi(s1,s2,e1)*multi(s1,e1,e2)&gt;0) &amp;&amp;</span><br><span class="line"></span><br><span class="line">            (multi(s2,s1,e2)*multi(s2,e2,e1)&gt;0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="不常用版"><a href="#不常用版" class="headerlink" title="不常用版"></a><strong>不常用版</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判两线段相交,包括端点和部分重合**</span><br><span class="line"></span><br><span class="line">int intersect_in(line u,line v)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (!dots_inline(u.a,u.b,v.a)||!dots_inline(u.a,u.b,v.b))</span><br><span class="line"></span><br><span class="line">        return !same_side(u.a,u.b,v)&amp;&amp;!same_side(v.a,v.b,u);</span><br><span class="line"></span><br><span class="line">    return dot_online_in(u.a,v)||dot_online_in(u.b,v)||dot_online_in(v.a,u)||dot_online_in(v.b,u);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int intersect_in(point u1,point u2,point v1,point v2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (!dots_inline(u1,u2,v1)||!dots_inline(u1,u2,v2))</span><br><span class="line"></span><br><span class="line">        return !same_side(u1,u2,v1,v2)&amp;&amp;!same_side(v1,v2,u1,u2);</span><br><span class="line"></span><br><span class="line">    return dot_online_in(u1,v1,v2)||dot_online_in(u2,v1,v2)||dot_online_in(v1,u1,u2)||dot_online_in(v2,u1,u2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//判两线段相交,不包括端点和部分重合**</span><br><span class="line"></span><br><span class="line">int intersect_ex(line u,line v)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return opposite_side(u.a,u.b,v)&amp;&amp;opposite_side(v.a,v.b,u);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int intersect_ex(point u1,point u2,point v1,point v2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return opposite_side(u1,u2,v1,v2)&amp;&amp;opposite_side(v1,v2,u1,u2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="求两条直线的交点"><a href="#求两条直线的交点" class="headerlink" title="求两条直线的交点"></a><strong>求两条直线的交点</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//计算两直线交点,注意事先判断直线是否平行!**</span><br><span class="line"></span><br><span class="line">**//线段交点请另外判线段相交(同时还是要判断是否平行!)**</span><br><span class="line"></span><br><span class="line">point intersection(point u1,point u2,point v1,point v2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point ret=u1;</span><br><span class="line"></span><br><span class="line">    double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))</span><br><span class="line"></span><br><span class="line">             /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));</span><br><span class="line"></span><br><span class="line">    ret.x+=(u2.x-u1.x)*t;</span><br><span class="line"></span><br><span class="line">    ret.y+=(u2.y-u1.y)*t;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="点到直线的最近距离"><a href="#点到直线的最近距离" class="headerlink" title="点到直线的最近距离"></a><strong>点到直线的最近距离</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">point ptoline(point p,point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point t=p;</span><br><span class="line"></span><br><span class="line">    t.x+=l1.y-l2.y,t.y+=l2.x-l1.x;</span><br><span class="line"></span><br><span class="line">    return intersection(p,t,l1,l2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="点到线段的最近距离"><a href="#点到线段的最近距离" class="headerlink" title="点到线段的最近距离"></a><strong>点到线段的最近距离</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">point ptoseg(point p,point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point t=p;</span><br><span class="line"></span><br><span class="line">    t.x+=l1.y-l2.y,t.y+=l2.x-l1.x;</span><br><span class="line"></span><br><span class="line">    if (xmult(l1,t,p)*xmult(l2,t,p)&gt;eps)</span><br><span class="line"></span><br><span class="line">        return distance(p,l1)&lt;distance(p,l2)?l1:l2;</span><br><span class="line"></span><br><span class="line">    return intersection(p,t,l1,l2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a><strong>多边形</strong></h3><h4 id="预备浮点函数"><a href="#预备浮点函数" class="headerlink" title="预备浮点函数"></a><strong>预备浮点函数</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#define MAXN 1000</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//offset为多变形坐标的最大绝对值**</span><br><span class="line"></span><br><span class="line">\#define offset 10000</span><br><span class="line"></span><br><span class="line">\#define eps 1e-8</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//浮点数判0**</span><br><span class="line"></span><br><span class="line">\#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//浮点数判断符**</span><br><span class="line"></span><br><span class="line">\#define _sign(x) ((x)&gt;eps?1:((x)&lt;-eps?2:0))</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//定义点**</span><br><span class="line"></span><br><span class="line">struct point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x,y;</span><br><span class="line"></span><br><span class="line">&#125;pt[MAXN ];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//定义线段**</span><br><span class="line"></span><br><span class="line">struct line</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point a,b;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//叉积**</span><br><span class="line"></span><br><span class="line">double xmult(point p1,point p2,point p0)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判定是否是凸多边形"><a href="#判定是否是凸多边形" class="headerlink" title="判定是否是凸多边形"></a><strong>判定是否是凸多边形</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判定凸多边形,顶点按顺时针或逆时针给出,允许相邻边共线,是凸多边形返回1，否则返回0**</span><br><span class="line"></span><br><span class="line">int is_convex(int n,point* p)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i,s[3]=&#123;1,1,1&#125;;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n&amp;&amp;s[1]|s[2];i++)</span><br><span class="line"></span><br><span class="line">        s[_sign(xmult(p[(i+1)%n],p[(i+2)%n],p[i]))]=0;</span><br><span class="line"></span><br><span class="line">    return s[1]|s[2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//判凸行，顶点按顺时针或逆时针给出,不允许相邻边共线,是凸多边形返回1，否则返回0**</span><br><span class="line"></span><br><span class="line">int is_convex_v2(int n,point* p)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i,s[3]=&#123;1,1,1&#125;;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n&amp;&amp;s[0]&amp;&amp;s[1]|s[2];i++)</span><br><span class="line"></span><br><span class="line">        s[_sign(xmult(p[(i+1)%n],p[(i+2)%n],p[i]))]=0;</span><br><span class="line"></span><br><span class="line">    return s[0]&amp;&amp;s[1]|s[2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判定点是否在多边形内"><a href="#判定点是否在多边形内" class="headerlink" title="判定点是否在多边形内"></a><strong>判定点是否在多边形内</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判点在凸多边形内或多边形边上时返回1，严格在凸多边形外返回0**</span><br><span class="line"></span><br><span class="line">int inside_convex(point q,int n,point* p)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i,s[3]=&#123;1,1,1&#125;;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n&amp;&amp;s[1]|s[2];i++)</span><br><span class="line"></span><br><span class="line">        s[_sign(xmult(p[(i+1)%n],q,p[i]))]=0;</span><br><span class="line"></span><br><span class="line">    return s[1]|s[2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//判点严格在凸多边形内返回1,在边上或者严格在外返回0**</span><br><span class="line"></span><br><span class="line">int inside_convex_v2(point q,int n,point* p)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i,s[3]=&#123;1,1,1&#125;;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n&amp;&amp;s[0]&amp;&amp;s[1]|s[2];i++)</span><br><span class="line"></span><br><span class="line">        s[_sign(xmult(p[(i+1)%n],q,p[i]))]=0;</span><br><span class="line"></span><br><span class="line">    return s[0]&amp;&amp;s[1]|s[2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//判点在任意多边形内,顶点按顺时针或逆时针给出**</span><br><span class="line"></span><br><span class="line">**//on_edge表示点在多边形边上时的返回值, offset为多边形坐标上限,严格在内返回1，严格在外返回0**</span><br><span class="line"></span><br><span class="line">int inside_polygon(point q,int n,point* p,int on_edge=2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point q2;</span><br><span class="line"></span><br><span class="line">    int i=0,count;</span><br><span class="line"></span><br><span class="line">    while (i&lt;n)</span><br><span class="line"></span><br><span class="line">        for (count=i=0,q2.x=rand()+offset,q2.y=rand()+offset;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (zero(xmult(q,p[i],p[(i+1)%n]))&amp;&amp;(p[i].x-q.x)*(p[(i+1)%n].x-q.x)&lt;eps</span><br><span class="line"></span><br><span class="line">                &amp;&amp;(p[i].y-q.y)*(p[(i+1)%n].y-q.y)&lt;eps)</span><br><span class="line"></span><br><span class="line">                return on_edge;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            else if (zero(xmult(q,q2,p[i])))</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            else if (xmult(q,p[i],q2)*xmult(q,p[(i+1)%n],q2)&lt;-eps&amp;&amp;</span><br><span class="line"></span><br><span class="line">                xmult(p[i],q,p[(i+1)%n])*xmult(p[i],q2,p[(i+1)%n])&lt;-eps)</span><br><span class="line"></span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return count&amp;1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判定一条线段是否在一个任意多边形内"><a href="#判定一条线段是否在一个任意多边形内" class="headerlink" title="判定一条线段是否在一个任意多边形内"></a><strong>判定一条线段是否在一个任意多边形内</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//预备函数**</span><br><span class="line"></span><br><span class="line">inline int opposite_side(point p1,point p2,point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return xmult(l1,p1,l2)*xmult(l1,p2,l2)&lt;-eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int dot_online_in(point p,point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return zero(xmult(p,l1,l2))&amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps&amp;&amp;(l1.y-p.y)*(l2.y-p.y)&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//判线段在任意多边形内,顶点按顺时针或逆时针给出,与边界相交返回1**</span><br><span class="line"></span><br><span class="line">int inside_polygon(point l1,point l2,int n,point* p)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point t[MAXN],tt;</span><br><span class="line"></span><br><span class="line">    int i,j,k=0;</span><br><span class="line"></span><br><span class="line">    if (!inside_polygon(l1,n,p)||!inside_polygon(l2,n,p))</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (opposite_side(l1,l2,p[i],p[(i+1)%n])&amp;&amp;opposite_side(p[i],p[(i+1)%n],l1,l2))</span><br><span class="line"></span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        else if (dot_online_in(l1,p[i],p[(i+1)%n]))</span><br><span class="line"></span><br><span class="line">            t[k++]=l1;</span><br><span class="line"></span><br><span class="line">        else if (dot_online_in(l2,p[i],p[(i+1)%n]))</span><br><span class="line"></span><br><span class="line">            t[k++]=l2;</span><br><span class="line"></span><br><span class="line">        else if (dot_online_in(p[i],l1,l2))</span><br><span class="line"></span><br><span class="line">            t[k++]=p[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;k;i++)</span><br><span class="line"></span><br><span class="line">        for (j=i+1;j&lt;k;j++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tt.x=(t[i].x+t[j].x)/2;</span><br><span class="line"></span><br><span class="line">            tt.y=(t[i].y+t[j].y)/2;</span><br><span class="line"></span><br><span class="line">            if (!inside_polygon(tt,n,p))</span><br><span class="line"></span><br><span class="line">                return 0;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三角形-1"><a href="#三角形-1" class="headerlink" title="三角形"></a><strong>三角形</strong></h3><h4 id="预备函数-1"><a href="#预备函数-1" class="headerlink" title="预备函数"></a><strong>预备函数</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">**//定义点**</span><br><span class="line"></span><br><span class="line">struct point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x,y;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct point point;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//定义直线**</span><br><span class="line"></span><br><span class="line">struct line</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point a,b;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct line line;</span><br><span class="line"></span><br><span class="line">**//两点距离**</span><br><span class="line"></span><br><span class="line">double distance(point p1,point p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//两直线求交点**</span><br><span class="line"></span><br><span class="line">point intersection(line u,line v)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	point ret=u.a;</span><br><span class="line"></span><br><span class="line">	double t=((u.a.x-v.a.x)*(v.a.y-v.b.y)-(u.a.y-v.a.y)*(v.a.x-v.b.x))</span><br><span class="line"></span><br><span class="line">			/((u.a.x-u.b.x)*(v.a.y-v.b.y)-(u.a.y-u.b.y)*(v.a.x-v.b.x));</span><br><span class="line"></span><br><span class="line">	ret.x+=(u.b.x-u.a.x)*t;</span><br><span class="line"></span><br><span class="line">	ret.y+=(u.b.y-u.a.y)*t;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="求三角形的外心"><a href="#求三角形的外心" class="headerlink" title="求三角形的外心"></a><strong>求三角形的外心</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">point circumcenter(point a,point b,point c)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	line u,v;</span><br><span class="line"></span><br><span class="line">	u.a.x=(a.x+b.x)/2;</span><br><span class="line"></span><br><span class="line">	u.a.y=(a.y+b.y)/2;</span><br><span class="line"></span><br><span class="line">	u.b.x=u.a.x-a.y+b.y;</span><br><span class="line"></span><br><span class="line">	u.b.y=u.a.y+a.x-b.x;</span><br><span class="line"></span><br><span class="line">	v.a.x=(a.x+c.x)/2;</span><br><span class="line"></span><br><span class="line">	v.a.y=(a.y+c.y)/2;</span><br><span class="line"></span><br><span class="line">	v.b.x=v.a.x-a.y+c.y;</span><br><span class="line"></span><br><span class="line">	v.b.y=v.a.y+a.x-c.x;</span><br><span class="line"></span><br><span class="line">	return intersection(u,v);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="求三角形内心"><a href="#求三角形内心" class="headerlink" title="求三角形内心"></a><strong>求三角形内心</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">point incenter(point a,point b,point c)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	line u,v;</span><br><span class="line"></span><br><span class="line">	double m,n;</span><br><span class="line"></span><br><span class="line">	u.a=a;</span><br><span class="line"></span><br><span class="line">	m=atan2(b.y-a.y,b.x-a.x);</span><br><span class="line"></span><br><span class="line">	n=atan2(c.y-a.y,c.x-a.x);</span><br><span class="line"></span><br><span class="line">	u.b.x=u.a.x+cos((m+n)/2);</span><br><span class="line"></span><br><span class="line">	u.b.y=u.a.y+sin((m+n)/2);</span><br><span class="line"></span><br><span class="line">	v.a=b;</span><br><span class="line"></span><br><span class="line">	m=atan2(a.y-b.y,a.x-b.x);</span><br><span class="line"></span><br><span class="line">	n=atan2(c.y-b.y,c.x-b.x);</span><br><span class="line"></span><br><span class="line">	v.b.x=v.a.x+cos((m+n)/2);</span><br><span class="line"></span><br><span class="line">	v.b.y=v.a.y+sin((m+n)/2);</span><br><span class="line"></span><br><span class="line">	return intersection(u,v);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="求三角形垂心"><a href="#求三角形垂心" class="headerlink" title="求三角形垂心"></a><strong>求三角形垂心</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">point perpencenter(point a,point b,point c)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	line u,v;</span><br><span class="line"></span><br><span class="line">	u.a=c;</span><br><span class="line"></span><br><span class="line">	u.b.x=u.a.x-a.y+b.y;</span><br><span class="line"></span><br><span class="line">	u.b.y=u.a.y+a.x-b.x;</span><br><span class="line"></span><br><span class="line">	v.a=b;</span><br><span class="line"></span><br><span class="line">	v.b.x=v.a.x-a.y+c.y;</span><br><span class="line"></span><br><span class="line">	v.b.y=v.a.y+a.x-c.x;</span><br><span class="line"></span><br><span class="line">	return intersection(u,v);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="圆-1"><a href="#圆-1" class="headerlink" title="圆"></a><strong>圆</strong></h3><h4 id="预备函数-2"><a href="#预备函数-2" class="headerlink" title="预备函数"></a><strong>预备函数</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#define eps 1e-8</span><br><span class="line"></span><br><span class="line">struct point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x,y;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct point point;</span><br><span class="line"></span><br><span class="line">double xmult(point p1,point p2,point p0)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double distance(point p1,point p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//点到直线的距离**</span><br><span class="line"></span><br><span class="line">double disptoline(point p,point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return fabs(xmult(p,l1,l2))/distance(l1,l2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//求两直线交点**</span><br><span class="line"></span><br><span class="line">point intersection(point u1,point u2,point v1,point v2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point ret=u1;</span><br><span class="line"></span><br><span class="line">    double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))</span><br><span class="line"></span><br><span class="line">             /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));</span><br><span class="line"></span><br><span class="line">    ret.x+=(u2.x-u1.x)*t;</span><br><span class="line"></span><br><span class="line">    ret.y+=(u2.y-u1.y)*t;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判定直线是否与圆相交"><a href="#判定直线是否与圆相交" class="headerlink" title="判定直线是否与圆相交"></a><strong>判定直线是否与圆相交</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//判直线和圆相交,包括相切</span><br><span class="line"></span><br><span class="line">int intersect_line_circle(point c,double r,point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return disptoline(c,l1,l2)&lt;r+eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判定线段与圆相交"><a href="#判定线段与圆相交" class="headerlink" title="判定线段与圆相交"></a><strong>判定线段与圆相交</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int intersect_seg_circle(point c,double r, point l1,point l2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double t1=distance(c,l1)-r,t2=distance(c,l2)-r;</span><br><span class="line"></span><br><span class="line">    point t=c;</span><br><span class="line"></span><br><span class="line">    if (t1&lt;eps||t2&lt;eps)</span><br><span class="line"></span><br><span class="line">        return t1&gt;-eps||t2&gt;-eps;</span><br><span class="line"></span><br><span class="line">    t.x+=l1.y-l2.y;</span><br><span class="line"></span><br><span class="line">    t.y+=l2.x-l1.x;</span><br><span class="line"></span><br><span class="line">    return xmult(l1,c,t)*xmult(l2,c,t)&lt;eps&amp;&amp;disptoline(c,l1,l2)-r&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判圆和圆相交"><a href="#判圆和圆相交" class="headerlink" title="判圆和圆相交"></a><strong>判圆和圆相交</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int intersect_circle_circle(point c1,double r1,point c2,double r2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return distance(c1,c2)&lt;r1+r2+eps&amp;&amp;distance(c1,c2)&gt;fabs(r1-r2)-eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算圆上到点p最近点"><a href="#计算圆上到点p最近点" class="headerlink" title="计算圆上到点p最近点"></a><strong>计算圆上到点p最近点</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//当p为圆心时，返回圆心本身**</span><br><span class="line"></span><br><span class="line">point dot_to_circle(point c,double r,point p)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point u,v;</span><br><span class="line"></span><br><span class="line">    if (distance(p,c)&lt;eps)</span><br><span class="line"></span><br><span class="line">        return p;</span><br><span class="line"></span><br><span class="line">    u.x=c.x+r*fabs(c.x-p.x)/distance(c,p);</span><br><span class="line"></span><br><span class="line">    u.y=c.y+r*fabs(c.y-p.y)/distance(c,p)*((c.x-p.x)*(c.y-p.y)&lt;0?-1:1);</span><br><span class="line"></span><br><span class="line">    v.x=c.x-r*fabs(c.x-p.x)/distance(c,p);</span><br><span class="line"></span><br><span class="line">    v.y=c.y-r*fabs(c.y-p.y)/distance(c,p)*((c.x-p.x)*(c.y-p.y)&lt;0?-1:1);</span><br><span class="line"></span><br><span class="line">    return distance(u,p)&lt;distance(v,p)?u:v;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算直线与圆的交点"><a href="#计算直线与圆的交点" class="headerlink" title="计算直线与圆的交点"></a><strong>计算直线与圆的交点</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//计算直线与圆的交点,保证直线与圆有交点**</span><br><span class="line"></span><br><span class="line">**//计算线段与圆的交点可用这个函数后判点是否在线段上**</span><br><span class="line"></span><br><span class="line">void intersection_line_circle(point c,double r,point l1,point l2,point&amp; p1,point&amp; p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point p=c;</span><br><span class="line"></span><br><span class="line">    double t;</span><br><span class="line"></span><br><span class="line">    p.x+=l1.y-l2.y;</span><br><span class="line"></span><br><span class="line">    p.y+=l2.x-l1.x;</span><br><span class="line"></span><br><span class="line">    p=intersection(p,c,l1,l2);</span><br><span class="line"></span><br><span class="line">    t=sqrt(r*r-distance(p,c)*distance(p,c))/distance(l1,l2);</span><br><span class="line"></span><br><span class="line">    p1.x=p.x+(l2.x-l1.x)*t;</span><br><span class="line"></span><br><span class="line">    p1.y=p.y+(l2.y-l1.y)*t;</span><br><span class="line"></span><br><span class="line">    p2.x=p.x-(l2.x-l1.x)*t;</span><br><span class="line"></span><br><span class="line">    p2.y=p.y-(l2.y-l1.y)*t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算两个圆的交点"><a href="#计算两个圆的交点" class="headerlink" title="计算两个圆的交点"></a><strong>计算两个圆的交点</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//计算圆与圆的交点,保证圆与圆有交点,圆心不重合**</span><br><span class="line"></span><br><span class="line">void intersection_circle_circle(point c1,double r1,point c2,double r2,point&amp; p1,point&amp; p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point u,v;</span><br><span class="line"></span><br><span class="line">    double t;</span><br><span class="line"></span><br><span class="line">    t=(1+(r1*r1-r2*r2)/distance(c1,c2)/distance(c1,c2))/2;</span><br><span class="line"></span><br><span class="line">    u.x=c1.x+(c2.x-c1.x)*t;</span><br><span class="line"></span><br><span class="line">    u.y=c1.y+(c2.y-c1.y)*t;</span><br><span class="line"></span><br><span class="line">    v.x=u.x+c1.y-c2.y;</span><br><span class="line"></span><br><span class="line">    v.y=u.y-c1.x+c2.x;</span><br><span class="line"></span><br><span class="line">    intersection_line_circle(c1,r1,u,v,p1,p2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="球面"><a href="#球面" class="headerlink" title="球面"></a><strong>球面</strong></h3><h4 id="给出地球经度纬度，计算圆心角"><a href="#给出地球经度纬度，计算圆心角" class="headerlink" title="给出地球经度纬度，计算圆心角"></a><strong>给出地球经度纬度，计算圆心角</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">const double pi=acos(-1);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//计算圆心角lat表示纬度,-90&lt;=w&lt;=90,lng表示经度**</span><br><span class="line"></span><br><span class="line">**//返回两点所在大圆劣弧对应圆心角,0&lt;=angle&lt;=pi**</span><br><span class="line"></span><br><span class="line">double angle(double lng1,double lat1,double lng2,double lat2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double dlng=fabs(lng1-lng2)*pi/180;</span><br><span class="line"></span><br><span class="line">    while (dlng&gt;=pi+pi)</span><br><span class="line"></span><br><span class="line">        dlng-=pi+pi;</span><br><span class="line"></span><br><span class="line">    if (dlng&gt;pi)</span><br><span class="line"></span><br><span class="line">        dlng=pi+pi-dlng;</span><br><span class="line"></span><br><span class="line">    lat1*=pi/180,lat2*=pi/180;</span><br><span class="line"></span><br><span class="line">    return acos(cos(lat1)*cos(lat2)*cos(dlng)+sin(lat1)*sin(lat2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="已知经纬度，计算地球上两点直线距离"><a href="#已知经纬度，计算地球上两点直线距离" class="headerlink" title="已知经纬度，计算地球上两点直线距离"></a><strong>已知经纬度，计算地球上两点直线距离</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//计算距离,r为球半径**</span><br><span class="line"></span><br><span class="line">double line_dist(double r,double lng1,double lat1,double lng2,double lat2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double dlng=fabs(lng1-lng2)*pi/180;</span><br><span class="line"></span><br><span class="line">    while (dlng&gt;=pi+pi)</span><br><span class="line"></span><br><span class="line">        dlng-=pi+pi;</span><br><span class="line"></span><br><span class="line">    if (dlng&gt;pi)</span><br><span class="line"></span><br><span class="line">        dlng=pi+pi-dlng;</span><br><span class="line"></span><br><span class="line">    lat1*=pi/180,lat2*=pi/180;</span><br><span class="line"></span><br><span class="line">    return r*sqrt(2-2*(cos(lat1)*cos(lat2)*cos(dlng)+sin(lat1)*sin(lat2)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="已知经纬度，计算地球上两点球面距离"><a href="#已知经纬度，计算地球上两点球面距离" class="headerlink" title="已知经纬度，计算地球上两点球面距离"></a><strong>已知经纬度，计算地球上两点球面距离</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//计算球面距离,r为球半径**</span><br><span class="line"></span><br><span class="line">inline double sphere_dist(double r,double lng1,double lat1,double lng2,double lat2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return r*angle(lng1,lat1,lng2,lat2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三维几何的若干模板"><a href="#三维几何的若干模板" class="headerlink" title="三维几何的若干模板"></a><strong>三维几何的若干模板</strong></h3><h4 id="预备函数-3"><a href="#预备函数-3" class="headerlink" title="预备函数"></a><strong>预备函数</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//三维几何函数库**</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#define eps 1e-8</span><br><span class="line"></span><br><span class="line">\#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)</span><br><span class="line"></span><br><span class="line">struct point3&#123;double x,y,z;&#125;;</span><br><span class="line"></span><br><span class="line">struct line3&#123;point3 a,b;&#125;;</span><br><span class="line"></span><br><span class="line">struct plane3&#123;point3 a,b,c;&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//计算cross product U x V**</span><br><span class="line"></span><br><span class="line">point3 xmult(point3 u,point3 v)&#123;</span><br><span class="line"></span><br><span class="line">	point3 ret;</span><br><span class="line"></span><br><span class="line">	ret.x=u.y*v.z-v.y*u.z;</span><br><span class="line"></span><br><span class="line">	ret.y=u.z*v.x-u.x*v.z;</span><br><span class="line"></span><br><span class="line">	ret.z=u.x*v.y-u.y*v.x;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//计算dot product U . V**</span><br><span class="line"></span><br><span class="line">double dmult(point3 u,point3 v)&#123;</span><br><span class="line"></span><br><span class="line">	return u.x*v.x+u.y*v.y+u.z*v.z;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//矢量差 U - V**</span><br><span class="line"></span><br><span class="line">point3 subt(point3 u,point3 v)&#123;</span><br><span class="line"></span><br><span class="line">	point3 ret;</span><br><span class="line"></span><br><span class="line">	ret.x=u.x-v.x;</span><br><span class="line"></span><br><span class="line">	ret.y=u.y-v.y;</span><br><span class="line"></span><br><span class="line">	ret.z=u.z-v.z;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//取平面法向量**</span><br><span class="line"></span><br><span class="line">point3 pvec(plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return xmult(subt(s.a,s.b),subt(s.b,s.c));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">point3 pvec(point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return xmult(subt(s1,s2),subt(s2,s3));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//两点距离,单参数取向量大小**</span><br><span class="line"></span><br><span class="line">double distance(point3 p1,point3 p2)&#123;</span><br><span class="line"></span><br><span class="line">	return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y)+(p1.z-p2.z)*(p1.z-p2.z));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//向量大小**</span><br><span class="line"></span><br><span class="line">double vlen(point3 p)&#123;</span><br><span class="line"></span><br><span class="line">	return sqrt(p.x*p.x+p.y*p.y+p.z*p.z);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判定三点是否共线"><a href="#判定三点是否共线" class="headerlink" title="判定三点是否共线"></a><strong>判定三点是否共线</strong></h4><p><strong>//判三点共线</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dots_inline(point3 p1,point3 p2,point3 p3)&#123;</span><br><span class="line"></span><br><span class="line">	return vlen(xmult(subt(p1,p2),subt(p2,p3)))&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判定四点是否共面"><a href="#判定四点是否共面" class="headerlink" title="判定四点是否共面"></a><strong>判定四点是否共面</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判四点共面**</span><br><span class="line"></span><br><span class="line">int dots_onplane(point3 a,point3 b,point3 c,point3 d)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(dmult(pvec(a,b,c),subt(d,a)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判定点是否在线段上"><a href="#判定点是否在线段上" class="headerlink" title="判定点是否在线段上"></a><strong>判定点是否在线段上</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判点是否在线段上,包括端点和共线**</span><br><span class="line"></span><br><span class="line">int dot_online_in(point3 p,line3 l)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(vlen(xmult(subt(p,l.a),subt(p,l.b))))&amp;&amp;(l.a.x-p.x)*(l.b.x-p.x)&lt;eps&amp;&amp;</span><br><span class="line"></span><br><span class="line">		(l.a.y-p.y)*(l.b.y-p.y)&lt;eps&amp;&amp;(l.a.z-p.z)*(l.b.z-p.z)&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dot_online_in(point3 p,point3 l1,point3 l2)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(vlen(xmult(subt(p,l1),subt(p,l2))))&amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps&amp;&amp;</span><br><span class="line"></span><br><span class="line">		(l1.y-p.y)*(l2.y-p.y)&lt;eps&amp;&amp;(l1.z-p.z)*(l2.z-p.z)&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//判点是否在线段上,不包括端点**</span><br><span class="line"></span><br><span class="line">int dot_online_ex(point3 p,line3 l)&#123;</span><br><span class="line"></span><br><span class="line">	return dot_online_in(p,l)&amp;&amp;(!zero(p.x-l.a.x)||!zero(p.y-l.a.y)||!zero(p.z-l.a.z))&amp;&amp;</span><br><span class="line"></span><br><span class="line">		(!zero(p.x-l.b.x)||!zero(p.y-l.b.y)||!zero(p.z-l.b.z));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dot_online_ex(point3 p,point3 l1,point3 l2)&#123;</span><br><span class="line"></span><br><span class="line">	return dot_online_in(p,l1,l2)&amp;&amp;(!zero(p.x-l1.x)||!zero(p.y-l1.y)||!zero(p.z-l1.z))&amp;&amp;</span><br><span class="line"></span><br><span class="line">		(!zero(p.x-l2.x)||!zero(p.y-l2.y)||!zero(p.z-l2.z));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断点是否在空间三角形上"><a href="#判断点是否在空间三角形上" class="headerlink" title="判断点是否在空间三角形上"></a><strong>判断点是否在空间三角形上</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判点是否在空间三角形上,包括边界,三点共线无意义**</span><br><span class="line"></span><br><span class="line">int dot_inplane_in(point3 p,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(vlen(xmult(subt(s.a,s.b),subt(s.a,s.c)))-vlen(xmult(subt(p,s.a),subt(p,s.b)))-</span><br><span class="line"></span><br><span class="line">		vlen(xmult(subt(p,s.b),subt(p,s.c)))-vlen(xmult(subt(p,s.c),subt(p,s.a))));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dot_inplane_in(point3 p,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(vlen(xmult(subt(s1,s2),subt(s1,s3)))-vlen(xmult(subt(p,s1),subt(p,s2)))-</span><br><span class="line"></span><br><span class="line">		vlen(xmult(subt(p,s2),subt(p,s3)))-vlen(xmult(subt(p,s3),subt(p,s1))));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//判点是否在空间三角形上,不包括边界,三点共线无意义**</span><br><span class="line"></span><br><span class="line">int dot_inplane_ex(point3 p,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return dot_inplane_in(p,s)&amp;&amp;vlen(xmult(subt(p,s.a),subt(p,s.b)))&gt;eps&amp;&amp;</span><br><span class="line"></span><br><span class="line">		vlen(xmult(subt(p,s.b),subt(p,s.c)))&gt;eps&amp;&amp;vlen(xmult(subt(p,s.c),subt(p,s.a)))&gt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dot_inplane_ex(point3 p,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return dot_inplane_in(p,s1,s2,s3)&amp;&amp;vlen(xmult(subt(p,s1),subt(p,s2)))&gt;eps&amp;&amp;</span><br><span class="line"></span><br><span class="line">		vlen(xmult(subt(p,s2),subt(p,s3)))&gt;eps&amp;&amp;vlen(xmult(subt(p,s3),subt(p,s1)))&gt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两点是否在线段同侧"><a href="#判断两点是否在线段同侧" class="headerlink" title="判断两点是否在线段同侧"></a><strong>判断两点是否在线段同侧</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判两点在线段同侧,点在线段上返回0,不共面无意义**</span><br><span class="line"></span><br><span class="line">int same_side(point3 p1,point3 p2,line3 l)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(xmult(subt(l.a,l.b),subt(p1,l.b)),xmult(subt(l.a,l.b),subt(p2,l.b)))&gt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int same_side(point3 p1,point3 p2,point3 l1,point3 l2)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(xmult(subt(l1,l2),subt(p1,l2)),xmult(subt(l1,l2),subt(p2,l2)))&gt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两点是否在线段异侧"><a href="#判断两点是否在线段异侧" class="headerlink" title="判断两点是否在线段异侧"></a><strong>判断两点是否在线段异侧</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判两点在线段异侧,点在线段上返回0,不共面无意义**</span><br><span class="line"></span><br><span class="line">int opposite_side(point3 p1,point3 p2,line3 l)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(xmult(subt(l.a,l.b),subt(p1,l.b)),xmult(subt(l.a,l.b),subt(p2,l.b)))&lt;-eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int opposite_side(point3 p1,point3 p2,point3 l1,point3 l2)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(xmult(subt(l1,l2),subt(p1,l2)),xmult(subt(l1,l2),subt(p2,l2)))&lt;-eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两点是否在平面同侧"><a href="#判断两点是否在平面同侧" class="headerlink" title="判断两点是否在平面同侧"></a><strong>判断两点是否在平面同侧</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判两点在平面同侧,点在平面上返回0**</span><br><span class="line"></span><br><span class="line">int same_side(point3 p1,point3 p2,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(pvec(s),subt(p1,s.a))*dmult(pvec(s),subt(p2,s.a))&gt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int same_side(point3 p1,point3 p2,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(pvec(s1,s2,s3),subt(p1,s1))*dmult(pvec(s1,s2,s3),subt(p2,s1))&gt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两点是否在平面异侧"><a href="#判断两点是否在平面异侧" class="headerlink" title="判断两点是否在平面异侧"></a><strong>判断两点是否在平面异侧</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判两点在平面异侧,点在平面上返回0**</span><br><span class="line"></span><br><span class="line">int opposite_side(point3 p1,point3 p2,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(pvec(s),subt(p1,s.a))*dmult(pvec(s),subt(p2,s.a))&lt;-eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int opposite_side(point3 p1,point3 p2,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(pvec(s1,s2,s3),subt(p1,s1))*dmult(pvec(s1,s2,s3),subt(p2,s1))&lt;-eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两空间直线是否平行"><a href="#判断两空间直线是否平行" class="headerlink" title="判断两空间直线是否平行"></a><strong>判断两空间直线是否平行</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判两直线平行**</span><br><span class="line"></span><br><span class="line">int parallel(line3 u,line3 v)&#123;</span><br><span class="line"></span><br><span class="line">	return vlen(xmult(subt(u.a,u.b),subt(v.a,v.b)))&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int parallel(point3 u1,point3 u2,point3 v1,point3 v2)&#123;</span><br><span class="line"></span><br><span class="line">	return vlen(xmult(subt(u1,u2),subt(v1,v2)))&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两平面是否平行"><a href="#判断两平面是否平行" class="headerlink" title="判断两平面是否平行"></a><strong>判断两平面是否平行</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判两平面平行**</span><br><span class="line"></span><br><span class="line">int parallel(plane3 u,plane3 v)&#123;</span><br><span class="line"></span><br><span class="line">	return vlen(xmult(pvec(u),pvec(v)))&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int parallel(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3)&#123;</span><br><span class="line"></span><br><span class="line">	return vlen(xmult(pvec(u1,u2,u3),pvec(v1,v2,v3)))&lt;eps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断直线是否与平面平行"><a href="#判断直线是否与平面平行" class="headerlink" title="判断直线是否与平面平行"></a><strong>判断直线是否与平面平行</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判直线与平面平行**</span><br><span class="line"></span><br><span class="line">int parallel(line3 l,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(dmult(subt(l.a,l.b),pvec(s)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int parallel(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(dmult(subt(l1,l2),pvec(s1,s2,s3)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两直线是否垂直"><a href="#判断两直线是否垂直" class="headerlink" title="判断两直线是否垂直"></a><strong>判断两直线是否垂直</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判两直线垂直**</span><br><span class="line"></span><br><span class="line">int perpendicular(line3 u,line3 v)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(dmult(subt(u.a,u.b),subt(v.a,v.b)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int perpendicular(point3 u1,point3 u2,point3 v1,point3 v2)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(dmult(subt(u1,u2),subt(v1,v2)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两平面是否垂直"><a href="#判断两平面是否垂直" class="headerlink" title="判断两平面是否垂直"></a><strong>判断两平面是否垂直</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//判两平面垂直</span><br><span class="line"></span><br><span class="line">int perpendicular(plane3 u,plane3 v)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(dmult(pvec(u),pvec(v)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int perpendicular(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3)&#123;</span><br><span class="line"></span><br><span class="line">	return zero(dmult(pvec(u1,u2,u3),pvec(v1,v2,v3)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断两条空间线段是否相交"><a href="#判断两条空间线段是否相交" class="headerlink" title="判断两条空间线段是否相交"></a><strong>判断两条空间线段是否相交</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判两线段相交,包括端点和部分重合**</span><br><span class="line"></span><br><span class="line">int intersect_in(line3 u,line3 v)&#123;</span><br><span class="line"></span><br><span class="line">	if (!dots_onplane(u.a,u.b,v.a,v.b))</span><br><span class="line"></span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	if (!dots_inline(u.a,u.b,v.a)||!dots_inline(u.a,u.b,v.b))</span><br><span class="line"></span><br><span class="line">		return !same_side(u.a,u.b,v)&amp;&amp;!same_side(v.a,v.b,u);</span><br><span class="line"></span><br><span class="line">	return dot_online_in(u.a,v)||dot_online_in(u.b,v)||dot_online_in(v.a,u)||dot_online_in(v.b,u);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int intersect_in(point3 u1,point3 u2,point3 v1,point3 v2)&#123;</span><br><span class="line"></span><br><span class="line">	if (!dots_onplane(u1,u2,v1,v2))</span><br><span class="line"></span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	if (!dots_inline(u1,u2,v1)||!dots_inline(u1,u2,v2))</span><br><span class="line"></span><br><span class="line">		return !same_side(u1,u2,v1,v2)&amp;&amp;!same_side(v1,v2,u1,u2);</span><br><span class="line"></span><br><span class="line">	return dot_online_in(u1,v1,v2)||dot_online_in(u2,v1,v2)||dot_online_in(v1,u1,u2)||dot_online_in(v2,u1,u2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//判两线段相交,不包括端点和部分重合**</span><br><span class="line"></span><br><span class="line">int intersect_ex(line3 u,line3 v)&#123;</span><br><span class="line"></span><br><span class="line">	return dots_onplane(u.a,u.b,v.a,v.b)&amp;&amp;opposite_side(u.a,u.b,v)&amp;&amp;opposite_side(v.a,v.b,u);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int intersect_ex(point3 u1,point3 u2,point3 v1,point3 v2)&#123;</span><br><span class="line"></span><br><span class="line">	return dots_onplane(u1,u2,v1,v2)&amp;&amp;opposite_side(u1,u2,v1,v2)&amp;&amp;opposite_side(v1,v2,u1,u2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断线段是否与空间三角形相交"><a href="#判断线段是否与空间三角形相交" class="headerlink" title="判断线段是否与空间三角形相交"></a><strong>判断线段是否与空间三角形相交</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//判线段与空间三角形相交,包括交于边界和(部分)包含**</span><br><span class="line"></span><br><span class="line">int intersect_in(line3 l,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return !same_side(l.a,l.b,s)&amp;&amp;!same_side(s.a,s.b,l.a,l.b,s.c)&amp;&amp;</span><br><span class="line"></span><br><span class="line">		!same_side(s.b,s.c,l.a,l.b,s.a)&amp;&amp;!same_side(s.c,s.a,l.a,l.b,s.b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int intersect_in(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return !same_side(l1,l2,s1,s2,s3)&amp;&amp;!same_side(s1,s2,l1,l2,s3)&amp;&amp;</span><br><span class="line"></span><br><span class="line">		!same_side(s2,s3,l1,l2,s1)&amp;&amp;!same_side(s3,s1,l1,l2,s2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//判线段与空间三角形相交,不包括交于边界和(部分)包含**</span><br><span class="line"></span><br><span class="line">int intersect_ex(line3 l,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return opposite_side(l.a,l.b,s)&amp;&amp;opposite_side(s.a,s.b,l.a,l.b,s.c)&amp;&amp;</span><br><span class="line"></span><br><span class="line">		opposite_side(s.b,s.c,l.a,l.b,s.a)&amp;&amp;opposite_side(s.c,s.a,l.a,l.b,s.b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int intersect_ex(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return opposite_side(l1,l2,s1,s2,s3)&amp;&amp;opposite_side(s1,s2,l1,l2,s3)&amp;&amp;</span><br><span class="line"></span><br><span class="line">		opposite_side(s2,s3,l1,l2,s1)&amp;&amp;opposite_side(s3,s1,l1,l2,s2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算两条直线的交点"><a href="#计算两条直线的交点" class="headerlink" title="计算两条直线的交点"></a><strong>计算两条直线的交点</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//计算两直线交点,注意事先判断直线是否共面和平行!**</span><br><span class="line"></span><br><span class="line">**//线段交点请另外判线段相交(同时还是要判断是否平行!)**</span><br><span class="line"></span><br><span class="line">point3 intersection(line3 u,line3 v)&#123;</span><br><span class="line"></span><br><span class="line">	point3 ret=u.a;</span><br><span class="line"></span><br><span class="line">	double t=((u.a.x-v.a.x)*(v.a.y-v.b.y)-(u.a.y-v.a.y)*(v.a.x-v.b.x))</span><br><span class="line"></span><br><span class="line">			/((u.a.x-u.b.x)*(v.a.y-v.b.y)-(u.a.y-u.b.y)*(v.a.x-v.b.x));</span><br><span class="line"></span><br><span class="line">	ret.x+=(u.b.x-u.a.x)*t;</span><br><span class="line"></span><br><span class="line">	ret.y+=(u.b.y-u.a.y)*t;</span><br><span class="line"></span><br><span class="line">	ret.z+=(u.b.z-u.a.z)*t;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">point3 intersection(point3 u1,point3 u2,point3 v1,point3 v2)&#123;</span><br><span class="line"></span><br><span class="line">	point3 ret=u1;</span><br><span class="line"></span><br><span class="line">	double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))</span><br><span class="line"></span><br><span class="line">			/((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));</span><br><span class="line"></span><br><span class="line">	ret.x+=(u2.x-u1.x)*t;</span><br><span class="line"></span><br><span class="line">	ret.y+=(u2.y-u1.y)*t;</span><br><span class="line"></span><br><span class="line">	ret.z+=(u2.z-u1.z)*t;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算直线与平面的交点"><a href="#计算直线与平面的交点" class="headerlink" title="计算直线与平面的交点"></a><strong>计算直线与平面的交点</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//计算直线与平面交点,注意事先判断是否平行,并保证三点不共线!**</span><br><span class="line"></span><br><span class="line">**//线段和空间三角形交点请另外判断**</span><br><span class="line"></span><br><span class="line">point3 intersection(line3 l,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	point3 ret=pvec(s);</span><br><span class="line"></span><br><span class="line">	double t=(ret.x*(s.a.x-l.a.x)+ret.y*(s.a.y-l.a.y)+ret.z*(s.a.z-l.a.z))/</span><br><span class="line"></span><br><span class="line">		(ret.x*(l.b.x-l.a.x)+ret.y*(l.b.y-l.a.y)+ret.z*(l.b.z-l.a.z));</span><br><span class="line"></span><br><span class="line">	ret.x=l.a.x+(l.b.x-l.a.x)*t;</span><br><span class="line"></span><br><span class="line">	ret.y=l.a.y+(l.b.y-l.a.y)*t;</span><br><span class="line"></span><br><span class="line">	ret.z=l.a.z+(l.b.z-l.a.z)*t;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">point3 intersection(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	point3 ret=pvec(s1,s2,s3);</span><br><span class="line"></span><br><span class="line">	double t=(ret.x*(s1.x-l1.x)+ret.y*(s1.y-l1.y)+ret.z*(s1.z-l1.z))/</span><br><span class="line"></span><br><span class="line">		(ret.x*(l2.x-l1.x)+ret.y*(l2.y-l1.y)+ret.z*(l2.z-l1.z));</span><br><span class="line"></span><br><span class="line">	ret.x=l1.x+(l2.x-l1.x)*t;</span><br><span class="line"></span><br><span class="line">	ret.y=l1.y+(l2.y-l1.y)*t;</span><br><span class="line"></span><br><span class="line">	ret.z=l1.z+(l2.z-l1.z)*t;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算两平面的交线"><a href="#计算两平面的交线" class="headerlink" title="计算两平面的交线"></a><strong>计算两平面的交线</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//计算两平面交线,注意事先判断是否平行,并保证三点不共线!**</span><br><span class="line"></span><br><span class="line">line3 intersection(plane3 u,plane3 v)&#123;</span><br><span class="line"></span><br><span class="line">	line3 ret;</span><br><span class="line"></span><br><span class="line">	ret.a=parallel(v.a,v.b,u.a,u.b,u.c)?intersection(v.b,v.c,u.a,u.b,u.c):intersection(v.a,v.b,u.a,u.b,u.c);</span><br><span class="line"></span><br><span class="line">	ret.b=parallel(v.c,v.a,u.a,u.b,u.c)?intersection(v.b,v.c,u.a,u.b,u.c):intersection(v.c,v.a,u.a,u.b,u.c);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">line3 intersection(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3)&#123;</span><br><span class="line"></span><br><span class="line">	line3 ret;</span><br><span class="line"></span><br><span class="line">	ret.a=parallel(v1,v2,u1,u2,u3)?intersection(v2,v3,u1,u2,u3):intersection(v1,v2,u1,u2,u3);</span><br><span class="line"></span><br><span class="line">	ret.b=parallel(v3,v1,u1,u2,u3)?intersection(v2,v3,u1,u2,u3):intersection(v3,v1,u1,u2,u3);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="点到直线的距离"><a href="#点到直线的距离" class="headerlink" title="点到直线的距离"></a><strong>点到直线的距离</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//点到直线距离**</span><br><span class="line"></span><br><span class="line">double ptoline(point3 p,line3 l)&#123;</span><br><span class="line"></span><br><span class="line">	return vlen(xmult(subt(p,l.a),subt(l.b,l.a)))/distance(l.a,l.b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double ptoline(point3 p,point3 l1,point3 l2)&#123;</span><br><span class="line"></span><br><span class="line">	return vlen(xmult(subt(p,l1),subt(l2,l1)))/distance(l1,l2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算点到平面的距离"><a href="#计算点到平面的距离" class="headerlink" title="计算点到平面的距离"></a><strong>计算点到平面的距离</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//点到平面距离**</span><br><span class="line"></span><br><span class="line">double ptoplane(point3 p,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return fabs(dmult(pvec(s),subt(p,s.a)))/vlen(pvec(s));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double ptoplane(point3 p,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return fabs(dmult(pvec(s1,s2,s3),subt(p,s1)))/vlen(pvec(s1,s2,s3));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算直线到直线的距离"><a href="#计算直线到直线的距离" class="headerlink" title="计算直线到直线的距离"></a><strong>计算直线到直线的距离</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//直线到直线距离**</span><br><span class="line"></span><br><span class="line">double linetoline(line3 u,line3 v)&#123;</span><br><span class="line"></span><br><span class="line">	point3 n=xmult(subt(u.a,u.b),subt(v.a,v.b));</span><br><span class="line"></span><br><span class="line">	return fabs(dmult(subt(u.a,v.a),n))/vlen(n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double linetoline(point3 u1,point3 u2,point3 v1,point3 v2)&#123;</span><br><span class="line"></span><br><span class="line">	point3 n=xmult(subt(u1,u2),subt(v1,v2));</span><br><span class="line"></span><br><span class="line">	return fabs(dmult(subt(u1,v1),n))/vlen(n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="空间两直线夹角的cos值"><a href="#空间两直线夹角的cos值" class="headerlink" title="空间两直线夹角的cos值"></a><strong>空间两直线夹角的cos值</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//两直线夹角cos值**</span><br><span class="line"></span><br><span class="line">double angle_cos(line3 u,line3 v)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(subt(u.a,u.b),subt(v.a,v.b))/vlen(subt(u.a,u.b))/vlen(subt(v.a,v.b));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double angle_cos(point3 u1,point3 u2,point3 v1,point3 v2)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(subt(u1,u2),subt(v1,v2))/vlen(subt(u1,u2))/vlen(subt(v1,v2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两平面夹角的cos值"><a href="#两平面夹角的cos值" class="headerlink" title="两平面夹角的cos值"></a><strong>两平面夹角的cos值</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//两平面夹角cos值**</span><br><span class="line"></span><br><span class="line">double angle_cos(plane3 u,plane3 v)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(pvec(u),pvec(v))/vlen(pvec(u))/vlen(pvec(v));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double angle_cos(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(pvec(u1,u2,u3),pvec(v1,v2,v3))/vlen(pvec(u1,u2,u3))/vlen(pvec(v1,v2,v3));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="直线与平面夹角sin值"><a href="#直线与平面夹角sin值" class="headerlink" title="直线与平面夹角sin值"></a><strong>直线与平面夹角sin值</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//直线平面夹角sin值</span><br><span class="line"></span><br><span class="line">double angle_sin(line3 l,plane3 s)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(subt(l.a,l.b),pvec(s))/vlen(subt(l.a,l.b))/vlen(pvec(s));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double angle_sin(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123;</span><br><span class="line"></span><br><span class="line">	return dmult(subt(l1,l2),pvec(s1,s2,s3))/vlen(subt(l1,l2))/vlen(pvec(s1,s2,s3));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高级计算几何"><a href="#高级计算几何" class="headerlink" title="高级计算几何"></a>高级计算几何</h2><h3 id="最远曼哈顿距离"><a href="#最远曼哈顿距离" class="headerlink" title="最远曼哈顿距离"></a><strong>最远曼哈顿距离</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#define INF 9999999999999.0</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x[5];</span><br><span class="line"></span><br><span class="line">&#125;pt[100005];</span><br><span class="line"></span><br><span class="line">double dis[32][100005], coe[5], minx[32], maxx[32];</span><br><span class="line"></span><br><span class="line">**//去掉绝对值后有2^D种可能**</span><br><span class="line"></span><br><span class="line">void GetD(int N, int D)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int s, i, j, tot=(1&lt;&lt;D);</span><br><span class="line"></span><br><span class="line">    for (s=0;s&lt;tot;s++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for (i=0;i&lt;D;i++)</span><br><span class="line"></span><br><span class="line">            if (s&amp;(1&lt;&lt;i))</span><br><span class="line"></span><br><span class="line">                coe[i]=-1.0;</span><br><span class="line"></span><br><span class="line">            else coe[i]=1.0;</span><br><span class="line"></span><br><span class="line">        for (i=0;i&lt;N;i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            dis[s][i]=0.0;</span><br><span class="line"></span><br><span class="line">            for (j=0;j&lt;D;j++)</span><br><span class="line"></span><br><span class="line">                dis[s][i]=dis[s][i]+coe[j]*pt[i].x[j];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//取每种可能中的最大差距**</span><br><span class="line"></span><br><span class="line">void Solve(int N, int D)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int s, i, tot=(1&lt;&lt;D);</span><br><span class="line"></span><br><span class="line">    double tmp, ans;</span><br><span class="line"></span><br><span class="line">    for (s=0;s&lt;tot;s++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        minx[s]=INF;</span><br><span class="line"></span><br><span class="line">        maxx[s]=-INF;</span><br><span class="line"></span><br><span class="line">        for (i=0; i&lt;N; i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (minx[s]&gt;dis[s][i]) minx[s]=dis[s][i];</span><br><span class="line"></span><br><span class="line">            if (maxx[s]&lt;dis[s][i]) maxx[s]=dis[s][i];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans=0.0;</span><br><span class="line"></span><br><span class="line">    for (s=0; s&lt;tot; s++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        tmp=maxx[s]-minx[s];</span><br><span class="line"></span><br><span class="line">        if (tmp&gt;ans) ans=tmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%.2lf\n&quot;, ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n, i;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d&quot;,&amp;n)==1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for (i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">          scanf(&quot;%lf%lf%lf%lf%lf&quot;,&amp;pt[i].x[0],&amp;pt[i].x[1],&amp;pt[i].x[2],&amp;pt[i].x[3],&amp;pt[i].x[4]);</span><br><span class="line"></span><br><span class="line">        GetD(n, 5);</span><br><span class="line"></span><br><span class="line">        Solve(n, 5);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最近点对"><a href="#最近点对" class="headerlink" title="最近点对"></a><strong>最近点对</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#define Max(x,y) (x)&gt;(y)?(x):(y)</span><br><span class="line"></span><br><span class="line">struct Q</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x, y;</span><br><span class="line"></span><br><span class="line">&#125;q[100001], sl[10], sr[10];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">int cntl, cntr, lm, rm;</span><br><span class="line"></span><br><span class="line">double ans;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">int cmp(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Q*a1=(struct Q*)p1;</span><br><span class="line"></span><br><span class="line">    struct Q*a2=(struct Q*)p2;</span><br><span class="line"></span><br><span class="line">    if (a1-&gt;x&lt;a2-&gt;x)return -1;</span><br><span class="line"></span><br><span class="line">    else if (a1-&gt;x==a2-&gt;x)return 0;</span><br><span class="line"></span><br><span class="line">    else return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">double CalDis(double x1, double y1, double x2, double y2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">void MinDis(int l, int r)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (l==r) return;</span><br><span class="line"></span><br><span class="line">    double dis;</span><br><span class="line"></span><br><span class="line">    if (l+1==r)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        dis=CalDis(q[l].x,q[l].y,q[r].x,q[r].y);</span><br><span class="line"></span><br><span class="line">        if (ans&gt;dis) ans=dis;</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int mid=(l+r)&gt;&gt;1, i, j;</span><br><span class="line"></span><br><span class="line">    MinDis(l,mid);</span><br><span class="line"></span><br><span class="line">    MinDis(mid+1,r);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    lm=mid+1-5;</span><br><span class="line"></span><br><span class="line">    if (lm&lt;l) lm=l;</span><br><span class="line"></span><br><span class="line">    rm=mid+5;</span><br><span class="line"></span><br><span class="line">    if (rm&gt;r) rm=r;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    cntl=cntr=0;</span><br><span class="line"></span><br><span class="line">    for (i=mid;i&gt;=lm;i--)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (q[mid+1].x-q[i].x&gt;=ans)break;</span><br><span class="line"></span><br><span class="line">        sl[++cntl]=q[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i=mid+1;i&lt;=rm;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (q[i].x-q[mid].x&gt;=ans)break;</span><br><span class="line"></span><br><span class="line">        sr[++cntr]=q[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    for (i=1;i&lt;=cntl;i++)</span><br><span class="line"></span><br><span class="line">        for (j=1;j&lt;=cntr;j++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            dis=CalDis(sl[i].x,sl[i].y,sr[j].x,sr[j].y);</span><br><span class="line"></span><br><span class="line">            if (dis&lt;ans) ans=dis;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n, i;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d&quot;,&amp;n)==1&amp;&amp;n)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;=n;i++)</span><br><span class="line"></span><br><span class="line">            scanf(&quot;%lf %lf&quot;, &amp;q[i].x,&amp;q[i].y);</span><br><span class="line"></span><br><span class="line">        qsort(q+1,n,sizeof(struct Q),cmp);</span><br><span class="line"></span><br><span class="line">        ans=CalDis(q[1].x,q[1].y,q[2].x,q[2].y);</span><br><span class="line"></span><br><span class="line">        MinDis(1,n);</span><br><span class="line"></span><br><span class="line">        printf(&quot;%.2lf\n&quot;,ans/2.0);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小包围圆"><a href="#最小包围圆" class="headerlink" title="最小包围圆"></a><strong>最小包围圆</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x;</span><br><span class="line"></span><br><span class="line">    double y;</span><br><span class="line"></span><br><span class="line">&#125;pt[1005];</span><br><span class="line"></span><br><span class="line">struct Traingle</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Point p[3];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Circle</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Point center;</span><br><span class="line"></span><br><span class="line">    double r;</span><br><span class="line"></span><br><span class="line">&#125;ans;</span><br><span class="line"></span><br><span class="line">**//计算两点距离**</span><br><span class="line"></span><br><span class="line">double Dis(struct Point p, struct Point q)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double dx=p.x-q.x;</span><br><span class="line"></span><br><span class="line">    double dy=p.y-q.y;</span><br><span class="line"></span><br><span class="line">    return sqrt(dx*dx+dy*dy);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//计算三角形面积**</span><br><span class="line"></span><br><span class="line">double Area(struct Traingle ct)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return fabs((ct.p[1].x-ct.p[0].x)*(ct.p[2].y-ct.p[0].y)-(ct.p[2].x-ct.p[0].x)*(ct.p[1].y-ct.p[0].y))/2.0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//求三角形的外接圆，返回圆心和半径(存在结构体&quot;圆&quot;中)**</span><br><span class="line"></span><br><span class="line">struct Circle CircumCircle(struct Traingle t)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Circle tmp;</span><br><span class="line"></span><br><span class="line">    double a, b, c, c1, c2;</span><br><span class="line"></span><br><span class="line">    double xA, yA, xB, yB, xC, yC;</span><br><span class="line"></span><br><span class="line">    a = Dis(t.p[0], t.p[1]);</span><br><span class="line"></span><br><span class="line">    b = Dis(t.p[1], t.p[2]);</span><br><span class="line"></span><br><span class="line">    c = Dis(t.p[2], t.p[0]);</span><br><span class="line"></span><br><span class="line">    //根据S = a * b * c / R / 4;求半径R</span><br><span class="line"></span><br><span class="line">    tmp.r = (a*b*c)/(Area(t)*4.0);</span><br><span class="line"></span><br><span class="line">    xA = t.p[0].x;</span><br><span class="line"></span><br><span class="line">    yA = t.p[0].y;</span><br><span class="line"></span><br><span class="line">    xB = t.p[1].x;</span><br><span class="line"></span><br><span class="line">    yB = t.p[1].y;</span><br><span class="line"></span><br><span class="line">    xC = t.p[2].x;</span><br><span class="line"></span><br><span class="line">    yC = t.p[2].y;</span><br><span class="line"></span><br><span class="line">    c1 = (xA*xA+yA*yA - xB*xB-yB*yB) / 2;</span><br><span class="line"></span><br><span class="line">    c2 = (xA*xA+yA*yA - xC*xC-yC*yC) / 2;</span><br><span class="line"></span><br><span class="line">    tmp.center.x = (c1*(yA - yC)-c2*(yA - yB)) / ((xA - xB)*(yA - yC)-(xA - xC)*(yA - yB));</span><br><span class="line"></span><br><span class="line">    tmp.center.y = (c1*(xA - xC)-c2*(xA - xB)) / ((yA - yB)*(xA - xC)-(yA - yC)*(xA - xB));</span><br><span class="line"></span><br><span class="line">    return tmp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//确定最小包围圆**</span><br><span class="line"></span><br><span class="line">struct Circle MinCircle(int num, struct Traingle ct)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Circle ret;</span><br><span class="line"></span><br><span class="line">    if (num==0) ret.r = 0.0;</span><br><span class="line"></span><br><span class="line">    else if (num==1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        ret.center = ct.p[0];</span><br><span class="line"></span><br><span class="line">        ret.r = 0.0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else if (num==2)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        ret.center.x = (ct.p[0].x+ct.p[1].x)/2.0;</span><br><span class="line"></span><br><span class="line">        ret.center.y = (ct.p[0].y+ct.p[1].y)/2.0;</span><br><span class="line"></span><br><span class="line">        ret.r = Dis(ct.p[0], ct.p[1])/2.0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else if(num==3) ret = CircumCircle(ct);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//递归实现增量算法**</span><br><span class="line"></span><br><span class="line">void Dfs(int x, int num, struct Traingle ct)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">    struct Point tmp;</span><br><span class="line"></span><br><span class="line">    ans = MinCircle(num, ct);</span><br><span class="line"></span><br><span class="line">    if (num==3) return;</span><br><span class="line"></span><br><span class="line">    for (i=1; i&lt;=x; i++)</span><br><span class="line"></span><br><span class="line">        if (Dis(pt[i], ans.center)&gt;ans.r)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ct.p[num]=pt[i];</span><br><span class="line"></span><br><span class="line">            Dfs(i-1, num+1, ct);</span><br><span class="line"></span><br><span class="line">            tmp=pt[i];</span><br><span class="line"></span><br><span class="line">            for (j=i;j&gt;=2;j--)</span><br><span class="line"></span><br><span class="line">                pt[j]=pt[j-1];</span><br><span class="line"></span><br><span class="line">            pt[1]=tmp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Solve(int n)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Traingle ct;</span><br><span class="line"></span><br><span class="line">    Dfs(n, 0, ct);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n, i;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n)!=EOF &amp;&amp; n)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;=n;i++)</span><br><span class="line"></span><br><span class="line">            scanf(&quot;%lf %lf&quot;, &amp;pt[i].x, &amp;pt[i].y);</span><br><span class="line"></span><br><span class="line">        Solve(n);</span><br><span class="line"></span><br><span class="line">        printf(&quot;%.2lf %.2lf %.2lf\n&quot;, ans.center.x, ans.center.y, ans.r);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求两个圆的交点"><a href="#求两个圆的交点" class="headerlink" title="求两个圆的交点"></a><strong>求两个圆的交点</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">const double eps = 1e-8;</span><br><span class="line"></span><br><span class="line">const double PI = acos(-1.0);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x;</span><br><span class="line"></span><br><span class="line">    double y;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct Point point;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">struct Line</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double s, t;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct Line Line;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">struct Circle</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Point center;</span><br><span class="line"></span><br><span class="line">    double r;</span><br><span class="line"></span><br><span class="line">    Line line[505];</span><br><span class="line"></span><br><span class="line">    int cnt;</span><br><span class="line"></span><br><span class="line">    bool covered;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;circle[105];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">double distance(point p1, point p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double dx = p1.x-p2.x;</span><br><span class="line"></span><br><span class="line">    double dy = p1.y-p2.y;</span><br><span class="line"></span><br><span class="line">    return sqrt(dx*dx + dy*dy);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">point intersection(point u1,point u2, point v1,point v2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point ret = u1;</span><br><span class="line"></span><br><span class="line">    double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x)) /</span><br><span class="line"></span><br><span class="line">             ((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));</span><br><span class="line"></span><br><span class="line">    ret.x += (u2.x-u1.x)*t;</span><br><span class="line"></span><br><span class="line">    ret.y += (u2.y-u1.y)*t;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">void intersection_line_circle(point c,double r,point l1,point l2,point&amp; p1,point&amp; p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point p=c;</span><br><span class="line"></span><br><span class="line">    double t;</span><br><span class="line"></span><br><span class="line">    p.x+=l1.y-l2.y;</span><br><span class="line"></span><br><span class="line">    p.y+=l2.x-l1.x;</span><br><span class="line"></span><br><span class="line">    p=intersection(p,c,l1,l2);</span><br><span class="line"></span><br><span class="line">    t=sqrt(r*r-distance(p,c)*distance(p,c))/distance(l1,l2);</span><br><span class="line"></span><br><span class="line">    p1.x=p.x+(l2.x-l1.x)*t;</span><br><span class="line"></span><br><span class="line">    p1.y=p.y+(l2.y-l1.y)*t;</span><br><span class="line"></span><br><span class="line">    p2.x=p.x-(l2.x-l1.x)*t;</span><br><span class="line"></span><br><span class="line">    p2.y=p.y-(l2.y-l1.y)*t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//计算圆与圆的交点,保证圆与圆有交点,圆心不重合**</span><br><span class="line"></span><br><span class="line">void intersection_circle_circle(point c1,double r1,point c2,double r2,point&amp; p1,point&amp; p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    point u,v;</span><br><span class="line"></span><br><span class="line">    double t;</span><br><span class="line"></span><br><span class="line">    t=(1+(r1*r1-r2*r2)/distance(c1,c2)/distance(c1,c2))/2;</span><br><span class="line"></span><br><span class="line">    u.x=c1.x+(c2.x-c1.x)*t;</span><br><span class="line"></span><br><span class="line">    u.y=c1.y+(c2.y-c1.y)*t;</span><br><span class="line"></span><br><span class="line">    v.x=u.x+c1.y-c2.y;</span><br><span class="line"></span><br><span class="line">    v.y=u.y-c1.x+c2.x;</span><br><span class="line"></span><br><span class="line">    intersection_line_circle(c1,r1,u,v,p1,p2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求三角形外接圆圆心"><a href="#求三角形外接圆圆心" class="headerlink" title="求三角形外接圆圆心"></a><strong>求三角形外接圆圆心</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x;</span><br><span class="line"></span><br><span class="line">    double y;</span><br><span class="line"></span><br><span class="line">&#125;pt[1005];</span><br><span class="line"></span><br><span class="line">struct Traingle</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Point p[3];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Circle</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Point center;</span><br><span class="line"></span><br><span class="line">    double r;</span><br><span class="line"></span><br><span class="line">**&#125;**ans;</span><br><span class="line"></span><br><span class="line">**//计算两点距离**</span><br><span class="line"></span><br><span class="line">double Dis(struct Point p, struct Point q)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double dx=p.x-q.x;</span><br><span class="line"></span><br><span class="line">    double dy=p.y-q.y;</span><br><span class="line"></span><br><span class="line">    return sqrt(dx*dx+dy*dy);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//计算三角形面积**</span><br><span class="line"></span><br><span class="line">double Area(struct Traingle ct)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return fabs((ct.p[1].x-ct.p[0].x)*(ct.p[2].y-ct.p[0].y)-(ct.p[2].x-ct.p[0].x)*(ct.p[1].y-ct.p[0].y))/2.0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//求三角形的外接圆，返回圆心和半径(存在结构体&quot;圆&quot;中)**</span><br><span class="line"></span><br><span class="line">struct Circle CircumCircle(struct Traingle t)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Circle tmp;</span><br><span class="line"></span><br><span class="line">    double a, b, c, c1, c2;</span><br><span class="line"></span><br><span class="line">    double xA, yA, xB, yB, xC, yC;</span><br><span class="line"></span><br><span class="line">    a = Dis(t.p[0], t.p[1]);</span><br><span class="line"></span><br><span class="line">    b = Dis(t.p[1], t.p[2]);</span><br><span class="line"></span><br><span class="line">    c = Dis(t.p[2], t.p[0]);</span><br><span class="line"></span><br><span class="line">    //根据S = a * b * c / R / 4;求半径R</span><br><span class="line"></span><br><span class="line">    tmp.r = (a*b*c)/(Area(t)*4.0);</span><br><span class="line"></span><br><span class="line">    xA = t.p[0].x;</span><br><span class="line"></span><br><span class="line">    yA = t.p[0].y;</span><br><span class="line"></span><br><span class="line">    xB = t.p[1].x;</span><br><span class="line"></span><br><span class="line">    yB = t.p[1].y;</span><br><span class="line"></span><br><span class="line">    xC = t.p[2].x;</span><br><span class="line"></span><br><span class="line">    yC = t.p[2].y;</span><br><span class="line"></span><br><span class="line">    c1 = (xA*xA+yA*yA - xB*xB-yB*yB) / 2;</span><br><span class="line"></span><br><span class="line">    c2 = (xA*xA+yA*yA - xC*xC-yC*yC) / 2;</span><br><span class="line"></span><br><span class="line">    tmp.center.x = (c1*(yA - yC)-c2*(yA - yB)) / ((xA - xB)*(yA - yC)-(xA - xC)*(yA - yB));</span><br><span class="line"></span><br><span class="line">    tmp.center.y = (c1*(xA - xC)-c2*(xA - xB)) / ((yA - yB)*(xA - xC)-(yA - yC)*(xA - xB));</span><br><span class="line"></span><br><span class="line">    return tmp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求凸包"><a href="#求凸包" class="headerlink" title="求凸包"></a><strong>求凸包</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#define INF 999999999.9</span><br><span class="line"></span><br><span class="line">\#define PI acos(-1.0)</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x, y, dis;</span><br><span class="line"></span><br><span class="line">&#125;pt[1005], stack[1005], p0;</span><br><span class="line"></span><br><span class="line">int top, tot;</span><br><span class="line"></span><br><span class="line">**//计算几何距离**</span><br><span class="line"></span><br><span class="line">double Dis(double x1, double y1, double x2, double y2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//极角比较， 返回-1: p0p1在p0p2的右侧，返回0:p0,p1,p2共线**</span><br><span class="line"></span><br><span class="line">int Cmp_PolarAngel(struct Point p1, struct Point p2, struct Point pb)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double delta=(p1.x-pb.x)*(p2.y-pb.y)-(p2.x-pb.x)*(p1.y-pb.y);</span><br><span class="line"></span><br><span class="line">    if (delta&lt;0.0) return 1;</span><br><span class="line"></span><br><span class="line">    else if (delta==0.0) return 0;</span><br><span class="line"></span><br><span class="line">    else return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**// 判断向量p2p3是否对p1p2构成左旋**</span><br><span class="line"></span><br><span class="line">bool Is_LeftTurn(struct Point p3, struct Point p2, struct Point p1)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int type=Cmp_PolarAngel(p3, p1, p2);</span><br><span class="line"></span><br><span class="line">    if (type&lt;0) return true;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//先按极角排，再按距离由小到大排**</span><br><span class="line"></span><br><span class="line">int Cmp(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Point*a1=(struct Point*)p1;</span><br><span class="line"></span><br><span class="line">    struct Point*a2=(struct Point*)p2;</span><br><span class="line"></span><br><span class="line">    int type=Cmp_PolarAngel(*a1, *a2, p0);</span><br><span class="line"></span><br><span class="line">    if (type&lt;0) return -1;</span><br><span class="line"></span><br><span class="line">    else if (type==0)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (a1-&gt;dis&lt;a2-&gt;dis) return -1;</span><br><span class="line"></span><br><span class="line">        else if (a1-&gt;dis==a2-&gt;dis) return 0;</span><br><span class="line"></span><br><span class="line">        else return 1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//求凸包**</span><br><span class="line"></span><br><span class="line">void Solve(int n)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i, k;</span><br><span class="line"></span><br><span class="line">    p0.x=p0.y=INF;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        scanf(&quot;%lf %lf&quot;,&amp;pt[i].x, &amp;pt[i].y);</span><br><span class="line"></span><br><span class="line">        if (pt[i].y &lt; p0.y)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            p0.y=pt[i].y;</span><br><span class="line"></span><br><span class="line">            p0.x=pt[i].x;</span><br><span class="line"></span><br><span class="line">            k=i;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else if (pt[i].y==p0.y)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (pt[i].x&lt;p0.x)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                p0.x=pt[i].x;</span><br><span class="line"></span><br><span class="line">                k=i;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pt[k]=pt[0];</span><br><span class="line"></span><br><span class="line">    pt[0]=p0;</span><br><span class="line"></span><br><span class="line">    for (i=1;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">        pt[i].dis=Dis(pt[i].x,pt[i].y, p0.x,p0.y);</span><br><span class="line"></span><br><span class="line">    qsort(pt+1, n-1, sizeof(struct Point), Cmp);</span><br><span class="line"></span><br><span class="line">    **//去掉极角相同的点**</span><br><span class="line"></span><br><span class="line">    tot=1;</span><br><span class="line"></span><br><span class="line">    for (i=2;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">        if (Cmp_PolarAngel(pt[i], pt[i-1], p0))</span><br><span class="line"></span><br><span class="line">            pt[tot++]=pt[i-1];</span><br><span class="line"></span><br><span class="line">    pt[tot++]=pt[n-1];</span><br><span class="line"></span><br><span class="line">    **//求凸包**</span><br><span class="line"></span><br><span class="line">    top=1;</span><br><span class="line"></span><br><span class="line">    stack[0]=pt[0];</span><br><span class="line"></span><br><span class="line">    stack[1]=pt[1];</span><br><span class="line"></span><br><span class="line">    for (i=2;i&lt;tot;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        while (top&gt;=1 &amp;&amp; Is_LeftTurn(pt[i], stack[top], stack[top-1])==false)</span><br><span class="line"></span><br><span class="line">            top--;</span><br><span class="line"></span><br><span class="line">        stack[++top]=pt[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d&quot;,&amp;n)==2)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Solve(n);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="凸包卡壳旋转求出所有对踵点、最远点对"><a href="#凸包卡壳旋转求出所有对踵点、最远点对" class="headerlink" title="凸包卡壳旋转求出所有对踵点、最远点对"></a><strong>凸包卡壳旋转求出所有对踵点、最远点对</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#define INF 999999999.9</span><br><span class="line"></span><br><span class="line">\#define PI acos(-1.0)</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x, y, dis;</span><br><span class="line"></span><br><span class="line">&#125;pt[6005], stack[6005], p0;</span><br><span class="line"></span><br><span class="line">int top, tot;</span><br><span class="line"></span><br><span class="line">**//计算几何距离**</span><br><span class="line"></span><br><span class="line">double Dis(double x1, double y1, double x2, double y2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//极角比较， 返回-1: p0p1在p0p2的右侧，返回0:p0,p1,p2共线**</span><br><span class="line"></span><br><span class="line">int Cmp_PolarAngel(struct Point p1, struct Point p2, struct Point pb)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double delta=(p1.x-pb.x)*(p2.y-pb.y)-(p2.x-pb.x)*(p1.y-pb.y);</span><br><span class="line"></span><br><span class="line">    if (delta&lt;0.0) return 1;</span><br><span class="line"></span><br><span class="line">    else if (delta==0.0) return 0;</span><br><span class="line"></span><br><span class="line">    else return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**// 判断向量p2p3是否对p1p2构成左旋**</span><br><span class="line"></span><br><span class="line">bool Is_LeftTurn(struct Point p3, struct Point p2, struct Point p1)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int type=Cmp_PolarAngel(p3, p1, p2);</span><br><span class="line"></span><br><span class="line">    if (type&lt;0) return true;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//先按极角排，再按距离由小到大排**</span><br><span class="line"></span><br><span class="line">int Cmp(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Point*a1=(struct Point*)p1;</span><br><span class="line"></span><br><span class="line">    struct Point*a2=(struct Point*)p2;</span><br><span class="line"></span><br><span class="line">    int type=Cmp_PolarAngel(*a1, *a2, p0);</span><br><span class="line"></span><br><span class="line">    if (type&lt;0) return -1;</span><br><span class="line"></span><br><span class="line">    else if (type==0)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (a1-&gt;dis&lt;a2-&gt;dis) return -1;</span><br><span class="line"></span><br><span class="line">        else if (a1-&gt;dis==a2-&gt;dis) return 0;</span><br><span class="line"></span><br><span class="line">        else return 1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//求凸包**</span><br><span class="line"></span><br><span class="line">void Hull(int n)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i, k;</span><br><span class="line"></span><br><span class="line">    p0.x=p0.y=INF;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        scanf(&quot;%lf %lf&quot;,&amp;pt[i].x, &amp;pt[i].y);</span><br><span class="line"></span><br><span class="line">        if (pt[i].y &lt; p0.y)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            p0.y=pt[i].y;</span><br><span class="line"></span><br><span class="line">            p0.x=pt[i].x;</span><br><span class="line"></span><br><span class="line">            k=i;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else if (pt[i].y==p0.y)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (pt[i].x&lt;p0.x)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                p0.x=pt[i].x;</span><br><span class="line"></span><br><span class="line">                k=i;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pt[k]=pt[0];</span><br><span class="line"></span><br><span class="line">    pt[0]=p0;</span><br><span class="line"></span><br><span class="line">    for (i=1;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">        pt[i].dis=Dis(pt[i].x,pt[i].y, p0.x,p0.y);</span><br><span class="line"></span><br><span class="line">    qsort(pt+1, n-1, sizeof(struct Point), Cmp);</span><br><span class="line"></span><br><span class="line">    **//去掉极角相同的点**</span><br><span class="line"></span><br><span class="line">    tot=1;</span><br><span class="line"></span><br><span class="line">    for (i=2;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">        if (Cmp_PolarAngel(pt[i], pt[i-1], p0))</span><br><span class="line"></span><br><span class="line">            pt[tot++]=pt[i-1];</span><br><span class="line"></span><br><span class="line">    pt[tot++]=pt[n-1];</span><br><span class="line"></span><br><span class="line">    **//求凸包**</span><br><span class="line"></span><br><span class="line">    top=1;</span><br><span class="line"></span><br><span class="line">    stack[0]=pt[0];</span><br><span class="line"></span><br><span class="line">    stack[1]=pt[1];</span><br><span class="line"></span><br><span class="line">    for (i=2;i&lt;tot;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        while (top&gt;=1 &amp;&amp; Is_LeftTurn(pt[i], stack[top], stack[top-1])==false)</span><br><span class="line"></span><br><span class="line">            top--;</span><br><span class="line"></span><br><span class="line">        stack[++top]=pt[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**//计算叉积**</span><br><span class="line"></span><br><span class="line">double CrossProduct(struct Point p1, struct Point p2, struct Point p3)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return (p1.x-p3.x)*(p2.y-p3.y)-(p2.x-p3.x)*(p1.y-p3.y);</span><br><span class="line"></span><br><span class="line">**&#125;**</span><br><span class="line"></span><br><span class="line">**//卡壳旋转，求出凸多边形所有对踵点**</span><br><span class="line"></span><br><span class="line">void Rotate(struct Point*ch, int n)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i, p=1;</span><br><span class="line"></span><br><span class="line">    double t1, t2, ans=0.0, dif;</span><br><span class="line"></span><br><span class="line">    ch[n]=ch[0];</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        **//如果下一个点与当前边构成的三角形的面积更大，则说明此时不构成对踵点**</span><br><span class="line"></span><br><span class="line">        while (fabs(CrossProduct(ch[i],ch[i+1],ch[p+1])) &gt; fabs(CrossProduct(ch[i],ch[i+1],ch[p])))</span><br><span class="line"></span><br><span class="line">            p=(p+1)%n;</span><br><span class="line"></span><br><span class="line">        dif=fabs(CrossProduct(ch[i],ch[i+1],ch[p+1])) - fabs(CrossProduct(ch[i],ch[i+1],ch[p]));</span><br><span class="line"></span><br><span class="line">        **//如果当前点和下一个点分别构成的三角形面积相等，则说明两条边即为平行线，对角线两端都可能是对踵点**</span><br><span class="line"></span><br><span class="line">        if (dif==0.0)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            t1=Dis(ch[p].x, ch[p].y, ch[i].x, ch[i].y);</span><br><span class="line"></span><br><span class="line">            t2=Dis(ch[p+1].x, ch[p+1].y, ch[i+1].x, ch[i+1].y);</span><br><span class="line"></span><br><span class="line">            if (t1&gt;ans)ans=t1;</span><br><span class="line"></span><br><span class="line">            if (t2&gt;ans)ans=t2;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        **//说明p，i是对踵点**</span><br><span class="line"></span><br><span class="line">        else if (dif&lt;0.0)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            t1=Dis(ch[p].x, ch[p].y, ch[i].x, ch[i].y);</span><br><span class="line"></span><br><span class="line">            if (t1&gt;ans)ans=t1;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%.2lf\n&quot;,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d&quot;,&amp;n)==1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Hull(n);</span><br><span class="line"></span><br><span class="line">        Rotate(stack, top+1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="凸包-旋转卡壳求平面面积最大三角"><a href="#凸包-旋转卡壳求平面面积最大三角" class="headerlink" title="凸包+旋转卡壳求平面面积最大三角"></a><strong>凸包+旋转卡壳求平面面积最大三角</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#define INF 99999999999.9</span><br><span class="line"></span><br><span class="line">\#define PI acos(-1.0)</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x, y, dis;</span><br><span class="line"></span><br><span class="line">&#125;pt[50005], stack[50005], p0;</span><br><span class="line"></span><br><span class="line">int top, tot;</span><br><span class="line"></span><br><span class="line">double Dis(double x1, double y1, double x2, double y2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Cmp_PolarAngel(struct Point p1, struct Point p2, struct Point pb)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double delta=(p1.x-pb.x)*(p2.y-pb.y)-(p2.x-pb.x)*(p1.y-pb.y);</span><br><span class="line"></span><br><span class="line">    if (delta&lt;0.0) return 1;</span><br><span class="line"></span><br><span class="line">    else if (delta==0.0) return 0;</span><br><span class="line"></span><br><span class="line">    else return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Is_LeftTurn(struct Point p3, struct Point p2, struct Point p1)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int type=Cmp_PolarAngel(p3, p1, p2);</span><br><span class="line"></span><br><span class="line">    if (type&lt;0) return true;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Cmp(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Point*a1=(struct Point*)p1;</span><br><span class="line"></span><br><span class="line">    struct Point*a2=(struct Point*)p2;</span><br><span class="line"></span><br><span class="line">    int type=Cmp_PolarAngel(*a1, *a2, p0);</span><br><span class="line"></span><br><span class="line">    if (type&lt;0) return -1;</span><br><span class="line"></span><br><span class="line">    else if (type==0)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (a1-&gt;dis&lt;a2-&gt;dis) return -1;</span><br><span class="line"></span><br><span class="line">        else if (a1-&gt;dis==a2-&gt;dis) return 0;</span><br><span class="line"></span><br><span class="line">        else return 1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Hull(int n)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i, k;</span><br><span class="line"></span><br><span class="line">    p0.x=p0.y=INF;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        scanf(&quot;%lf %lf&quot;,&amp;pt[i].x, &amp;pt[i].y);</span><br><span class="line"></span><br><span class="line">        if (pt[i].y &lt; p0.y)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            p0.y=pt[i].y;</span><br><span class="line"></span><br><span class="line">            p0.x=pt[i].x;</span><br><span class="line"></span><br><span class="line">            k=i;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else if (pt[i].y==p0.y)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (pt[i].x&lt;p0.x)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                p0.x=pt[i].x;</span><br><span class="line"></span><br><span class="line">                k=i;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pt[k]=pt[0];</span><br><span class="line"></span><br><span class="line">    pt[0]=p0;</span><br><span class="line"></span><br><span class="line">    for (i=1;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">        pt[i].dis=Dis(pt[i].x,pt[i].y, p0.x,p0.y);</span><br><span class="line"></span><br><span class="line">    qsort(pt+1, n-1, sizeof(struct Point), Cmp);</span><br><span class="line"></span><br><span class="line">    tot=1;</span><br><span class="line"></span><br><span class="line">    for (i=2;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">        if (Cmp_PolarAngel(pt[i], pt[i-1], p0))</span><br><span class="line"></span><br><span class="line">            pt[tot++]=pt[i-1];</span><br><span class="line"></span><br><span class="line">    pt[tot++]=pt[n-1];</span><br><span class="line"></span><br><span class="line">    top=1;</span><br><span class="line"></span><br><span class="line">    stack[0]=pt[0];</span><br><span class="line"></span><br><span class="line">    stack[1]=pt[1];</span><br><span class="line"></span><br><span class="line">    for (i=2;i&lt;tot;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        while (top&gt;=1 &amp;&amp; Is_LeftTurn(pt[i], stack[top], stack[top-1])==false)</span><br><span class="line"></span><br><span class="line">            top--;</span><br><span class="line"></span><br><span class="line">        stack[++top]=pt[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double TArea(struct Point p1, struct Point p2, struct Point p3)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return fabs((p1.x-p3.x)*(p2.y-p3.y)-(p2.x-p3.x)*(p1.y-p3.y));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Rotate(struct Point*ch, int n)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (n&lt;3)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        printf(&quot;0.00\n&quot;);</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int i, j, k;</span><br><span class="line"></span><br><span class="line">    double ans=0.0, tmp;</span><br><span class="line"></span><br><span class="line">    ch[n]=ch[0];</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        j=(i+1)%n;</span><br><span class="line"></span><br><span class="line">        k=(j+1)%n;</span><br><span class="line"></span><br><span class="line">        while ((j!=k) &amp;&amp; (k!=i))</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            while (TArea(ch[i],ch[j],ch[k+1])&gt;TArea(ch[i],ch[j],ch[k]))</span><br><span class="line"></span><br><span class="line">                k=(k+1)%n;</span><br><span class="line"></span><br><span class="line">            tmp=TArea(ch[i],ch[j], ch[k]);</span><br><span class="line"></span><br><span class="line">            if (tmp&gt;ans) ans=tmp;</span><br><span class="line"></span><br><span class="line">            j=(j+1)%n;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%.2lf\n&quot;,ans/2.0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d&quot;,&amp;n)==1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (n==-1)break;</span><br><span class="line"></span><br><span class="line">        Hull(n);</span><br><span class="line"></span><br><span class="line">        Rotate(stack, top+1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Pick定理"><a href="#Pick定理" class="headerlink" title="Pick定理"></a><strong>Pick定理</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**// Pick定理求整点多边形内部整点数目**</span><br><span class="line"></span><br><span class="line">**// (1) 给定顶点座标均是整点（或正方形格点）的简单多边形，皮克定理说明了其面积A和内部格点数目i、边上格点数目b的关系：A = i + b/2 - 1；**</span><br><span class="line"></span><br><span class="line">**// (2) 在两点（x1，y1），（x2，y2）连线之间的整点个数（包含一个端点）为：gcd（|x1－x2|，|y1－y2|）；**</span><br><span class="line"></span><br><span class="line">**// (3) 求三角形面积用叉乘**</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">\#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">long long x[3], y[3], area, b;</span><br><span class="line"></span><br><span class="line">long long My_Abs(long long t)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (t&lt;0) return -t;</span><br><span class="line"></span><br><span class="line">    return t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long Gcd(long long x, long long y)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (y==0) return x;</span><br><span class="line"></span><br><span class="line">    long long mod=x%y;</span><br><span class="line"></span><br><span class="line">    while (mod)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        x=y;</span><br><span class="line"></span><br><span class="line">        y=mod;</span><br><span class="line"></span><br><span class="line">        mod=x%y;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    while (1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for (i = 0;i &lt; 3;i ++)</span><br><span class="line"></span><br><span class="line">            scanf(&quot;%lld %lld&quot;, &amp;x[i], &amp;y[i]);</span><br><span class="line"></span><br><span class="line">        if(x[0]==0&amp;&amp;y[0]==0&amp;&amp;x[1]==0&amp;&amp;y[1]==0&amp;&amp;x[2]==0&amp;&amp;y[2]==0) break;</span><br><span class="line"></span><br><span class="line">        area = (x[1]-x[0])*(y[2]-y[0])-(x[2]-x[0])*(y[1]-y[0]);</span><br><span class="line"></span><br><span class="line">        area = My_Abs(area);</span><br><span class="line"></span><br><span class="line">        b=0;</span><br><span class="line"></span><br><span class="line">        b=Gcd(My_Abs(x[1]-x[0]), My_Abs(y[1]-y[0])) + Gcd(My_Abs(x[2]-x[0]), My_Abs(y[2]-y[0])) + Gcd(My_Abs(x[1]-x[2]), My_Abs(y[1]-y[2]));</span><br><span class="line"></span><br><span class="line">        printf(&quot;%lld\n&quot;, (area-b+2)/2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求多边形面积和重心"><a href="#求多边形面积和重心" class="headerlink" title="求多边形面积和重心"></a><strong>求多边形面积和重心</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">int x[1000003], y[1000003];</span><br><span class="line"></span><br><span class="line">double A, tx, ty, tmp;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int cases, n, i;</span><br><span class="line"></span><br><span class="line">    scanf (&quot;%d&quot;, &amp;cases);</span><br><span class="line"></span><br><span class="line">    while (cases --)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        scanf (&quot;%d&quot;, &amp;n);</span><br><span class="line"></span><br><span class="line">        A = 0.0;</span><br><span class="line"></span><br><span class="line">        x[0] = y[0] = 0;</span><br><span class="line"></span><br><span class="line">        for (i = 1; i &lt;= n; i ++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            scanf (&quot;%d %d&quot;, &amp;x[i], &amp;y[i]);</span><br><span class="line"></span><br><span class="line">            A += (x[i-1]*y[i] - x[i]*y[i-1]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        A += x[n]*y[1] - x[1]*y[n];</span><br><span class="line"></span><br><span class="line">        A = A / 2.0;</span><br><span class="line"></span><br><span class="line">        tx = ty = 0.0;</span><br><span class="line"></span><br><span class="line">        for (i = 1; i &lt; n; i ++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tmp = x[i]*y[i+1] - x[i+1]*y[i];</span><br><span class="line"></span><br><span class="line">            tx += (x[i]+x[i+1]) * tmp;</span><br><span class="line"></span><br><span class="line">            ty += (y[i]+y[i+1]) * tmp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp = x[n]*y[1] - x[1]*y[n];</span><br><span class="line"></span><br><span class="line">        tx += (x[n]+x[1])*tmp;</span><br><span class="line"></span><br><span class="line">        ty += (y[n]+y[1])*tmp;</span><br><span class="line"></span><br><span class="line">        printf (&quot;%.2lf %.2lf\n&quot;, tx/(6.0*A), ty/(6.0*A));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断一个简单多边形是否有核"><a href="#判断一个简单多边形是否有核" class="headerlink" title="判断一个简单多边形是否有核"></a><strong>判断一个简单多边形是否有核</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">const int INF = (1&lt;&lt;30);</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int x, y;</span><br><span class="line"></span><br><span class="line">&#125;pt[150];</span><br><span class="line"></span><br><span class="line">typedef struct Point Point;</span><br><span class="line"></span><br><span class="line">bool turn_right[150];</span><br><span class="line"></span><br><span class="line">int det(Point s1, Point t1, Point s2, Point t2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int d1x = t1.x-s1.x;</span><br><span class="line"></span><br><span class="line">    int d1y = t1.y-s1.y;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    int d2x = t2.x-s2.x;</span><br><span class="line"></span><br><span class="line">    int d2y = t2.y-s2.y;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    return d1x*d2y - d2x*d1y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Swap(int &amp;a, int &amp;b)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (a&gt;b)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int t=a;</span><br><span class="line"></span><br><span class="line">        a=b;</span><br><span class="line"></span><br><span class="line">        b=t;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n, i, cross, maxx, minx, maxy, miny, maxn, minn, countn=0;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n)==1&amp;&amp;n)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        maxx=maxy=-INF;</span><br><span class="line"></span><br><span class="line">        minx=miny=INF;</span><br><span class="line"></span><br><span class="line">        **//点按顺时针给出**</span><br><span class="line"></span><br><span class="line">        for (i=1; i&lt;=n; i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            scanf(&quot;%d %d&quot;, &amp;pt[i].x, &amp;pt[i].y);</span><br><span class="line"></span><br><span class="line">            if (maxx&lt;pt[i].x) maxx=pt[i].x;</span><br><span class="line"></span><br><span class="line">            if (maxy&lt;pt[i].y) maxy=pt[i].y;</span><br><span class="line"></span><br><span class="line">            if (minx&gt;pt[i].x) minx=pt[i].x;</span><br><span class="line"></span><br><span class="line">            if (miny&gt;pt[i].y) miny=pt[i].y;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pt[n+1]=pt[1];</span><br><span class="line"></span><br><span class="line">        pt[n+2]=pt[2];</span><br><span class="line"></span><br><span class="line">        pt[n+3]=pt[3];</span><br><span class="line"></span><br><span class="line">        pt[n+4]=pt[4];</span><br><span class="line"></span><br><span class="line">        **//求每条线段的转向**</span><br><span class="line"></span><br><span class="line">        for (i=1; i&lt;=n+1; i ++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            cross = det(pt[i],pt[i+1], pt[i+1], pt[i+2]);</span><br><span class="line"></span><br><span class="line">            if (cross&lt;0)</span><br><span class="line"></span><br><span class="line">                turn_right[i+1]=true;</span><br><span class="line"></span><br><span class="line">            else turn_right[i+1]=false;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        **//两条边连续右转的为凸处，只有此时才可影响“核”肯恩存在的范围**</span><br><span class="line"></span><br><span class="line">        for (i=2; i&lt;= n+1; i++)</span><br><span class="line"></span><br><span class="line">            if (turn_right[i] &amp;&amp; turn_right[i+1])</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                if (pt[i].x==pt[i+1].x)</span><br><span class="line"></span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    minn=pt[i].y;</span><br><span class="line"></span><br><span class="line">                    maxn=pt[i+1].y;</span><br><span class="line"></span><br><span class="line">                    Swap(minn, maxn);</span><br><span class="line"></span><br><span class="line">                    if (minn&gt;miny) miny=minn;</span><br><span class="line"></span><br><span class="line">                    if (maxn&lt;maxy) maxy=maxn;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                else</span><br><span class="line"></span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    minn=pt[i].x;</span><br><span class="line"></span><br><span class="line">                    maxn=pt[i+1].x;</span><br><span class="line"></span><br><span class="line">                    Swap(minn, maxn);</span><br><span class="line"></span><br><span class="line">                    if (minn&gt;minx) minx=minn;</span><br><span class="line"></span><br><span class="line">                    if (maxn&lt;maxx) maxx=maxn;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        if (minx&lt;=maxx &amp;&amp; miny&lt;=maxy)</span><br><span class="line"></span><br><span class="line">            printf(&quot;Floor #%d\nSurveillance is possible.\n\n&quot;, ++countn);</span><br><span class="line"></span><br><span class="line">        else printf(&quot;Floor #%d\nSurveillance is impossible.\n\n&quot;, ++countn);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a><strong>模拟退火</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#define Lim 0.999999</span><br><span class="line"></span><br><span class="line">\#define EPS 1e-2</span><br><span class="line"></span><br><span class="line">\#define PI acos(-1.0)</span><br><span class="line"></span><br><span class="line">double Temp, maxx, minx, maxy, miny, lx, ly, dif;</span><br><span class="line"></span><br><span class="line">int nt, ns, nc;</span><br><span class="line"></span><br><span class="line">struct Target</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x, y;</span><br><span class="line"></span><br><span class="line">&#125;T[105];</span><br><span class="line"></span><br><span class="line">struct Solution</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x, y;</span><br><span class="line"></span><br><span class="line">    double f;</span><br><span class="line"></span><br><span class="line">&#125;S[25], P, A;</span><br><span class="line"></span><br><span class="line">double Dis(double x1, double y1, double x2, double y2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Seed(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;ns;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        S[i].x=minx+((double)(rand()%1000+1)/1000.0)*lx;</span><br><span class="line"></span><br><span class="line">        S[i].y=miny+((double)(rand()%1000+1)/1000.0)*ly;</span><br><span class="line"></span><br><span class="line">        S[i].f=0.0;</span><br><span class="line"></span><br><span class="line">        for (j=0;j&lt;nt;j++)</span><br><span class="line"></span><br><span class="line">            S[i].f=S[i].f+Dis(S[i].x,S[i].y, T[j].x, T[j].y);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Trans(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i, j, k;</span><br><span class="line"></span><br><span class="line">    double theta;</span><br><span class="line"></span><br><span class="line">    for (i=0;i&lt;ns;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        P=S[i];</span><br><span class="line"></span><br><span class="line">        for (j=0;j&lt;nc;j++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            theta=(((double)(rand()%1000+1))/1000.0)*2.0*PI;</span><br><span class="line"></span><br><span class="line">            A.x=P.x+Temp*cos(theta);</span><br><span class="line"></span><br><span class="line">            A.y=P.y+Temp*sin(theta);</span><br><span class="line"></span><br><span class="line">            if (A.x&lt;minx||A.x&gt;maxx||A.y&lt;miny||A.y&gt;maxy)</span><br><span class="line"></span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            A.f=0.0;</span><br><span class="line"></span><br><span class="line">            for (k=0;k&lt;nt;k++)</span><br><span class="line"></span><br><span class="line">                A.f=A.f+Dis(A.x,A.y,T[k].x,T[k].y);</span><br><span class="line"></span><br><span class="line">            dif=A.f-S[i].f;</span><br><span class="line"></span><br><span class="line">            if (dif&lt;0.0)S[i]=A;</span><br><span class="line"></span><br><span class="line">            else</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                dif=exp(-dif/Temp);</span><br><span class="line"></span><br><span class="line">                if (dif&gt;Lim) S[i]=A;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i, k;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d&quot;,&amp;nt)==1&amp;&amp;nt)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        maxx=maxy=0;</span><br><span class="line"></span><br><span class="line">        minx=miny=(1&lt;&lt;20);</span><br><span class="line"></span><br><span class="line">        for (i=0;i&lt;nt;i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            scanf(&quot;%lf %lf&quot;,&amp;T[i].x,&amp;T[i].y);</span><br><span class="line"></span><br><span class="line">            if (maxx&lt;T[i].x)maxx=T[i].x;</span><br><span class="line"></span><br><span class="line">            if (minx&gt;T[i].x)minx=T[i].x;</span><br><span class="line"></span><br><span class="line">            if (maxy&lt;T[i].y)maxy=T[i].y;</span><br><span class="line"></span><br><span class="line">            if (miny&gt;T[i].y)miny=T[i].y;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lx=maxx-minx;</span><br><span class="line"></span><br><span class="line">        ly=maxy-miny;</span><br><span class="line"></span><br><span class="line">        Temp=sqrt(lx*lx+ly*ly)/3.0;</span><br><span class="line"></span><br><span class="line">        ns=5, nc=10;</span><br><span class="line"></span><br><span class="line">        Seed();</span><br><span class="line"></span><br><span class="line">        while (Temp&gt;EPS)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            Trans();</span><br><span class="line"></span><br><span class="line">            Temp=Temp*0.40;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        k=0;</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;ns;i++)</span><br><span class="line"></span><br><span class="line">            if (S[k].f&gt;S[i].f)</span><br><span class="line"></span><br><span class="line">                k=i;</span><br><span class="line"></span><br><span class="line">        printf (&quot;%.0lf\n&quot;, S[k].f);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六边形坐标系"><a href="#六边形坐标系" class="headerlink" title="六边形坐标系"></a><strong>六边形坐标系</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//第一种六边形坐标系**</span><br><span class="line"></span><br><span class="line">\#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">double Dis(double x1, double y1, double x2, double y2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    double dx=x1-x2;</span><br><span class="line"></span><br><span class="line">​    double dy=y1-y2;</span><br><span class="line"></span><br><span class="line">​    return sqrt(dx*dx+dy*dy);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Get_KL(double L, double x, double y, int &amp;k, int &amp;l, double &amp;cd)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    k=floor((2.0*x)/(3.0*L));</span><br><span class="line"></span><br><span class="line">​    l=floor((2.0*y)/(sqrt(3.0)*L));</span><br><span class="line"></span><br><span class="line">​    double d1, d2, x1, y1, x2, y2;</span><br><span class="line"></span><br><span class="line">​    if ((k+l)&amp;1)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        x1=k*L*1.5;</span><br><span class="line"></span><br><span class="line">​        y1=(l+1.0)*L*sqrt(3.0)*0.5;</span><br><span class="line"></span><br><span class="line">​        x2=(k+1.0)*L*1.5;</span><br><span class="line"></span><br><span class="line">​        y2=l*L*sqrt(3.0)*0.5;</span><br><span class="line"></span><br><span class="line">​        d1=Dis(x1,y1, x,y);</span><br><span class="line"></span><br><span class="line">​        d2=Dis(x2,y2, x,y);</span><br><span class="line"></span><br><span class="line">​        if (d1&gt;d2)</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​            k++;</span><br><span class="line"></span><br><span class="line">​            cd=d2;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        else</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​            l++;</span><br><span class="line"></span><br><span class="line">​            cd=d1;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    else</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        x1=k*L*1.5;</span><br><span class="line"></span><br><span class="line">​        y1=l*L*sqrt(3.0)*0.5;</span><br><span class="line"></span><br><span class="line">​        x2=(k+1.0)*L*1.5;</span><br><span class="line"></span><br><span class="line">​        y2=(l+1.0)*L*sqrt(3.0)*0.5;</span><br><span class="line"></span><br><span class="line">​        d1=Dis(x1,y1, x,y);</span><br><span class="line"></span><br><span class="line">​        d2=Dis(x2,y2, x,y);</span><br><span class="line"></span><br><span class="line">​        if (d1&gt;d2)</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​            k++,l++;</span><br><span class="line"></span><br><span class="line">​            cd=d2;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        else cd=d1;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int My_Abs(int x)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    if (x&lt;0) return -x;</span><br><span class="line"></span><br><span class="line">​    return x;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    double L, x1, y1, x2, y2, ans, cd1, cd2;</span><br><span class="line"></span><br><span class="line">​    int k1, l1, k2, l2;</span><br><span class="line"></span><br><span class="line">​    while (scanf(&quot;%lf %lf %lf %lf %lf&quot;,&amp;L,&amp;x1,&amp;y1,&amp;x2,&amp;y2)==5)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        if (L==0.0&amp;&amp;x1==0.0&amp;&amp;y1==0.0&amp;&amp;x2==0.0&amp;&amp;y2==0.0) break;</span><br><span class="line"></span><br><span class="line">​        Get_KL(L, x1, y1, k1, l1, cd1);</span><br><span class="line"></span><br><span class="line">​        Get_KL(L, x2, y2, k2, l2, cd2);</span><br><span class="line"></span><br><span class="line">​        if (k1==k2&amp;&amp;l1==l2) printf(&quot;%.3lf\n&quot;, Dis(x1,y1, x2,y2));</span><br><span class="line"></span><br><span class="line">​        else</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​            ans=cd1+cd2;</span><br><span class="line"></span><br><span class="line">​            if (My_Abs(k1-k2) &gt; My_Abs(l1-l2))</span><br><span class="line"></span><br><span class="line">​                ans=ans+sqrt(3.0)*L*My_Abs(k1-k2);</span><br><span class="line"></span><br><span class="line">​            else ans=ans+sqrt(3.0)*L*My_Abs(k1-k2)+sqrt(3.0)*L*(double)(My_Abs(l1-l2)-My_Abs(k1-k2))/2.0;</span><br><span class="line"></span><br><span class="line">​            printf(&quot;%.3lf\n&quot;, ans);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**//第二种六边形坐标系**</span><br><span class="line"></span><br><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">struct A</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    int x, y, num;</span><br><span class="line"></span><br><span class="line">&#125;a[10001];</span><br><span class="line"></span><br><span class="line">const int dec[6][2] = &#123;&#123;-1,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;1,-1&#125;,&#123;1,0&#125;,&#123;0,1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">bool adj(int x1, int y1, int x2, int y2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    if (x1 == x2 &amp;&amp; abs(y1-y2) == 1) return true;</span><br><span class="line"></span><br><span class="line">​    if (y1 == y2 &amp;&amp; abs(x1-x2) == 1) return true;</span><br><span class="line"></span><br><span class="line">​    if (x1 == x2 + 1 &amp;&amp; y1 == y2 -1) return true;</span><br><span class="line"></span><br><span class="line">​    if (x1 == x2 - 1 &amp;&amp; y1 == y2 +1) return true;</span><br><span class="line"></span><br><span class="line">​    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool flag[10001];</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    int i, j, k, x, u, v, cut, minn, cnt[6];</span><br><span class="line"></span><br><span class="line">​    memset(cnt, 0, sizeof(cnt));</span><br><span class="line"></span><br><span class="line">​    a[1].num = 1, cnt[1] = 1;</span><br><span class="line"></span><br><span class="line">​    a[1].x = a[1].y = 0;</span><br><span class="line"></span><br><span class="line">​    for (i = 2; i &lt; 10001; i ++)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        k = (int)((3.0+sqrt(12.0*i - 3.0))/6.0+0.0000001);</span><br><span class="line"></span><br><span class="line">​        if (i == 3*(k-1)*(k-1)+3*(k-1)+1) k  --;</span><br><span class="line"></span><br><span class="line">​        j = i - (3*(k-1)*(k-1)+3*(k-1)+1);</span><br><span class="line"></span><br><span class="line">​        **// 当前的六边形是第k层的第j个六边形**</span><br><span class="line"></span><br><span class="line">​        if (j == 1) a[i].x = a[i-1].x, a[i].y = a[i-1].y + 1;</span><br><span class="line"></span><br><span class="line">​        else</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​            x = (j-1) / k;</span><br><span class="line"></span><br><span class="line">​            a[i].x = a[i-1].x + dec[x][0], a[i].y = a[i-1].y + dec[x][1];</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        memset(flag, false, sizeof(flag));</span><br><span class="line"></span><br><span class="line">​        x = 12*k-6, cut = 0;</span><br><span class="line"></span><br><span class="line">​        for (u = i-1, v = 0; u&gt;=1&amp;&amp;v&lt;x; u --, v ++)</span><br><span class="line"></span><br><span class="line">​            if (adj(a[u].x, a[u].y, a[i].x, a[i].y))</span><br><span class="line"></span><br><span class="line">​            &#123;</span><br><span class="line"></span><br><span class="line">​                cut ++;</span><br><span class="line"></span><br><span class="line">​                flag[a[u].num] = true;</span><br><span class="line"></span><br><span class="line">​                if (cut == 3) break;</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​        minn = 10001;</span><br><span class="line"></span><br><span class="line">​        for (u = 1; u &lt; 6; u ++)</span><br><span class="line"></span><br><span class="line">​            if ((!flag[u])&amp;&amp;minn &gt; cnt[u])</span><br><span class="line"></span><br><span class="line">​            &#123;</span><br><span class="line"></span><br><span class="line">​                minn = cnt[u];</span><br><span class="line"></span><br><span class="line">​                x = u;</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​        a[i].num = x;</span><br><span class="line"></span><br><span class="line">​        cnt[x] ++;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    scanf (&quot;%d&quot;, &amp;x);</span><br><span class="line"></span><br><span class="line">​    while (x --)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        scanf (&quot;%d&quot;, &amp;i);</span><br><span class="line"></span><br><span class="line">​        printf (&quot;%d\n&quot;, a[i].num);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用一个给定半径的圆覆盖最多的点"><a href="#用一个给定半径的圆覆盖最多的点" class="headerlink" title="用一个给定半径的圆覆盖最多的点"></a><strong>用一个给定半径的圆覆盖最多的点</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**//同半径圆的圆弧表示**</span><br><span class="line"></span><br><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">\#define PI acos(-1.0)</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x, y;</span><br><span class="line"></span><br><span class="line">&#125;pt[2005];</span><br><span class="line"></span><br><span class="line">double dis[2005][2005];</span><br><span class="line"></span><br><span class="line">struct List</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double a;</span><br><span class="line"></span><br><span class="line">    bool flag;</span><br><span class="line"></span><br><span class="line">    int id;</span><br><span class="line"></span><br><span class="line">&#125;list[8005];</span><br><span class="line"></span><br><span class="line">int cnt;</span><br><span class="line"></span><br><span class="line">double Dis(int i, int j)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double dx=pt[i].x-pt[j].x;</span><br><span class="line"></span><br><span class="line">    double dy=pt[i].y-pt[j].y;</span><br><span class="line"></span><br><span class="line">    return sqrt(dx*dx+dy*dy);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Cmp(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct List*a1=(struct List*)p1;</span><br><span class="line"></span><br><span class="line">    struct List*a2=(struct List*)p2;</span><br><span class="line"></span><br><span class="line">    if (a1-&gt;a&lt;a2-&gt;a)return -1;</span><br><span class="line"></span><br><span class="line">    else if (a1-&gt;a==a2-&gt;a) return a1-&gt;id-a2-&gt;id;</span><br><span class="line"></span><br><span class="line">    else return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n, i, j, ans, num;</span><br><span class="line"></span><br><span class="line">    double r, theta, delta, a1, a2;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d %lf&quot;,&amp;n,&amp;r)==2)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (n==0&amp;&amp;r==0.0) break;</span><br><span class="line"></span><br><span class="line">        r=r+0.001;</span><br><span class="line"></span><br><span class="line">        r=r*2.0;</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;=n;i++)</span><br><span class="line"></span><br><span class="line">            scanf(&quot;%lf %lf&quot;, &amp;pt[i].x, &amp;pt[i].y);</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">            for (j=i+1;j&lt;=n;j++)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                dis[i][j]=Dis(i, j);</span><br><span class="line"></span><br><span class="line">                dis[j][i]=dis[i][j];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ans=0;</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;=n;i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            cnt=0;</span><br><span class="line"></span><br><span class="line">            for (j=1;j&lt;=n;j++)</span><br><span class="line"></span><br><span class="line">                if ((j!=i)&amp;&amp;(dis[i][j]&lt;=r))</span><br><span class="line"></span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    theta=atan2(pt[j].y-pt[i].y, pt[j].x-pt[i].x);</span><br><span class="line"></span><br><span class="line">                    if (theta&lt;0.0) theta=theta+2.0*PI;</span><br><span class="line"></span><br><span class="line">                    delta=acos(dis[i][j]/r);</span><br><span class="line"></span><br><span class="line">                    a1=theta-delta;</span><br><span class="line"></span><br><span class="line">                    a2=theta+delta;</span><br><span class="line"></span><br><span class="line">                    list[++cnt].a=a1;</span><br><span class="line"></span><br><span class="line">                    list[cnt].flag=true;</span><br><span class="line"></span><br><span class="line">                    list[cnt].id=cnt;</span><br><span class="line"></span><br><span class="line">                    list[++cnt].a=a2;</span><br><span class="line"></span><br><span class="line">                    list[cnt].flag=false;</span><br><span class="line"></span><br><span class="line">                    list[cnt].id=cnt;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            qsort(list+1,cnt,sizeof(struct List),Cmp);</span><br><span class="line"></span><br><span class="line">            num=0;</span><br><span class="line"></span><br><span class="line">            for (j=1;j&lt;=cnt;j++)</span><br><span class="line"></span><br><span class="line">                if (list[j].flag)</span><br><span class="line"></span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    num++;</span><br><span class="line"></span><br><span class="line">                    if (num&gt;ans) ans=num;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                else num--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;It is possible to cover %d points.\n&quot;, ans+1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不等大的圆的圆弧表示"><a href="#不等大的圆的圆弧表示" class="headerlink" title="不等大的圆的圆弧表示"></a><strong>不等大的圆的圆弧表示</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">intersection_circle_circle(circle[i].center, circle[i].r, circle[j].center, circle[j].r, p1, p2);</span><br><span class="line"></span><br><span class="line">                    a1= atan2(p1.y-circle[j].center.y, p1.x-circle[j].center.x);</span><br><span class="line"></span><br><span class="line">                    if (a1&lt;0.0) a1=a1+2.0*PI;</span><br><span class="line"></span><br><span class="line">                    a2= atan2(p2.y-circle[j].center.y, p2.x-circle[j].center.x);</span><br><span class="line"></span><br><span class="line">                    if (a2&lt;0.0) a2=a2+2.0*PI;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">                    if (a1&gt;a2)</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        tmp=a1;</span><br><span class="line"></span><br><span class="line">                        a1=a2;</span><br><span class="line"></span><br><span class="line">                        a2=tmp;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    mid=(a1+a2)/2.0;</span><br><span class="line"></span><br><span class="line">                    xtest = circle[j].center.x +circle[j].r*cos(mid);</span><br><span class="line"></span><br><span class="line">                    ytest = circle[j].center.y +circle[j].r*sin(mid);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">                    if (!point_in_circle(xtest, ytest, i))</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        circle[j].cnt++;</span><br><span class="line"></span><br><span class="line">                        circle[j].line[circle[j].cnt].s=0;</span><br><span class="line"></span><br><span class="line">                        circle[j].line[circle[j].cnt].t=a1;</span><br><span class="line"></span><br><span class="line">                        circle[j].cnt++;</span><br><span class="line"></span><br><span class="line">                        circle[j].line[circle[j].cnt].s=a2;</span><br><span class="line"></span><br><span class="line">                        circle[j].line[circle[j].cnt].t=2.0*PI;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    else</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        circle[j].cnt++;</span><br><span class="line"></span><br><span class="line">                        circle[j].line[circle[j].cnt].s=a1;</span><br><span class="line"></span><br><span class="line">                        circle[j].line[circle[j].cnt].t=a2;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩形面积并"><a href="#矩形面积并" class="headerlink" title="矩形面积并"></a><strong>矩形面积并</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int l, r, cnt;</span><br><span class="line"></span><br><span class="line">    double cover;</span><br><span class="line"></span><br><span class="line">&#125;node[80005];</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x;</span><br><span class="line"></span><br><span class="line">    double y1, y2;</span><br><span class="line"></span><br><span class="line">    int id_y1, id_y2, id_x;</span><br><span class="line"></span><br><span class="line">    bool flag;</span><br><span class="line"></span><br><span class="line">&#125;pt[20005];</span><br><span class="line"></span><br><span class="line">double y[20005];</span><br><span class="line"></span><br><span class="line">int total, cnty;</span><br><span class="line"></span><br><span class="line">int cmp1(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double*a1=(double*)p1;</span><br><span class="line"></span><br><span class="line">    double*a2=(double*)p2;</span><br><span class="line"></span><br><span class="line">    if (*a1&lt;*a2) return -1;</span><br><span class="line"></span><br><span class="line">    else if (*a1==*a2) return 0;</span><br><span class="line"></span><br><span class="line">    else return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cmp2(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Point*a1=(struct Point*)p1;</span><br><span class="line"></span><br><span class="line">    struct Point*a2=(struct Point*)p2;</span><br><span class="line"></span><br><span class="line">    if (a1-&gt;x&lt;a2-&gt;x) return -1;</span><br><span class="line"></span><br><span class="line">    else if (a1-&gt;x==a2-&gt;x)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (a1-&gt;id_x&lt;a2-&gt;id_x) return -1;</span><br><span class="line"></span><br><span class="line">        else if (a1-&gt;id_x==a2-&gt;id_x) return 0;</span><br><span class="line"></span><br><span class="line">        else return 1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int find(double target)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int head=1, tail=cnty, mid;</span><br><span class="line"></span><br><span class="line">    while (head&lt;=tail)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        mid=(head+tail)&gt;&gt;1;</span><br><span class="line"></span><br><span class="line">        if (y[mid]==target) return mid;</span><br><span class="line"></span><br><span class="line">        else if (y[mid]&lt;target) head=mid+1;</span><br><span class="line"></span><br><span class="line">        else tail=mid-1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Build(int l, int r, int s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    node[s].l=l;</span><br><span class="line"></span><br><span class="line">    node[s].r=r;</span><br><span class="line"></span><br><span class="line">    node[s].cnt=0;</span><br><span class="line"></span><br><span class="line">    node[s].cover=0.0;</span><br><span class="line"></span><br><span class="line">    if (l+1&lt;r)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int mid=(l+r)&gt;&gt;1;</span><br><span class="line"></span><br><span class="line">        Build(l,mid,s&lt;&lt;1);</span><br><span class="line"></span><br><span class="line">        Build(mid,r,(s&lt;&lt;1)+1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Update(int s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (node[s].cnt&gt;0)</span><br><span class="line"></span><br><span class="line">        node[s].cover=y[node[s].r]-y[node[s].l];</span><br><span class="line"></span><br><span class="line">    else if(node[s].l+1==node[s].r)</span><br><span class="line"></span><br><span class="line">        node[s].cover=0.0;</span><br><span class="line"></span><br><span class="line">    else node[s].cover=node[s&lt;&lt;1].cover+node[(s&lt;&lt;1)+1].cover;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Insert(int l, int r, int s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (l&lt;=node[s].l&amp;&amp;node[s].r&lt;=r)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        node[s].cnt++;</span><br><span class="line"></span><br><span class="line">        Update(s);</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (node[s].l+1&lt;node[s].r)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int mid=(node[s].l+node[s].r)&gt;&gt;1;</span><br><span class="line"></span><br><span class="line">        if (l&lt;mid) Insert(l,r,s&lt;&lt;1);</span><br><span class="line"></span><br><span class="line">        if (r&gt;mid) Insert(l,r,(s&lt;&lt;1)+1);</span><br><span class="line"></span><br><span class="line">        Update(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Delete(int l, int r, int s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (l&lt;=node[s].l&amp;&amp;node[s].r&lt;=r)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (node[s].cnt&gt;0)</span><br><span class="line"></span><br><span class="line">            node[s].cnt--;</span><br><span class="line"></span><br><span class="line">        Update(s);</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (node[s].l+1&lt;node[s].r)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int mid=(node[s].l+node[s].r)&gt;&gt;1;</span><br><span class="line"></span><br><span class="line">        if (l&lt;mid) Delete(l,r,s&lt;&lt;1);</span><br><span class="line"></span><br><span class="line">        if (r&gt;mid) Delete(l,r,(s&lt;&lt;1)+1);</span><br><span class="line"></span><br><span class="line">        Update(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n, i, j, countn=0;</span><br><span class="line"></span><br><span class="line">    double ans;</span><br><span class="line"></span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n)==1 &amp;&amp; n)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        cnty=total=0;</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;=n;i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            total++;</span><br><span class="line"></span><br><span class="line">            scanf(&quot;%lf %lf&quot;, &amp;pt[total].x, &amp;pt[total].y1);</span><br><span class="line"></span><br><span class="line">            pt[total].flag=true;</span><br><span class="line"></span><br><span class="line">            pt[total].id_x=total;</span><br><span class="line"></span><br><span class="line">            y[++cnty]=pt[total].y1;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            total++;</span><br><span class="line"></span><br><span class="line">            scanf(&quot;%lf %lf&quot;, &amp;pt[total].x, &amp;pt[total].y2);</span><br><span class="line"></span><br><span class="line">            pt[total].flag=false;</span><br><span class="line"></span><br><span class="line">            pt[total].id_x=total;</span><br><span class="line"></span><br><span class="line">            y[++cnty]=pt[total].y2;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            pt[total].y1=pt[total-1].y1;</span><br><span class="line"></span><br><span class="line">            pt[total-1].y2=pt[total].y2;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qsort(y+1, cnty, sizeof(double), cmp1);</span><br><span class="line"></span><br><span class="line">        j=cnty;</span><br><span class="line"></span><br><span class="line">        cnty=1;</span><br><span class="line"></span><br><span class="line">        for (i=2;i&lt;=j;i++)</span><br><span class="line"></span><br><span class="line">            if (y[i]!=y[i-1])</span><br><span class="line"></span><br><span class="line">                y[++cnty]=y[i];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;=total;i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            pt[i].id_y1=find(pt[i].y1);</span><br><span class="line"></span><br><span class="line">            pt[i].id_y2=find(pt[i].y2);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qsort(pt+1, total, sizeof(struct Point), cmp2);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        ans=0.0;</span><br><span class="line"></span><br><span class="line">        Build(1,cnty,1);</span><br><span class="line"></span><br><span class="line">        Insert(pt[1].id_y1, pt[1].id_y2, 1);</span><br><span class="line"></span><br><span class="line">        for (i=2;i&lt;=total;i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ans=ans+(pt[i].x-pt[i-1].x)*node[1].cover;</span><br><span class="line"></span><br><span class="line">            if (pt[i].flag) Insert(pt[i].id_y1, pt[i].id_y2, 1);</span><br><span class="line"></span><br><span class="line">            else Delete(pt[i].id_y1, pt[i].id_y2, 1);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;%.0lf\n&quot;, ans+1e-10);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩形的周长并"><a href="#矩形的周长并" class="headerlink" title="矩形的周长并"></a><strong>矩形的周长并</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int x, y;</span><br><span class="line"></span><br><span class="line">&#125;plist[10001];</span><br><span class="line"></span><br><span class="line">struct Line</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int x, b, e, flag;</span><br><span class="line"></span><br><span class="line">&#125;llist[10001];</span><br><span class="line"></span><br><span class="line">struct Item</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int y, id, idx;</span><br><span class="line"></span><br><span class="line">&#125;ilist[10001];</span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int l, r, c, m, line;</span><br><span class="line"></span><br><span class="line">    bool lf, rf;</span><br><span class="line"></span><br><span class="line">&#125;node[40005];</span><br><span class="line"></span><br><span class="line">int ys[10001];</span><br><span class="line"></span><br><span class="line">int cmp1(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Item *a1 = (struct Item*)p1;</span><br><span class="line"></span><br><span class="line">    struct Item *a2 = (struct Item*)p2;</span><br><span class="line"></span><br><span class="line">    return a1-&gt;y - a2-&gt;y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cmp2(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Item *a1 = (struct Item*)p1;</span><br><span class="line"></span><br><span class="line">    struct Item *a2 = (struct Item*)p2;</span><br><span class="line"></span><br><span class="line">    return a1-&gt;id - a2-&gt;id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cmp3(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Line *a1 = (struct Line*)p1;</span><br><span class="line"></span><br><span class="line">    struct Line *a2 = (struct Line*)p2;</span><br><span class="line"></span><br><span class="line">    return a1-&gt;x - a2-&gt;x;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getm(int s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (node[s].c &gt; 0)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        node[s].m = ys[node[s].r-1] - ys[node[s].l-1];</span><br><span class="line"></span><br><span class="line">        node[s].line = 1;</span><br><span class="line"></span><br><span class="line">        node[s].rf = node[s].lf = true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else if (node[s].r - node[s].l &lt;= 1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        node[s].m = node[s].line = 0;</span><br><span class="line"></span><br><span class="line">        node[s].rf = node[s].lf = false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        node[s].m = node[s&lt;&lt;1].m + node[(s&lt;&lt;1)+1].m;</span><br><span class="line"></span><br><span class="line">        node[s].line = node[s&lt;&lt;1].line + node[(s&lt;&lt;1)+1].line;</span><br><span class="line"></span><br><span class="line">        if (node[s&lt;&lt;1].rf &amp;&amp; node[(s&lt;&lt;1)+1].lf) node[s].line --;</span><br><span class="line"></span><br><span class="line">        node[s].lf = node[s&lt;&lt;1].lf;</span><br><span class="line"></span><br><span class="line">        node[s].rf = node[(s&lt;&lt;1)+1].rf;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void build(int l, int r, int s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    node[s].l = l;</span><br><span class="line"></span><br><span class="line">    node[s].r = r;</span><br><span class="line"></span><br><span class="line">    node[s].c = node[s].m = node[s].line;</span><br><span class="line"></span><br><span class="line">    if (node[s].r - node[s].l &gt; 1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int mid = (node[s].l + node[s].r)&gt;&gt;1;</span><br><span class="line"></span><br><span class="line">        build(l,mid,s&lt;&lt;1);</span><br><span class="line"></span><br><span class="line">        build(mid,r,(s&lt;&lt;1)+1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(int l, int r, int s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (l &lt;= node[s].l &amp;&amp; node[s].r &lt;= r)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        node[s].c ++;</span><br><span class="line"></span><br><span class="line">        getm(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (node[s].r - node[s].l &gt; 1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int mid = (node[s].l + node[s].r)&gt;&gt;1;</span><br><span class="line"></span><br><span class="line">        if (l &lt; mid) insert(l, r, s&lt;&lt;1);</span><br><span class="line"></span><br><span class="line">        if (mid &lt; r) insert(l, r, (s&lt;&lt;1)+1);</span><br><span class="line"></span><br><span class="line">        getm(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void delet(int l, int r, int s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (l &lt;= node[s].l &amp;&amp; node[s].r &lt;= r)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        node[s].c --;</span><br><span class="line"></span><br><span class="line">        getm(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (node[s].r - node[s].l &gt; 1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int mid = (node[s].l + node[s].r)&gt;&gt;1;</span><br><span class="line"></span><br><span class="line">        if (l &lt; mid) delet(l, r, s&lt;&lt;1);</span><br><span class="line"></span><br><span class="line">        if (mid &lt; r) delet(l, r, (s&lt;&lt;1)+1);</span><br><span class="line"></span><br><span class="line">        getm(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int n, i, j, l, r, x1, y1, x2, y2, tot, p, ans;</span><br><span class="line"></span><br><span class="line">    while (scanf (&quot;%d&quot;, &amp;n) == 1 &amp;&amp; n)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; n; i ++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            scanf (&quot;%d %d %d %d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line"></span><br><span class="line">            l = 2*i;</span><br><span class="line"></span><br><span class="line">            r = l + 1;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            plist[l].x = x1;</span><br><span class="line"></span><br><span class="line">            plist[l].y = y1;</span><br><span class="line"></span><br><span class="line">            plist[r].x = x2;</span><br><span class="line"></span><br><span class="line">            plist[r].y = y2;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            ilist[l].y = y1;</span><br><span class="line"></span><br><span class="line">            ilist[l].id = l;</span><br><span class="line"></span><br><span class="line">            ilist[r].y = y2;</span><br><span class="line"></span><br><span class="line">            ilist[r].id = r;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tot = 2*n;</span><br><span class="line"></span><br><span class="line">        qsort(ilist, tot, sizeof(struct Item), cmp1);</span><br><span class="line"></span><br><span class="line">        ys[0] = ilist[0].y;</span><br><span class="line"></span><br><span class="line">        ilist[0].idx = 0;</span><br><span class="line"></span><br><span class="line">        j = 0;</span><br><span class="line"></span><br><span class="line">        for (i = 1; i &lt; tot; i ++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (ilist[i].y != ilist[i-1].y)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                j ++;</span><br><span class="line"></span><br><span class="line">                ys[j] = ilist[i].y;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ilist[i].idx = j;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = j + 1;</span><br><span class="line"></span><br><span class="line">        qsort(ilist, tot, sizeof(struct Item), cmp2);</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; n; i ++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            l = 2*i;</span><br><span class="line"></span><br><span class="line">            r = l + 1;</span><br><span class="line"></span><br><span class="line">            llist[l].x = plist[l].x;</span><br><span class="line"></span><br><span class="line">            llist[l].b = ilist[l].idx;</span><br><span class="line"></span><br><span class="line">            llist[l].e = ilist[r].idx;</span><br><span class="line"></span><br><span class="line">            llist[l].flag = 1;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            llist[r].x = plist[r].x;</span><br><span class="line"></span><br><span class="line">            llist[r].b = ilist[l].idx;</span><br><span class="line"></span><br><span class="line">            llist[r].e = ilist[r].idx;</span><br><span class="line"></span><br><span class="line">            llist[r].flag = 0;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qsort(llist, tot, sizeof(struct Line), cmp3);</span><br><span class="line"></span><br><span class="line">        build(1,p,1);</span><br><span class="line"></span><br><span class="line">        insert(llist[0].b+1, llist[0].e+1,1);</span><br><span class="line"></span><br><span class="line">        int now_m = node[1].m, now_line = node[1].line;</span><br><span class="line"></span><br><span class="line">        ans = now_m;</span><br><span class="line"></span><br><span class="line">        for (i = 1; i &lt; tot; i ++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (llist[i].flag) insert(llist[i].b+1, llist[i].e+1, 1);</span><br><span class="line"></span><br><span class="line">            else delet(llist[i].b+1, llist[i].e+1, 1);</span><br><span class="line"></span><br><span class="line">            ans += (abs(node[1].m - now_m) + 2*(llist[i].x - llist[i-1].x)*now_line);</span><br><span class="line"></span><br><span class="line">            now_m = node[1].m;</span><br><span class="line"></span><br><span class="line">            now_line = node[1].line;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf (&quot;%d\n&quot;, ans);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最近圆对"><a href="#最近圆对" class="headerlink" title="最近圆对"></a><strong>最近圆对</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">\#include&lt;set&gt;</span><br><span class="line"></span><br><span class="line">\#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">set &lt;int&gt;tree;</span><br><span class="line"></span><br><span class="line">set &lt;int&gt;::iterator iter;</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x;</span><br><span class="line"></span><br><span class="line">    int id, flag;</span><br><span class="line"></span><br><span class="line">&#125;p1[100001], p2[100001];</span><br><span class="line"></span><br><span class="line">int tot1, tot2;</span><br><span class="line"></span><br><span class="line">struct Q</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double x,y, r;</span><br><span class="line"></span><br><span class="line">&#125;q[50001];</span><br><span class="line"></span><br><span class="line">int cmp(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Point*a1=(struct Point*)p1;</span><br><span class="line"></span><br><span class="line">    struct Point*a2=(struct Point*)p2;</span><br><span class="line"></span><br><span class="line">    if (a1-&gt;x&lt;a2-&gt;x) return -1;</span><br><span class="line"></span><br><span class="line">    else if (a1-&gt;x==a2-&gt;x) return a2-&gt;flag-a1-&gt;flag;</span><br><span class="line"></span><br><span class="line">    else return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cmp1(const void*p1, const void*p2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct Q*a1=(struct Q*)p1;</span><br><span class="line"></span><br><span class="line">    struct Q*a2=(struct Q*)p2;</span><br><span class="line"></span><br><span class="line">    if (a1-&gt;y&lt;a2-&gt;y)return -1;</span><br><span class="line"></span><br><span class="line">    else if (a1-&gt;y==a2-&gt;y)return 0;</span><br><span class="line"></span><br><span class="line">    else return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double dis(double x1, double y1, double x2, double y2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool judge(int i, int j, double d)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (dis(q[i].x, q[i].y, q[j].x, q[j].y)&lt;=q[i].r+q[j].r+2.0*d)</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool insert(int v,double d)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    iter = tree.insert(v).first;</span><br><span class="line"></span><br><span class="line">    if (iter != tree.begin())</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (judge(v, *--iter,d))</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++iter;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (++iter != tree.end())</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (judge(v, *iter,d))</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool remove(int v,double d)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    iter = tree.find(v);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    if (iter != tree.begin() &amp;&amp; iter != --tree.end())</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int a = *--iter;</span><br><span class="line"></span><br><span class="line">        ++iter;</span><br><span class="line"></span><br><span class="line">        int b = *++iter;</span><br><span class="line"></span><br><span class="line">        if (judge(a, b,d))</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tree.erase(v);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool check(double d)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i=1, j=1;</span><br><span class="line"></span><br><span class="line">    while (i&lt;=tot1&amp;&amp;j&lt;=tot2)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (p1[i].x-d&lt;=p2[j].x+d)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (insert(p1[i++].id, d))</span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (remove(p2[j++].id, d))</span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (i&lt;=tot1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (insert(p1[i++].id, d))</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (j&lt;=tot2)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (remove(p2[j++].id, d))</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int cases, n, i;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;,&amp;cases);</span><br><span class="line"></span><br><span class="line">    while (cases--)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"></span><br><span class="line">        tot1=tot2=0;</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;=n;i++)</span><br><span class="line"></span><br><span class="line">            scanf(&quot;%lf %lf %lf&quot;,&amp;q[i].x,&amp;q[i].y, &amp;q[i].r);</span><br><span class="line"></span><br><span class="line">        qsort(q+1,n,sizeof(struct Q),cmp1);</span><br><span class="line"></span><br><span class="line">        for (i=1;i&lt;=n;i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tot1++;</span><br><span class="line"></span><br><span class="line">            p1[tot1].x=q[i].x-q[i].r;</span><br><span class="line"></span><br><span class="line">            p1[tot1].id=i;</span><br><span class="line"></span><br><span class="line">            p1[tot1].flag=1;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">            tot2++;</span><br><span class="line"></span><br><span class="line">            p2[tot2].x=q[i].x+q[i].r;</span><br><span class="line"></span><br><span class="line">            p2[tot2].id=i;</span><br><span class="line"></span><br><span class="line">            p2[tot2].flag=-1;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qsort(p1+1,tot1,sizeof(struct Point),cmp);</span><br><span class="line"></span><br><span class="line">        qsort(p2+1,tot2,sizeof(struct Point),cmp);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        double head=0.0, tail=dis(q[1].x,q[1].y,q[2].x,q[2].y)+1.0, mid;</span><br><span class="line"></span><br><span class="line">        while (tail-head&gt;1e-8)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tree.clear();</span><br><span class="line"></span><br><span class="line">            mid=(head+tail)/2.0;</span><br><span class="line"></span><br><span class="line">            if (check(mid))</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                tail=mid;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            else head=mid;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf (&quot;%.6lf\n&quot;,2.0*head);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求两个圆的面积交"><a href="#求两个圆的面积交" class="headerlink" title="求两个圆的面积交"></a><strong>求两个圆的面积交</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double area_of_overlap(point c1, double r1, point c2, double r2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    double a = distance(c1, c2), b = r1, c = r2;</span><br><span class="line"></span><br><span class="line">double cta1 = acos((a * a + b * b - c * c) / 2 / (a * b)), </span><br><span class="line"></span><br><span class="line">      cta2 = acos((a * a + c * c - b * b) / 2 / (a * c));</span><br><span class="line"></span><br><span class="line">    double s1 = r1*r1*cta1 - r1*r1*sin(cta1)*(a * a + b * b - c * c) / 2 / (a * b);</span><br><span class="line"></span><br><span class="line">    double s2 = r2*r2*cta2 - r2*r2*sin(cta2)*(a * a + c * c - b * b) / 2 / (a * c);</span><br><span class="line"></span><br><span class="line">    return s1 + s2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><h2 id="Nim博弈"><a href="#Nim博弈" class="headerlink" title="Nim博弈"></a>Nim博弈</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;cstring&gt;  </span><br><span class="line">#include &lt;cstdio&gt;  </span><br><span class="line">#define LL long long  </span><br><span class="line">#define mod 1000000007  </span><br><span class="line">#define sz 100005  </span><br><span class="line">using namespace std;  </span><br><span class="line">int sg[sz];  </span><br><span class="line">bool vis[sz];  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    //´ò±í³ÌÐò  </span><br><span class="line">    /*int tmp; </span><br><span class="line">    sg[0]=0; </span><br><span class="line">    for(int i=1;i&lt;=50;i++) </span><br><span class="line">    &#123; </span><br><span class="line">        memset(vis,0,sizeof(vis)); </span><br><span class="line">        for(int j=0;j&lt;i;j++) </span><br><span class="line">            vis[sg[j]]=1; </span><br><span class="line">        for(int k=1;k&lt;i;k++) </span><br><span class="line">        &#123; </span><br><span class="line">            for(int m=1;m&lt;i;m++) </span><br><span class="line">            &#123; </span><br><span class="line">                int u=i-k-m; </span><br><span class="line">                if(u&gt;0) </span><br><span class="line">                &#123; </span><br><span class="line">                    tmp=sg[k]^sg[m]^sg[u]; </span><br><span class="line">                    vis[tmp]=1; </span><br><span class="line">                &#125; </span><br><span class="line">                else </span><br><span class="line">                    break; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        for(int x=0;;x++) </span><br><span class="line">            if(!vis[x]) </span><br><span class="line">            &#123; </span><br><span class="line">                sg[i]=x; </span><br><span class="line">                printf(&quot;sg[%d]: %d\n&quot;,i,x); </span><br><span class="line">                break; </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;*/  </span><br><span class="line">    int t,n,tmp,s;  </span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);  </span><br><span class="line">    while(t--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        s=0;  </span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);  </span><br><span class="line">        while(n--)  </span><br><span class="line">        &#123;  </span><br><span class="line">            scanf(&quot;%d&quot;,&amp;tmp);  </span><br><span class="line">            if(tmp%8==7)  </span><br><span class="line">                s^=(tmp+1);  </span><br><span class="line">            else if(tmp%8==0)  </span><br><span class="line">                s^=(tmp-1);  </span><br><span class="line">            else  </span><br><span class="line">                s^=tmp;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(s)  </span><br><span class="line">            printf(&quot;First player wins.\n&quot;);  </span><br><span class="line">        else  </span><br><span class="line">            printf(&quot;Second player wins.\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int wzf(int a,int b)&#123;</span><br><span class="line">        if(a&lt;b)&#123;</span><br><span class="line">            a^=b;</span><br><span class="line">            b^=a;</span><br><span class="line">            a^=b;</span><br><span class="line">        &#125;</span><br><span class="line">        int k=a-b;</span><br><span class="line">        a=(int)(k*(1+sqrt(5))/2.0);</span><br><span class="line">        if(a==b)</span><br><span class="line">            return 1;</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	for(int i=1;i&lt;100;i++)</span><br><span class="line">		for(int j=1;j&lt;100;j++)</span><br><span class="line">		if(wzf(i,j)) printf(&quot;(%d,%d) %d\n&quot;,i,j,i-j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int d[1000][10], n, k;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"> </span><br><span class="line">	d[0][0] = 1;</span><br><span class="line"> </span><br><span class="line">	for (int i = 1; i &lt;= n; i++)</span><br><span class="line">		d[i][1] = 1;</span><br><span class="line"> </span><br><span class="line">	for (int i = 1; i &lt;= n; i++)</span><br><span class="line"> </span><br><span class="line">		for (int j = 1; j &lt;= k; j++)</span><br><span class="line"> </span><br><span class="line">			if (i &gt;= j)</span><br><span class="line"> </span><br><span class="line">				d[i][j] = d[i - j][j] + d[i - 1][j - 1];</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; d[n][k]&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间K大数"><a href="#区间K大数" class="headerlink" title="区间K大数"></a>区间K大数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#define MAXN 10010</span><br><span class="line">#define MAXE 100010</span><br><span class="line">using namespace std;</span><br><span class="line">int head[MAXN],tot1,tot2;</span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int u,v,next;</span><br><span class="line">&#125; e1[MAXE],e2[MAXN];</span><br><span class="line">void addEdge(int u,int v,Edge* edge,int&amp; tol)</span><br><span class="line">&#123;</span><br><span class="line">    edge[tol].u=u;</span><br><span class="line">    edge[tol].v=v;</span><br><span class="line">    edge[tol].next=head[u];</span><br><span class="line">    head[u]=tol++;</span><br><span class="line">&#125;</span><br><span class="line">int n,m;</span><br><span class="line">int low[MAXN],dfn[MAXN],stack[MAXN],belong[MAXN],num[MAXN];</span><br><span class="line">bool instack[MAXN];</span><br><span class="line">int scc,top,INDEX;</span><br><span class="line">void Tarjan(int u)</span><br><span class="line">&#123;</span><br><span class="line">    int v;</span><br><span class="line">    low[u]=dfn[u]=++INDEX;</span><br><span class="line">    stack[top++]=u;</span><br><span class="line">    instack[u]=true;</span><br><span class="line">    for(int i=head[u]; i!=-1; i=e1[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        v=e1[i].v;</span><br><span class="line">        if(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            Tarjan(v);</span><br><span class="line">            if(low[u]&gt;low[v])</span><br><span class="line">                low[u]=low[v];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(instack[v]&amp;&amp;low[u]&gt;dfn[v])</span><br><span class="line">            low[u]=dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line">    if(low[u]==dfn[u])</span><br><span class="line">    &#123;</span><br><span class="line">        ++scc;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            v=stack[--top];</span><br><span class="line">            instack[v]=false;</span><br><span class="line">            belong[v]=scc;</span><br><span class="line">            num[scc]++;</span><br><span class="line">        &#125;</span><br><span class="line">        while(u!=v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int inde[MAXN],outde[MAXN];</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">    memset(dfn,0,sizeof(dfn));</span><br><span class="line">    memset(instack,false,sizeof(instack));</span><br><span class="line">    memset(num,0,sizeof(num));</span><br><span class="line">    scc=top=INDEX=0;</span><br><span class="line">    for(int i=1; i&lt;=n; ++i)</span><br><span class="line">        if(!dfn[i])</span><br><span class="line">            Tarjan(i);</span><br><span class="line">    tot2=0;</span><br><span class="line">    memset(head,-1,sizeof(head));</span><br><span class="line">    memset(inde,0,sizeof(inde));</span><br><span class="line">    memset(outde,0,sizeof(outde));</span><br><span class="line">    int u,v;</span><br><span class="line">    for(int i=0; i&lt;m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        u=belong[e1[i].u];</span><br><span class="line">        v=belong[e1[i].v];</span><br><span class="line">        if(u!=v)</span><br><span class="line">        &#123;</span><br><span class="line">            addEdge(u,v,e2,tot2);</span><br><span class="line">            inde[v]++;</span><br><span class="line">            outde[u]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int a=0,b=0;</span><br><span class="line">    for(int i=1; i&lt;=scc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!inde[i])</span><br><span class="line">            a++;</span><br><span class="line">        if(!outde[i])</span><br><span class="line">            b++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(scc==1)</span><br><span class="line">        printf(&quot;0\n&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;%d\n&quot;,max(a,b));</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int zushu;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;zushu);</span><br><span class="line">    while(zushu--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        tot1=0;</span><br><span class="line">        memset(head,-1,sizeof(head));</span><br><span class="line">        int u,v;</span><br><span class="line">        for(int i=0; i&lt;m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">            addEdge(u,v,e1,tot1);</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">22. 22. 22. 22. 区间 KKKK 大数</span><br><span class="line">//POJ 2104</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int NMAX = 100000;</span><br><span class="line">const int LOGNMAX = 17 +1;</span><br><span class="line">int sortseq[LOGNMAX][NMAX];</span><br><span class="line">int num[NMAX];</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int l,r,d;</span><br><span class="line">    node * pl,* pr;</span><br><span class="line">&#125; mem[(NMAX&lt;&lt;1)+100];</span><br><span class="line">int mempos,n,m;</span><br><span class="line">node * root;</span><br><span class="line">node * make_tree(int l,int r,int d)</span><br><span class="line">&#123;</span><br><span class="line">    node * rt = mem+(mempos ++);</span><br><span class="line">    rt-&gt;l = l;</span><br><span class="line">    rt-&gt;r = r;</span><br><span class="line">    rt-&gt;d = d;</span><br><span class="line">    if (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        sortseq[d][l] = num[l];</span><br><span class="line">        return rt;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (l+r) &gt;&gt; 1;</span><br><span class="line">    rt-&gt;pl = make_tree(l,mid,d+1);</span><br><span class="line">    rt-&gt;pr = make_tree(mid+1,r,d+1);</span><br><span class="line">    int i=l,j=mid+1,k=l;</span><br><span class="line">    while (i&lt;=mid &amp;&amp; j&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        if (sortseq[d+1][i] &lt; sortseq[d+1][j])</span><br><span class="line">            sortseq[d][k++] =</span><br><span class="line">                sortseq[d+1][i++];</span><br><span class="line">        else</span><br><span class="line">            sortseq[d][k++] = sortseq[d+1][j++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (i&lt;=mid)</span><br><span class="line">        sortseq[d][k++] = sortseq[d+1][i++];</span><br><span class="line">    while (j&lt;=r)</span><br><span class="line">        sortseq[d][k++] = sortseq[d+1][j++];</span><br><span class="line">    return rt;</span><br><span class="line">&#125;</span><br><span class="line">int s,t,rank;</span><br><span class="line">int query(node * rt,int val)</span><br><span class="line">&#123;</span><br><span class="line">    int i,mid,ret;</span><br><span class="line">    if (s &lt;= rt-&gt;l &amp;&amp; rt-&gt;r &lt;= t)</span><br><span class="line">    &#123;</span><br><span class="line">        if (val &lt;= sortseq[rt-&gt;d][rt-&gt;l])</span><br><span class="line">            return 0;</span><br><span class="line">        else if (sortseq[rt-&gt;d][rt-&gt;r] &lt; val)</span><br><span class="line">            return rt-&gt;r - rt-&gt;l +1;</span><br><span class="line">        else if (sortseq[rt-&gt;d][rt-&gt;r] == val)</span><br><span class="line">            return rt-&gt;r - rt-&gt;l;</span><br><span class="line">        int l = rt-&gt;l, r = rt-&gt;r, mid;</span><br><span class="line">        while (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l+r) &gt;&gt; 1;</span><br><span class="line">            if (val &lt;= sortseq[rt-&gt;d][mid])</span><br><span class="line">                r = mid-1;</span><br><span class="line">            else</span><br><span class="line">                l = mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        return l - rt-&gt;l;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ret = 0;</span><br><span class="line">        mid = (rt-&gt;l+rt-&gt;r) &gt;&gt; 1;</span><br><span class="line">        if (s &lt;= mid)</span><br><span class="line">            ret += query(rt-&gt;pl,val);</span><br><span class="line">        if (mid+1 &lt;= t)</span><br><span class="line">            ret += query(rt-&gt;pr,val);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 二分查找时遇到相同值的处理非常重要</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,l,r;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for (i=0; i&lt;n; i++)</span><br><span class="line">        scanf(&quot;%d&quot;,num+i);</span><br><span class="line">    mempos = 0;</span><br><span class="line">    root = make_tree(0,n-1,0);</span><br><span class="line">    while (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        s = get_val()-1;</span><br><span class="line">        t = get_val()-1;</span><br><span class="line">        rank = get_val()-1;</span><br><span class="line">        l = 0, r = n-1;</span><br><span class="line">        while (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid = (l+r) &gt;&gt; 1;</span><br><span class="line">// 二分查找sortseq[0][mid]在区间[s,t]中的排名</span><br><span class="line">            int pos = query(root,sortseq[0][mid]);</span><br><span class="line">            if (rank &lt; pos)</span><br><span class="line">                r = mid-1;</span><br><span class="line">            else</span><br><span class="line">                l = mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,sortseq[0][r]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int getid(int x)&#123;</span><br><span class="line">	return lower_bound(v.begin(),v.end(),x) - v.begin() + 1;</span><br><span class="line">&#125;</span><br><span class="line">	for(int i = 1;i&lt;=n;++i)&#123;</span><br><span class="line">    	scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    	v.push_back(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">	sort(v.begin(),v.end()), v.erase(unique(v.begin(),v.end()),v.end());</span><br></pre></td></tr></table></figure>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="统计1的个数"><a href="#统计1的个数" class="headerlink" title="统计1的个数"></a>统计1的个数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int NumberOfOne(int n) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while(n) &#123;</span><br><span class="line">    	n &amp;= (n-1);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="strtok-和-sscanf-结合输入"><a href="#strtok-和-sscanf-结合输入" class="headerlink" title="strtok 和 sscanf 结合输入"></a>strtok 和 sscanf 结合输入</h2><p>空格作为分隔输入，读取一行的整数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gets(buf);</span><br><span class="line">int v;</span><br><span class="line">char *p = strtok(buf,&quot; &quot;);</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">    sscanf(p,&quot;%d&quot;,&amp;v);</span><br><span class="line">    p = strtok(NULL,&quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输入输出挂"><a href="#输入输出挂" class="headerlink" title="输入输出挂"></a>输入输出挂</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//适用于正负整数</span><br><span class="line">template &lt;class T&gt;inline bool scan_d(T &amp;ret)</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    int sgn;</span><br><span class="line">    if(c=getchar(),c==EOF)</span><br><span class="line">        return 0; //EOF</span><br><span class="line">    while(c!=&apos;−&apos;&amp;&amp;(c&lt;&apos;0&apos;||c&gt;&apos;9&apos;))</span><br><span class="line">        c=getchar();</span><br><span class="line">    sgn=(c==&apos;−&apos;)?−1:1;</span><br><span class="line">    ret=(c==&apos;−&apos;)?0:(c−&apos;0&apos;);</span><br><span class="line">    while(c=getchar(),c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;)</span><br><span class="line">        ret=ret*10+(c−&apos;0&apos;);</span><br><span class="line">    ret*=sgn;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">inline void out(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x&gt;9)</span><br><span class="line">        out(x/10);</span><br><span class="line">    putchar(x%10+&apos;0&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>博弈论</tag>
        <tag>图论</tag>
        <tag>数论</tag>
        <tag>计算几何</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/06/08/2025-06-08/</url>
    <content><![CDATA[<p>梦的破壁者：输出型爱好  ——论白日梦的因果重塑</p>
<h3 id="第一幕：白日梦的甜蜜沼泽——当因果链断裂时"><a href="#第一幕：白日梦的甜蜜沼泽——当因果链断裂时" class="headerlink" title="第一幕：白日梦的甜蜜沼泽——当因果链断裂时"></a><strong>第一幕：白日梦的甜蜜沼泽——当因果链断裂时</strong></h3><p>晨光斜照书案时，我常盯着茶杯里浮沉的叶片怔忡——倘若此刻突然继承一笔神秘遗产，该购置林间木屋还是环球船票？这般念头如露水般在脑际闪烁，又随水汽蒸发无踪。这便是典型的白日梦境：<strong>愿望如烟花盛放于高空（果），却因行动之引信从未点燃（因），构成典型的”断桥式幻想”，终成虚妄的因果悖论。</strong></p>
<p>人总是痴迷于果，却怠慢于因。譬如幻想中彩票的狂喜，却从不踏足彩票站；渴慕登台领奖的荣光，却拒绝伏案磨砺的孤寂。白日梦便在这因果的裂隙中滋生，它悬于现实之上，如海市蜃楼般诱人，脚下却无寸土可依。它是一场颅内盛宴，以虚妄的甘霖浇灌干涸的渴望，却终究结不出可摘的果实。无用之用，固有其玄妙——庄子观鱼之乐，嵇康锻铁之闲，皆在功利之外开辟精神的自留地。然今日之”白日梦”，常沦为逃避行动的精致借口，沉溺于虚幻的”果”，而主动割裂了耕耘的”因”。此等梦境，终究是镜花水月，徒耗心神。 </p>
<p>古人称其为”黄粱美梦”，书生卢生枕青瓷入眠，梦中登科拜相，醒时灶上黍米未熟。现代心理学却揭示其本质：<strong>白日梦是欲望的镜像迷宫，我们在其中反复推演”倘若…就…”的虚拟剧本</strong>，却吝于在现实舞台迈出第一步。恰似渴盼中彩票者从不购彩，向往琴艺者永不触弦——当”因”的土壤始终荒芜，”果”的枝桠便只能寄生在意识的云端。</p>
<p>这种断裂在当代生活比比皆是：</p>
<ul>
<li>书架囤积三百本写作教程却从未提笔的”知识收藏家”</li>
<li>深夜收藏健身视频却在晨光中点击”稍后再练”的都市人</li>
<li>孩子能背诵课文却无法讲解错题的”沉默优等生”</li>
</ul>
<p>当”因”的土壤持续荒芜，”果”的枝桠只能寄生在意识的云端。心理学实验显示，长期沉溺此类幻想者，大脑会分泌大量多巴胺制造虚假满足，而前额叶皮层（负责执行功能的区域）活跃度持续降低——这正是行动力瘫痪的神经学根源。正如中国古代”黄粱美梦”的寓言 ，<strong>虚幻的因果演绎越是华丽，现实的行动根基越是脆弱</strong>。 </p>
<h3 id="第二幕：断桥修复术——无用之用的哲学启示"><a href="#第二幕：断桥修复术——无用之用的哲学启示" class="headerlink" title="第二幕：断桥修复术——无用之用的哲学启示"></a><strong>第二幕：断桥修复术——无用之用的哲学启示</strong></h3><p>要破解这一困局，需重返庄周梦蝶的哲学现场。当庄子质疑”不知周之梦为胡蝶与？胡蝶之梦为周与？”时，他揭示的不仅是认知相对论，更暗含存在转化的密钥：梦与醒的辩证统一，需通过”物证”实现连接。</p>
<ul>
<li><p><strong>物证转化案例</strong></p>
<p>19世纪巴黎的阁楼里，巴尔扎克将暴富妄想转化为《人间喜剧》的青铜群像；史铁生把”健康幻想”转化为对生死界限的勘探因而写成《务虚笔记》与《病隙碎笔》；罗翔将“完美法治”的执念解构为“圆圈正义”的谦卑认知而著成《法律的悖论》。这些实践印证了萨特的存在主义哲学：”人不是其所是，而是其所成”。当我们把彩票幻想转化为一张手绘彩票设计图，把环球旅行空想拆解为异国文化研究笔记——虚幻之果（what if）便倒逼实在之因（to do）。</p>
</li>
<li><p><strong>无用之用的现代显影</strong></p>
<p>日本匠人秋山利辉要求学徒每日绘制”器物灵魂草图”——这些看似与家具制作无关的线条练习（无用之果），需持续八年方准入技术研修（实在之因）。当草图积累逾万张时，学徒对木材肌理的感知力已融入血脉。 时间给他的复利回报，秋山工坊的学徒中，37%自立门户成为国宝级匠人，其作品被大英博物馆永久收藏。这种”以无用手训育有用之技”的模式，恰是庄子”无用之大用”的当代诠释——看似务虚的幻想，恰是创造的胚胎。</p>
</li>
</ul>
<p>庄周梦蝶的”物化”哲学在此显出新解：<strong>梦与醒的边界本是流动的，致命分野在于是否留下”物证”。</strong>蝶舞翩跹终随晨光消散，但若将蝶影绘于绢帛、谱入琴曲，虚幻的振翅便化作可触摸的翅痕。此谓”无用之用”的大用：看似务虚的幻想，恰是创造的胚胎。</p>
<p>此刻我们触及核心命题：<strong>所有可持续的创造，本质是因果链的重构工程。</strong>当陀思妥耶夫斯基赌轮盘还清债务的妄想（果）催生《赌徒》小说创作（因），当稿纸堆积（因）成就文学巨匠（果）——新的因果闭环便取代了断裂的幻想链。</p>
<h3 id="第三幕：输出型爱好——为幻想铸造青铜骨骼"><a href="#第三幕：输出型爱好——为幻想铸造青铜骨骼" class="headerlink" title="第三幕：输出型爱好——为幻想铸造青铜骨骼"></a>第三幕：输出型爱好——为幻想铸造青铜骨骼</h3><p>经济学中有道残酷公式：<strong>回报率 = 本金 × 收益率 × 时间</strong>。若输出值为零，整个等式即刻崩塌。至此我们看清核心公式：<strong>生命效能=（输入×转化率）×输出频次</strong>。当转化率趋近于零时，百万字的阅读量也不过是意识的泥石流。 这解释了为何囤积千本书籍的脑库不如撰写三篇笔记的心灵丰盈——前者如雨水积于死潭，后者似溪流催动水车。</p>
<p>我们常误将消费当创作：刷百条短视频称”学习影像叙事”，听万首歌曲谓”钻研乐理”。然则梭罗在《瓦尔登湖》中早有点破：”我步入丛林，因为我希望生活得有意义，我希望活的深刻，并汲取生命中所有的精华。然后从中学习，以免让我在生命终结时，却发现自己从来没有活过。”真正有效的阅读，是文字与生命经验发生的化合反应。</p>
<p>那些被浪漫化的”白日梦想家”，若只耽于颅内风暴而手无一物，其梦想不过是精致的废墟。真正的梦想家如凡尔纳笔下的尼摩船长，其海底两万里的瑰丽幻想，根植于对海洋学、工程学的深厚输入，更在小说这一载体中实现了磅礴的输出。幻想若不能借由某种形式显影于世，终究是幽闭密室里的独舞，其光不耀，其热不传。当输入如江河奔涌，却无一道闸门引导其倾泻，这丰沛的积累便只能在体内淤积、腐化，最终回报率为零。我们消费海量信息，聆听万千道理，若止步于此，不过是在意识的仓库里囤积了一堆未曾拆封的珍宝，蒙尘且无用。 </p>
<p>输入是采撷星光，输出才是铸造星座。此时，”输出型爱好”便显现其非凡价值。它非为换取世俗功利的工具，而是为奔涌的思绪开凿河道，让无形的精神能量获得具象的骨相。写作、绘画、摄影、手工、编程、演讲……凡此种种，皆是将灵魂印记拓印于世的技艺。此般爱好，本质上是主动与世界建立深度联结的管道——它迫使混沌的思绪在输出中澄澈，让私密的感动在分享中共振。如木工大师经年累月的敲打，从爱好者蜕变为传承者；如咖啡师荣姐由分享早餐美学而衍生出产品变现与商拍邀约；如设计师春春通过朋友圈输出作品，倒逼输入精进，终成独特风格的开创者。输出，赋予热爱以复利的翅膀。</p>
<p>《白日梦想家》更擅此道：沃尔特·米蒂（电影《白日梦想家》主角）从直升机跃入冰海追摄雪豹的瞬间，正是将脑海冒险投射为胶片的因果渡越。当幻想不再是思维的蒲公英，而是扎根于输出行为的种子——摄影机是锹，暗房是沃土，展览馆便是破土的苗圃。</p>
<h3 id="第四幕：破壁法则——在因果链上播种的农艺"><a href="#第四幕：破壁法则——在因果链上播种的农艺" class="headerlink" title="第四幕：破壁法则——在因果链上播种的农艺"></a>第四幕：破壁法则——在因果链上播种的农艺</h3><p>如何将飘渺的白日梦锻造成可触的输出？不妨借科学之刃雕琢幻想之玉：</p>
<ol>
<li><strong>以WOOP之法锚定虚幻</strong>： 德国心理学家Oettingen的”心理对照”（Mental Contrasting）提供路径——Wish（明确愿望）、Outcome（想象结果）、Obstacle（预见障碍）、Plan（制定对策）。幻想中彩票者，若用此法，必先自问：阻碍何在？是未曾购买？是选号无方？对策为何？是每周定额投入？是研究概率策略？此法在幻想与现实间架设理性之桥，让白日梦成为行动蓝图而非麻醉剂。</li>
<li><strong>择一事深耕，为输出赋形</strong>： 兴趣是火种，输出是燃炉。内向者可执笔为矛（写作、编程），外向者能发声为剑（演讲、视频）。不必贪多，择一契合天赋与热情之事：善思者写作，善察者摄影，善言者播客，善工者手作。如范范所倡：确定领域、制定计划、多渠道分享。写作不必鸿篇巨制，从百字日记开始；摄影无需昂贵器材，手机镜头亦能捕捉光影真意。工具仅为载体，核心在表达的冲动与持续的实践。</li>
<li><strong>以行动为针，缝合因果裂隙</strong>： 吸引力法则非玄学空想，其核心在于”量子行动”——幻想触发灵感，灵感催生最小行动，行动收获反馈，反馈驱动修正。白日梦若仅止步于”想”，便是无根之萍；唯有”做”，才能将”因”植入现实土壤。如陶艺家揉捏第一块陶土，程序员敲下第一行代码，写作者写出第一个句子——微小的行动，是打破虚幻与现实壁垒的锤击。行动中自会遭遇瓶颈，此时反馈如明镜：读者评论、观众反应、作品滞销皆是指路牌。调整非失败，而是路径的优化，如演讲者从听众眼神中调整节奏，写作者从退稿信中磨砺笔锋。</li>
<li><strong>在时间的长河中淘洗真金</strong>： 输出型爱好的回报，非即时兑现的快钱，而是”复制类职业”的长期复利。转换类职业（如按件计酬的工人）以时间换生存资料；复制类职业（如作家、程序员）则以一次高质量输出，撬动时间的杠杆，让作品在流通中持续增值。当写作凝结成书，代码封装为软件，摄影汇聚成集，手艺沉淀为品牌，其能量便能超越个体生命的时限，在更广阔的空间与时间里回响。此过程需如匠人般的沉潜与耐心，”事缓则圆，静待花开”。</li>
</ol>
<h3 id="终幕：在现实的砧板上锻打星辰"><a href="#终幕：在现实的砧板上锻打星辰" class="headerlink" title="终幕：在现实的砧板上锻打星辰"></a>终幕：在现实的砧板上锻打星辰</h3><p>每个孩童都曾是白日梦的富矿者，直到成人世界为其贴上”不切实”的封条。然纵观文明长河：凡·高在阿尔勒的艳阳下幻想旋涡星空，却以油彩将其凝成《星月夜》；曹雪芹于”举家食粥”间追忆旧日繁华，终将幻梦淬炼为《红楼梦》的玉璧。</p>
<p>白日梦本无罪，它是人类心智对庸常的温柔叛离，对可能性的诗意勘探。然若任其飘荡于虚空中，终将耗散于无形。唯有以”输出”为引信，才能点燃幻想深处的能量，将飘渺的蜃楼锻造成可栖居的精神家园。当我们提笔、举镜、运刀、编码、发声——每一次输出的动作，都是对虚无的抵抗，对存在的确证。那些在时间里埋下的种子，终将在专注的汗水中破土，将个体的微光，汇聚成照亮人间角落的星辰。无用之用，至此方为大用；白日梦想家，至此才真正拥有了大地上的居所。 </p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2025/06/07/2025-06-07/</url>
    <content><![CDATA[<h2 id="递归梦境：在熵增深渊里焊接银河渡船"><a href="#递归梦境：在熵增深渊里焊接银河渡船" class="headerlink" title="递归梦境：在熵增深渊里焊接银河渡船"></a><strong>递归梦境：在熵增深渊里焊接银河渡船</strong></h2><p>空调外机的低鸣在子夜涨潮，忽被一阵急促的键盘敲击声刺破——我的手指在梦醒后敲打着虚空。</p>
<p>今夜梦境是台越狱的虚拟机： 高考卷面的沙沙声竟编译成工位键盘的疾雨，出租屋上铺床架的呻吟突变为经理破门的训斥。两个时空的钢索绞紧胸腔，勒紧每个正在逃逸的梦境。</p>
<hr>
<h3 id="一、叩问：梦为何总在旧代码里编译？"><a href="#一、叩问：梦为何总在旧代码里编译？" class="headerlink" title="一、叩问：梦为何总在旧代码里编译？"></a><strong>一、叩问：梦为何总在旧代码里编译？</strong></h3><p>最近梦境如顽固的递归函数，今夜意识流溢出核心栈：</p>
<ul>
<li><p><strong>场景A</strong>：高考在即，然而放学时校门口油锅里滋啦作响的油条，香味漫过十年光阴直抵今晨的舌根。突然，油条香气刺穿时空防火墙 ，物理公式在演算纸上坍缩成乱码，同桌突然将纸团抛过楚河汉界。  而校门口油锅滋啦作响的爆鸣，竟在十年后编译成唤醒胃囊的<code>SystemCall</code>。</p>
<p>——  <em>弗洛伊德注：味觉记忆是埋入海马体的Hook函数，当现实感官带宽不足时，触发童年补偿性回滚</em>  </p>
</li>
<li><p><strong>场景B</strong>：即将奔赴职场，城中村出租屋里，中介甩来的电子合同在手机屏闪烁，<code>rm -rf youth</code>（删除青春）的代码幻影在条款间游走。 出租屋的日光灯管焊入视觉暂留区，睡在上铺的我，鼾声沿双层床架垂直坠落，在耳蜗里堆叠成<code>ERROR</code>日志瀑布。 眼皮烙着青白灼痕，如<code>BIOS</code>启动失败的报错光标。</p>
<p>—— <em>荣格注：过度劳累时，集体潜意识将压力具象为「光污染废墟」，提醒主体平衡阴阳能量场</em> </p>
</li>
<li><p><strong>场景C</strong>：通宵加班，室友的抱怨声悬浮在宿舍暖光里：“本月宽带费暖气费均摊。” 声波未抵达听觉皮层，经理推门的震波震落了墙灰，墙灰粒子在经理的训斥声中完成量子跃迁。那被震落的尘埃， 竟在晨光衍射中重组为浮动的金粉矩阵。</p>
<p>—— <em>量子梦境假说：观察者效应使创伤记忆发生波函数坍缩，痛苦被意识渲染为勋章</em> </p>
</li>
</ul>
<p>醒时指尖残留着薄膜键盘的塑胶触感，鼻腔却灌满此刻卧室的香薰机水雾。那些被deadline追杀、被ERROR日志与线上问题逼至深渊的日夜，竟在回望时镀上了蜜色光晕。而此刻人体工学椅托着腰椎，4K屏流淌着护眼光谱，灵魂却像被抽走核心线程的进程，悬停在静默的等待队列。</p>
<hr>
<h3 id="二、辩证：怀旧是记忆的编译谬误吗？"><a href="#二、辩证：怀旧是记忆的编译谬误吗？" class="headerlink" title="二、辩证：怀旧是记忆的编译谬误吗？"></a><strong>二、辩证：怀旧是记忆的编译谬误吗？</strong></h3><h4 id="假说1：怀旧是懦弱的返祖现象"><a href="#假说1：怀旧是懦弱的返祖现象" class="headerlink" title="假说1：怀旧是懦弱的返祖现象"></a>假说1：怀旧是懦弱的返祖现象</h4><p>如同过时的API接口强行调用废弃库函数，在舒适区的沙箱里反复执行<code>nostalgia.exe</code>。当现实CPU满载运行时，意识却将线程切换至ROM只读存储器——那些高考油条的焦香、双层床架的震颤，不过是刻录在神经突触里的只读扇区。我们像被困在死循环的进程，用昨日残片构建今日的虚拟内存，实则是畏惧为未来分配新的堆栈空间。 </p>
<h4 id="假说2：梦境是现实的镜像溢出"><a href="#假说2：梦境是现实的镜像溢出" class="headerlink" title="假说2：梦境是现实的镜像溢出"></a>假说2：梦境是现实的镜像溢出</h4><p>当现实进入低功耗模式（安逸生活），被压抑的匮乏体验便激活海马体的Hook函数。那些被<code>kill -9</code>强制终止的奋斗进程（高考冲刺/职场求生），在睡眠态获得root权限后开始疯狂回滚。记忆熔断保护器被击穿，十年陈的油锅爆鸣与经理训斥声在脑皮层混音播放——这是精神熵增的必然：系统必须调用高负载记忆（奋斗岁月）维持能量守恒，否则安逸的温水将彻底溶解灵魂的晶体振荡器。 </p>
<h4 id="假说3：幻象是未来的加密信函"><a href="#假说3：幻象是未来的加密信函" class="headerlink" title="假说3：幻象是未来的加密信函"></a>假说3：幻象是未来的加密信函</h4><p>当晨光中的墙灰坍缩为金粉矩阵时，我听见量子比特在耳蜗低语：所有创伤都是被折叠的虫洞入口。高考演算纸上的乱码实则是自解压程序，正将物理公式重组为职场危机的补丁包；经理破门的震波在时空连续体上激发的涟漪，此刻正推动我的指尖敲下这行代码。正如量子纠缠无视光锥约束，那些在ERROR日志里垂直坠落的鼾声，终将在某次波函数坍缩中重组为超导量子比特。</p>
<hr>
<h3 id="三、顿悟：光在裂隙处显形"><a href="#三、顿悟：光在裂隙处显形" class="headerlink" title="三、顿悟：光在裂隙处显形"></a><strong>三、顿悟：光在裂隙处显形</strong></h3><p>我抽出大学时买的已落灰的《庄子》，指尖在“与时俱化”旁按出指纹。那时不懂何谓“安时而处顺”，只觉每个字都是砸向铁屋的陨石。</p>
<p>落灰的《庄子》突然释放电磁脉冲。当指纹激活”与时俱化”的古老字节，所有递归梦境瞬间终止core dump。我意识到：高考考场上抛来的橡皮擦、出租屋墙灰震荡成的金粉、甚至经理训斥声在听觉神经激发的量子纠缠——这些从来不是需要修复的bug，而是宇宙编译器预埋的<code>#pragma</code>优化指令。 油条香气穿透的何止时空防火墙？它早已将海马体改造成冯诺依曼架构的奇点：童年滋啦作响的油锅是L1缓存，职场键盘疾雨是L2预取器，而此刻卧室香薰机的氤氲水雾，正通过嗅觉总线将整个记忆体系升级为存算一体架构。原来光从未消失，它只是被压缩在人生.bin文件的间隙里，等待<code>dd</code>命令的按位读取。 </p>
<hr>
<blockquote>
<p><strong>终章：向熵增宣战的生灵</strong></p>
<p>机箱风扇的尘埃在4K护眼光谱中跳起玻色-爱因斯坦凝聚之舞。那些被Deadline追杀的日夜、被线上问题逼至悬崖的瞬间，此刻正以反物质态注入我的脊髓——它们不再是需要GC回收的堆内存，而是驱动量子隧穿的势垒。  人体工学椅托举的何止腰椎？它承载着正进行实时无损压缩的时空连续性。当十年前的油条香与今日的键盘声在哈希表中碰撞出希格斯玻色子，我终于编译出对抗热寂的终极算法：将高考答卷的演算纸折成哥德尔宇宙船，让经理训斥声的震波转换为曲率引擎的初始动能。机箱风扇卷起尘埃起舞。<br>此身此夜，且以残存指骨为焊枪，熔铸断点成银河渡船。那些曾经日夜敲打我的ERROR日志，此刻正以超流体形态托举船体，驶向记忆奇点的事件视界。 </p>
<p>蓦然读懂《齐物论》页脚的指纹：<br><strong>与时俱化者，非弃旧也——昨日之我凿穿的岩层，恰是今日之光抵达的甬道</strong></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>一句话影评，剧荒时可以捞捞</title>
    <url>/2020/12/06/2020-12-06/</url>
    <content><![CDATA[<h1 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h1><h2 id="内地"><a href="#内地" class="headerlink" title="内地"></a>内地</h2><h3 id="姜文"><a href="#姜文" class="headerlink" title="姜文"></a>姜文</h3><h4 id="执导"><a href="#执导" class="headerlink" title="执导"></a>执导</h4><h5 id="《阳光灿烂的日子》"><a href="#《阳光灿烂的日子》" class="headerlink" title="《阳光灿烂的日子》"></a>《阳光灿烂的日子》</h5><p>一句话影评：</p>
<p>综合评分（个人）：★★★★☆</p>
<p>编剧：★★★★★</p>
<p>镜头：★★★★☆</p>
<p>配乐：★★☆</p>
<p>立意：★★★★★</p>
<p>故事结构：★★★★★</p>
<p>电影影响力：★★★★☆</p>
<p>分类：剧情</p>
<p>标签：青春</p>
<h5 id="《让子弹飞》"><a href="#《让子弹飞》" class="headerlink" title="《让子弹飞》"></a>《让子弹飞》</h5><p>一句话影评：</p>
<p>综合评分（个人）：★★★★☆</p>
<p>编剧：★★★★★</p>
<p>镜头：★★★☆</p>
<p>配乐：★★★★☆</p>
<p>立意：★★★</p>
<p>故事结构：★★★★★</p>
<p>电影影响力：★★★★☆</p>
<p>分类：</p>
<p>标签：</p>
<h5 id="《太阳照常升起》"><a href="#《太阳照常升起》" class="headerlink" title="《太阳照常升起》"></a>《太阳照常升起》</h5><p>一句话影评：</p>
<p>综合评分（个人）：★★★★☆</p>
<p>编剧：★★★★★</p>
<p>镜头：★★★★</p>
<p>配乐：★★★★☆</p>
<p>立意：★★★</p>
<p>故事结构：★★★★★</p>
<p>电影影响力：★★★</p>
<p>分类：</p>
<p>标签：</p>
<h5 id="《鬼子来了》"><a href="#《鬼子来了》" class="headerlink" title="《鬼子来了》"></a>《鬼子来了》</h5><p>一句话影评：</p>
<p>综合评分（个人）：★★★★☆</p>
<p>编剧：★★★★★</p>
<p>镜头：★★★★</p>
<p>配乐：★★★</p>
<p>立意：★★★★★</p>
<p>故事结构：★★★★★</p>
<p>电影影响力：★★★★☆</p>
<p>分类：</p>
<p>标签：</p>
<h5 id="《一步之遥》"><a href="#《一步之遥》" class="headerlink" title="《一步之遥》"></a>《一步之遥》</h5><p>一句话影评：</p>
<p>综合评分（个人）：★★★☆</p>
<p>编剧：★★★★★</p>
<p>镜头：★★★★</p>
<p>配乐：★★★★☆</p>
<p>立意：★★★</p>
<p>故事结构：★★★☆</p>
<p>电影影响力：★★★</p>
<p>分类：</p>
<p>标签：</p>
<h5 id="《邪不压正》"><a href="#《邪不压正》" class="headerlink" title="《邪不压正》"></a>《邪不压正》</h5><p>一句话影评：</p>
<p>综合评分（个人）：★★★☆</p>
<p>编剧：★★★☆</p>
<p>镜头：★★★★</p>
<p>配乐：★★★★☆</p>
<p>立意：★★★</p>
<p>故事结构：★★★★★</p>
<p>电影影响力：★★★</p>
<p>分类：</p>
<p>标签：</p>
<h4 id="主演"><a href="#主演" class="headerlink" title="主演"></a>主演</h4><h5 id="《有话好好说》"><a href="#《有话好好说》" class="headerlink" title="《有话好好说》"></a>《有话好好说》</h5><p>一句话影评：</p>
<p>综合评分（个人）：★★★★</p>
<p>编剧：★★★☆</p>
<p>镜头：★★★★</p>
<p>配乐：★★★★☆</p>
<p>立意：★★★</p>
<p>故事结构：★★★★★</p>
<p>电影影响力：★★★</p>
<p>分类：</p>
<p>标签：</p>
<h5 id="《芙蓉镇》"><a href="#《芙蓉镇》" class="headerlink" title="《芙蓉镇》"></a>《芙蓉镇》</h5><h3 id="张艺谋"><a href="#张艺谋" class="headerlink" title="张艺谋"></a>张艺谋</h3><h3 id="冯小刚"><a href="#冯小刚" class="headerlink" title="冯小刚"></a>冯小刚</h3><h5 id="《天下无贼》"><a href="#《天下无贼》" class="headerlink" title="《天下无贼》"></a>《天下无贼》</h5><h3 id="徐峥"><a href="#徐峥" class="headerlink" title="徐峥"></a>徐峥</h3><h3 id="沈腾"><a href="#沈腾" class="headerlink" title="沈腾"></a>沈腾</h3><h3 id="黄渤"><a href="#黄渤" class="headerlink" title="黄渤"></a>黄渤</h3><h2 id="港台"><a href="#港台" class="headerlink" title="港台"></a>港台</h2><h3 id="王家卫"><a href="#王家卫" class="headerlink" title="王家卫"></a>王家卫</h3><p>《东邪西毒》</p>
<p>《重庆森林》</p>
<p>《阿飞正传》</p>
<p>《花样年华》</p>
<p>《2046》</p>
<p>《堕落天使》</p>
<p>《一代宗师》</p>
<h3 id="周星驰"><a href="#周星驰" class="headerlink" title="周星驰"></a>周星驰</h3><p>《功夫》</p>
<p>《少林足球》</p>
<p>《大话西游1-2》</p>
<p>《食神》</p>
<p>《国产凌凌漆》</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h2 id="欧美"><a href="#欧美" class="headerlink" title="欧美"></a>欧美</h2><h3 id="时光三部曲"><a href="#时光三部曲" class="headerlink" title="时光三部曲"></a>时光三部曲</h3><p>《海上钢琴师》</p>
<p>《天堂电影院》</p>
<p>《西西里的美丽传说》</p>
<h3 id="人生篇"><a href="#人生篇" class="headerlink" title="人生篇"></a>人生篇</h3><p>《教父1-3》</p>
<p>《美国往事》</p>
<p>《灿烂人生1-3》</p>
<h2 id="日韩"><a href="#日韩" class="headerlink" title="日韩"></a>日韩</h2><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h1 id="动漫"><a href="#动漫" class="headerlink" title="动漫"></a>动漫</h1><h2 id="欧美-1"><a href="#欧美-1" class="headerlink" title="欧美"></a>欧美</h2><p>《飞屋环游记》</p>
<p>《疯狂动物城》</p>
<p>《头脑特工队》</p>
<p>《玩具总动员1-4》</p>
<p>《无敌破坏王》</p>
<p>《疯狂原始人》</p>
<h2 id="日韩-1"><a href="#日韩-1" class="headerlink" title="日韩"></a>日韩</h2><h3 id="今敏"><a href="#今敏" class="headerlink" title="今敏"></a>今敏</h3><p>《红辣椒》</p>
<p>《未麻的部屋》</p>
<p>《千年女优》</p>
<h3 id="宫崎骏"><a href="#宫崎骏" class="headerlink" title="宫崎骏"></a>宫崎骏</h3><p>《千与千寻》</p>
<p>《红猪》</p>
<p>《龙猫》</p>
<p>《侧耳倾听》</p>
<p>《哈尔的移动城堡》</p>
<p>《魔女宅急便》</p>
<p>《幽灵公主》</p>
<p>《风之谷》</p>
<p>《天空之城》</p>
<p>《百变狸猫》</p>
<p>《起风了》</p>
<h3 id="新海诚"><a href="#新海诚" class="headerlink" title="新海诚"></a>新海诚</h3><p>《秒速五厘米》</p>
<p>《你的名字。》</p>
<p>《天气之子》</p>
<p>《言叶之庭》</p>
<h3 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h3><p>《声之形》</p>
<p>《穿越时空的少女》</p>
<p>《我想吃掉你的胰脏》</p>
<p>《烟花》</p>
<h2 id="内地-1"><a href="#内地-1" class="headerlink" title="内地"></a>内地</h2><p>《白蛇：缘起》</p>
<p>《大圣归来》</p>
]]></content>
  </entry>
  <entry>
    <title>【性格篇】自称尼古拉的马迪奥——由性格所决定不同的《灿烂人生》</title>
    <url>/2020/11/14/2020-11-14/</url>
    <content><![CDATA[<p>一直以来都想写一些关于对性格思考方面的文字。今天正好有空以《灿烂人生》这部电影对性格进行一番探讨。首先我先以两个主人公尼古拉和马迪奥为切入点梳理一下剧情。</p>
<p>1966年的罗马，社会动荡，经济萧条。马迪奥与尼古拉两兄弟的故事便从这座历史悠久而又命运坎坷的城市展开。</p>
<p>故事开始，两兄弟都在罗马大学学习，马迪奥学习文学，向来聪明，成绩优秀，但性格有点孤立，和父母之间很少沟通。在一次期末考试中，由于推崇一位辱骂父辈的诗人而遭到老师的责备，由于无法忍受老师对诗歌的浅薄见解而拂袖而去。这是电影中第一次表现他性格的镜头，简单粗暴地对抗着自己所认为的黑暗，尽管电影已预见他未来注定悲剧的命运，仍义无反顾。</p>
<p>尼古拉攻读医学，一直敬仰马迪奥，虽然成绩没有马迪奥好，但为人友善亲切，深受父母的赞赏。在期末考试中，虽然成绩不是很优异，但凭借宽仁之心博得考官赞赏，获得了考官给出的最高分。考官建议他游历四方，因为意大利没有希望。</p>
<p>马迪奥在精神病院帮工时，陪一个叫佐珍的患者做病理分析。佐珍一头金发，美丽的外表却掩饰不住对世界充满警觉的眼神。马迪奥很快被佐珍吸引，然而在相处的过程中佐珍喜怒无常的脾气让两人相处并不愉快。经询问马迪奥得知，年少时佐珍与常人无异，由于母亲的去世渐渐封闭了自我，成为了被社会判为有“缺陷”的人。一次马迪奥给佐珍拍照时偶然间发现了佐珍额头上的伤痕，经询问尼古拉得知这是长时间受点击留下的伤痕。马迪奥恍然大悟，那些道貌岸然的医生背地里经常折磨着佐珍。二人原本计划与朋友巴图和卡洛一起出国旅行，但不忍看佐珍在医院受折磨，于是决定先帮佐珍回家，然后再旅行。</p>
<p>途中，三人露宿在一家破旧的房屋里，马迪奥久久难免。他起身发现了一个佐珍笔记本，里面写着马迪奥的名字，马迪奥感慨万千，就在这时佐珍忽然醒了，看见自己的笔记本在马迪奥手上，愤怒地抢夺着笔记本，马迪奥连忙解释，但面对佐珍的大喊大叫却束手无策。尼古拉被惊醒后，从容的支开马迪奥，说一切由他处理。友善地为佐珍系着纽扣，佐珍平息下来，默默看着尼古拉做的一切。远处马迪奥也看在眼里。</p>
<p>早上，三人来到佐珍的家里，他父亲见到佐珍后却不愿接纳佐珍，想着已经支付了医院的费用，不管兄弟两人的解释，要求佐珍回去。此时马迪奥愤怒地跟她父亲扭打一起，最终无果而归。兄弟二人只好商定将佐珍送到意大利最好的精神病医院。</p>
<p>三人来到一家杂货店，马迪奥为了弥补佐珍，为她点了一首歌，佐珍比划着喜欢的曲名。此刻二人的心走到了一生中最近的时刻。尼古拉建议佐珍多与人交流，让她去买三个冰淇淋，但佐珍再买冰淇淋时异常的行为引起了警察的注意，由于没有身份证而被警察带走。兄弟二人看在眼里却没有办法，因为私自把精神病人带出医院属于犯法。</p>
<p>晚上，二人露宿车站，马迪奥彻夜难眠，他看着这眼前世界的不公自己却无能为力。终于他起身拎起行李踏上了返回罗马的列车。闻到动静的尼古拉起身询问马迪奥为什么丢下自己和朋友独自回去罗马，马迪奥只说那次重要的考试他没有通过。尼古拉愤然关上了列车的门，二人分道扬镳，自此两人截然不同的命运从这趟列车展开。</p>
<p>未完待续，，，，，，</p>
]]></content>
  </entry>
  <entry>
    <title>基于云存储的图像管理平台设计与实现</title>
    <url>/2020/07/01/2020-07-01/</url>
    <content><![CDATA[<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps1.jpg" alt="img"></p>
<p>毕 业 设 计</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps2.jpg" alt="img"> </p>
<p><strong>题目：</strong> <strong>基于云存储的图像管理平台设计与实现</strong>                                                                       </p>
<p><strong>学    生：</strong>         王骏         </p>
<p><strong>学    号：</strong>     201606060129     </p>
<p><strong>学    院：</strong>电子信息与人工智能学院</p>
<p><strong>专    业：</strong>   计算机科学与技术   </p>
<p><strong>指导教师：</strong>         齐勇         </p>
<p>2020<strong>年</strong> 6 <strong>月</strong> 30 <strong>日</strong></p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps3.jpg" alt="img"></p>
<p><strong>毕业设计（论文）任务书</strong></p>
<p>电子信息与人工智能 <strong>学院</strong> 计算机科学与技术 <strong>专业</strong> 163<strong>班级 学生：</strong>王骏</p>
<p><strong>题目：</strong>            基于云存储的图像管理平台设计与实现                                                 </p>
<p><strong>毕业设计（论文）从</strong> 2020 <strong>年</strong> 2 <strong>月</strong> 24 <strong>日起到</strong> 2020 <strong>年</strong> 6 <strong>月</strong>   15   <strong>日</strong></p>
<p><strong>课题的意义及培养目标：</strong></p>
<p>在本本次毕业设计中，将会综合运用本科所学计算机科学与技术专业相关知识，完成实际的应用开发。</p>
<p>传统的云存储系统采用集中的存储服务器存放所有数据，存储服务器成为系统性能的瓶颈，也是可靠性和安全性的焦点，不能满足大规模存储应用的需要。</p>
<p>分布式网络存储系统采用可扩展的系统结构，利用多台存储服务器分担存储负荷，利用位置服务器定位存储信息，它不但提高了系统的可靠性、可用性和存取效率，还易于扩展。因此，本项目利用多台服务器的存储资源来弥补传统云存储系统的不足，通过Nginx服务器作为负载均衡服务实现高负载的分布式云存储方案。</p>
<p><strong>设计（论文）所需收集的原始数据与资料：</strong></p>
<p>C++相关的开发软件工具，Qt客户端设计工具，Nginx服务器，Linux操作系统，MySQL数据库，Redis数据库，分布式文件系统，项目所需的图像数据，分布式文件系统相关资料。</p>
<p><strong>课题的主要任务（需附有技术指标分析）：</strong></p>
<p>本次设计主要为高负载高并发基于分布式的图像管理存储平台。主要实现用户注册，用户登陆，图像文件列表获取，文件上传，下载，分享，删除等基本功能。</p>
<p>本次设计采用C/S架构，分为客户端和服务端，客户端采用Qt进行界面设计。服务端的基本流程为，客户端请求经过反向代理后通过HTTP服务器请求进行相应分布式文件系统管理及数据库管理。以上传为例，首先客户端的请求通过Nginx反向迭代处理作为负载均衡方案，之后通过对应服务器请求先进行数据库信息校验，当该上传数据不存在时，通过追踪器将图像数据存储到相应的分布式文件系统中，再将存储信息存储至数据库以及缓存数据库中。</p>
<p>预计：并发量同步请求初步预计500人左右。本地测试上传速度：30MB/S ~ 50MB/S 客户端下载速度： 20MB/S ~ 40MB/S 服务器中上传速度： 5MB/S ~ 7MB/S 客户端下载速度： 0.1MB/S~ 0.15MB/S </p>
<p><strong>设计（论文）进度安排及完成的相关任务（以教学周为单位）：</strong></p>
<table>
<thead>
<tr>
<th><strong>周 次</strong></th>
<th><strong>设计（论文）任务及要求</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1-3</td>
<td>相关资料的查阅与学习</td>
</tr>
<tr>
<td>4-5</td>
<td>整个方案的初步设计</td>
</tr>
<tr>
<td>6-10</td>
<td>代码的设计与实现</td>
</tr>
<tr>
<td>11-12</td>
<td>测试与bug修复</td>
</tr>
<tr>
<td>13-14</td>
<td>论文的梳理</td>
</tr>
<tr>
<td>15-16</td>
<td>论文的完善</td>
</tr>
</tbody>
</table>
<p>​                                    学生签名：             </p>
<p>​                                    指导教师：             </p>
<p>​                                  教研室主任：             </p>
<p>基于云存储的图像管理平台设计与实现</p>
<h1 id="摘-要"><a href="#摘-要" class="headerlink" title="摘 要"></a>摘 要</h1><p>随着计算机与网络的发展，国内外的图像存储已逐渐实现由传统图像向数字化图像转型。这意味着图像越来越多地以二进制信息保存在计算机中，这样不仅可以长期保存，而且还有方便复制、随意修改、便于传输等优点。而随着大数据与云计算的发展，图像的存储逐渐也向分布式存储方向发展，使得图像管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连。分布式文件系统的设计基于C/S模式。而且分布式文件系统也轻松解决了海量图像处理的难题。</p>
<p>利用大数据和云计算的优势，以云存储的方式进行图像数字化存储管理，可以解决常规对象存储所常见的海量图像存储效率低下且不安全、服务器无法承载多用户并发访问等问题。因此设计一套基于分布式文件系统的云存储图像管理平台，为用户提供高效且安全的图像上传、下载、分享、预览等对象存储与管理服务，解决常规物理存储所带来的数据易丢失难恢复、下载存储不方便、存储空间有限、需随身携带等问题，同时解决普通存储网盘用户并发量低下、数据共享性差等问题。</p>
<p>平台采用C/S模型，即客户端/服务端模式。客户端通过Qt可视化设计工具设计用户界面与文件管理界面，客户端语言通过使用Qt类库完成客户端逻辑。服务端框架首先采用Nginx服务器进行反向代理，解决负载均衡与高并发问题；数据对象存储通过分布式文件系统FastDFS进行数据存储；数据库通过持久化数据库MySQL与缓存数据库Redis的协调工作进行数据信息管理；服务端语言采用以C++语言为主的CGI程序完成服务端逻辑。</p>
<p>基于云存储的图像管理平台，最终为用户提供高效且安全的图像云存储与管理服务，包括用户的登录与注册、数据上传、数据下载、文件列表浏览、共享文件浏览、下载榜浏览、数据传输情况浏览、文件的共享与转存、数据删除、图像预览等功能，可作为图床进行图像存储，也可作为云盘进行对象存储，方便用户对图像数据进行数字化管理。</p>
<p>关键词：云存储，分布式文件系统，Nginx，MySQL，C++，Qt</p>
<p><strong>Design and</strong> <strong>I**</strong>mplementation of<strong> </strong>I<strong>**mage</strong> <strong>M**</strong>anagement<strong> </strong>P<strong>**latform based on</strong> <strong>C**</strong>loud<strong> </strong>S<strong>**torage</strong></p>
<h1 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a><strong>ABSTRACT</strong></h1><p>With the development of computer and network, image storage at home and abroad has gradually realized the transformation from traditional image to digital image. This means that the image is more and more stored in the computer with binary information, which not only can be saved for a long time, but also has the advantages of convenient replication, arbitrary modification, easy transmission and so on. With the development of big data and cloud computing, the storage of images is also gradually developing towards distributed storage. The design of distributed file system is based on C / S mode. Moreover, the distributed file system can easily solve the problem of massive image processing.</p>
<p>By using the advantages of big data and cloud computing, digital image storage management in the way of cloud storage can solve the common problems of mass image storage, such as low efficiency and insecurity, the server can not carry multi-user concurrent access and so on. Therefore, a set of cloud storage image management platform based on the distributed file system is designed to provide users with efficient and safe image upload, download, share, preview and other object storage and management services, to solve the problems brought by the conventional physical storage, such as easy loss and hard recovery of data, inconvenient Download and storage, limited storage space, need to carry around, and to solve the common storage network disk There are many problems such as low concurrent users and poor data sharing.</p>
<p>The platform adopts C / S model, namely client / server mode. The client uses QT visual design tool to design user interface and file management interface, and the client language uses QT class library to complete the client logic. The server framework first uses nginx server as the reverse proxy to solve the problem of load balance and high concurrency; the data object storage uses fastdfs as the distributed file system for data storage; the database uses MySQL as the persistent database to coordinate with redis as the cache database for data information management; the server language uses CGI program based on C + + to complete the server logic.</p>
<p>The image management platform based on cloud storage provides users with efficient and safe image cloud storage and management services, including user login and registration, data upload, data download, file list browsing, shared file browsing, download list browsing, data transmission browsing, file sharing and transfer, data deletion, image preview and other functions, which can be used as a drawing bed Image storage can also be used as cloud disk for object storage, which is convenient for users to digitize image data management.</p>
<p><strong>Key</strong> <strong>words:</strong> Cloud Storage, Distributed File System, Nginx, MySQL, C + +, QT</p>
<p>目 录</p>
<p><a href="#_Toc2488">摘 要    I</a></p>
<p><a href="#_Toc13379">ABSTRACT    II</a></p>
<p><a href="#_Toc24459">1 绪论    1</a></p>
<p><a href="#_Toc16618">1.1 课题背景    1</a></p>
<p><a href="#_Toc1878">1.2 发展趋势    1</a></p>
<p><a href="#_Toc30693">1.3 项目意义    2</a></p>
<p><a href="#_Toc4211">2 需求分析    4</a></p>
<p><a href="#_Toc9992">2.1 功能需求分析    4</a></p>
<p><a href="#_Toc9660">2.1.1 服务端功能需求分析    4</a></p>
<p><a href="#_Toc30903">2.1.2 客户端功能需求分析    4</a></p>
<p><a href="#_Toc3888">2.2 可行性分析    5</a></p>
<p><a href="#_Toc26488">2.2.1 经济可行性分析    5</a></p>
<p><a href="#_Toc28087">2.2.2 技术可行性分析    5</a></p>
<p><a href="#_Toc18212">2.2.3 运行可行性分析    5</a></p>
<p><a href="#_Toc27154">2.2.4 操作可行性分析    6</a></p>
<p><a href="#_Toc22683">3 技术支持    7</a></p>
<p><a href="#_Toc6199">3.1 FastDFS分布式文件系统    7</a></p>
<p><a href="#_Toc17449">3.2 Nginx服务器反向代理与负载均衡    8</a></p>
<p><a href="#_Toc6830">3.3 Qt客户端GUI界面设计    10</a></p>
<p><a href="#_Toc30717">4 设计方案    12</a></p>
<p><a href="#_Toc11686">4.1 设计原理    12</a></p>
<p><a href="#_Toc4956">4.2 总体设计方案    12</a></p>
<p><a href="#_Toc16343">4.2.1 客户端设计方案    13</a></p>
<p><a href="#_Toc3197">4.2.2 服务端设计方案    14</a></p>
<p><a href="#_Toc12152">4.3 功能模块方案    14</a></p>
<p><a href="#_Toc28206">4.3.1 用户注册与登录    14</a></p>
<p><a href="#_Toc13258">4.3.2 文件列表查询    16</a></p>
<p><a href="#_Toc13231">4.3.3 数据上传与秒传    16</a></p>
<p><a href="#_Toc4">4.3.4 文件删除    18</a></p>
<p><a href="#_Toc15469">4.3.5 文件共享与共享列表查询    19</a></p>
<p><a href="#_Toc21161">4.3.6 数据下载    20</a></p>
<p><a href="#_Toc24190">4.3.7 图像预览    21</a></p>
<p><a href="#_Toc31890">4.4 流程关系    22</a></p>
<p><a href="#_Toc5645">4.4.1 客户端流程    22</a></p>
<p><a href="#_Toc1323">4.4.2 服务端流程    23</a></p>
<p><a href="#_Toc278">5 具体实现    25</a></p>
<p><a href="#_Toc32181">5.1 服务端架构实现    25</a></p>
<p><a href="#_Toc4647">5.1.1 负载均衡    25</a></p>
<p><a href="#_Toc25489">5.1.2 数据库设计    25</a></p>
<p><a href="#_Toc1570">5.1.3 文件对象存储    28</a></p>
<p><a href="#_Toc8402">5.2 客户端架构实现    29</a></p>
<p><a href="#_Toc20029">5.2.1 用户界面设计    29</a></p>
<p><a href="#_Toc19068">5.2.2 文件界面设计    31</a></p>
<p><a href="#_Toc4461">5.2.3 基础功能模块    35</a></p>
<p><a href="#_Toc28158">5.3 功能模块实现    38</a></p>
<p><a href="#_Toc22221">5.3.1 数据封装与提取    38</a></p>
<p><a href="#_Toc10445">5.3.2 用户登录与注册    39</a></p>
<p><a href="#_Toc13752">5.3.3 数据上传模块（上传、秒传）    40</a></p>
<p><a href="#_Toc19878">5.3.4 文件查询模块（文件列表、共享列表、下载榜）    41</a></p>
<p><a href="#_Toc13182">5.3.5 文件处理模块（删除、共享、转存）    42</a></p>
<p><a href="#_Toc31739">5.3.6 数据下载模块    43</a></p>
<p><a href="#_Toc27560">5.3.7 图像预览模块    43</a></p>
<p><a href="#_Toc23461">6 测试    46</a></p>
<p><a href="#_Toc16209">6.1 程序调试    46</a></p>
<p><a href="#_Toc26451">6.2 工具测试    46</a></p>
<p><a href="#_Toc27750">6.2.1 测试的目的和意义    46</a></p>
<p><a href="#_Toc17235">6.2.2 测试框架    46</a></p>
<p><a href="#_Toc19357">6.2.3 测试步骤    46</a></p>
<p><a href="#_Toc11694">6.3 测试用例设计    47</a></p>
<p><a href="#_Toc6990">6.4 测试数据及结果    48</a></p>
<p><a href="#_Toc9634">6.4.1 功能测试数据及结果    48</a></p>
<p><a href="#_Toc25635">6.4.2 性能测试结果    52</a></p>
<p><a href="#_Toc11899">7 总结    53</a></p>
<p><a href="#_Toc14779">致 谢    54</a></p>
<p><a href="#_Toc10261">参 考 文 献    55</a></p>
<p><a href="#_Toc32742">附 录    57</a></p>
<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><h2 id="1-1-课题背景"><a href="#1-1-课题背景" class="headerlink" title="1.1 课题背景"></a>1.1 课题背景</h2><p>由于大数据与云计算技术的普及，互联网已经与人们的生活越来越密切，人们无时无刻不产生着各种数据。同时伴随着直播、短视频、电子相册、数字影院等流媒体的发展，图像数据处理需求正急速增长，传统的物理存储由于共享性差、数据处理缓慢、不易于迁移与恢复等缺点，已渐渐不适用于业务发展需求。而随着云计算的发展，分布式存储的大容量存储、方便移植、快速存储、快速共享、快速备份等各种优点逐渐显现出来，图像存储已渐渐从传统的物理存储方式转变为云存储方式。</p>
<p>基于云存储的图像管理方式是大数据时代数据对象存储的重要方式之一，这种对象存储方式不仅应用于图像管理，更应用于大数据时代影视、文件、用户信息等各种数据存储之上。通过云存储的方式，可对数据随时上传下载，随时分享备份，使数据对象的管理更加方便方便，更加安全。项目尝试采用分布式文件系统对数据对象进行存储，同时采用Nginx服务器实现高并发与负载均衡，对海量用户的请求进行响应，为用户提供可靠、方便的图像管理平台。</p>
<h2 id="1-2-发展趋势"><a href="#1-2-发展趋势" class="headerlink" title="1.2 发展趋势"></a>1.2 发展趋势</h2><p>随着计算机与网络的发展，国内外的图像存储已逐渐实现由传统图像向数字化图像转型。这意味着图像越来越多地以二进制信息保存在计算机中，这样不仅可以长期保存，而且还有方便复制、随意修改、便于传输等优点。而随着大数据与云计算的发展，图像的存储方式逐渐向分布式存储方向发展，使得图像管理的物理存储资源不一定直接连接在本地服务器结点上，而是通过网络与存储结点连接[1]，因此衍生出了分布式文件系统。分布式文件系统即集群文件系统，是指物理存储资源通过网络与结点相连，支持大数量的节点以及PB级的数量存储[2]。因此，分布式文件系统解决了海量图像处理相关的难题。</p>
<p>国内自从2008到2009年间，以华为为代表的一些国内互联网企业开始踏足个人云存储业务，开发出国内第一批网盘产品。2010年以后，出于占领大数据时代入口的目的，国内互联网巨头也纷纷布局云存储业务，腾讯、百度、360、金山、华为等互联网企业也陆续推出了自己的云盘，并开始跑马圈地[3]。这意味着大数据不仅为国内开拓了广阔的市场，也使得国内已逐渐由传统存储向云存储转型[4]。而自从阿里云、腾讯云纷纷崛起，不仅推动了云计算在国内的发展，也在客观上对国内的市场进行了开拓，对云服务提供商们形成了刺激作用。2018年我国数字经济规模达到31.3万亿元，占当年GDP比重达34.8%[5]。</p>
<p>进入5G时代，5G将与AI智能、IoT物联网、Cloud云、Big Data大数据、Edge Cloud边缘云等技术交叉发展，共同构建智能化的基础设施。云已成为新型信息基础设施的重要组成部分，也是面向政企提供数字化服务的主入口，各行各业的数字化发展已经离不开云计算的支撑。中国云市场IaaS、PaaS、SaaS服务模式继续协同发展，市场规模随客户需求的变化而调整[6]。</p>
<p>国外云存储市场2017年为307亿美元，预计到2022年889.1亿美元，CAGR为23.7%[7]。中国云存储市场2017年规模为88.68亿人民币，同比增长71.8%，2018年同比增长率将上升至72.8%[8]，市场规模为158.5亿元人民币。Gartner在2019年的报告中显示：到2024年，40%的企业将实施至少一种混合云存储方式，高于2019年的10%[9]。存储如何更好的服务私有云，成为企业级存储的一个重要课题。除了存储自身的池化、自动化之外，向上提供API，方便私有云管理平台按需驱动存储资源的创建、调整、优化甚至回收，将逐渐成为必备配置。云化对接包含两大块，一是对接开源的云管理平台；二是对接商业的云管理平台，首当其冲的是能够被主流Hypervisor识别，如VMware ESXi、Microsoft Hyper-V[10]。</p>
<h2 id="1-3-项目意义"><a href="#1-3-项目意义" class="headerlink" title="1.3 项目意义"></a>1.3 项目意义</h2><p>如今数据处理需求飞速增长，稍不留神便会跟不上时代发展的步伐。传统的数据管理技术已逐渐不能满足互联网应用所提出的对大数据管理的要求。如何高效地存储和管理海量图像数据，已然成为当今时代的热门探讨话题。</p>
<p>而云存储、云服务、虚拟化等IT热词的不断盛行，已标志着云计算正引领着时代发展的趋势。相较于传统的物理存储，基于云存储的图像管理方式不仅解决了物理硬件易损坏、数据易丢失的问题，而且存储容量可弹性扩展，这意味着基于云存储的图像管理方式不仅扩容方便，而且在存储更新或者服务升级的过程中并不会引起服务中断，造成不必要的损失。</p>
<p>本着开源精神，借鉴传统数据存储与管理的方式，针对大数据与云计算的特点，设计了一套基于云存储的图像管理平台，方便管理图像数据。该平台采用分布式文件系统、缓存数据库、负载均衡等技术，具备弹性伸缩、弹性扩容、高并发等特点，支持海量图像数据的存储与管理。实践证明，该平台具备可行性，可满足空间信息服务的多种需求。</p>
<p>平台设计使用的服务器是基于FastDFS分布式文件系统以及Nginx服务器作为反向代理的Linux服务器，编程语言使用C++语言，图像存储于FastDFS中，数据信息存储于持久性数据库MySQL，Redis作为辅助提高访问效率。客户端使用Qt作为开发工具设计该平台。该平台客户端界面美观方便，功能齐全。数据采用Md5加密算法与Base64数据处理技术，保证数据传输的安全性[11]。该平台是一个简单实用的图像管理平台，具有以下功能：</p>
<p>用户注册与登录，文件的上传与下载，查询与删除，共享与转存。同时针对图像文件具备预览功能。</p>
<p>该平台重在为用户提供一套完整的图像管理与存储服务，解决常规物理存储所带来的数据易丢失难恢复、下载存储不方便、存储空间有限、需随身携带等问题，同时解决普通存储网盘用户并发量低下、数据共享性差等问题。</p>
<h1 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2  需求分析"></a>2  需求分析</h1><h2 id="2-1-功能需求分析"><a href="#2-1-功能需求分析" class="headerlink" title="2.1 功能需求分析"></a>2.1 功能需求分析</h2><h3 id="2-1-1-服务端功能需求分析"><a href="#2-1-1-服务端功能需求分析" class="headerlink" title="2.1.1 服务端功能需求分析"></a>2.1.1 服务端功能需求分析</h3><p>传统的云存储方式将数据直接集中存储于某一台或多台服务器或者硬盘上，这样虽然方便服务端的查询，但是一旦服务器或硬盘损坏，便会造成数据丢失且无法恢复。而且由于数据无法直接共享，导致资源的浪费。如今随着时代的发展，无论软件还是硬件的更新速度越来越快，传统的存储方式由于更新麻烦，数据迁移或备份困难，因此已渐渐被分布式存储所替代。因此，对于服务端，应该满足以下需求：</p>
<p>(1) 功能需求</p>
<p>(a) 为用户提供云存储服务。</p>
<p>(b) 满足用户完备的图像管理功能需求。</p>
<p>(c) 对于用户的数据管理应具备快速响应。</p>
<p>(d) 针对多人访问服务器的情况应具备负载均衡的能力。</p>
<p>(e) 数据应具备快速备份与易迁移的特性，保证用户数据不会因服务器问题而丢失。</p>
<p>(2) 性能需求</p>
<p>(a) 多人同时访问服务器应具备高并发性。</p>
<p>(b) 并发不会带来内存泄露等安全问题。</p>
<p>(c) 对于高频数据访问应快速响应，而低频数据应不过多占用内存资源。</p>
<p>(d) 对于用户的信息例如密码等敏感信息应保证安全性。</p>
<p>(e) 程序执行流程合理，代码思路清晰，不会造成逻辑上的问题。</p>
<p>(3) 可靠、可用性需求</p>
<p>(a) 针对各类错误应有相应的提示或解决方案。</p>
<p>(b) 对于失败操作需要有一套完整的错误码进行失败原因提示与排查。</p>
<h3 id="2-1-2-客户端功能需求分析"><a href="#2-1-2-客户端功能需求分析" class="headerlink" title="2.1.2 客户端功能需求分析"></a>2.1.2 客户端功能需求分析</h3><p>客户端作为用户一系列操作的载体，对用户的使用体验起着最直接的决定作用。因此，客户端不仅需要具备齐全的功能服务，还需具备美观、操作简单、处理流畅等特性，这样才能避免用户的流失。因此，将客户端独立出来进行需求分析。以下从业务需求与性能需求两部分进行分析：</p>
<p>(1) 业务需求</p>
<p>(a) 为用户提供用户身份的载体，因此需包含用户登录与注册界面。</p>
<p>(b) 作为平台的核心，需具备上传图像与下载图像的功能按钮。</p>
<p>(c) 方便数据的交互，因此需具备共享文件的浏览界面。</p>
<p>(d) 提高用户数据获取的速度，为用户提供数据下载量的界面。</p>
<p>(e) 为节约用户空间，需为用户提供图像预览的功能。</p>
<p>(f) 为节约加载速度，可增加缓存机制。</p>
<p>(2) 性能需求</p>
<p>(a) 界面简约又不失美观。</p>
<p>(b) 任何操作不造成客户端界面交互无响应。</p>
<p>(c) 在数据交互的过程中需保证数据的安全性。</p>
<p>(d) 及时对服务端响应异常的情况进行处理。</p>
<h2 id="2-2-可行性分析"><a href="#2-2-可行性分析" class="headerlink" title="2.2 可行性分析"></a>2.2 可行性分析</h2><h3 id="2-2-1-经济可行性分析"><a href="#2-2-1-经济可行性分析" class="headerlink" title="2.2.1 经济可行性分析"></a>2.2.1 经济可行性分析</h3><p>对于该平台软件所需要的一系列相关资料均可以通过互联网和文献材料进行获取采集，由于开源软件的盛行，对于软件所依赖的各种库均可从GitHub网站获取。而国内云计算的发展，无论操作系统还是硬件设备均可从国内云计算公司获取，无需特殊的工具，且开发成本较低，软件程序简单易实现，从经济的角度来看，对于该平台软件的开发经济方面可行。</p>
<h3 id="2-2-2-技术可行性分析"><a href="#2-2-2-技术可行性分析" class="headerlink" title="2.2.2 技术可行性分析"></a>2.2.2 技术可行性分析</h3><p>由于开源软件的盛行，目前主流的分布式文件系统均具备备份与数据迁移功能，同时也能保证数据的安全性。而针对高并发问题，目前Nginx服务器可通过反向代理实现负载均衡，解决了高并发的问题[12]。而随着非关系型数据库的发展，针对高频访问的数据可直接存入非关系型数据库中，这样便显著提高了访问效率。对于客户端与服务端数据如何进行交互，这已经在互联网正式普及之时便已解决，而作为主流可靠的传输方式，HTTP协议已经成为TCP传输的典范。因此，从技术角度来看，通过HTTP协议将客户端数据传输服务端，服务端通过Nginx服务器进行反向代理，监听网络，通过CGI程序将接收到的数据加以处理，数据存储于FastDFS中，信息存储于MySQL，同时Redis加以辅助[13]，这种设计方式是可行的。</p>
<h3 id="2-2-3-运行可行性分析"><a href="#2-2-3-运行可行性分析" class="headerlink" title="2.2.3 运行可行性分析"></a>2.2.3 运行可行性分析</h3><p>运行性是对组织结构最直观的影响，它决定着用户的体验感。主要体现在客户端美观与流畅上。而该平台的设计界面通过Qt设计，简约而不失美观，操作十分简单，功能齐全，由于Qt各种动态库获取方便，因此只需要有相应的动态库文件，在Windows操作系统上安装便可运行。</p>
<h3 id="2-2-4-操作可行性分析"><a href="#2-2-4-操作可行性分析" class="headerlink" title="2.2.4 操作可行性分析"></a>2.2.4 操作可行性分析</h3><p>软件的设计开发分为客户端与服务端两部分，客户端主要所采用的工具是Qt 5.4.1，开发出的应用程序客户端在Windows操作系统的计算机上运行，分为用户界面与文件界面两部分，以UI界面窗口的方式呈现给用户，接收鼠标和键盘的输入，以显示器作为载体输出，符合新时代计算机操作系统用户的使用习惯，方便用户对图像数据进行存储和管理，包括用户的登录、注册以及图像的上传、下载、共享、预览、转存、秒传、删除等一系列操作，简单而且容易上手。而服务端作为用户数据的载体，必须保证数据的安全性与可靠性，因此服务端的操作均由服务端代码进行处理，不直接授予用户权限。所以此软件在操作上是可行的。</p>
<p>综上所述，该平台软件的开发与设计从经济、技术、运行、操作等各个方面完全可行。</p>
<h1 id="3-技术支持"><a href="#3-技术支持" class="headerlink" title="3  技术支持"></a>3  技术支持</h1><h2 id="3-1-FastDFS分布式文件系统"><a href="#3-1-FastDFS分布式文件系统" class="headerlink" title="3.1 FastDFS分布式文件系统"></a>3.1 FastDFS分布式文件系统</h2><p>传统的网络存储系统通过集中的存储方式将全部数据存放到服务器上[14]，因此服务器的性能成为数据安全性与可靠性的关键。而针对以数据为根本的大数据时代，显然传统的网络存储方式已不能满足时代的要求。因此，衍生出了分布式文件系统。</p>
<p>分布式文件系统可以简单理解为将对象数据离散地分布存储到许多台独立的存储设备上。分布式文件系统存储方式采用弹性扩展的结构，通过多态弹性服务器来分担数据存储的负荷，通过追踪器服务器来定位存储的结点，这种方式不仅提高了系统的执行效率，而且由于其本身易于扩展的特性，显著提高了系统的实用性与可靠性。</p>
<p>FastDFS分布式文件系统是一款轻量级开源项目，由C语言实现，支持Uinx、Linux等操作系统，为互联网应用开发定制。可用于管理不局限于图像的各种数据，包括对象存储、数据同步、上传、下载、删除等一系列操作[15]，解决了大空间存储和负载均衡等问题，追求高性能和弹性扩展。</p>
<p>FastDFS分布式文件系统分为三部分：追踪器Tracker，存储结点Storage，客户端Client。客户端Client和存储结点Storage请求连接追踪器Tracker，Storage主动向Tracker报告空闲存储空间、数据同步状况、上传下载次数等信息。每次启动时存储结点会启动单线程实现对追踪器的连接与汇报信息。FastDFS可划分多个组，每组所包含的存储结点由追踪器获取。整体架构如下图：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps4.png" alt="img"></p>
<p>图3-1 FastDFS分布式文件系统结构</p>
<p>FastDFS集群可分为追踪器集群与存储结点集群，追踪器集群之间是平等的关系，不存在单点故障的情况，Client访问追踪器通过轮回的方式请求。存储结点集群通过分组的方式集群，存储容量为每个存储结点容量之和[16]。</p>
<p>FastDFS集群的扩容分为横向扩容与纵向扩容，横向扩容可通过添加组的方式进行空间扩充，而纵向扩容用来实现备份，一组内的最大容量为当前组内存储结点中空间最小的服务器容量。集群整体结构如下：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps5.png" alt="img"></p>
<p>图3-2 FastDFS分布式文件系统集群</p>
<h2 id="3-2-Nginx服务器反向代理与负载均衡"><a href="#3-2-Nginx服务器反向代理与负载均衡" class="headerlink" title="3.2 Nginx服务器反向代理与负载均衡"></a>3.2 Nginx服务器反向代理与负载均衡</h2><p>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件代理服务器，采用C进行编写。不仅可以作为HTTP服务器相应Web请求，同时还可以作为反向代理服务器。其特点是占有内存少，并发能力强。Nginx 既可以直接支持Rails和PHP程序，也可以支持作为HTTP代理服务对外服务[17]。</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps6.png" alt="img"></p>
<p>图3-3 反向代理服务器原理</p>
<p>Nginx三个核心功能是静态服务器、反向代理和负载均衡[18]。这三个功能通过配置文件来实现，所有配置选项代码大致分为以下几部分：</p>
<p>main                                # 全局配置</p>
<p>events {                            # Nginx工作模式配置</p>
<p>}</p>
<p>HTTP {                                # HTTP设置</p>
<p>​    ….</p>
<p>​    server {                        # 服务器主机配置</p>
<p>​        ….</p>
<p>​        location {                    # 路由配置</p>
<p>​            ….</p>
<p>​        }</p>
<p>​        location path {</p>
<p>​            ….</p>
<p>​        }</p>
<p>​        location otherpath {</p>
<p>​            ….</p>
<p>​        }</p>
<p>​    }</p>
<p>​    server {</p>
<p>​        ….</p>
<p>​        location {</p>
<p>​            ….</p>
<p>​        }</p>
<p>​    }</p>
<p>​    upstream name {                    # 负载均衡配置</p>
<p>​        ….</p>
<p>​    }</p>
<p>}</p>
<p>如上述配置文件所示，主要由6个部分组成：</p>
<p>(a) main：用于全局信息的配置。</p>
<p>(b) events：用于Nginx工作模式的配置。</p>
<p>(c) HTTP：用于进行HTTP协议信息的一些配置。</p>
<p>(d) server：用于进行服务器访问信息的配置。</p>
<p>(e) location：用于进行访问路由的配置。</p>
<p>(f) upstream：用于进行负载均衡的配置。</p>
<p>upstream模块主要负责负载均衡的配置[19]。简单的配置方式如下：</p>
<p>upstream name {</p>
<p>​    ip_hash;</p>
<p>​    server 192.168.1.100:8000;</p>
<p>​    server 192.168.1.100:8001 down;</p>
<p>​    server 192.168.1.100:8002 max_fails=3;</p>
<p>​    server 192.168.1.100:8003 fail_timeout=20s;</p>
<p>​    server 192.168.1.100:8004 max_fails=3 fail_timeout=20s;</p>
<p>}</p>
<p>核心配置信息如下：</p>
<p>(a) ip_hash：指定请求调度算法。</p>
<p>(b) server host:port：分发服务器的列表配置。</p>
<p>(c) down：表示该主机暂停服务。</p>
<p>(d) max_fails：表示失败最大次数，超过失败最大次数暂停服务。</p>
<p>(e) fail_timeout：表示请求失败，指定的时间后重新请求。</p>
<h2 id="3-3-Qt客户端GUI界面设计"><a href="#3-3-Qt客户端GUI界面设计" class="headerlink" title="3.3 Qt客户端GUI界面设计"></a>3.3 Qt客户端GUI界面设计</h2><p>Qt作为一款开源的跨平台图形界面开发框架，既可以对GUI进行设计，同时由于其是基于C++的面向对象的框架，因此同样可以作为C++编译软件编写程序。Qt类库中的类大致分为两种类型：一种是独立的不从任何类集成的类；另一种直接继承自Qt类。</p>
<p>独立的类通常在Qt类库中用来实现独立的功能。继承自Qt的类主要分为QEvent类和QObject类。QEvent类是所有QT事件响应类的基类，QObject类是所有应用组件的基类[20]。</p>
<p>QWidget类是组件容器，所有能结合在一起的组件均继承自从该类。而QWidget类则继承自QObject基类[21]。</p>
<p>信号和槽是Qt引进的一种处理机制，信号可以被理解为一个对象发出的事件请求，槽是处理信号的函数。</p>
<p>信号和槽能完成回调函数的所有功能，并且信号和槽机制是类型安全的，而且还能完成其他许多复杂的功能。</p>
<p>信号和槽可以是单一或者多对多的关系。一个信号可以被连接到多个槽，一个槽也可以响应多个信号，此外，信号之间也可以被连接[22]。</p>
<h1 id="4-设计方案"><a href="#4-设计方案" class="headerlink" title="4  设计方案"></a>4  设计方案</h1><h2 id="4-1-设计原理"><a href="#4-1-设计原理" class="headerlink" title="4.1 设计原理"></a>4.1 设计原理</h2><p>该项目的设计采用C/S结构，即客户端/服务端模式。首先，客户端响应用户的请求，将用户的请求封装成Json格式，然后通过HTTP协议发送给服务端。对于密码等敏感信息可通过Md5加密后封装成Json格式发送[23]。在整个数据交互的过程中，客户端始终保证用户操作的合理性。</p>
<p>服务端通过指定端口接收到数据后，首先由Nginx服务器进行反向代理，将数据转发给Nginx配置文件中记录的Web服务器IP。Web服务器接收到数据后根据当前数据HTTP请求头的类型将不同类型数据，通过配置文件中对应的端口转发给服务器相应的CGI程序进行处理，端口对应的CGI程序首先对数据进行拆解，获取数据具体的请求，然后进行处理，并将处理结果转发给客户端。</p>
<p>对于数据对象本身，CGI程序通过分布式文件系统追踪器对存储结点的数据进行操作，对于信息类数据，CGI程序则将对持久性数据库MySQL进行一系列操作，同时缓存数据库Redis加以辅助提高效率。</p>
<p>整体结构如下：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps7.png" alt="img"></p>
<p>图4-1 总体设计框架</p>
<h2 id="4-2-总体设计方案"><a href="#4-2-总体设计方案" class="headerlink" title="4.2 总体设计方案"></a>4.2 总体设计方案</h2><p>该平台总体包括客户端与服务端两部分。二者之间数据以Json格式通过HTTP协议进行交互。同时对于特殊数据例如密码需进行Md5加密，然后封装Json格式传输。</p>
<p>客户端主要分为界面设计与功能模块两部分。界面设计分为用户界面和文件界面，其中用户界面包括登录界面、注册界面、设置界面；文件界面包括我的文件、共享文件、下载榜、传输列表。功能模块包括基础功能模块与特殊功能模块，其中基础功能统一封装在一个基础功能类中，用于实现包括数据封装与解析、HTTP传输、读取配置文件、加密等功能；特殊功能模块作为工具类，包括实现上传下载任务与进度、图像预览等功能。</p>
<p>服务端主要包括服务端框架搭建与功能模块两部分。服务端框架包括Nginx与负载均衡、MySQL数据库与Redis缓存数据库、分布式文件系统的搭建。功能模块用于实现包括用户注册与登录、文件上传与秒传、文件列表查询、文件共享与转存、文件删除、文件下载等功能[24]。</p>
<p>具体整体设计方案如下图：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps8.png" alt="img"></p>
<p>图4-2 总体方案结构</p>
<h3 id="4-2-1-客户端设计方案"><a href="#4-2-1-客户端设计方案" class="headerlink" title="4.2.1 客户端设计方案"></a>4.2.1 客户端设计方案</h3><p>由于客户端是用户直接进行数据交互的载体，因此客户端在达到美观简洁的同时需要有平台完整的功能。根据平台的需求，客户端采用Qt编译器进行客户端代码的编写与界面的设计。作为图像文件管理平台，需要为用户提供文件界面供用户进行管理操作；同时为方便用户信息的验证，客户端还需用户界面获取用户的信息。因此客户端包括用户界面与文件界面。</p>
<p>用户界面通过一个主QWidget，包含三个子QWidget，分别作为登录、注册、设置三个子界面，通过不同的按钮切换不同的子界面。登录注册用于用户的身份校验，设置用于设置代理服务器服务器的端口号和IP用于数据交互。</p>
<p>通过登录界面信息校验成功后会关闭用户界面，同时打开文件界面。文件界面包括头部和信息部两部分组成，头部包含多个文件功能切换按钮，信息部界面主要用于对文件信息的展示，因此在设计上，头部作为公共部分只需一个QWidget派生类，而信息部分展示界面通过不同的QWidget派生类与头部拼接成不同的文件界面。</p>
<h3 id="4-2-2-服务端设计方案"><a href="#4-2-2-服务端设计方案" class="headerlink" title="4.2.2 服务端设计方案"></a>4.2.2 服务端设计方案</h3><p>对于服务端，需要保障数据的高并发与流畅性，因此通过一个Nginx服务器配置使得客户端直接连接的服务器具备反向代理与负载均衡的功能。由于Nginx服务器不能直接处理动态数据，因此Web服务器需要借助CGI程序来处理动态响应。处理不同事件的CGI程序绑定Web服务器不同的端口，通过HTTP协议请求头来确定对应端口，供CGI程序处理。对于数据本身，CGI程序通过分布式文件系统提供的API对分布式文件系统进行操作。同时对于信息类数据存于MySQL，将访问量大的数据插入非关系型数据库，以便下次查找直接从非关系型数据库中提取数据。</p>
<p>对于分布式文件系统采用FastDFS，需要配置追踪器与存储节点，使得服务器构建成一个集群。同时对于每一台存储节点服务器，通过Storage与Nginx绑定，使得存储于存储节点服务器的数据可通过Url的方式直接访问，而不需重新下载。这样只需将文件对应的Url存储于数据库中，下载或者访问时直接通过访问数据库中的Url即可，不需再从存储节点中下载后发送给客户端，显著地提高了下载与访问效率。</p>
<p>对于数据库采用MySQL进行数据库设计以及增删改查，根据需求需建五张表，用户表用于用户登录的确认，文件表作为文件信息的保存，共享文件表用于共享文件信息的获取，用户文件表用于用户文件信息的获取，用户文件数量表用于辅助用户访问文件界面时文件的展示，同时为扩展功能提供预留空位。</p>
<p>缓存数据库通过Redis对访问频繁的数据进行存储。每次获取信息先查询Redis，如果没有需要的信息则访问MySQL，同时将查询数据存入Redis，提高数据获取效率。</p>
<h2 id="4-3-功能模块方案"><a href="#4-3-功能模块方案" class="headerlink" title="4.3 功能模块方案"></a>4.3 功能模块方案</h2><h3 id="4-3-1-用户注册与登录"><a href="#4-3-1-用户注册与登录" class="headerlink" title="4.3.1 用户注册与登录"></a>4.3.1 用户注册与登录</h3><p>对于用户模块可按功能具体划分为注册模块与登录模块。二者客户端为通过继承用户界面而派生的两个子界面。服务端主要对数据库进行操作。</p>
<p>注册的客户端逻辑为：用户通过进入注册界面的填写注册信息，客户端代码获取数据后进行逻辑判断，如果用户名或昵称不符合格式要求，则向客户端反馈用户名或昵称格式不符合要求的消息；如果密码不符合格式要求或两次输入密码不一致，则向客户端反馈密码相关操作失败的消息；如果电话或者邮箱不符合规范，则向客户端反馈电话或者邮箱格式不规范的消息。如果用户填写的注册信息均通过客户端校验格式的代码验证，则首先用Md5对密码加密，然后封装成Json格式以HTTP协议发送给服务端。如果服务端长时间未响应则反馈注册失败信息。Web服务端通过请求头为reg交给相应端口的CGI程序。服务端CGI程序的逻辑为：首先将Json数据提取出来，然后查询数据库用户表与通过Json解析的用户名进行比对，如果用户表存在该用户名，则反馈用户名重复的状态码，否则将该注册用户信息插入用户表中，反馈注册成功的状态码。客户端接收到状态码后，通过比对，如果不为成功状态码则根据状态码类型向用户反馈注册失败的原因，并提示用户重新注册；否则客户端会提示用户注册成功，同时会跳转至用户登录的界面，待用户进行登录操作。</p>
<p>注册流程如下：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps9.png" alt="img"></p>
<p>图4-3 用户注册流程图</p>
<p>登录的客户端逻辑为用户通过登录界面填写用户名与密码，如果选择记住密码则登录成功后会把用户以及用户密码的Md5值保存到缓存配置文件中[25]。用户通过登录界面填写登录信息，点击登录按钮，客户端会通过信号槽将登录信息向服务端发送，Web服务端根据请求头为login交给相应端口的CGI程序。服务端CGI程序的逻辑为首先将Json数据提取出来，然后查询数据库用户表与解析后的用户名与密码进行比对，如果存在该用户名，并且密码Md5值跟数据库中密码存储信息一致则反馈注册成功状态码，否则反馈根据情况反馈登录失败状态码。客户端接收到状态码后，如果不为登录成功状态码则提示用户登录失败，否则客户端跳转至我的文件界面。</p>
<p>登录流程如下：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps10.png" alt="img"></p>
<p>图4-4 用户登录流程图</p>
<h3 id="4-3-2-文件列表查询"><a href="#4-3-2-文件列表查询" class="headerlink" title="4.3.2 文件列表查询"></a>4.3.2 文件列表查询</h3><p>当用户进入文件界面后，客户端需要保存当前用户的所有文件信息，因此会向服务端发起当前用户的文件查询请求。当服务端通过请求头myfile将用户信息交给相应端口的CGI程序。CGI程序逻辑为通过以用户名查询数据库user_file_list表将所有文件信息传给客户端，客户端获取到所有信息后，通过QWigitList将文件信息按图标的形式排列到界面，同时在排列过程中对于文件为图像类型的文件进行判断，如果该图像文件在缓存中有缩略图，则显示缩略图，否则显示默认图片。</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps11.png" alt="img"></p>
<p>图4-5 文件列表查询流程图</p>
<h3 id="4-3-3-数据上传与秒传"><a href="#4-3-3-数据上传与秒传" class="headerlink" title="4.3.3 数据上传与秒传"></a>4.3.3 数据上传与秒传</h3><p>当用户进行上传操作时，首先是采取秒传的方式，将待上传文件的信息通过Md5加密，然后封装好数据后通过HTTP传输，服务端通过Md5请求头交给负责秒传的CGI程序。CGI程序通过文件信息表中Md5值的比较，判断当前文件信息是否存在于数据库中，如果存在则将该文件信息与该用户通过user_file_list表进行关联，否则返回数据库无该文件信息的状态码。客户端接受到状态码后进行判断，成功则不需再进行上传操作，即实现了秒传，否则需要进一步进行上传操作。</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps12.png" alt="img"></p>
<p>图4-6 数据秒传流程图</p>
<p>上传过程需要客户端维护一个上传队列。客户端选择文件路径后，每次对于确定无法秒传需要上传的文件信息假如到上传队列中。上传时每次从队列中提取队首元素进行请求，上传完成时将该任务从队列中移除。该过程客户端会时时跟进上传进度，并且将进度按进度条的形式更新在数据传输列表界面。</p>
<p>开始上传时，客户端获取到该文件后将文件以二进制流的形式进行HTTP传输。服务端通过请求头upload将用户信息与数据交给相应端口的CGI程序。CGI程序逻辑为首先通过数据库file_info表判断该文件是否存在，若存在则判断该用户是否拥有，是则反馈已拥有状态码，负责对user_file_list与user_file_count表进行修改操作。否则会通过fork创建子进程，子进程将数据上传到分布式文件系统，通过fdfs_upload_file的API将提取出的二进制流文件上传到分布式文件系统，同时获取到分布式文件系统反馈的文件id，让id传给父进程。父进程用于处理数据信息，将文件生成后的信息插入到file_info表中，同时将用户与文件但关联信息插入到user_file_list中，同时对user_file_count表进行更新。文件信息处理好后，给用户反馈成功状态码。在父子进程的过程中任意一步出现问题均反馈失败状态码。客户端接收到状态码后，通过状态码比对，如果是成功状态码则向用户反馈上传成功的信息，否则给用户反馈上传失败的信息。</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps13.png" alt="img"></p>
<p>图4-7 数据上传流程图</p>
<h3 id="4-3-4-文件删除"><a href="#4-3-4-文件删除" class="headerlink" title="4.3.4 文件删除"></a>4.3.4 文件删除</h3><p>当用户请求删除操作时，客户端首先需要进行判断用户请求的文件拥有者是否为该用户，如果不是则提示文件不属于该用户的错误信息；否则向服务端发起请求。服务端接收到请求后，通过请求头dealfile或者dealsharefile将用户信息与数据交给相应端口用于文件操作的CGI程序，CGI程序进行处理。CGI程序的逻辑为首先进行数据库查询，首先对user_file_count表进行减一操作，对user_file_list中该用户与该文件的关联进行删除。最后需要通过file_info表的数量属性进行判断，如果大于1，则将该属性减1，否则将该信息从数据库file_info表中删除。同时子进程需通过分布式文件系统提供的fdfs_delete_file相关API对通过该文件Id删除分布式文件系统中该文件的数据。一切成功后向客户端反馈状态码。客户端收到反馈后刷新界面。</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps14.png" alt="img"></p>
<p>图4-8 文件删除流程图</p>
<h3 id="4-3-5-文件共享与共享列表查询"><a href="#4-3-5-文件共享与共享列表查询" class="headerlink" title="4.3.5 文件共享与共享列表查询"></a>4.3.5 文件共享与共享列表查询</h3><p>当用户切换到共享文件界面时，会向服务端发起共享文件列表获取的请求，通过share_file_list表进行共享文件信息的查询，然后将查询到的列表信息发送给客户端。客户端接收到数据后对界面按照图标显示的方式进行刷新。对下载榜界面，服务端会将文件按下载量进行排序，然后发给客户端，客户端通过信息列表的形式进行显示。</p>
<p>当用户发起共享或者取消共享操作后，客户端逻辑首先进行判断用户发起的请求文件是否属于该用户，不是的话反馈错误信息；是的话需要根据该文件信息判断该文件分享状态，如果已是该状态则不需操作，否则会向服务端发起请求。当服务端接收到请求后，通过请求头dealfile或者dealsharefile将用户信息与数据交给相应端口用于文件操作的CGI程序，CGI程序的逻辑为首先提取数据，对数据库share_file_list表进行插入，然后对file_info表等文件相关的表进行更新。最后反馈状态码。</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps15.png" alt="img"></p>
<p>图4-9 文件共享流程图</p>
<h3 id="4-3-6-数据下载"><a href="#4-3-6-数据下载" class="headerlink" title="4.3.6 数据下载"></a>4.3.6 数据下载</h3><p>下载模块首先需保证服务端存储结点Storage与Web处理服务器Nginx相关联，关联后对于存储结点上的数据可直接通过Url进行下载。客户端维护一个下载队列。而下载的流程主要是用户发起下载请求后，客户端会向服务器请求该文件Url信息，收到文件Url后，客户端将下载信息插入下载队列。客户端每次执行队首任务，根据下载信息向相应Url进行Get请求，请求成功后便开始数据下载，同时对于下载进度通过进度条时时更新在数据传输列表界面上。当下载完成时，将该任务从下载队列中移除，然后进行下一个文件下载。</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps16.png" alt="img"></p>
<p>图4-10 文件下载流程图</p>
<h3 id="4-3-7-图像预览"><a href="#4-3-7-图像预览" class="headerlink" title="4.3.7 图像预览"></a>4.3.7 图像预览</h3><p>由于用户进入文件界面后，客户端代码会将当前缓存中的文件数据保存起来，因此当用户点击预览按钮时，首先客户端会判断该文件信息的类型，如果为图像文件方可进行预览操作，否则反馈失败信息。客户端根据当前保存的文件信息进行Url获取，同时通过HTTP协议对该Url进行请求，获取到响应后客户端会通过QLable进行图像的绘制，为用户呈现该图像的完整状态。同时客户端会将该图像文件缓存起来，以便下次再次访问该图像文件时直接对缓存中的数据进行绘制，而不需在向服务器进行请求。</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps17.png" alt="img"></p>
<p>图4-11 图像预览流程图</p>
<h2 id="4-4-流程关系"><a href="#4-4-流程关系" class="headerlink" title="4.4 流程关系"></a>4.4 流程关系</h2><p>本项目的流程并不是很复杂，但是由于涉及到的东西较多，因此整个项目流程的清晰度决定了项目实现的难易。</p>
<h3 id="4-4-1-客户端流程"><a href="#4-4-1-客户端流程" class="headerlink" title="4.4.1 客户端流程"></a>4.4.1 客户端流程</h3><p>客户端流程分为用户界面流程与文件界面流程两部分。用户通过可执行文件首先加载的是用户界面，通过用户界面的设置栏设置反向代理服务器的IP与端口号，客户端程序保存IP与端口号，之后将所有相关数据发送对于发现代理服务器IP。设置完成后，用户可选择性通过注册栏发送注册信息给服务端，收到服务端注册成功的反馈后跳转至登录界面。用户通过登录界面填写用户名及密码，点击登录后，获取服务端的反馈信息，校验成功则跳转文件界面，否则提示登录失败。</p>
<p>进入文件界面后，默认在我的文件界面，客户端会向服务端发送当前用户信息以及获取当前用户拥有文件信息，得到服务端反馈的信息后，客户端代码将其文件信息绘制到UI界面上，同时如果本地缓存中有相应文件的缓存缩略图，则将默认显示图像替换为缩略图图像，实现预览效果。</p>
<p>文件界面默认主界面有上传按钮，点击后可选择指定文件夹下的一个或多个图像文件进行上传操作，然后会切换到文件界面的传输列表界面。文件主界面空白域右键点击事件包括文件重新排序与上传等操作，其中上传操作与点击上传按钮事件一样。文件默认展示文件类型图像，如果该文件为图像文件且缓存中有该文件的缩略图，则以缩略图的方式显示。文件右键点击事件包括下载、共享、预览、删除、属性等点击事件，对应下载、共享、预览、删除、属性操作。</p>
<p>文件界面包含主界面、共享文件界面、下载榜界面、传输列表界面四部分，在UI头部有相应切换事件响应的按钮。</p>
<p>共享文件界面与下载榜界面的流程与主界面的流程相似，唯一不同的是向服务端请求的是共享文件信息而不是用户文件信息。共享文件界面与下载榜界面的不同在于排列方式不同以及文件信息显示方式不同，共享文件界面的排列方式为按共享时间顺序排列，同时以图标的形势显示文件；而下载榜是以文件下载量的方式进行排序，以详细信息的方式进行显示。</p>
<p>传输列表包含上传列表、下载列表、传输记录三部分，对应上传进度、下载进度、上传下载记录三部分的展示。</p>
<p>主界面同时包含切换用户按钮，点击后跳转登录界面。</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps18.png" alt="img"></p>
<p>图4-12 客户端总体流程图</p>
<h3 id="4-4-2-服务端流程"><a href="#4-4-2-服务端流程" class="headerlink" title="4.4.2 服务端流程"></a>4.4.2 服务端流程</h3><p>服务端整体的流程包括数据转发、数据提取、分布式文件系统操作、数据库操作四部分。</p>
<p>首先数据转发部分主要流程是反向代理服务器接收到数据后根据并发权重将数据转发给Web服务器，Web服务器通过配置文件与HTTP请求头信息进行类型解析，根据不同的类型将数据发送给不同的端口所绑定的CGI程序。</p>
<p>数据提取主要为服务端公共代码的任务，将Json数据中的信息提取出来，然后供CGI程序进行响应一系列执行操作。</p>
<p>分布式文件系统通过FastDFS提供的API对数据对象进行上传、下载、删除操作。在此之前需要服务器先搭建好分布式文件系统的集群。由于FastDFS为C语言所写，因此安装后的API直接可以用到服务端C++程序中。</p>
<p>数据库操作主要分为两部分，一部分是通过MySQL进行数据的增删改查，另一部分是对访问量较多的数据储存于Redis[26]。所有程序在对数据库进行操作时，首先会从缓存数据库Redis中查询，如果缓存数据库中已有该数据，则直接获取，否则会从MySQL中进行查询，然后在处理数据的过程中将数据同时插入缓存数据库中。</p>
<p>服务端从功能部分大致分为用户登录与注册、文件上传或删除、文件共享与转存、文件下载与预览几部分。这些功能模块均首先通过数据转发后进行数据提取，然后进行各类型的一系列操作。</p>
<p>用户登录与注册部分主要为数据库操作；文件上传或删除包括分布式文件系统操作与数据库操作两部分；文件的共享与转存操作并未涉及到分布式文件系统操作，主要为数据库操作。</p>
<p>文件下载与预览部分有两种实现方式，第一种也是常规的方式包括分布式文件操作与数据库操作，但这样每次会造成效率的低下，因此通过第三方软件将存储结点Storage与Nginx连接，使得存储结点的数据可直接以Url的方式进行获取，这样只需要进行数据库操作即可，即将Url保存至数据库中，而数据的获取直接通过Url便可下载，而不需经过分布式文件系统追踪器等一系列过程。</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps19.png" alt="img"></p>
<p>图4-13 服务端总体流程图</p>
<h1 id="5-具体实现"><a href="#5-具体实现" class="headerlink" title="5  具体实现"></a>5  具体实现</h1><h2 id="5-1-服务端架构实现"><a href="#5-1-服务端架构实现" class="headerlink" title="5.1 服务端架构实现"></a>5.1 服务端架构实现</h2><h3 id="5-1-1-负载均衡"><a href="#5-1-1-负载均衡" class="headerlink" title="5.1.1 负载均衡"></a>5.1.1 负载均衡</h3><p>Nginx负载均衡是在反向代理的基础上完成的，首先用户通过浏览器或者客户端连接到Nginx反向代理服务器，Nginx通过配置文件中的server模块找到server_name映射的域名，通过proxy_pass+Url找到upstream模块，然后访问server相应的地址。upstream模块中可设置多个IP，同时赋予权重，每次用户访问服务器时，Nginx都会按权重将用户请求分配到upstream模块中对应的IP，这样便实现了负载均衡。</p>
<p>负载均衡通过配置Nginx.conf实现[27]。具体负载均衡部分配置样例如下：</p>
<p>upstream test.com{</p>
<p>server 39.96.209.253:80; #服务器1</p>
<p>server 172.17.49.222:80; #服务器2</p>
<p>}</p>
<p>server{</p>
<p>listen 80;</p>
<p>server_name localhost;</p>
<p>Location /{</p>
<p>proxy_pass HTTP://test.com;</p>
<p>}</p>
<p>}</p>
<h3 id="5-1-2-数据库设计"><a href="#5-1-2-数据库设计" class="headerlink" title="5.1.2 数据库设计"></a>5.1.2 数据库设计</h3><p>数据库主要用于存储用户与文件的信息，数据信息存于MySQL中。数据库表主要分为五张表，具体表结构如下图所示：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps20.jpg" alt="img"> </p>
<p>图5-1 数据库表结构</p>
<p>user表用于储存用户相关信息。当用户注册时将信息插入该表中；当用户登录时通过查询该表进行用户身份校验，校验成功方能进入文件界面对图像进行管理。user表中包含name、nickname、password、phone、createtime、email六个栏位，其中name作为用户名，password作为密码，用于登录时校验，其余作为用户信息储存栏位。</p>
<p>表5-1 user表</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>列名</th>
<th>数据类型</th>
<th>长度</th>
<th>主键</th>
<th>允许空</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>name</td>
<td>varchar</td>
<td>20</td>
<td>是</td>
<td>否</td>
<td>用户id</td>
</tr>
<tr>
<td>2</td>
<td>nickname</td>
<td>varchar</td>
<td>20</td>
<td></td>
<td>是</td>
<td>用户昵称</td>
</tr>
<tr>
<td>3</td>
<td>password</td>
<td>varchar</td>
<td>65</td>
<td></td>
<td>是</td>
<td>用户密码</td>
</tr>
<tr>
<td>4</td>
<td>phone</td>
<td>varchar</td>
<td>12</td>
<td></td>
<td>是</td>
<td>电话</td>
</tr>
<tr>
<td>5</td>
<td>createtime</td>
<td>datetime</td>
<td>0</td>
<td></td>
<td>是</td>
<td>注册时间</td>
</tr>
<tr>
<td>6</td>
<td>email</td>
<td>varchar</td>
<td>30</td>
<td></td>
<td>是</td>
<td>邮箱</td>
</tr>
</tbody>
</table>
<p>file_info表用于储存文件信息。该表包括md5、file_id、url、size、type、count六个栏位。md5作为文件的唯一标识，也可认为是文件的唯一id标识；file_id用于储存文件在分布式文件系统中对应的id即文件名，可通过该id从分布式文件系统中下载文件；url用于储存该文件的获取网址；size用于记录文件的大小；type代表该文件类型；count用于统计有多少用户拥有该文件，主要用于文件删除。</p>
<p>表5-2 file_info表</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>列名</th>
<th>数据类型</th>
<th>长度</th>
<th>主键</th>
<th>允许空</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>md5</td>
<td>varchar</td>
<td>65</td>
<td>是</td>
<td>否</td>
<td>文件id</td>
</tr>
<tr>
<td>2</td>
<td>file_id</td>
<td>varchar</td>
<td>100</td>
<td></td>
<td>是</td>
<td>对象存储id</td>
</tr>
<tr>
<td>3</td>
<td>url</td>
<td>varchar</td>
<td>100</td>
<td></td>
<td>是</td>
<td>文件url</td>
</tr>
<tr>
<td>4</td>
<td>size</td>
<td>bigint</td>
<td>20</td>
<td></td>
<td>是</td>
<td>文件大小</td>
</tr>
<tr>
<td>5</td>
<td>type</td>
<td>varchar</td>
<td>10</td>
<td></td>
<td>是</td>
<td>文件类型</td>
</tr>
<tr>
<td>6</td>
<td>count</td>
<td>int</td>
<td>11</td>
<td></td>
<td>是</td>
<td>拥有者数量</td>
</tr>
</tbody>
</table>
<p>user_file_list作为用户与文件的关系桥梁而存在。表共包含user、md5、createtime、filename、shared_status、pv六栏。user代表用户id；md5代表文件id；createtime代表用户拥有该文件的时间；filename代表用户拥有该文件时的文件名；share_status用于表示该文件的分享状态；pv表示该用户对该文件的下载次数。</p>
<p>表5-3 user_file_list表</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>列名</th>
<th>数据类型</th>
<th>长度</th>
<th>主键</th>
<th>允许空</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>user</td>
<td>varchar</td>
<td>20</td>
<td></td>
<td>否</td>
<td>用户id</td>
</tr>
<tr>
<td>2</td>
<td>md5</td>
<td>varchar</td>
<td>65</td>
<td></td>
<td>否</td>
<td>文件id</td>
</tr>
<tr>
<td>3</td>
<td>createtime</td>
<td>datetime</td>
<td>0</td>
<td></td>
<td>是</td>
<td>关联时间</td>
</tr>
<tr>
<td>4</td>
<td>filename</td>
<td>varchar</td>
<td>100</td>
<td></td>
<td>是</td>
<td>文件名称</td>
</tr>
<tr>
<td>5</td>
<td>shared_status</td>
<td>int</td>
<td>11</td>
<td></td>
<td>是</td>
<td>分享状态</td>
</tr>
<tr>
<td>6</td>
<td>pv</td>
<td>int</td>
<td>11</td>
<td></td>
<td>是</td>
<td>下载量</td>
</tr>
</tbody>
</table>
<p>share_file_list表记录共享文件的信息。包括user、md5、createtime、filename、pv五个栏位。user代表该文件的分享者；md5代表该文件id；createtime代表分享时间；filename代表该文件被分享时的文件名；pv代表该文件全部的下载次数。</p>
<p>表5-4 share_file_list表</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>列名</th>
<th>数据类型</th>
<th>长度</th>
<th>主键</th>
<th>允许空</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>user</td>
<td>varchar</td>
<td>65</td>
<td></td>
<td>否</td>
<td>分享用户id</td>
</tr>
<tr>
<td>2</td>
<td>md5</td>
<td>varchar</td>
<td>65</td>
<td></td>
<td>否</td>
<td>分享文件id</td>
</tr>
<tr>
<td>3</td>
<td>createtime</td>
<td>datetime</td>
<td>0</td>
<td></td>
<td>是</td>
<td>分享时间</td>
</tr>
<tr>
<td>4</td>
<td>filename</td>
<td>varchar</td>
<td>100</td>
<td></td>
<td>是</td>
<td>文件名称</td>
</tr>
<tr>
<td>5</td>
<td>pv</td>
<td>int</td>
<td>11</td>
<td></td>
<td>是</td>
<td>下载量</td>
</tr>
</tbody>
</table>
<p>user_file_count表主要记录用户当前拥有多少个文件。其主要用于文件列表获取前访问，如果文件列表数量庞大，需先访问用户文件数目，再分批访问。该表共user、count两个栏位。user代表用户id；count代表该用户拥有文件数量。</p>
<p>表5-5 user_file_count表</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>列名</th>
<th>数据类型</th>
<th>长度</th>
<th>主键</th>
<th>允许空</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>user</td>
<td>varchar</td>
<td>20</td>
<td>是</td>
<td>否</td>
<td>用户id</td>
</tr>
<tr>
<td>2</td>
<td>count</td>
<td>int</td>
<td>11</td>
<td></td>
<td>是</td>
<td>用户文件数</td>
</tr>
</tbody>
</table>
<h3 id="5-1-3-文件对象存储"><a href="#5-1-3-文件对象存储" class="headerlink" title="5.1.3 文件对象存储"></a>5.1.3 文件对象存储</h3><p>数据对象本身存储与分布式文件系统中。在服务器上安装好FastDFS分布式文件系统后，需要修改配置文件。由于FastDFS分布式文件系统包括追踪器、存储节点、客户端三部分，因此需要修改tracker.conf、storage.conf、client.conf三个配置文件。</p>
<p>先配置Tracker，再添加一个Storage，每添加添加一个Storage，实际上是Storage连接Tracker，Tracker必须存在，否则Storage无法加进来，Client主要用于测试上传、下载文件。</p>
<p>假如有3台以上的服务器或者虚拟机，一台用来作为Tracker、一台用来作为Client、其他多台用来作为Storage，不过前提需要保证这些服务器之间的网络均可以互相PING通。如果并没有足够多的设备，一台服务器可以同时作为Tracker、Storage、Client使用。</p>
<p>首先是tracker.conf的配置，追踪器服务器需要修改，其他服务器可以不用配置。bind_addr需要修改为追踪器服务器所在的IP，port修改为绑定的端口， base_path为日志目录，配置样例如下：</p>
<p>bind_addr=39.96.209.253</p>
<p>port=22122</p>
<p>base_path=/home/fastdfs/tracker</p>
<p>作为存储节点的服务器需要修改storage.conf，主要修改以下部分。group_name表示存储节点所属的组；bind_addr表示存储节点绑定的IP；port为存储节点绑定的端口；base_path表示存储日志目录；store_path_count配置存储目录的个数；store_path0配置具体的存储目录；tracker_server用于配置连接Tracker的时候使用的IP和端口；配置样例如下：</p>
<p>group_name=group1 </p>
<p>bind_addr=39.96.209.253</p>
<p>port=23000 </p>
<p>base_path=/home/fastdfs/storage  </p>
<p>store_path_count=1 </p>
<p>store_path0=/home/fastdfs/storage</p>
<p>tracker_server=39.96.209.253:22122</p>
<p>客户端服务器主要通过API请求上传、下载等操作。因此所有用于响应用户请求的HTTP服务器均需对文件client.conf进行配置。主要需要修改两部分：base_path配置日志目录；tracker_server配置连接Tracker服务器时使用的IP和端口。Client配置样例如下：</p>
<p>base_path=/home/fastdfs/client </p>
<p>tracker_server=39.96.209.253:22122</p>
<p>配置文件配置完成后，所有响应请求的HTTP服务器通过Client调用API向Tracker请求上传、下载等操作[28]。对于常用的API，可通过源码的方式获取。文件上传调用fdfs_upload_file，下载调用fdfs_download_file，删除调用fdfs_delete_file[29]。因此对于数据上传、下载或删除请求，我们可以通过加载fdfs_upload_file.c，fdfs_download_file.c，fdfs_delete_file.c获取对应操作的API。</p>
<h2 id="5-2-客户端架构实现"><a href="#5-2-客户端架构实现" class="headerlink" title="5.2 客户端架构实现"></a>5.2 客户端架构实现</h2><h3 id="5-2-1-用户界面设计"><a href="#5-2-1-用户界面设计" class="headerlink" title="5.2.1 用户界面设计"></a>5.2.1 用户界面设计</h3><p>客户端界面分为两部分，用户界面与文件界面。其中用户界面为一个主界面包含注册、登录、设置三个子界面。而文件界面由按钮栏和文件列表栏两部分拼凑而成，文件列表栏作为父类有我的文件界面、共享列表界面、下载榜列表界面和传输列表界面四个派生类，通过按钮栏的点击事件通过信号槽触发回调函数，创建不同的文件列表栏派生类。</p>
<p>用户界面由一个主界面Login类构成，该类由信息栏title_widget与表单栏stackedWidget两部分组成。信息栏主要用于图标、标题等固定信息的展示；表单栏包含三个QWidget子界面login_page、register_page与set_page，分别用于登录、注册与设置。具体结构如下图：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps21.png" alt="img"></p>
<p>图 5-2 用户界面结构</p>
<p>当触发切换界面按钮事件时，通过信号槽触发回调函数，通过回调函数调用setCurrentWidget(…)方法根据传参子界面参数进行不同界面的切换。用户界面类的声明如下：</p>
<p>class Login : public QDialog{</p>
<p>​    Q_OBJECT</p>
<p>public:</p>
<p>​    explicit Login(QWidget *parent = 0);</p>
<p>​    ~Login();</p>
<p>​    // 设置登陆用户信息的Json包</p>
<p>​    QByteArray setLoginJson(QString user, QString pwd);</p>
<p>​    // 设置注册用户信息的Json包</p>
<p>​    QByteArray setRegisterJson(QString userName, QString nickName, QString firstPwd, QString phone, QString email);</p>
<p>​    // 得到服务器回复的登陆状态， 状态码返回值为 “000”, 或 “001”，还有登陆section</p>
<p>​    QStringList getLoginStatus(QByteArray json);</p>
<p>protected:</p>
<p>​    void paintEvent(QPaintEvent *);</p>
<p>private slots:</p>
<p>​    void on_register_btn_clicked();</p>
<p>​    void on_login_btn_clicked();</p>
<p>​    void on_set_ok_btn_clicked();</p>
<p>private:</p>
<p>​    // 读取配置信息，设置默认登录状态，默认设置信息</p>
<p>​    void readCfg();</p>
<p>private:</p>
<p>​    Ui::Login *ui;</p>
<p>​    // 处理网络请求类对象</p>
<p>​    QNetworkAccessManager* m_manager;</p>
<p>​    // 主窗口指针</p>
<p>​    MainWindow* m_mainWin;</p>
<p>​    Common m_cm;</p>
<p>};</p>
<p>其登录主界面效果展示如下：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps22.jpg" alt="img"> </p>
<p>图5-3 登录界面效果图</p>
<p>用户进入登录界面后，通过点击注册，进入注册界面，点击关闭会返回登录界面。其注册界面效果展示如下：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps23.jpg" alt="img"> </p>
<p>图5-4 注册界面效果图</p>
<h3 id="5-2-2-文件界面设计"><a href="#5-2-2-文件界面设计" class="headerlink" title="5.2.2 文件界面设计"></a>5.2.2 文件界面设计</h3><p>文件界面作为文件基础界面，在用户点击登录按钮后启动。文件界面分为导航栏ButtonGroup类与文件列表界面MainWindow类两部分组成。结构如下：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps24.png" alt="img"></p>
<p>图5-5 文件界面结构</p>
<p>文件列表界面MainWindow中包含ButtonGroup指针，在启动界面时会通过指针先加载导航栏ButtonGroup类。导航栏由我的文件、共享列表、下载榜、传输列表、切换用户5个界面切换按钮以及关闭之类的基础按钮组成，通过信号槽分别对应不同回调函数。其回调函数声明在signals中。ButtonGroup类声明代码声明如下：</p>
<p>class ButtonGroup : public QWidget{</p>
<p>​    Q_OBJECT</p>
<p>public:</p>
<p>​    explicit ButtonGroup(QWidget *parent = 0);</p>
<p>​    ~ButtonGroup();</p>
<p>public slots:</p>
<p>​    // 按钮处理函数</p>
<p>​    void slotButtonClick(Page cur);</p>
<p>​    void slotButtonClick(QString text);</p>
<p>​    void setParent(QWidget *parent);</p>
<p>….</p>
<p>signals:</p>
<p>​    void sigMyFile();        //我的文件信号</p>
<p>​    void sigShareList();        //共享文件信号</p>
<p>​    void sigDownload();    //下载榜信号</p>
<p>​    void sigTransform();    //传输列表信号</p>
<p>​    void sigSwitchUser();    //切换用户信号</p>
<p>​    void closeWindow();    //关闭信号</p>
<p>​    void minWindow();        //最小化信号</p>
<p>​    void maxWindow();        //最大化信号</p>
<p>private:</p>
<p>​    Ui::ButtonGroup *ui;</p>
<p>​    QPoint m_pos;</p>
<p>​    QWidget* m_parent;</p>
<p>​    QSignalMapper* m_mapper;</p>
<p>​    QToolButton* m_curBtn;</p>
<p>​    QMap&lt;QString, QToolButton*&gt; m_btns;</p>
<p>​    QMap&lt;Page, QString&gt; m_pages;        //文件列表界面及名称</p>
<p>};</p>
<p>导航栏ButtonGroup 效果界面展示图如下：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps25.jpg" alt="img"> </p>
<p>图5-6 文件界面导航栏</p>
<p>文件列表MainWindow作为父类共包含我的文件界面MyFileWg类、共享列表界面ShareList类、下载榜界面RankingList类和传输列表界面Transfer类四个派生类，这四个界面均继承自MainWindow类。通过不同的按钮触发信号槽对应的回调函数绘制不同的子界面。</p>
<p>文件列表界面父类MainWindow具体声明代码如下：</p>
<p>class MainWindow : public QMainWindow{</p>
<p>​    Q_OBJECT</p>
<p>public:</p>
<p>​    explicit MainWindow(QWidget *parent = 0);</p>
<p>​    void showMainWindow();    // 显示主窗口</p>
<p>​    void managerSignals();        // 处理信号</p>
<p>​    void loginAgain();            // 重新登陆</p>
<p>signals:</p>
<p>​    void changeUser();            // 切换用户按钮信号</p>
<p>protected:</p>
<p>​    void paintEvent(QPaintEvent *event);</p>
<p>private:</p>
<p>​    Ui::MainWindow *ui;        //文件界面指针</p>
<p>​    Common m_common;        //工具类</p>
<p>};</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps26.jpg" alt="img"> </p>
<p>图5-7 我的文件效果图</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps27.jpg" alt="img"> </p>
<p>图5-8 共享列表效果图</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps28.jpg" alt="img"> </p>
<p>图5-9 下载榜效果图</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps29.jpg" alt="img"> </p>
<p>图5-10 传输列表效果图</p>
<h3 id="5-2-3-基础功能模块"><a href="#5-2-3-基础功能模块" class="headerlink" title="5.2.3 基础功能模块"></a>5.2.3 基础功能模块</h3><p>客户端在进行界面设计的同时为了避免代码冗余，需要对一些比较常用的方法进行抽离，实现高内聚低耦合。因此将这些常用的方法封装成工具类，放在Common文件夹里。该文件夹包含基础类文件和工具类文件。基础类汇集在common.cpp，工具类包括Md5加密算法des.c、用户信息保存logininfoinstance.cpp、下载任务列表downloadtask.cpp、下载进度界面downloadlayout.cpp、上传任务列表uploadtask.cpp、上传进度界面uploadlayout.cpp。</p>
<p>基础类头文件common.h包含宏定义配置，包括配置文件的宏定义与正则表达式的宏定义，同时包括文件类的属性声明。基础类Common包括读写配置文件、读写日志、文件类型判断、Md5加密、HTTP通信、获取状态码等方法的实现。具体声明如下：</p>
<p>class Common : public QObject{</p>
<p>​    Q_OBJECT</p>
<p>public:</p>
<p>​    Common(QObject* parent = 0);</p>
<p>​    ~Common();</p>
<p>​    // 窗口在屏幕中央显示</p>
<p>​    void moveToCenter(QWidget *tmp);</p>
<p>​    // 从配置文件中得到相对应的参数</p>
<p>​    QString getCfgValue(QString title, QString key, QString path = CONFFILE);</p>
<p>​    // 通过读取文件, 得到文件类型, 存放在typeList</p>
<p>​    void getFileTypeList();</p>
<p>​    // 得到文件后缀，参数为文件类型，函数内部判断是否有此类型，如果有，使用此类型，没有，使用other.png</p>
<p>​    QString getFileType(QString type);</p>
<p>​    // 登录信息，写入配置文件</p>
<p>​    void writeLoginInfo(QString user, QString pwd, bool isRemeber, QString path = CONFFILE);</p>
<p>​    // 服务器信息，写入配置文件</p>
<p>​    void writeWebInfo(QString ip, QString port, QString path=CONFFILE);</p>
<p>​    // 获取某个文件的Md5码</p>
<p>​    QString getFileMd5(QString filePath);</p>
<p>​    // 将某个字符串加密成Md5码</p>
<p>​    QString getStrMd5(QString str = “”);</p>
<p>​    // 产生分隔线</p>
<p>​    QString getBoundary();</p>
<p>​    // 得到服务器回复的状态码， 返回值为 “000”, 或 “001”</p>
<p>​    QString getCode(QByteArray json);</p>
<p>​    // 传输数据记录到本地文件，user：操作用户，name：操作的文件, code: 操作码， path: 文件保存的路径</p>
<p>​    void writeRecord(QString user, QString name, QString code, QString path = RECORDDIR);</p>
<p>​    // 得到HTTP通信类对象</p>
<p>​    static QNetworkAccessManager* getNetManager();</p>
<p>public:</p>
<p>​    static QStringList  m_typeList;</p>
<p>private:</p>
<p>​    // 文件类型路径</p>
<p>​    static QString      m_typePath;</p>
<p>​    static QNetworkAccessManager *m_netManager;</p>
<p>};</p>
<p>其配置反向代理服务器IP与端口的设置界面如下：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps30.jpg" alt="img"> </p>
<p>图5-11 配置设置效果图</p>
<p>工具类LoginInfoInstance为单例模式，当用户信息确认后会将当前用户信息与服务器信息保存到堆中，每次当需要获取用户信息或服务器信息时直接从堆中获取。</p>
<p>工具类中下载任务列表DownloadTask、下载进度界面DownloadLayout、上传任务列表UploadTask、上传进度界面UploadLayout均采用单例设计模式。</p>
<p>Layout作为客户端界面，当客户端访问数据传输列表界面时会加载该单例模式界面。其界面如下：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps31.jpg" alt="img"> </p>
<p>图5-12 任务进度图</p>
<p>Task作为任务，维护一个队列，当有任务时会将任务插入队列中，每次提取队首任务进行上传、下载操作。当任务完成时从队列中删除该任务。以上传任务为例，其界面效果图如下：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps32.jpg" alt="img"> </p>
<p>图5-13上传任务界面效果图</p>
<h2 id="5-3-功能模块实现"><a href="#5-3-功能模块实现" class="headerlink" title="5.3 功能模块实现"></a>5.3 功能模块实现</h2><h3 id="5-3-1-数据封装与提取"><a href="#5-3-1-数据封装与提取" class="headerlink" title="5.3.1 数据封装与提取"></a>5.3.1 数据封装与提取</h3><p>由于客户端跟服务端数据之间需要不断交互，但客户端和服务端无论在操作系统还是开发工具上都截然不同，因此数据需要采用统一的格式去存储。而Json作为跨平台的数据交互方式，因此可以将数据封装成Json格式，进行交互。</p>
<p>封装与提取的过程由于客户端与服务端的开发工具不同因此实现方式也不同。首先对于服务端，cJSON是由纯C实现的，跨平台性较好。cJSON是采用链表存储的。</p>
<p>cJSON库在使用时只需两步：将cJSON.c和cJSON.h添加到项目即可；如果在命令行进行链接还需加上-lm表示链接math库[30]。</p>
<p>对于客户端，由于Qt将C++封装成了一套专属于Qt的语言，同时有一套自己的框架，因此对于Json的处理Qt有操作Json数据的中心类QJsonDocument。因此对于解析Json数据只需调用API即可，而对于封装Json数据的方法代码如下：</p>
<p>void Common::writeWebInfo(QString ip, QString port, QString path){</p>
<p>​    // Web_server信息</p>
<p>​    QMap&lt;QString, QVariant&gt; web_server;</p>
<p>​    web_server.insert(“ip”, ip);</p>
<p>​    web_server.insert(“port”, port);</p>
<p>​    // type_path信息</p>
<p>​    QMap&lt;QString, QVariant&gt; type_path;</p>
<p>​    type_path.insert(“path”, m_typePath);</p>
<p>​    // login信息</p>
<p>​    QString user = getCfgValue(“login”, “user”);</p>
<p>​    QString pwd = getCfgValue(“login”, “pwd”);</p>
<p>​    QString remember = getCfgValue(“login”, “remember”);</p>
<p>​    QMap&lt;QString, QVariant&gt; login;</p>
<p>​    login.insert(“user”, user);</p>
<p>​    login.insert(“pwd”, pwd);</p>
<p>​    login.insert(“remember”, remember);</p>
<p>​    QMap&lt;QString, QVariant&gt; json;</p>
<p>​    json.insert(“web_server”, web_server);</p>
<p>​    json.insert(“type_path”, type_path);</p>
<p>​    json.insert(“login”, login);</p>
<p>​    QJsonDocument jsonDocument = QJsonDocument::fromVariant(json);</p>
<p>​    file.write(jsonDocument.toJson());</p>
<p>​    file.close();</p>
<p>}</p>
<h3 id="5-3-2-用户登录与注册"><a href="#5-3-2-用户登录与注册" class="headerlink" title="5.3.2 用户登录与注册"></a>5.3.2 用户登录与注册</h3><p>对于用户部分，除了客户端界面以外，服务端的实现主要是对于数据库的操作，首先Web服务器Nginx将登录请求交由10000端口CGI程序进行处理，将注册请求交由10001端口CGI程序进行处理，需要配置如下：</p>
<p>location /login{</p>
<p>fastcgi_pass 127.0.0.1:10000;</p>
<p>include fastcgi.conf;</p>
<p>}</p>
<p>location /reg{</p>
<p>fastcgi_pass 127.0.0.1:10001;</p>
<p>include fastcgi.conf;</p>
<p>}</p>
<p>Shell命令需要将端口与CGI程序绑定，脚本如下：</p>
<p>spawn-fcgi -a 127.0.0.1 -p 10000 -f ./bin_cgi/login</p>
<p>spawn-fcgi -a 127.0.0.1 -p 10001 -f ./bin_cgi/register</p>
<p>通过配置文件将数据传递给对应端口的CGI程序，登录模块的核心部分是数据库信息的比对与结果的封装，数据封装通过数据处理模块完成，而核心的SQL操作语句如下：</p>
<p>sprintf(sql_cmd, “select password from user where name=\”%s\””, user);</p>
<p>注册部分对于数据库操作的核心代码如下：</p>
<p>sprintf(sql_cmd, “insert into user (name, nickname, password, phone, createtime, email) values (‘%s’, ‘%s’, ‘%s’, ‘%s’, ‘%s’, ‘%s’)”, user, nick_name, pwd, tel, time_str ,email);</p>
<h3 id="5-3-3-数据上传模块（上传、秒传）"><a href="#5-3-3-数据上传模块（上传、秒传）" class="headerlink" title="5.3.3 数据上传模块（上传、秒传）"></a>5.3.3 数据上传模块（上传、秒传）</h3><p>文件上传分为秒传与上传，秒传是对于服务端已有该文件的情况下无需再对文件进行分布式文件系统存储，而直接更改数据库，上传则需要将文件上传到分布式文件系统，</p>
<p>对于客户端的上传请求，首先客户端将上传请求插入到上传队列里，对于完成的请求从队列中删除。</p>
<p>当第0号任务开始进行上传工作时，客户端将文件信息封装后向服务器发起秒传请求，服务端接收到请求后对请求头进行判断，如果是Md5，则将数据信息传给10003端口绑定的CGI程序。CGI程序对数据库进行查询，如果有该文件信息，则直接更改数据库，通过file_info表将文件信息和该用户信息相关联，然后反馈成功状态码。否则反馈失败状态码。Web服务器Nginx需要配置如下：</p>
<p>location /Md5{</p>
<p>​    fastcgi_pass 127.0.0.1:10003;</p>
<p>​    include fastcgi.conf;</p>
<p>}</p>
<p>Shell命令需要将端口与CGI程序绑定，脚本如下：</p>
<p>spawn-fcgi -a 127.0.0.1 -p 10003 -f ./bin_cgi/Md5</p>
<p>客户端接收到服务端的反馈信息后，如果状态码提示服务器没有该文件，则意味着无法秒传，需继续进行数据上传操作。客户端向服务端发送请求：</p>
<p>QNetworkReply * reply = m_manager-&gt;post( request, data );</p>
<p>if(reply == NULL){</p>
<p>​    cout &lt;&lt; “reply == NULL”;</p>
<p>​    return;</p>
<p>}</p>
<p>服务端接收到Post请求后对请求头进行判断是否为upload，将数据信息传给10002端口绑定的CGI程序。CGI程序对数据库进行添加文件信息操作，同时通过fdfs_upload_file提供的API将数据信息上传到服务器分布式文件系统中。Web服务器Nginx需要配置如下：</p>
<p>location /upload{</p>
<p>fastcgi_pass 127.0.0.1:10002;</p>
<p>include fastcgi.conf;</p>
<p>}</p>
<p>Shell命令需要将端口与CGI程序绑定，脚本如下：</p>
<p>spawn-fcgi -a 127.0.0.1 -p 10002 -f ./bin_cgi/upload</p>
<p>客户端的数据传输列表界面时时跟进当前的上传进度，当有可用数据更新时，会刷新界面。跟进的信号槽代码如下：</p>
<p>connect(reply, &amp;QNetworkReply::uploadProgress, <a href="qint64 bytesRead, qint64 totalBytes">=</a>{</p>
<p>​    if(totalBytes != 0) {</p>
<p>​        dp-&gt;setProgress(bytesRead/1024, totalBytes/1024); //设置进度条</p>
<p>​    }</p>
<p>});</p>
<h3 id="5-3-4-文件查询模块（文件列表、共享列表、下载榜）"><a href="#5-3-4-文件查询模块（文件列表、共享列表、下载榜）" class="headerlink" title="5.3.4 文件查询模块（文件列表、共享列表、下载榜）"></a>5.3.4 文件查询模块（文件列表、共享列表、下载榜）</h3><p>对于客户端的请求，首先Web服务器Nginx将文件信息请求交由10004端口CGI程序进行处理，将共享列表请求交由10006端口CGI程序进行处理，需要配置如下：</p>
<p>location /myfiles{</p>
<p>fastcgi_pass 127.0.0.1:10004;</p>
<p>include fastcgi.conf;</p>
<p>}</p>
<p>location /sharefiles{</p>
<p>fastcgi_pass 127.0.0.1:10006;</p>
<p>include fastcgi.conf;</p>
<p>}</p>
<p>Shell命令需要将端口与CGI程序绑定，脚本如下：</p>
<p>spawn-fcgi -a 127.0.0.1 -p 10004 -f ./bin_cgi/myfiles</p>
<p>spawn-fcgi -a 127.0.0.1 -p 10006 -f ./bin_cgi/sharefiles</p>
<p>对于CGI程序，文件信息与共享文件分别交给myfiles.c与sharefiles.c处理。以myfiles.c为例，首先会对数据提取的信息状态进行比对，判断具体请求，比如下载榜需将请求数据排序。对于文件信息列表请求的数据库核心代码如下：</p>
<p>sprintf(sql_cmd, “select user_file_list.*, file_info.Url, file_info.size, file_info.type from file_info, user_file_list where user = ‘%s’ and file_info.Md5 = user_file_list.Md5 limit %d, %d”, user, start, count);</p>
<h3 id="5-3-5-文件处理模块（删除、共享、转存）"><a href="#5-3-5-文件处理模块（删除、共享、转存）" class="headerlink" title="5.3.5 文件处理模块（删除、共享、转存）"></a>5.3.5 文件处理模块（删除、共享、转存）</h3><p>对于客户端的删除、共享、取消共享、转存等请求，首先Web服务器Nginx将文件信息请求交由10004端口CGI程序进行处理，将共享列表请求交由10006端口CGI程序进行处理，需要配置如下：</p>
<p>location //dealfile{</p>
<p>fastcgi_pass 127.0.0.1:10005;</p>
<p>include fastcgi.conf;</p>
<p>}</p>
<p>location //dealsharefile{</p>
<p>fastcgi_pass 127.0.0.1:10007;</p>
<p>include fastcgi.conf;</p>
<p>}</p>
<p>Shell命令需要将端口与CGI程序绑定，脚本如下：</p>
<p>spawn-fcgi -a 127.0.0.1 -p 10005 -f ./bin_cgi/dealfile</p>
<p>spawn-fcgi -a 127.0.0.1 -p 10007 -f ./bin_cgi/sharefiles</p>
<p>对于CGI程序，需要将文件划分为普通文件与共享文件，普通文件可直接操作，而共享文件需要进行判断共享文件拥有者。普通文件与共享文件的处理分别交给dealfile.c与sharefiles.c处理。以dealfile.c为例，首先会对数据请求类型进行判断，请求类型具体分为删除、分享、取消分享、转存等类型，四者均对数据库进行增删改查操作，只有删除操作在确认该文件拥有者为0时会对分布式文件系统中的文件进行删除，具体删除FastDFS中文件的核心代码如下：</p>
<p>int remove_file_from_storage(char *fileid){</p>
<p>​    int ret = 0;</p>
<p>​    //读取fdfs client 配置文件的路径</p>
<p>​    char fdfs_cli_conf_path[256] = {0};</p>
<p>​    get_cfg_value(CFG_PATH, “dfs_path”, “client”, fdfs_cli_conf_path);</p>
<p>​    char cmd[1024*2] = {0};</p>
<p>​    sprintf(cmd, “fdfs_delete_file %s %s”, fdfs_cli_conf_path, fileid);</p>
<p>​    ret = system(cmd);</p>
<p>​    return ret;</p>
<p>}</p>
<h3 id="5-3-6-数据下载模块"><a href="#5-3-6-数据下载模块" class="headerlink" title="5.3.6 数据下载模块"></a>5.3.6 数据下载模块</h3><p>由于服务器端存储结点Storage与Nginx关联，因此存储在存储结点的数据可直接通过Url的方式进行获取，提高了服务端下载的效率。对于客户端，维护一个静态队列，队列中存储需要下载的任务信息。每次移除已经下载完成的任务，将最新下载请求进行数据封装后插入下载队列。当队列第0个任务元素需要下载时，首先通过该文件Url发起HTTP请求，具体Get请求代码如下：</p>
<p>QNetworkReply * reply = m_manager-&gt;get( QNetworkRequest(Url) );</p>
<p>if(reply == NULL){</p>
<p>​    p-&gt;dealDownloadTask(); //删除任务</p>
<p>​    cout &lt;&lt; “get err”;</p>
<p>​    return;</p>
<p>}</p>
<p>获取请求的数据完成时，就会发送信号SIGNAL(finished())，代码如下：</p>
<p>connect(reply, &amp;QNetworkReply::finished, <a href>=</a>{</p>
<p>​    cout &lt;&lt; “下载完成”;</p>
<p>​    reply-&gt;deleteLater();</p>
<p>p-&gt;dealDownloadTask();//删除下载任务</p>
<p>m_cm.writeRecord(user, filename, “010”); //下载文件成功，记录</p>
<p>dealFilePv(Md5, filename); //下载文件pv字段处理</p>
<p>});</p>
<p>reply在有数据时发出readyRead信号，我们便可保存数据。具体代码如下：</p>
<p>connect(reply, &amp;QNetworkReply::readyRead, <a href>=</a>{</p>
<p>​    if (file != NULL){</p>
<p>​        file-&gt;write(reply-&gt;readAll());</p>
<p>​    }</p>
<p>});</p>
<p>有可用数据更新时，会通过信号槽刷新进度界面，代码如下：</p>
<p>connect(reply, &amp;QNetworkReply::downloadProgress, <a href="qint64 bytesRead, qint64 totalBytes">=</a>{</p>
<p>​    dp-&gt;setProgress(bytesRead, totalBytes);//设置进度</p>
<p>});</p>
<h3 id="5-3-7-图像预览模块"><a href="#5-3-7-图像预览模块" class="headerlink" title="5.3.7 图像预览模块"></a>5.3.7 图像预览模块</h3><p>由于图像Url信息保存在数据库中，而在文件列表请求的过程中会默认将Url保存到文件信息中，因此对于图像预览，需要根据传进来不同的Url参数进行请求。首先创建QNetworkAccessManager进行HTTP通信，然后建立信号连接槽，通过Get的方式向Url发起请求。流程如下：</p>
<p>void PreviewImg::load_network_img(QString Url){</p>
<p>​    currentPicture = new QPixmap;</p>
<p>​    //获取网络图片</p>
<p>​    QNetworkAccessManager *manager;</p>
<p>​    manager = new QNetworkAccessManager(this);</p>
<p>​    connect(manager, SIGNAL(finished(QNetworkReply*)),</p>
<p>​        this, SLOT(replyFinished(QNetworkReply*)));</p>
<p>​    manager-&gt;get(QNetworkRequest(QUrl( Url )));</p>
<p>}</p>
<p>当请求完成时会调用完成回调函数，绘制预览图像界面，同时如果用户选择缓存图片，则会对缩略图及缓存图片进行本地缓存，之后访问直接先通过缓存加载图像，加快下一次访问时的效率。回调函数如下：</p>
<p>void PreviewImg::replyFinished(QNetworkReply *reply){</p>
<p>​    if (reply-&gt;error() == QNetworkReply::NoError){</p>
<p>​        currentPicture-&gt;loadFromData(reply-&gt;readAll());//获取字节流QPixmap对象</p>
<p>​        QString filename = cachePathFile;</p>
<p>​        currentFileName = filename;</p>
<p>​        if(flag){//true预览图片，false加载缩略图</p>
<p>​            showImgFile(currentPicture);//加载预览界面</p>
<p>​        }else{</p>
<p>​            PreviewImg::isTask = false;//缩略图请求任务结束</p>
<p>​        }</p>
<p>​        if(isCache){    //是否缓存图片</p>
<p>​            currentPicture-&gt;save(cachePathFile);//保存图片</p>
<p>​            saveIcoFile(currentPicture);//保存缩略图</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps33.jpg" alt="img"> </p>
<p>图5-14 图像预览列表图</p>
<h1 id="6-测试"><a href="#6-测试" class="headerlink" title="6  测试"></a>6  测试</h1><h2 id="6-1-程序调试"><a href="#6-1-程序调试" class="headerlink" title="6.1 程序调试"></a>6.1 程序调试</h2><p>任何项目在开发过程中均或多或少会遇到各种各样的错误，除了比较基础的配置环境问题或语法错误以外，还有很多问题是在程序运行的过程中才能发现的。因此在程序设计的同时，尽量使每个模块独立，减少文件之间因耦合度过高而出现错误的几率，达到高内聚低耦合的效果，这样在每个模块设计完成的同时可以独立测试，方便排查错误，提高修复错误的效率。</p>
<p>在程序调试的程序的过程中，服务端主要通过Linux自带的GDB工具进行断点调试，排查错误语法；客户端主要通过Qt Creator语法错误提示和Debug断点单步调试，迅速定位错误代码并显示错误信息。</p>
<h2 id="6-2-工具测试"><a href="#6-2-工具测试" class="headerlink" title="6.2 工具测试"></a>6.2 工具测试</h2><h3 id="6-2-1-测试的目的和意义"><a href="#6-2-1-测试的目的和意义" class="headerlink" title="6.2.1 测试的目的和意义"></a>6.2.1 测试的目的和意义</h3><p>软件测试重点在于在真实的软件运行环境下通过与软件需求进行比较，发现软件与需求有所偏差的地方。</p>
<p>此次软件测试的目的在于检查基于云存储的图像管理平台已完成的功能，发现软件在运行过程中出现的错误并及时解决，使软件能正常运行，确保每个功能可以正常使用，同时尽量保证软件的功能基本符合软件需求。</p>
<h3 id="6-2-2-测试框架"><a href="#6-2-2-测试框架" class="headerlink" title="6.2.2 测试框架"></a>6.2.2 测试框架</h3><p>QTestLib为用户提供了一个操作简便的单元测试框架，因此本次测试使用Qt Creator 自带的单元测试框架QTestlib进行测试。</p>
<h3 id="6-2-3-测试步骤"><a href="#6-2-3-测试步骤" class="headerlink" title="6.2.3 测试步骤"></a>6.2.3 测试步骤</h3><p>本平台的设计步骤通过断点调试、单元测试、集成测试、系统测试四部分对系统的功能和性能进行检查和完善[31]。</p>
<p>首先是单元测试，单元测试以功能模块或函数作为对象，通常采用白盒测试技术，辅以黑盒技术，集中地对程序所实现的每个功能模块进行测试，竭力覆盖每个函数，检验各个程序模块是否存在问题，与所描述的功能是否相符合。</p>
<p>其次是集成测试，把已通过单元测试完成的模块进行组合，最终组成所预期的平台系统。其作用主要是检验软件体系的结构是否合理，检查接口之间的问题。</p>
<p>最后是系统测试，把已经集成测试的软件纳入实际运行环境中，与硬件、外设等支持软件运行的系统因素组合，进行环境相关的测试。</p>
<h2 id="6-3-测试用例设计"><a href="#6-3-测试用例设计" class="headerlink" title="6.3 测试用例设计"></a>6.3 测试用例设计</h2><p>QTestLib为用户提供了一个操作简便的单元测试框架，使用时可以通过在新建项目栏点击其他项目-Qt单元测试，也可以直接在工程文件里加入语句Qt+=testlib。其基本操作代码如下：</p>
<p>class Untitled2Test : public QObject {</p>
<p>Q_OBJECT</p>
<p>public:</p>
<p>Untitled2Test();</p>
<p>private Q_SLOTS:</p>
<p>void initTestCase();</p>
<p>void cleanupTestCase();</p>
<p>void testCase1();</p>
<p>};</p>
<p>Untitled2Test::Untitled2Test() {</p>
<p>…</p>
<p>}</p>
<p>void Untitled2Test::initTestCase() {</p>
<p>…</p>
<p>}</p>
<p>void Untitled2Test::cleanupTestCase() {</p>
<p>…</p>
<p>}</p>
<p>void Untitled2Test::testCase1() {</p>
<p>QVERIFY2(true, “Failure”);</p>
<p>}</p>
<p>QTEST_APPLESS_MAIN(Untitled2Test)</p>
<p>#include “tst_untitled2test.moc”</p>
<p>其中，首个测试函数执行前调用initTestCase()；最后一个测试函数执行后调用cleanupTestCase()；每个测试函数执行前调用init()；每个测试函数执行后调用cleanup()[32]。</p>
<p>对于GUI相关的操作，Qtestlib同样提供了接口。通过对控件传递信息来检查结果。常用的操作函数例如鼠标的点击事件QTest::mouseClick()，以及键盘的点击事件QTest::keyClick()[33]。</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps34.jpg" alt="img"> </p>
<p>图6-1 GUI单元测试部分结果</p>
<h2 id="6-4-测试数据及结果"><a href="#6-4-测试数据及结果" class="headerlink" title="6.4 测试数据及结果"></a>6.4 测试数据及结果</h2><h3 id="6-4-1-功能测试数据及结果"><a href="#6-4-1-功能测试数据及结果" class="headerlink" title="6.4.1 功能测试数据及结果"></a>6.4.1 功能测试数据及结果</h3><p>功能测试通过对平台已实现的功能进行单元测试与集成测试，查看功能在运行状况下是否与预期的功能效果相符，同时查找在单步调试中未发现而在程序运行中会出现的潜在错误。以下是功能测试数据及结果。</p>
<p>表6-1 功能测试结果</p>
<table>
<thead>
<tr>
<th>功能模块</th>
<th>前置条件</th>
<th>测试步骤</th>
<th>预期结果</th>
<th>实测结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>设置测试-IP</td>
<td>进入设置界面</td>
<td>IP输入不规范</td>
<td>提示IP不正确</td>
<td>提示IP不正确</td>
</tr>
<tr>
<td>设置测试-端口</td>
<td>进入设置界面</td>
<td>端口输入不规范</td>
<td>提示端口不正确</td>
<td>提示端口不正确</td>
</tr>
<tr>
<td>设置测试-集成测试</td>
<td>进入设置界面</td>
<td>IP与端口输入均符合规范</td>
<td>自动跳转至登录界面</td>
<td>自动跳转至登录界面</td>
</tr>
<tr>
<td>设置测试-集成测试</td>
<td>进入注册界面，信息输入正确</td>
<td>未设置端口和IP</td>
<td>提示注册连接失败</td>
<td>提示注册连接失败</td>
</tr>
<tr>
<td>设置测试-集成测试</td>
<td>进入登录界面，信息输入正确</td>
<td>未设置端口和IP</td>
<td>提示登录连接失败</td>
<td>提示登录连接失败</td>
</tr>
<tr>
<td>用户注册测试-必填项</td>
<td>进入用户注册页面</td>
<td>信息栏为空，点击注册</td>
<td>提示用户注册信息为空</td>
<td>提示用户注册信息为空</td>
</tr>
<tr>
<td>用户注册测试-边界值</td>
<td>进入用户注册页面</td>
<td>输入用户名不规范，其他信息规范</td>
<td>提示注册失败</td>
<td>提示用户名不正确</td>
</tr>
<tr>
<td>用户注册测试-边界值</td>
<td>进入用户注册页面</td>
<td>输入昵称不规范，其他信息规范</td>
<td>提示注册失败</td>
<td>提示昵称不正确</td>
</tr>
<tr>
<td>用户注册测试-边界值</td>
<td>进入用户注册页面</td>
<td>输入密码不规范，其他信息规范</td>
<td>提示注册失败</td>
<td>提示密码不正确</td>
</tr>
<tr>
<td>用户注册测试-边界值</td>
<td>进入用户注册页面</td>
<td>输入两次密码不同，其他信息规范</td>
<td>提示注册失败</td>
<td>提示两次密码不同</td>
</tr>
</tbody>
</table>
<p>续表 6-1</p>
<table>
<thead>
<tr>
<th>功能模块</th>
<th>前置条件</th>
<th>测试步骤</th>
<th>预期结果</th>
<th>实测结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户注册测试-边界值</td>
<td>进入用户注册页面</td>
<td>输入电话不规范，其他信息规范</td>
<td>提示注册失败</td>
<td>提示电话不正确</td>
</tr>
<tr>
<td>用户注册测试-边界值</td>
<td>进入用户注册页面</td>
<td>输入邮箱不规范，其他信息规范</td>
<td>提示注册失败</td>
<td>提示邮箱格式不正确</td>
</tr>
<tr>
<td>用户注册测试-集成测试</td>
<td>进入用户注册页面，IP与端口可用</td>
<td>填写用户名存在，其他信息填写正确</td>
<td>提示注册失败</td>
<td>提示用户已存在</td>
</tr>
<tr>
<td>用户注册测试-集成测试</td>
<td>进入用户注册页面，IP与端口可用</td>
<td>填写注册均信息规范且用户名不存在</td>
<td>提示注册成功，跳转登录界面</td>
<td>提示注册成功，跳转登录界面</td>
</tr>
<tr>
<td>用户登录测试-必填项</td>
<td>用户已经注册并激活账户</td>
<td>用户名为空，密码规范，点击登录</td>
<td>提示用户名为空</td>
<td>提示用户名为空</td>
</tr>
<tr>
<td>用户登录测试-必填项</td>
<td>用户已经注册并激活账户</td>
<td>密码为空，用户名规范，点击登录</td>
<td>提示密码为空</td>
<td>提示密码为空</td>
</tr>
<tr>
<td>用户登录测试-边界值</td>
<td>用户已经注册并激活账户</td>
<td>用户名规范，密码不规范，点击登录</td>
<td>登陆失败</td>
<td>登陆失败</td>
</tr>
<tr>
<td>用户登录测试-边界值</td>
<td>用户已经注册并激活账户</td>
<td>密码规范，用户名不规范，点击登录</td>
<td>登陆失败</td>
<td>登陆失败</td>
</tr>
<tr>
<td>用户登录测试-边界值</td>
<td>用户已经注册并激活账户</td>
<td>密码与用户名均不规范，点击登录</td>
<td>登陆失败</td>
<td>登陆失败</td>
</tr>
<tr>
<td>用户登录测试-集成测试</td>
<td>用户已经注册账户</td>
<td>用户名和密码输入正确，点击登录</td>
<td>登录成功，跳转至我的文件界面</td>
<td>登录成功，跳转至我的文件界面</td>
</tr>
<tr>
<td>用户登录测试-缓存测试</td>
<td>用户已经注册账户</td>
<td>选择记住密码登录，再进登录界面</td>
<td>登录栏有上次用户输入的信息</td>
<td>登录栏有上次用户输入的信息</td>
</tr>
<tr>
<td>文件上传测试-文件类型</td>
<td>1.用户已登录，并进入文件页面；2.准备1个非图像文件</td>
<td>1.选择非图像文件文件；2.确认上传</td>
<td>提示上传成功，文件信息保存至数据库中</td>
<td>提示上传成功，文件信息保存至数据库中</td>
</tr>
<tr>
<td>文件上传测试-文件类型</td>
<td>1.用户已登录，并进入文件页面；2.准备1个图像文件</td>
<td>1.选择图像文件；2.确认上传</td>
<td>提示上传成功，文件信息保存至数据库中</td>
<td>提示上传成功，文件信息保存至数据库中</td>
</tr>
<tr>
<td>文件上传测试-性能测试</td>
<td>1.用户已登录，并进入文件页面；2.准备10个文件</td>
<td>1.选择准备好的文件；2.确认上传</td>
<td>10个文件加入到上传队列</td>
<td>10个文件加入到上传队列</td>
</tr>
</tbody>
</table>
<p>续表 6-1</p>
<table>
<thead>
<tr>
<th>功能模块</th>
<th>前置条件</th>
<th>测试步骤</th>
<th>预期结果</th>
<th>实测结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件上传测试-性能测试</td>
<td>用户已登录，并进入文件页面</td>
<td>1.选择1KB文件；2.确认上传</td>
<td>成功上传</td>
<td>成功上传</td>
</tr>
<tr>
<td>文件上传测试-性能测试</td>
<td>用户已登录，并进入文件页面</td>
<td>选择准备的100MB文件；确认上传</td>
<td>成功上传</td>
<td>成功上传</td>
</tr>
<tr>
<td>文件秒传测试-性能测试</td>
<td>1.用户已登录，并进入文件页面；2.准备已上传过的文件</td>
<td>1.选择准备好的文件；2.确认上传</td>
<td>直接提示上传成功，文件信息保存至数据库中</td>
<td>直接提示上传成功，文件信息保存至数据库中</td>
</tr>
<tr>
<td>文件下载测试</td>
<td>1.用户已经登陆；2.已经有上传好的文件</td>
<td>1.选择一个自己文件点击下载；2.在本地打开文件</td>
<td>文件成功打开，且格式正确</td>
<td>文件成功打开，且格式正确</td>
</tr>
<tr>
<td>文件下载测试-共享文件</td>
<td>1.用户已经登陆；2.系统中有共享文件存在</td>
<td>在共享文件界面点击一个文件下载，然后打开下载文件</td>
<td>文件成功打开，且格式正确</td>
<td>文件成功打开，且格式正确</td>
</tr>
<tr>
<td>文件下载测试-共享文件</td>
<td>1.用户已经登陆；3.系统中有共享文件存在</td>
<td>在共享文件界面点击一个文件下载，然后再上传该文件</td>
<td>文件采用秒传方式上传成功</td>
<td>文件采用秒传方式上传成功</td>
</tr>
<tr>
<td>文件共享测试</td>
<td>1.用户已经登陆；2.文件列表存在文件</td>
<td>用户选择文件设为共享并进共享页面</td>
<td>用户1可以查找到该文件</td>
<td>用户1可以查找到该文件</td>
</tr>
<tr>
<td>文件共享测试</td>
<td>1.准备两个用户，且已经登陆；2.文件列表存在文件</td>
<td>1.用户1选择一个文件共享；2.用户2转存该文件</td>
<td>用户2可以在共享界面转存该文件</td>
<td>用户2可以在共享界面转存该文件</td>
</tr>
<tr>
<td>文件共享测试</td>
<td>1.准备两个用户，且已经登陆；2.文件列表存在文件</td>
<td>1.用户1选择一个文件共享；2.用户2取消共享该文件</td>
<td>用户2不可以在共享界面取消共享该文件</td>
<td>用户2不可以在共享界面取消共享该文件</td>
</tr>
<tr>
<td>文件共享测试</td>
<td>1.准备两个用户，且已经登陆；2.文件列表存在文件</td>
<td>1.用户1选择文件取消共享；2.用户2前往共享页面</td>
<td>用户2不可以找到该文件</td>
<td>用户2不可以找到该文件</td>
</tr>
<tr>
<td>文件共享测试</td>
<td>1.用户已经登陆；2.文件列表存在文件</td>
<td>用户将转存文件共享</td>
<td>用户不可以共享该文件</td>
<td>用户不可以共享该文件</td>
</tr>
<tr>
<td>文件列表测试-我的文件</td>
<td>1.用户已经登录；2.该存在文件</td>
<td>进入我的文件</td>
<td>图标形式显示用户所有文件</td>
<td>图标形式显示用户所有文件</td>
</tr>
</tbody>
</table>
<p>续表 6-1</p>
<table>
<thead>
<tr>
<th>功能模块</th>
<th>前置条件</th>
<th>测试步骤</th>
<th>预期结果</th>
<th>实测结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件列表测试-共享文件</td>
<td>1.用户已经登录；2.存在共享文件</td>
<td>进入共享文件</td>
<td>图标形式显示所有共享文件</td>
<td>图标形式显示所有共享文件</td>
</tr>
<tr>
<td>文件列表测试-下载榜</td>
<td>1.用户已经登录；2.存在共享文件</td>
<td>进入下载榜</td>
<td>以下载量排序共享文件信息</td>
<td>以下载量排序共享文件信息</td>
</tr>
<tr>
<td>文件删除测试-删除普通文件</td>
<td>1.用户已经登录；2.系统中存在文件</td>
<td>1.用户选择一个文件删除</td>
<td>用户文件列表中没有该文件</td>
<td>用户文件列表中没有该文件</td>
</tr>
<tr>
<td>文件删除测试-删除共享文件</td>
<td>1.准备两个用户，且已经登录；2.系统中存在文件</td>
<td>1.用户1删除自己的共享文件；2.用户2进入共享页面</td>
<td>用户2不可以找到该文件</td>
<td>用户2不可以找到该文件</td>
</tr>
<tr>
<td>文件删除测试-删除共享文件</td>
<td>1.用户已经登录；2.系统中存在文件</td>
<td>用户选择非自己的共享文件点击删除</td>
<td>删除失败</td>
<td>删除失败</td>
</tr>
<tr>
<td>文件删除测试-删除共享文件</td>
<td>用户1用户2均拥有该共享文件，且用户1为共享者</td>
<td>1.用户1删除该文件2.用户2进入共享文件界面查找</td>
<td>用户2不可以查找到该文件</td>
<td>用户2不可以查找到该文件</td>
</tr>
<tr>
<td>文件删除测试-删除共享文件</td>
<td>用户1用户2均拥有该共享文件，且用户2为共享者</td>
<td>1.用户1删除该文件2.用户2进入共享文件界面查找</td>
<td>用户2可以查找到该文件</td>
<td>用户2可以查找到该文件</td>
</tr>
<tr>
<td>图像预览测试</td>
<td>用户拥有已上传非图像文件</td>
<td>选中非图像文件右键点击预览</td>
<td>提示该文件非图像，无法预览</td>
<td>提示该文件非图像，无法预览</td>
</tr>
<tr>
<td>图像预览测试</td>
<td>用户拥有已上传图像文件并点击预览</td>
<td>选中图像文件右键点击预览</td>
<td>显示预览效果</td>
<td>显示预览效果</td>
</tr>
<tr>
<td>图像预览测试-缩略图</td>
<td>进入文件列表界面，缓存没有预览图</td>
<td>无</td>
<td>先显示默认图像，一段时间后部分图像逐渐显现缩略图</td>
<td>先显示默认图像，一段时间后部分图像逐渐显现缩略图</td>
</tr>
<tr>
<td>图像预览测试-缩略图</td>
<td>进入文件列表界面，缓存有预览图</td>
<td>无</td>
<td>显示图像缩略图</td>
<td>显示图像缩略图</td>
</tr>
<tr>
<td>图像预览测试-缩略图</td>
<td>进入文件列表界面</td>
<td>1.预览图像文件2.刷新文件列表</td>
<td>预览过的图像文件显示图像缩略图</td>
<td>预览过的图像文件显示图像缩略图</td>
</tr>
<tr>
<td>图像预览测试-缓存</td>
<td>进入文件列表界面</td>
<td>右键取消缓存，刷新界面</td>
<td>未在缓存中的缩略图不会自动加载</td>
<td>未在缓存中的缩略图不会自动加载</td>
</tr>
<tr>
<td>图像预览测试-缓存</td>
<td>进入文件列表界面</td>
<td>右键点击清理缓存</td>
<td>缓存文件清空</td>
<td>缓存文件清空</td>
</tr>
<tr>
<td>用户切换测试</td>
<td>进入文件界面</td>
<td>点击切换用户</td>
<td>切换到登录界面</td>
<td>切换到登录界面</td>
</tr>
</tbody>
</table>
<h3 id="6-4-2-性能测试结果"><a href="#6-4-2-性能测试结果" class="headerlink" title="6.4.2 性能测试结果"></a>6.4.2 性能测试结果</h3><p>在性能测试中主要通过SpeedTest性能测试工具监控指定进程，通过上传或下载指定大小的数据来测试上传与下载过程中数据接收的速度。在文件上传或下载的速度测试过程中以采样时间段速度的形式进行平均速度的计算。以下是采样测试结果。</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps35.jpg" alt="img"> </p>
<p>图6-2 虚拟机服务端环境性能测试</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml11024\wps36.jpg" alt="img"> </p>
<p>图6-3 阿里云服务端环境性能测试</p>
<h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7  总结"></a>7  总结</h1><p>作为大学四年知识汇聚的结晶，基于云存储的图像管理平台的设计与实现最终顺利完成。该平台尽管采用C++设计，但所包含的技术点却很多。</p>
<p>首先服务端的架构就包含分布式文件系统、持久化数据库、非关系型数据库、负载均衡等比较新但应用很广的技术，这些技术原本只能通过书籍或课堂接触，而通过本平台的设计均得到了实践，因此对今后应用的开发有着启迪性的作用；同时，对于目前服务端主流的分布式文件系统、Redis、MySQL、Nginx等应用较广的技术的使用越来越熟练。由于服务端部署在Linux操作系统上，同时用到很多云计算相关技术，为之后无论是应用开发还是大数据开发均提供了宝贵的经验。</p>
<p>客户端通过Qt设计，而Qt作为C++跨平台界面开发的工具，里面支持包括Lambda表达式等一系列C++11特性，同时包含很多通过C++实现的比较新的技术。在设计客户端的同时，不仅巩固了C++基础，同时也为客户端相关的开发积累了丰富的经验。</p>
<p>刚开始设计该平台时，我还没有多少项目开发经验，但由于该应用的功能正好用处很广，不仅可以用来作为文件存储的云盘，同时还可以作为图床供博客使用，因此满怀兴趣的我开始查阅云存储相关的资料。在学习的过程中，不仅掌握了目前时代较前沿的技术，同时也拓展了视野，认识到纸上得来终觉浅，作为开发者不仅需要不断学习，更重要的是进行实践，有了足够的设计经验，对于新的技术学起来会非常快，这样才能跟随时代发展而不被时代所甩掉。</p>
<p>该平台作为较完整的项目，我将会通过GitHub将该平台开源化，供其他开发者使用的同时进行学习与交流，为开源软件贡献一份尽管微不足道但充满诚意的力量。</p>
<h1 id="致-谢"><a href="#致-谢" class="headerlink" title="致 谢"></a>致 谢</h1><p>首先，我要感谢我的指导老师——齐勇老师。此次基于云存储的图像管理平台设计与实现以及毕业论文的撰写与完善均是在齐勇老师的耐心辅导下完成的，从毕业设计开题到毕业论文的完善，齐老师都定期查看，悉心辅导，同时推荐了许多有用的材料，给予我很多有价值的建议。尽管由于一系列不可控因素的存在，导致此次毕业设计齐老师只能通过线上的方式指导，但齐老师那对于学术的严谨态度、对于项目的精益求精品质都使我受益匪浅。正因为齐老师这种认真负责的责任感以及对学生细致入微的关爱，让我一次次在面对压力与困难时从未妥协，也正因为有齐老师的指导我才可以顺顺利利地完成这次毕业设计。</p>
<p>其次，我还要感谢和同一毕业小组的同学们，在完成毕业设计的时光里我们互相勉励，一起解决了毕业设计中的一个个问题，一起进步与成长。纵使日后各奔东西，曾经的这份共情仍在。</p>
<p>在我们即将踏出校门步入社会之际，我的思绪万千，曾几何时懵懵懂懂地踏入大学校门，连最基本的编程都还没学，而现在已经能够独立自主设计一个完整的项目，这背后不仅包含自身的努力与付出，更映射着学校的栽培、老师的关爱、辅导员的呵护以及同学们的互助。因此我向你们致以我最真挚的感激，感谢一路有你们伴我度过这段有欢笑、有快乐、有付出、有收获的大学时光。</p>
<h1 id="参-考-文-献"><a href="#参-考-文-献" class="headerlink" title="参 考 文 献"></a>参 考 文 献</h1><p>[1]  张雨, 蔡鑫, 李爱民, 等. 分布式文件系统与 MPP 数据库的混搭架构在电信大数据平台中的应用[J]. 电信科学, 2013, 29(11): 12-16.</p>
<p>[2]  王波. 基于FastDFS的轻量级分布式文件系统的设计与实现[D]. 东北大学,2013.</p>
<p>[3]  巨头的云计算,谁将是下一个霸主?[J]. 软件, 2018, 39(06): 224-227.</p>
<p>[4]  杨正洪. 智慧城市: 大数据, 物联网和云计算之应用[M]. 清华大学出版社, 2017.</p>
<p>[5]  陈肇雄. 推进工业和信息化高质量发展[J]. 网信军民融合,2019(07):5-7.</p>
<p>[6]  徐为成. 5G时代 云计算发展的五大新趋势[J]. 通信世界,2019(20):46.</p>
<p>[7]  Li S, Da Xu L, Zhao S. 5G Internet of Things: A survey[J]. Journal of Industrial Information Integration, 2018, 10: 1-9.</p>
<p>[8]  本刊讯. 工信部印发《云计算发展三年行动计划(2017-2019年)》[J]. 中国公共安全, 2017(05): 20.</p>
<p>[9]  Singh J. Study on challenges, opportunities and predictions in cloud computing[J]. International Journal of Modern Education and Computer Science, 2017, 9(3): 17.</p>
<p>[10]  Jiang C, Wang Y, Ou D, et al. Energy efficiency comparison of hypervisors[J]. Sustainable Computing: Informatics and Systems, 2019, 22: 311-321.</p>
<p>[11]  Mesran M, Abdullah D, Hartama D, et al. Combination Base64 and Hashing Variable Length for Securing Data[C]//Journal of Physics: Conference Series. 2018, 1028: 012056.</p>
<p>[12]  刘佳祎,崔建明,智春. 基于Nginx服务器的动态负载均衡策略研究[J/OL]. 桂林理工大学学报:1-11[2020-06-22].</p>
<p>[13]  Hallberg J. Memcached och Redis cachning på lokalt system i en dator[J]. 2019.</p>
<p>[14]  张兰. 基于云计算的电子商务数据缓存处理的研究[J]. 电脑知识与技术,2016,12(23):249-250.</p>
<p>[15]  余庆. 分布式文件系统 FastDFS 架构剖析[J]. 程序员, 2010 (11): 63-65.</p>
<p>[16]  阮光耀. 基于负载均衡的FastDFS新存储节点的同步任务分配策略研究[D]. 武汉纺织大学,2019.</p>
<p>[17]  赵晔. 基于Nginx的Web后端服务器集群负载均衡技术的研究与改进[D]. 昆明理工大学,2017.</p>
<p>[18]  Chen X, Song Y, Ye H, et al. Research and Implementation of Digital Ancient Book Library Based on Solr/Lucene[J]. 2018.</p>
<p>[19]  许红军. 灵活配置,强化Nginx安全管理[J]. 网络安全和信息化,2018(06):132-135.</p>
<p>[20]  Eng L Z. Qt5 C++ GUI programming cookbook[M]. Packt Publishing Ltd, 2016.</p>
<p>[21]  Pospelov G. Developing BornAgain graphical user interface: lessons learned[C]//Workshop on Neutron Scattering Data Analysis Software. 2018, 6: 8.</p>
<p>[22]  陶文玲,侯冬青. PyQt5与Qt设计师在GUI开发中的应用[J]. 湖南邮电职业技术学院学报,2020,19(01):19-21.</p>
<p>[23]  李飞. 基于C/S模式的图件管理系统的构建[J]. 科技视界,2019(27):39-41.</p>
<p>[24]  石珊. 云平台下基于FastDFS的文件管理系统的研究与实现[D]. 电子科技大学,2019.</p>
<p>[25]  Bhandari A, Bhuiyan M, Prasad P W C. Enhancement of MD5 Algorithm for Secured Web Development[J]. JSW, 2017, 12(4): 240-252.</p>
<p>[26]  Carlson J L. Redis in action[M]. Manning Publications Co., 2013.</p>
<p>[27]  张云, 许江淳, 李玉惠, 等. 基于 Nginx 服务器负载均衡技术的研究与改进[J]. 软件, 2017, 38(8): 6-12.</p>
<p>[28]  王宁. 基于分布式云平台视频存储及管理[D]. 中国石油大学(华东),2016.</p>
<p>[29]  孔德云. 基于FastDFS的大并发问题的研究与应用[D]. 中北大学,2017.</p>
<p>[30]  Bourhis P, Reutter J L, Suárez F, et al. JSON: data model, query languages and schema specification[C]//Proceedings of the 36th ACM SIGMOD-SIGACT-SIGAI symposium on principles of database systems. 2017: 123-135.</p>
<p>[31]  杨丽波. 浅析集成测试和系统测试的关系[J]. 电子测试,2017(20):109-110.</p>
<p>[32]  范方政. 软件测试技术与缺陷跟踪管理的应用研究[D]. 吉林大学,2014.</p>
<p>[33]  朱健. 基于Qt Test的自动化单元测试[J]. 价值工程,2017,36(14):216-219.</p>
<h1 id="附-录"><a href="#附-录" class="headerlink" title="附 录"></a>附 录</h1><p><a href="#_Toc30457">图3-1  FastDFS分布式文件系统结构    7</a></p>
<p><a href="#_Toc2862">图3-2  FastDFS分布式文件系统集群    8</a></p>
<p><a href="#_Toc4893">图3-3  反向代理服务器原理    9</a></p>
<p><a href="#_Toc32637">图4-1  总体设计框架    12</a></p>
<p><a href="#_Toc29224">图4-2  总体方案结构    13</a></p>
<p><a href="#_Toc16969">图4-3  用户注册流程图    15</a></p>
<p><a href="#_Toc31498">图4-4  用户登录流程图    16</a></p>
<p><a href="#_Toc28835">图4-5  文件列表查询流程图    16</a></p>
<p><a href="#_Toc9982">图4-6  数据秒传流程图    17</a></p>
<p><a href="#_Toc24130">图4-7  数据上传流程图    18</a></p>
<p><a href="#_Toc32014">图4-8  文件删除流程图    19</a></p>
<p><a href="#_Toc3366">图4-9  文件共享流程图    20</a></p>
<p><a href="#_Toc26329">图4-10  文件下载流程图    21</a></p>
<p><a href="#_Toc18554">图4-11  图像预览流程图    21</a></p>
<p><a href="#_Toc17044">图4-12  客户端总体流程图    23</a></p>
<p><a href="#_Toc26303">图4-13  服务端总体流程图    24</a></p>
<p><a href="#_Toc22095">图5-1  数据库表结构    26</a></p>
<p><a href="#_Toc30503">图 5-2  用户界面结构    29</a></p>
<p><a href="#_Toc2169">图5-3  登录界面效果图    31</a></p>
<p><a href="#_Toc24127">图5-4  注册界面效果图    31</a></p>
<p><a href="#_Toc423">图5-5  文件界面结构    32</a></p>
<p><a href="#_Toc9681">图5-6  文件界面导航栏    33</a></p>
<p><a href="#_Toc7057">图5-7  我的文件效果图    34</a></p>
<p><a href="#_Toc1033">图5-8  共享列表效果图    34</a></p>
<p><a href="#_Toc16733">图5-9  下载榜效果图    35</a></p>
<p><a href="#_Toc24022">图5-10  传输列表效果图    35</a></p>
<p><a href="#_Toc9505">图5-11  配置设置效果图    37</a></p>
<p><a href="#_Toc18579">图5-12  任务进度图    38</a></p>
<p><a href="#_Toc28323">图5-13 上传任务界面效果图    38</a></p>
<p><a href="#_Toc20199">图5-14  图像预览列表图    45</a></p>
<p><a href="#_Toc18275">图6-1  GUI单元测试部分结果    48</a></p>
<p><a href="#_Toc31978">图6-2  虚拟机服务端环境性能测试    52</a></p>
<p><a href="#_Toc26587">图6-3  阿里云服务端环境性能测试    52</a></p>
]]></content>
  </entry>
  <entry>
    <title>请逗留一刻吧，是那样美丽</title>
    <url>/2020/05/14/2020-05-14/</url>
    <content><![CDATA[<p>你只管努力，一切交给天意。很久前便听过这句话，听起来挺励志的，就像我的大四。然而随着涉世越来越深，我却渐渐明白，很多事情其实不是我们能决定的，哪怕独自再怎么努力。曾经年少轻狂，某人给我贴上了“自以为是”的标签而离开。四年时间，我逐渐磨灭了的脾气，收敛了的锋芒，处处考虑别人感受，向着某人所期待的模样改变，结果最后还是换来某人一句“自以为是”而结束。我不断为维持我们的联系而努力，尽管她从来不曾考虑过我们的感情如何经营。所以当再次约她时，最终仍然换得一句“你太自以为是了”而结束，这一次我反而释怀了，因为我明白了，自以为是的不是我。我终于明白，在感情的世界里，一个人的努力是不够的，感情是需要两个人共同经营的。而且感情的世界最主要的是平等，一旦一方失去平衡，感情很难维护。试想一下，假如对方享受惯了被追的感觉，对你爱理不理，你再怎么努力都是白费，因为你再怎么努力也唤不醒一个装睡的人。感情如此，人生亦如此。就像我努力求职，最终成功签约心仪的公司，然而却因学校方面的一个简简单单的手续卡了我三个月。我终于明白，有时候，即使你努力，也白费，你的命运常常需要交到其他人手上，所以，人脉很重要。</p>
<p>曾经我也想过一了百了。</p>
<p>在疫情爆发的那段岁月里，每一天都是浑浑噩噩，一方面因为久久得不到学校方面的任何消息，使得我的精神饱受折磨；另一方面由于长期受到鼻炎的困扰，导致每天从睁开眼开始便是噩梦。就这样，一天天消磨着时间，每天都想做出改变，但每天都重复着昨天的过程。我常常在想，为什么上帝总是选择我，明明我只想安安稳稳，却总是被命运推着起起伏伏；明明想从今天起做出改变，但依旧重复着单调的生活。</p>
<p>那段时间，我总是把自己封闭起来，把所有情绪包裹在肚子里，不像任何人诉说心里的苦，即使对家人也不例外，因此家里人并不太清楚具体发生的事情。因此某天因为没有获得返校的资格而心中一肚子委屈，终于在吃饭时全部宣泄到了家人的身上。小时候每次发火，母亲总是忍耐我，而其他人骂我；但随着我的成长，懂得东西越来越多，家里人都知道说不过我，所以每次在我发火时，其他人反而总是忍耐我，只有母亲开始反驳我。我知道，母亲是怕我误入歧途，随着我的经历越来越多，没人再能管我，所以每次当我做错事或者宣泄情绪时，只有母亲站了出来。这一次所有人都开始劝我母亲不要再说下去，而我母亲却一直在指我错误的地方。终于当我母亲说理解我最近的心情，我说“你理解个屁”时，我母亲又一次哭了，或许是因为激动，或许是因为听到我受到委屈。那天，我上楼后，长期以来积在心里的委屈，终于以眼泪的形式散落出来。我躲在房间里哭的歇斯底里，或许因为委屈，或许因为母亲。</p>
<p>很长时间我常常想着如何没有痛苦地一了百了，但每当想起之后家人的眼泪，就打消了这个念头。有时候甚至抱怨，明明疫情把我的精神璀璨的支离破碎，为什么不让我患上肺炎，这样至少我便有了死去的理由，不用担心受到别人的谴责，或许这只是我想逃避一切的借口吧。</p>
<p>自疫情以来，我越来越喜欢睡觉，也越来越容易做梦。因为我发现当心情不好时，睡一觉什么都过去了，心情也好了，同时梦里的世界总是那么美好。某一天梦里，因为衣服脏了，我开始抱怨，结果母亲骂了我，随后因为意外我真的死去了。然后我以上帝视角看着一切，在我死后，我获得了想要的一切，我获得了所有的闪卡（可能和我玩的游戏有关），美国总统宣布我生前对世界的贡献（可能与每天的新闻报道有关），街头小巷也放映着我喜欢但不被大众接受的音乐（可能因为华晨宇得歌王后被大众黑），尽管我得到了一切，但是我已经死了，那一刻，我在呐喊，多希望上帝赋予我生命，哪怕一切化为乌有。我终于明白，当我死后我是多么希望我活下去。有时候不得不承认，梦虽然荒诞，像《爱丽丝梦游仙境》或者《红辣椒》一样，但却是我们潜意识真实的感受，像《夏洛特烦恼》，鼓舞我们继续向前，或许这一切都是上帝的指示，就像但丁的《神曲》。于是，我醒了，带着生的希望。</p>
<p>用漫不经心的态度，过随遇而安的生活。</p>
<p>虽然打消了死亡的念头，但生活中的无奈并未消退。曾经天天蹲教育厅，终于教育厅宣布可以开学了，于是蹲学校。然而当知道自己没办法去学校，而自己可能因为意外而面临失业时，犹如晴空霹雳，渐渐地，我不再去关注任何开学的消息，对生活也渐渐失去希望。某天夜里，我睁开了眼，却无法动，眼前一副鬼脸，一根棒子压着我，就像雷神的锤子落在洛基身上，施了魔法一样，明明意识想控制身体，但就是无法动。我清楚，这是魔鬼的考验，于是用尽全身的力气动了动手指，最终拜托了魔鬼的困扰。尽管这次成功了，但生活的烦恼越来越多。</p>
<p>后来发现了《与神对话》这部作品，于是一段时间生活又充满了阳光，开始了等待。然而迟迟等不到开学的消息，反而等来越来越多不好的消息。我开始埋怨，明明一个章的事情，结果拖了我三个月没有消息，眼前政府贪污，但至少有钱可以办事，现在政府领导们不接受贿赂，但也不愿承担风险，有钱也没办法。看着自己可能面临失业，我开始抱怨制度，甚至渐渐开始质疑上帝。某天梦里，我躺在床上，魔鬼抱起了我，而我却欣然接受了。然后我便醒了，我知道，这一刻，我已离上帝越来越远，渐渐变成了魔鬼。</p>
<p>然而事情总有解决的途径，上帝通过考验使人成长，但所有的苦难都是人们所能承受的。当困扰我三个月的问题有了解决途径时，我终于明白，其实之所以被困扰，完全是我自己困扰着我自己。每个人都只能通过自己的方式来认识世界，我们没办法感受别人的心情。也许在你看来很复杂的事情其实并没有那么复杂，在你看来很重要的事情别人可能并不了解情况，所有的困扰都是我们自己给自己带来的。当我们抱怨自己的命运在别人的一念之间，自己所有的努力都没有任何作用时，不妨多从别人的角度看待问题，多沟通，一切并不难解决。</p>
<p>在心门终于打开那一刻，我来到了天台，夕阳照在身上，群鸟飞翔，一切充满了生机。我知道，上帝不会放弃每一个人。</p>
<p>请逗留一刻吧，是那样美丽。</p>
]]></content>
  </entry>
  <entry>
    <title>分布式云盘部署服务端的漫漫bug路</title>
    <url>/2020/03/13/2020-03-13/</url>
    <content><![CDATA[<p>云盘服务端代码经历两天bug之后终于部署到了自己的服务器上。因此总结一下这两天所出现的所有问题，日后再出现同样的问题便可解决。</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ol>
<li><p>服务端代码部署到虚拟机并启动</p>
</li>
<li><p>发现问题，Qt客户端注册与登录无响应</p>
</li>
<li><p>检查客户端登录注册代码，发现没有问题</p>
</li>
<li><p>检查客户端收到的错误码，发现客户端并未收到服务端反馈的错误码</p>
</li>
<li><p>查询服务端Nginx服务器log日志，发现80端口请求注册登录端口未成功</p>
</li>
<li><p>检查登录注册端口，发现未启动端口，排除客户端的问题</p>
</li>
<li><p>关闭防火墙，仍无法启动端口</p>
</li>
<li><p>重新启动服务端代码，查看服务端cgi程序的log日志，发现并没有log日志</p>
</li>
<li><p>spawn-fcgi启动报错提示spawn-fcgi: child exited with: 127</p>
</li>
<li><p>尝试执行 <code>spawn-fcgi</code> 命令 ，发现没有问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qianyouyou:~ $ spawn-fcgi</span><br><span class="line">Usage: spawn-fcgi [options] [-- &lt;fcgiapp&gt; [fcgi app arguments]]</span><br><span class="line">spawn-fcgi v1.6.5 - spawns FastCGI processes</span><br><span class="line">Options:</span><br><span class="line">省略一万字</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行cgi程序，发现问题<code>No such file or directory</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 找一下 libfcgi.so 位置在哪里。</span><br><span class="line">qianyouyou:~ $ whereis libfcgi.so</span><br><span class="line">libfcgi: /usr/local/lib/libfcgi.so /usr/local/lib/libfcgi.a /usr/local/lib/libfcgi.la</span><br><span class="line"></span><br><span class="line"># 然后查看一下 /usr/local/lib/ 下面有什么。</span><br><span class="line">qianyouyou:~ $ ll /usr/local/lib/libfcgi.so*</span><br><span class="line">lrwxrwxrwx 1 root root   16 Jan  8 16:07 /usr/local/lib/libfcgi.so -&gt; libfcgi.so.0.0.0*</span><br><span class="line">-rwxr-xr-x 1 root root 124K Jan  8 16:07 /usr/local/lib/libfcgi.so.0.0.0*</span><br><span class="line"></span><br><span class="line"># 原来没有 libfcgi.so.0 这个文件， 那我们就创造一个吧。</span><br><span class="line">qianyouyou:~ $ sudo ln -s /usr/local/lib/libfcgi.so.0.0.0 /usr/local/lib/libfcgi.so.0</span><br><span class="line"></span><br><span class="line"># 执行cgi还是不行，于是我把 libfcgi.so.0 在 /usr/lib64/ 和 /usr/lib/ 里都链接了一份。</span><br><span class="line">qianyouyou:~ $ sudo ln -s /usr/local/lib/libfcgi.so.0.0.0 /usr/lib/libfcgi.so.0</span><br><span class="line">qianyouyou:~ $ sudo ln -s /usr/local/lib/libfcgi.so.0.0.0 /usr/lib64/libfcgi.so.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//fcgi和glog都需要建立软连接, 正常情况下只要在/usr/lib目录下建立链接就可以了，如果不行的话在/usr/lib64目录下也建立链接</span><br><span class="line"># ln -s /usr/local/lib/libfcgi.so.0  /usr/lib/libfcgi.so.0</span><br><span class="line"># ln -s /usr/local/lib/libfcgi.so.0  /usr/lib64/libfcgi.so.0</span><br><span class="line"># ln -s /usr/local/lib/libglog.so.0  /usr/lib/libglog.so.0</span><br><span class="line"># ln -s /usr/local/lib/libglog.so.0  /usr/lib64/libglog.so.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>依然提示<code>No such file or directory</code>，重新make编译代码，提示找不到<code>mysql/mysql.h</code></p>
</li>
<li><p>发现问题，虚拟机装了mysql-server，没有装mysql-devel，安装mysql-devel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Ununtu安装</span><br><span class="line">sudo apt-get install libmysql++-dev</span><br><span class="line"># CentOS安装</span><br><span class="line">sudo yum install -y mysql-devel</span><br></pre></td></tr></table></figure>
</li>
<li><p>make成功，重新启动成功，查看相应端口已启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -ant | grep 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端登录注册失败，返回错误码，查询服务端log日志，发现没有相应数据库表</p>
</li>
<li><p>远程链接数据库，创建相应数据表</p>
</li>
<li><p>虚拟机服务端部署成功</p>
</li>
<li><p>代码部署到服务器，make同样提示没有<code>mysql/mysql.h</code></p>
</li>
<li><p>安装mysql-devel未成功，提示冲突</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transaction check error: file /usr/include/mysql/client_plugin.h from install of mariadb-1:5.5.41-2.el7_0.x86_64 conflicts with file from package MySQL-client-5.0.96-1.glibc23.x86_64</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>查阅yum安装如何避免冲突，删掉冲突文件，均没有用(后发现由于文件夹为软连接)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yum查看依赖库</span><br><span class="line">yum search mysql</span><br><span class="line"></span><br><span class="line">yum install mysql-devel --exclude a    #a为冲突包名</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于已安装mysql为自定义文件夹，因此锁定问题为找不到自定义文件夹库</p>
</li>
<li><p>创建预编译链接，创建静态库动态库链接。<a href="https://blog.csdn.net/qq_22203741/article/details/77742800" target="_blank" rel="noopener">查阅</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一次性命令</span><br><span class="line">export C_INCLUDE_PATH=/www/server/mysql/include:$C_INCLUDE_PATH</span><br><span class="line">export CPLUS_INCLUDE_PATH=/www/server/mysql/include:$CPLUS_INCLUDE_PATH</span><br><span class="line">export LD_LIBRARY_PATH=/www/server/mysql/lib:$LD_LIBRARY_PATH</span><br><span class="line">export LIBRARY_PATH=/www/server/mysql/lib:$LIBRARY_PATH</span><br><span class="line"></span><br><span class="line"># 所有用户都执行需将以上命令添加至/etc/profile</span><br><span class="line"></span><br><span class="line"># 动态库路径可添加至/etc/ld.so.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>make成功，但除了login与upload外其余端口均为启动</p>
</li>
<li><p>执行login可执行文件，提示没有<code>libmysqlcient.so.20</code></p>
</li>
<li><p>下载libmysqlclient.so.20，执行可执行文件，仍然报错</p>
</li>
<li><p>更换mysql版本为5.7</p>
</li>
<li><p>原本部署的博客无法访问。重新配置博客，博客访问成功。<a href="http://jpress.io/article/category/install" target="_blank" rel="noopener">网站1</a><a href="https://blog.shiyunhong.com/3025.html" target="_blank" rel="noopener">网站2</a></p>
</li>
<li><p>服务端重新启动，云盘服务端启动成功</p>
</li>
<li><p>客户端启动，可注册，不可登录</p>
</li>
<li><p>检查服务端代码，发现代码没问题</p>
</li>
<li><p>重新编译，提示没有任何文件改动，删除cgi所有.o文件，重新编译成功。</p>
</li>
<li><p>服务器云盘部署成功。</p>
</li>
</ol>
<h1 id="防火墙相关"><a href="#防火墙相关" class="headerlink" title="防火墙相关"></a>防火墙相关</h1><p>一、CentOS 7快速开放端口：</p>
<p>CentOS升级到7之后，发现无法使用iptables控制Linuxs的端口，baidu之后发现Centos 7使用firewalld代替了原来的iptables。下面记录如何使用firewalld开放Linux端口：</p>
<p>开启端口</p>
<p>[root@centos7 ~]# firewall-cmd –zone=public –add-port=80/tcp –permanent</p>
<p>查询端口号80 是否开启：</p>
<p>[root@centos7 ~]# firewall-cmd –query-port=80/tcp</p>
<p>重启防火墙：</p>
<p>[root@centos7 ~]# firewall-cmd –reload</p>
<p>查询有哪些端口是开启的:</p>
<p>[root@centos7 ~]# firewall-cmd –list-port</p>
<p>命令含义：</p>
<p>–zone #作用域<br>–add-port=80/tcp #添加端口，格式为：端口/通讯协议<br>–permanent #永久生效，没有此参数重启后失效</p>
<p>关闭firewall：</p>
<p>systemctl stop firewalld.service #停止firewall</p>
<p>systemctl disable firewalld.service #禁止firewall开机启动</p>
<p>二、CentOS6防火墙开放端口：</p>
<p>在我们使用CentOS系统的时候，CentOS防火墙有时是需要改变设置的。CentOS防火墙默认是打开的，设置CentOS防火墙开放端口方法如下：</p>
<p>打开iptables的配置文件：vi /etc/sysconfig/iptables</p>
<p>修改CentOS防火墙时注意：一定要给自己留好后路,留VNC一个管理端口和SSh的管理端口</p>
<p>下面是一个iptables的示例：</p>
<p># Firewall configuration written by system-config-securitylevel<br># Manual customization of this file is not recommended.<br>*filter<br>:INPUT ACCEPT [0:0]<br>:FORWARD ACCEPT [0:0]<br>:OUTPUT ACCEPT [0:0]<br>:RH-Firewall-1-INPUT - [0:0]<br>-A INPUT -j RH-Firewall-1-INPUT<br>-A FORWARD -j RH-Firewall-1-INPUT<br>-A RH-Firewall-1-INPUT -i lo -j ACCEPT<br>-A RH-Firewall-1-INPUT -p icmp –icmp-type any -j ACCEPT<br>-A RH-Firewall-1-INPUT -p 50 -j ACCEPT<br>-A RH-Firewall-1-INPUT -p 51 -j ACCEPT<br>-A RH-Firewall-1-INPUT -m state –state ESTABLISHED,RELATED -j ACCEPT<br>-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 53 -j ACCEPT<br>-A RH-Firewall-1-INPUT -m state –state NEW -m udp -p udp –dport 53 -j ACCEPT<br>-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT<br>-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 25 -j ACCEPT<br>-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT<br>-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 443 -j ACCEPT<br>-A RH-Firewall-1-INPUT -j REJECT –reject-with icmp-host-prohibited<br>COMMIT</p>
<p>修改CentOS防火墙需要注意的是，你必须根据自己服务器的情况来修改这个文件。</p>
<p>举例来说，如果你不希望开放80端口提供web服务，那么应该相应的删除这一行：<br>-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT</p>
<p>全部修改完之后重启iptables:service iptables restart</p>
<p>你可以验证一下是否规则都已经生效：iptables -L</p>
<p>这样，我们就完成了CentOS防火墙的设置修改。</p>
<h1 id="库相关"><a href="#库相关" class="headerlink" title="库相关"></a>库相关</h1><p><strong>方法一：在编译自己的项目时添加-L和-I编译选项</strong></p>
<p> 1）添加头文件路径： -I     #指明头文件的路径  </p>
<p>2）添加库文件路径： -L    #指定目录。link的时候，去找的目录。gcc会先从-L指定的目录去找，然后才查找默认路径。（告诉gcc,-l库名最可能在这个目录下）。 -l     #指定文件（库名），linking options  </p>
<p>注：-l紧接着就是库名，这里的库名不是真正的库文件名。比如说数学库，它的库名是m，他的库文件名是libm.so。再比如说matlab eigen库，它的库名是eng，它的库文件名是libeng.so。很容易总结得：把库文件名的头lib和尾.so去掉就是库名了。在使用时，“-leng”就告诉gcc在链接阶段引用共享函数库libeng.so。</p>
<p><strong>方法二：将库路径添加到环境变量</strong></p>
<p>1）添加头文件路径：  在/etc/profile中添加（根据语言不同，任选其一）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export C_INCLUDE_PATH=C_INCLUDE_PATH:头文件路径            #c </span><br><span class="line"></span><br><span class="line">export CPLUS_INCLUDE_PATH=CPLUS_INCLUDE_PATH:头文件路径    #c++ </span><br><span class="line"></span><br><span class="line">export OBJC_INCLUDE_PATH=OBJC_INCLUDE_PATH:头文件路径      #java</span><br></pre></td></tr></table></figure>
<p>终端重启后需执行一次source。 </p>
<p>另有一种方法：在/etc/ld.so.conf文件中加入自定义的lib库的路径，然后执行<code>sudo /sbin/ldconfig</code>，这个方法对所有终端有效。  </p>
<p>2）添加库文件路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LIBRARY_PATH    #used by gcc before compilation to search for directories containing libraries that need to be linked to your program.</span><br><span class="line">LD_LIBRARY_PATH    #used by your program to search for directories containing the libraries after it has been successfully compiled and linked.</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATLAB=/opt/MATLAB/R2012a</span><br><span class="line">export LIBRARY_PATH=$LIBRARY_PATH:$MATLAB/bin/glnxa64</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$MATLAB/bin/glnxa64</span><br></pre></td></tr></table></figure>
<p>题外话，顺便提一下LIBRARY_PATH和LD_LIBRARY_PATH的区别： </p>
<p>我们知道Linux下有2种库：static libraries和shared libraries。如（这里）阐述的，静态库是在编译期间会被链接并拷贝到你的程序中，因此运行时不再需要该静态库。动态库在编译时并不会被拷贝到你的程序中，而是在程序运行时才被载入，因此在程序运行时还需要动态库存在，这时就会用到LD_LIBRARY_PATH指定的路径去查找这个动态库。The libraries can be static or shared. If it is static then the code is copied over into your program and you don’t need to search for the library after your program is compiled and linked. If your library is shared then it needs to be dynamically linked to your program and that’s when LD_LIBRARY_PATH comes into play.</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>库文件在连接（静态库和共享 库）和运行（仅限共享库的程序，静态库会和可执行编译到一起）时被使用，其搜索路径是在系统中进行设置的。一般 Linux 系统把 /lib 和 /usr/lib 两个目录作为默认的库搜索路径，所以使用这两个目录中的库时不需要进行设置搜索路径即可直接使用。对于处于默认库搜索路径之外的库，需要将库的位置添加到 库的搜索路径之中。</p>
<p>设置库文件的搜索路径总的来说有以下几种：</p>
<ul>
<li>LIBRARY_PATH、LD_LIBRARY_PATH等 环境变量：指定连接、运行时库文件路径；</li>
<li>/etc/ld.so.conf 文件：添加链接时库文件的搜索路径，运行时还需要使用ldconfig命令将路径刷新到ld.so.cache中；</li>
<li>g++/gcc参数-L、-l、-I：指定链接时库文件的路径、名字和头文件，运行时还需要使用环境变量或者在文件/etc/ld.so.conf中指定（或者放到默认/lib路径），然后ldconfig；</li>
</ul>
<p>在/etc/profile中添加如下环境变量。</p>
<p> 编译时用到的环境变量： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#gcc找到头文件的路径</span><br><span class="line">C_INCLUDE_PATH=/usr/include/libxml2:/MyLib</span><br><span class="line">export C_INCLUDE_PATH</span><br><span class="line"> </span><br><span class="line">#g++找到头文件的路径</span><br><span class="line">CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/include/libxml2:/MyLib</span><br><span class="line">export CPLUS_INCLUDE_PATH</span><br><span class="line"> </span><br><span class="line">#gcc和g++在编译的链接(link)阶段查找库文件的目录列表</span><br><span class="line">LIBRARY_PATH=$LIBRARY_PATH:/MyLib</span><br><span class="line">export LIBRARY_PATH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对于头文件的搜索路径:export  C_INCLUDE_PATH=&lt;your include path&gt;;</span><br><span class="line">对于库文件的搜索路径:export  LIBRARY_PATH=&lt;your lib path&gt;;</span><br></pre></td></tr></table></figure>
<p>运行时环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#程序运行时查找ku文件的路径</span><br><span class="line">LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/MyLib</span><br><span class="line">export LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>
<h1 id="mysql相关"><a href="#mysql相关" class="headerlink" title="mysql相关"></a>mysql相关</h1><h2 id="设置远程连接"><a href="#设置远程连接" class="headerlink" title="设置远程连接"></a>设置远程连接</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><ol>
<li><p>编辑mysql配置文件，把其中<code>bind-address = 127.0.0.1</code>注释了。<code>vi /etc/mysql/mysql.conf.d/mysqld.cnf</code> </p>
</li>
<li><p>使用root进入mysql命令行，执行如下2个命令，示例中mysql的root账号和密码：root</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line">grant all privileges on 库名.表名 to &apos;用户名&apos;@&apos;IP地址&apos;</span><br><span class="line">identified by &apos;密码&apos; with grant option;</span><br><span class="line"></span><br><span class="line">#例：</span><br><span class="line">mysql&gt; grant all on . to root@&apos;%&apos; identified by &apos;root&apos; with grant option;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>重启mysql<code>/etc/init.d/mysql restart</code></li>
</ol>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><ol>
<li>编辑mysql配置文件，把其中bind-address = 127.0.0.1注释了。<code>vi /etc/mysql/mysql.conf.d/mysqld.cnf</code> </li>
<li>使用root进入mysql命令行，执行如下2个命令，示例中mysql的root账号密码：root</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   mysql –u root -p        </span><br><span class="line"></span><br><span class="line">   mysql&gt; use mysql; </span><br><span class="line"></span><br><span class="line">   mysql&gt; update user set host = &apos;%&apos; where user = &apos;root&apos;;</span><br><span class="line"></span><br><span class="line">   mysql&gt; flush privileges;</span><br><span class="line">   </span><br><span class="line">#第一句是以权限用户root登录</span><br><span class="line">#第二句：选择mysql库</span><br><span class="line">#第三句：修改host值（以通配符%的内容增加主机/IP地址），当然也可以直接增加IP地址</span><br><span class="line">#第四句：刷新MySQL的系统权限相关表</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>重启mysql<code>/etc/init.d/mysql restart</code></li>
</ol>
<h2 id="修改MySQL默认编码"><a href="#修改MySQL默认编码" class="headerlink" title="修改MySQL默认编码"></a>修改MySQL默认编码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">......  </span><br><span class="line">[mysqld]  </span><br><span class="line">......   </span><br><span class="line">character-set-server=utf8  </span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h2 id="设置表名不区分大小写"><a href="#设置表名不区分大小写" class="headerlink" title="设置表名不区分大小写"></a>设置表名不区分大小写</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">......  </span><br><span class="line">[mysqld]  </span><br><span class="line">......   </span><br><span class="line">character-set-server=utf8</span><br><span class="line">lower_case_table_names=1</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h1 id="Jpress相关"><a href="#Jpress相关" class="headerlink" title="Jpress相关"></a>Jpress相关</h1><h2 id="通过宝塔进行安装"><a href="#通过宝塔进行安装" class="headerlink" title="通过宝塔进行安装"></a>通过宝塔进行安装</h2><p>宝塔是一个优秀的可视化服务器管理工具，提供了web操作面板，方便我们通过宝塔的web面板对服务器进行管理，例如</p>
<p>1、数据库安装、账号密码管理和数据管理 2、FTP账号的管理 3、各种服务器软件的安装，php、tomcat、nginx等 4、文件管理</p>
<p>宝塔的官网网站： <a href="http://www.bt.cn/" target="_blank" rel="noopener">http://www.bt.cn</a></p>
<p>通过宝塔进行安装 JPress，大概分为以下几个步骤：</p>
<p>1、购买服务器并安装宝塔 2、通过宝塔的后台面板安装nginx、Mysql和tomcat。 3、创建网站，并启用tomcat功能 4、上传JPress的war包，并解压缩 5、访问网站，走jpress自动安装过程</p>
<h3 id="1、购买服务器并安装宝塔"><a href="#1、购买服务器并安装宝塔" class="headerlink" title="1、购买服务器并安装宝塔"></a>1、购买服务器并安装宝塔</h3><p>购买服务器建议购买阿里云的 centos 7.4 以上 ，里面不要安装其他任何功能（笔者在centos 7.2 下安装宝塔，nginx是无法使用的，centos 7.4 没问题）</p>
<p>安装宝塔非常简单，用 root 账号进入Linux服务，然后执行如下命令即可自动安装宝塔：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://</span><br><span class="line">download.bt.cn/install/install_6.0.sh &amp;&amp; bash install.sh</span><br></pre></td></tr></table></figure>
<p>需要注意的是：安装的过程中控制台会打印安装的过程，在安装完成后，控制台会输出宝塔的登陆地址、账号和密码。</p>
<p>重要事情说三遍：</p>
<blockquote>
<p>登陆地址、账号和密码，这部分务必要记住。 登陆地址、账号和密码，这部分务必要记住。 登陆地址、账号和密码，这部分务必要记住。</p>
</blockquote>
<h3 id="2、通过宝塔的后台，安装nginx、mysql和tomcat"><a href="#2、通过宝塔的后台，安装nginx、mysql和tomcat" class="headerlink" title="2、通过宝塔的后台，安装nginx、mysql和tomcat"></a>2、通过宝塔的后台，安装nginx、mysql和tomcat</h3><p>可以在宝塔的后台，通过 <code>软件管理 &gt; 运行环境</code> 可以找到 nginx、mysql 和 tomcat。</p>
<p>点击安装即可。</p>
<p>需要注意的是各个软件的版本号：</p>
<ul>
<li>nginx ： 1.14</li>
<li>tomcat ： 8.5</li>
<li>mysql ： 5.6</li>
</ul>
<h3 id="3、创建网站"><a href="#3、创建网站" class="headerlink" title="3、创建网站"></a>3、创建网站</h3><p>在宝塔后台，通 <code>网站 &gt; 添加网站</code> 创建一个新的网站。</p>
<p>创建网站的时候需要注意的是，创建mysql数据库的时候，版本要选择 <code>utf8mb4</code> 编码。</p>
<p>在宝塔后台的 <code>网站</code> 里，点击网站域名，在 <code>tomcat</code> 菜单里，启用 tomcat 功能。 <img src="https://gitee.com/fuhai/jpress/raw/master/doc/images/install_02.jpg" alt="img"></p>
<h3 id="4、上传war，并解压缩"><a href="#4、上传war，并解压缩" class="headerlink" title="4、上传war，并解压缩"></a>4、上传war，并解压缩</h3><p>在宝塔后台的 <code>网站</code> 里，点击根目录对应的目录链接，然后上传 jpress.war 到此目录。</p>
<p>因为宝塔无法对 .war 这种文件格式解压缩，所以需要重命名为 jpress.zip ，当然也可以在本地先把 jpress.war 先重命名为 jpress.zip 然后再上传也可以。</p>
<p>操作完成后，点击 jpress.zip 的解压缩即可。</p>
<h3 id="5、访问网站走jpress自动安装过程"><a href="#5、访问网站走jpress自动安装过程" class="headerlink" title="5、访问网站走jpress自动安装过程"></a>5、访问网站走jpress自动安装过程</h3><p>访问你的域名，JPress自动引导进行安装，在JPress安装向导的过程中，只需要填写宝塔创建完毕的数据库账号和密码即可。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote>
<p>问题：宝塔安装初次安装JPress无法正常启动？</p>
<p>答：</p>
<p>1、请查看下 /WEB-INF/classes 目录下是否有 <code>jboot.porperties</code> 和 <code>install.lock</code> 这两个文件，如果有的话请删除。</p>
<p>2、尝试重启 nginx 和 tomcat。</p>
</blockquote>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>大数据</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt5中QObject::connect()传参为lambda注意问题</title>
    <url>/2020/03/11/2020-03-11/</url>
    <content><![CDATA[<p> 在 Qt 5 中，<code>QObject::connect()</code>有五个重载： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QMetaObject::Connection connect(const QObject *, const char *,</span><br><span class="line">                                const QObject *, const char *,</span><br><span class="line">                                Qt::ConnectionType);</span><br><span class="line"> </span><br><span class="line">QMetaObject::Connection connect(const QObject *, const QMetaMethod &amp;,</span><br><span class="line">                                const QObject *, const QMetaMethod &amp;,</span><br><span class="line">                                Qt::ConnectionType);</span><br><span class="line"> </span><br><span class="line">QMetaObject::Connection connect(const QObject *, const char *,</span><br><span class="line">                                const char *,</span><br><span class="line">                                Qt::ConnectionType) const;</span><br><span class="line"> </span><br><span class="line">QMetaObject::Connection connect(const QObject *, PointerToMemberFunction,</span><br><span class="line">                                const QObject *, PointerToMemberFunction,</span><br><span class="line">                                Qt::ConnectionType)</span><br><span class="line"> </span><br><span class="line">QMetaObject::Connection connect(const QObject *, PointerToMemberFunction,</span><br><span class="line">                                Functor);</span><br></pre></td></tr></table></figure>
<p>由于做界面窗口最大化按钮时，第一次点击最大化窗口，第二次还原为原大小窗口，因此需要自己写一个函数。而为了避免代码冗余，于是在connect传参时使用了lambda表达式，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connect(ui-&gt;btn_group, &amp;ButtonGroup::maxWindow, [=]()</span><br><span class="line">&#123;</span><br><span class="line">    static bool flag = false;</span><br><span class="line">    if(!flag)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;showMaximized();</span><br><span class="line">        flag = true;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;showNormal();</span><br><span class="line">        flag = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>于是编译错误，提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">no matching function for call to (类名):：connect()……</span><br></pre></td></tr></table></figure>
<p>看到这个错误，首先想到的是参数问题，由于connect()参数为四个，虽然lambda表达式默认可以省略this参数，但还是添加上试试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connect(ui-&gt;btn_group, &amp;ButtonGroup::maxWindow, this, [=]()&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>结果还是编译错误。后来上网查阅相关错误，结果大多数人的错误基本都是传参问题，但基本没有用lambda表达式的。于是删掉lambda表达式改用函数调用，结果编译通过。因此错误锁定在lambda表达式上。</p>
<p>后来发现，lambda表达式是C++11范畴，于是在pro文件当中添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG += c++11</span><br></pre></td></tr></table></figure>
<p>编译通过。</p>
<p>因此Qt使用lambda表达式时，首先使用的编译器要支持要用的C++11 特性，其次，在.pro中加上 <code>CONFIG += c++11</code></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Qt</tag>
        <tag>UI</tag>
        <tag>lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx+fastDFS搭建图床服务端</title>
    <url>/2020/03/09/2020-03-09/</url>
    <content><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>服务器：Linux（CentOS 7.x，Ubuntu）</p>
<h2 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h2><h3 id="宝塔安装"><a href="#宝塔安装" class="headerlink" title="宝塔安装"></a>宝塔安装</h3><p>通过宝塔面板编译安装 Nginx 1.15</p>
<h3 id="Ubuntu源码安装"><a href="#Ubuntu源码安装" class="headerlink" title="Ubuntu源码安装"></a>Ubuntu源码安装</h3><h4 id="APT安装"><a href="#APT安装" class="headerlink" title="APT安装"></a>APT安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure>
<h4 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h4><p>安装包：nginx-1.10.1.tar.gz</p>
<h5 id="安装相关软件"><a href="#安装相关软件" class="headerlink" title="安装相关软件"></a>安装相关软件</h5><p>安装gcc g++的依赖库（如果没有gcc）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install libtool</span><br><span class="line">centos的话：yum install gcc-c++</span><br></pre></td></tr></table></figure>
<p>安装pcre依赖库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libpcre3 libpcre3-dev</span><br><span class="line">centos的话：yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure>
<p>安装zlib依赖库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install zlib1g-dev</span><br><span class="line">centos的话：yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure>
<p>安装SSL依赖库（16.04默认已经安装了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssl</span><br><span class="line">centos的话：yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure>
<h5 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h5><p>关于configure、make、make install</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">源码的安装一般由有这三个步骤：配置(configure)、编译(make)、安装(make install)</span><br><span class="line"></span><br><span class="line">其中–prefix选项就是配置安装的路径，如果不配置该选项，安装后可执行文件默认放在/usr /local/bin，库文件默认放在/usr/local/lib，配置文件默认放在/usr/local/etc，其它的资源文件放在/usr /local/share，比较分散。</span><br><span class="line">为了便于集中管理某个软件的各种文件，可以配置–prefix，如：./configure –prefix=/usr/local 。可以把所有资源文件放在/usr/local的路径中，就不会分散了。</span><br><span class="line">使用--prefix选项的另一个好处是方便卸载软件或移植软件；当某个安装的软件不再需要时，只须简单的删除该安装目录，就可以把软件卸载得干干净净；而移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统下）。</span><br></pre></td></tr></table></figure>
<p>configure</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先检查机器的一些配置和环境，系统的相关依赖。如果缺少相关依赖，脚本会停止执行，软件安装失败</span><br><span class="line">根据之前检查环境和依赖的结果，生产Makefile文件（main job）</span><br></pre></td></tr></table></figure>
<p>make</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make是Unix系统下的一个包。执行make命令需Makefile文件。make会根据Makefile文件中指令来安装软件</span><br><span class="line">Makefile文件中有许多标签，来表示不同的section。一般的，make会编译源代码并生成可执行文件，其实Makefile主要就是描述文件编译的相互依赖关系</span><br></pre></td></tr></table></figure>
<p>make install</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当执行make命令不加任何参数，程序就会按照Makefile的指令在相应的section间跳转并且执行相应的命令</span><br><span class="line">加上install参数即执行make install时，程序只会执行install section处的命令。install section的指令会将make阶段生产的可执行文件拷贝到相应的地方，例如/usr/local/bin</span><br><span class="line">make clean 会删除上次make生产的obj文件以及可执行文件</span><br></pre></td></tr></table></figure>
<p>配置软链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx</span><br></pre></td></tr></table></figure>
<p>现在就可以不用路径直接输入nginx启动。</p>
<p>配置开机启动服务</p>
<p>在/etc/init.d/下创建nginx文件，sudo vim /etc/init.d/nginx，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">### BEGIN INIT INFO</span><br><span class="line"># Provides:      nginx</span><br><span class="line"># Required-Start:    $local_fs $remote_fs $network $syslog $named</span><br><span class="line"># Required-Stop:     $local_fs $remote_fs $network $syslog $named</span><br><span class="line"># Default-Start:     2 3 4 5</span><br><span class="line"># Default-Stop:      0 1 6</span><br><span class="line"># Short-Description: starts the nginx web server</span><br><span class="line"># Description:       starts nginx using start-stop-daemon</span><br><span class="line">### END INIT INFO</span><br><span class="line"></span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">DAEMON=/usr/local/nginx/sbin/nginx</span><br><span class="line">NAME=nginx</span><br><span class="line">DESC=nginx</span><br><span class="line"></span><br><span class="line"># Include nginx defaults if available</span><br><span class="line">if [ -r /etc/default/nginx ]; then</span><br><span class="line">    . /etc/default/nginx</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">STOP_SCHEDULE=&quot;$&#123;STOP_SCHEDULE:-QUIT/5/TERM/5/KILL/5&#125;&quot;</span><br><span class="line"></span><br><span class="line">test -x $DAEMON || exit 0</span><br><span class="line"></span><br><span class="line">. /lib/init/vars.sh</span><br><span class="line">. /lib/lsb/init-functions</span><br><span class="line"></span><br><span class="line"># Try to extract nginx pidfile</span><br><span class="line">PID=$(cat /usr/local/nginx/conf/nginx.conf | grep -Ev &apos;^\s*#&apos; | awk &apos;BEGIN &#123; RS=&quot;[;&#123;&#125;]&quot; &#125; &#123; if ($1 == &quot;pid&quot;) print $2 &#125;&apos; | head -n1)</span><br><span class="line">if [ -z &quot;$PID&quot; ]; then</span><br><span class="line">    PID=/run/nginx.pid</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -n &quot;$ULIMIT&quot; ]; then</span><br><span class="line">    # Set ulimit if it is set in /etc/default/nginx</span><br><span class="line">    ulimit $ULIMIT</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">start_nginx() &#123;</span><br><span class="line">    # Start the daemon/service</span><br><span class="line">    #</span><br><span class="line">    # Returns:</span><br><span class="line">    #   0 if daemon has been started</span><br><span class="line">    #   1 if daemon was already running</span><br><span class="line">    #   2 if daemon could not be started</span><br><span class="line">    start-stop-daemon --start --quiet --pidfile $PID --exec $DAEMON --test &gt; /dev/null \</span><br><span class="line">        || return 1</span><br><span class="line">    start-stop-daemon --start --quiet --pidfile $PID --exec $DAEMON -- \</span><br><span class="line">        $DAEMON_OPTS 2&gt;/dev/null \</span><br><span class="line">        || return 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_config() &#123;</span><br><span class="line">    # Test the nginx configuration</span><br><span class="line">    $DAEMON -t $DAEMON_OPTS &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop_nginx() &#123;</span><br><span class="line">    # Stops the daemon/service</span><br><span class="line">    #</span><br><span class="line">    # Return</span><br><span class="line">    #   0 if daemon has been stopped</span><br><span class="line">    #   1 if daemon was already stopped</span><br><span class="line">    #   2 if daemon could not be stopped</span><br><span class="line">    #   other if a failure occurred</span><br><span class="line">    start-stop-daemon --stop --quiet --retry=$STOP_SCHEDULE --pidfile $PID --name $NAME</span><br><span class="line">    RETVAL=&quot;$?&quot;</span><br><span class="line">    sleep 1</span><br><span class="line">    return &quot;$RETVAL&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reload_nginx() &#123;</span><br><span class="line">    # Function that sends a SIGHUP to the daemon/service</span><br><span class="line">    start-stop-daemon --stop --signal HUP --quiet --pidfile $PID --name $NAME</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rotate_logs() &#123;</span><br><span class="line">    # Rotate log files</span><br><span class="line">    start-stop-daemon --stop --signal USR1 --quiet --pidfile $PID --name $NAME</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upgrade_nginx() &#123;</span><br><span class="line">    # Online upgrade nginx executable</span><br><span class="line">    # http://nginx.org/en/docs/control.html</span><br><span class="line">    #</span><br><span class="line">    # Return</span><br><span class="line">    #   0 if nginx has been successfully upgraded</span><br><span class="line">    #   1 if nginx is not running</span><br><span class="line">    #   2 if the pid files were not created on time</span><br><span class="line">    #   3 if the old master could not be killed</span><br><span class="line">    if start-stop-daemon --stop --signal USR2 --quiet --pidfile $PID --name $NAME; then</span><br><span class="line">        # Wait for both old and new master to write their pid file</span><br><span class="line">        while [ ! -s &quot;$&#123;PID&#125;.oldbin&quot; ] || [ ! -s &quot;$&#123;PID&#125;&quot; ]; do</span><br><span class="line">            cnt=`expr $cnt + 1`</span><br><span class="line">            if [ $cnt -gt 10 ]; then</span><br><span class="line">                return 2</span><br><span class="line">            fi</span><br><span class="line">            sleep 1</span><br><span class="line">        done</span><br><span class="line">        # Everything is ready, gracefully stop the old master</span><br><span class="line">        if start-stop-daemon --stop --signal QUIT --quiet --pidfile &quot;$&#123;PID&#125;.oldbin&quot; --name $NAME; then</span><br><span class="line">            return 0</span><br><span class="line">        else</span><br><span class="line">            return 3</span><br><span class="line">        fi</span><br><span class="line">    else</span><br><span class="line">        return 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">    start)</span><br><span class="line">        log_daemon_msg &quot;Starting $DESC&quot; &quot;$NAME&quot;</span><br><span class="line">        start_nginx</span><br><span class="line">        case &quot;$?&quot; in</span><br><span class="line">            0|1) log_end_msg 0 ;;</span><br><span class="line">            2)   log_end_msg 1 ;;</span><br><span class="line">        esac</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        log_daemon_msg &quot;Stopping $DESC&quot; &quot;$NAME&quot;</span><br><span class="line">        stop_nginx</span><br><span class="line">        case &quot;$?&quot; in</span><br><span class="line">            0|1) log_end_msg 0 ;;</span><br><span class="line">            2)   log_end_msg 1 ;;</span><br><span class="line">        esac</span><br><span class="line">        ;;</span><br><span class="line">    restart)</span><br><span class="line">        log_daemon_msg &quot;Restarting $DESC&quot; &quot;$NAME&quot;</span><br><span class="line"></span><br><span class="line">        # Check configuration before stopping nginx</span><br><span class="line">        if ! test_config; then</span><br><span class="line">            log_end_msg 1 # Configuration error</span><br><span class="line">            exit $?</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        stop_nginx</span><br><span class="line">        case &quot;$?&quot; in</span><br><span class="line">            0|1)</span><br><span class="line">                start_nginx</span><br><span class="line">                case &quot;$?&quot; in</span><br><span class="line">                    0) log_end_msg 0 ;;</span><br><span class="line">                    1) log_end_msg 1 ;; # Old process is still running</span><br><span class="line">                    *) log_end_msg 1 ;; # Failed to start</span><br><span class="line">                esac</span><br><span class="line">                ;;</span><br><span class="line">            *)</span><br><span class="line">                # Failed to stop</span><br><span class="line">                log_end_msg 1</span><br><span class="line">                ;;</span><br><span class="line">        esac</span><br><span class="line">        ;;</span><br><span class="line">    reload|force-reload)</span><br><span class="line">        log_daemon_msg &quot;Reloading $DESC configuration&quot; &quot;$NAME&quot;</span><br><span class="line"></span><br><span class="line">        # Check configuration before stopping nginx</span><br><span class="line">        #</span><br><span class="line">        # This is not entirely correct since the on-disk nginx binary</span><br><span class="line">        # may differ from the in-memory one, but that&apos;s not common.</span><br><span class="line">        # We prefer to check the configuration and return an error</span><br><span class="line">        # to the administrator.</span><br><span class="line">        if ! test_config; then</span><br><span class="line">            log_end_msg 1 # Configuration error</span><br><span class="line">            exit $?</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        reload_nginx</span><br><span class="line">        log_end_msg $?</span><br><span class="line">        ;;</span><br><span class="line">    configtest|testconfig)</span><br><span class="line">        log_daemon_msg &quot;Testing $DESC configuration&quot;</span><br><span class="line">        test_config</span><br><span class="line">        log_end_msg $?</span><br><span class="line">        ;;</span><br><span class="line">    status)</span><br><span class="line">        status_of_proc -p $PID &quot;$DAEMON&quot; &quot;$NAME&quot; &amp;&amp; exit 0 || exit $?</span><br><span class="line">        ;;</span><br><span class="line">    upgrade)</span><br><span class="line">        log_daemon_msg &quot;Upgrading binary&quot; &quot;$NAME&quot;</span><br><span class="line">        upgrade_nginx</span><br><span class="line">        log_end_msg $?</span><br><span class="line">        ;;</span><br><span class="line">    rotate)</span><br><span class="line">        log_daemon_msg &quot;Re-opening $DESC log files&quot; &quot;$NAME&quot;</span><br><span class="line">        rotate_logs</span><br><span class="line">        log_end_msg $?</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo &quot;Usage: $NAME &#123;start|stop|restart|reload|force-reload|status|configtest|rotate|upgrade&#125;&quot; &gt;&amp;2</span><br><span class="line">        exit 3</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p>-</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#设置服务脚本有执行权限</span><br><span class="line">sudo chmod +x /etc/init.d/nginx</span><br><span class="line">#注册服务</span><br><span class="line">cd /etc/init.d/</span><br><span class="line">sudo update-rc.d nginx defaults</span><br></pre></td></tr></table></figure>
<p>现在基本上就可以开机启动了，常用的命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service nginx &#123;start|stop|restart|reload|force-reload|status|configtest|rotate|upgrade&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fastDFS软件准备"><a href="#fastDFS软件准备" class="headerlink" title="fastDFS软件准备"></a>fastDFS软件准备</h2><p>fastdfs-5.10.tar.gz</p>
<p>libfastcommon-1.36.zip</p>
<p>fastdfs-nginx-module_v1.16.tar.gz</p>
<h2 id="阿里云服务器准备"><a href="#阿里云服务器准备" class="headerlink" title="阿里云服务器准备"></a>阿里云服务器准备</h2><p>参考</p>
<p><a href="https://www.cnblogs.com/guigujun/p/7804670.html" target="_blank" rel="noopener">https://www.cnblogs.com/guigujun/p/7804670.html</a></p>
<p>本人使用的是阿里云服务器,配置上和上面教程略有不同</p>
<p>阿里防火墙 开放端口 TCP 22122 23000 等,记得开放要用的端口,否则后面操作失败</p>
<p>由于有了阿里云防火墙,所以服务器上的防火墙基本都不想开了,因为如果开放一个端口,要改阿里防火墙和服务器防火墙 2个地方,太繁琐了,所以可以使用以下命令禁用服务器自身的防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#关闭防火墙</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line">#禁止防火墙开机自启</span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>
<h1 id="fastDFS安装"><a href="#fastDFS安装" class="headerlink" title="fastDFS安装"></a>fastDFS安装</h1><h2 id="安装libfastcommon"><a href="#安装libfastcommon" class="headerlink" title="安装libfastcommon"></a>安装libfastcommon</h2><p>使用软件上传所有FastDFS软件到服务器的 /home/package/fdfs目录上（目录自己建立）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /home/package/fdfs</span><br><span class="line"></span><br><span class="line"># 解压所有的压缩包</span><br><span class="line">unzip libfastcommon-1.0.36.zip</span><br><span class="line">tar -zxvf fastdfs-5.10.tar.gz</span><br><span class="line">tar -zxvf fastdfs-nginx-module_v1.16.tar.gz</span><br><span class="line"></span><br><span class="line"># 安装fastdfs的环境</span><br><span class="line">cd libfastcommon-1.0.36</span><br><span class="line">./make.sh</span><br><span class="line">./make.sh install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#建立软链接(可省略)</span><br><span class="line">ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so</span><br><span class="line">ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so</span><br><span class="line">ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so</span><br><span class="line">ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so</span><br></pre></td></tr></table></figure>
<h2 id="安装fastDFS"><a href="#安装fastDFS" class="headerlink" title="安装fastDFS"></a>安装fastDFS</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装FastDFS</span><br><span class="line">cd /home/package/fdfs/fastdfs-5.10</span><br><span class="line">./make.sh</span><br><span class="line">./make.sh install</span><br><span class="line"></span><br><span class="line">#从样本中拷贝配置文件</span><br><span class="line">cd /etc/fdfs/</span><br><span class="line">cp client.conf.sample client.conf</span><br><span class="line">cp storage.conf.sample storage.conf</span><br><span class="line">cp tracker.conf.sample tracker.conf</span><br></pre></td></tr></table></figure>
<h3 id="配置tracker"><a href="#配置tracker" class="headerlink" title="配置tracker"></a>配置tracker</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一并把后面要的所有目录创建</span><br><span class="line">mkdir /home/fastdfs/tracker</span><br><span class="line">mkdir /home/fastdfs/storage</span><br><span class="line">mkdir /home/fastdfs/client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">******************************************</span><br><span class="line"># 配置文件 tracker</span><br><span class="line">vim /etc/fdfs/tracker.conf</span><br><span class="line"># 关注以下配置</span><br><span class="line">disabled=false </span><br><span class="line">port=22122 	#默认端口号 </span><br><span class="line">base_path=/home/fastdfs/tracker #自己刚创建的目录 </span><br><span class="line">#http.server_port=8080 	#默认端口是8080</span><br><span class="line">#bind_addr 留空即可,不写则(外网内网)都可以访问</span><br><span class="line">bind_addr=</span><br><span class="line">#bind_addr=192.168.133.128	内网网址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查看支持命令 ,常用的有 start,stop,status</span><br><span class="line">service fdfs_trackerd</span><br><span class="line"># 启动tracker,这里显示ok还不行,还得看下面的监听端口看不看得到</span><br><span class="line">service fdfs_trackerd start</span><br><span class="line">#fdfs_trackerd /etc/fdfs/tracker.conf 同样可以启动</span><br><span class="line"></span><br><span class="line"># 开机自启动</span><br><span class="line">echo &quot;service fdfs_trackerd start&quot; |tee -a /etc/rc.d/rc.local</span><br><span class="line"></span><br><span class="line">#查看tracker监听端口</span><br><span class="line"># 这里必须看到 tracker的监听端口,否则请检查上面的操作</span><br><span class="line">netstat -unltp|grep fdfs</span><br></pre></td></tr></table></figure>
<h3 id="配置storage"><a href="#配置storage" class="headerlink" title="配置storage"></a>配置storage</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*****************************</span><br><span class="line"># 配置文件 storage</span><br><span class="line">vim /etc/fdfs/storage.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 注意下列配置</span><br><span class="line">disabled=false </span><br><span class="line">group_name=group1 #组名，根据实际情况修改 </span><br><span class="line">port=23000 #设置storage的端口号，默认是23000，同一个组的storage端口号必须一致 </span><br><span class="line">base_path=/home/fastdfs/storage #设置storage数据文件和日志目录 </span><br><span class="line">store_path_count=1 #存储路径个数，需要和store_path个数匹配 </span><br><span class="line">store_path0=/home/fastdfs/storage_data #实际文件存储路径 </span><br><span class="line">tracker_server=公网IP:22122 #阿里云服务器的公网IP</span><br><span class="line">#bind_addr 留空即可,不写则(外网内网)都可以访问</span><br><span class="line">bind_addr=</span><br><span class="line">#bind_addr=192.168.133.128	内网网址</span><br><span class="line">#http.server_port=8888 #设置 http 端口号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建软引用</span><br><span class="line">ln -s /usr/bin/fdfs_storaged /usr/local/bin</span><br><span class="line"></span><br><span class="line">#启动storage ,这里ok还不行,必须看到storage的监听端口才行</span><br><span class="line">service fdfs_storaged start</span><br><span class="line">#fdfs_storaged /etc/fdfs/storage.conf</span><br><span class="line"></span><br><span class="line">#开机自启动 storage</span><br><span class="line">echo &quot;service fdfs_storaged start&quot; |tee -a /etc/rc.d/rc.local</span><br><span class="line"></span><br><span class="line"># 看一下是否有tracker和storage的2个监听端口,否则请检查上面操作</span><br><span class="line">netstat -unltp | grep fdfs</span><br></pre></td></tr></table></figure>
<h3 id="配置client"><a href="#配置client" class="headerlink" title="配置client"></a>配置client</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/fdfs/client.conf</span><br><span class="line"></span><br><span class="line"># 注意以下配置</span><br><span class="line">base_path=/home/fastdfs/client #tracker服务器文件路径</span><br><span class="line">tracker_server=公网IP:22122 #tracker服务器IP地址和端口号</span><br><span class="line">#http.tracker_server_port=8080 # tracker 服务器的 http端口号，必须和tracker的设置对应起来</span><br></pre></td></tr></table></figure>
<h3 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h3><h4 id="检验测试"><a href="#检验测试" class="headerlink" title="检验测试"></a>检验测试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdfs_moniter /etc/fdfs/client.conf</span><br></pre></td></tr></table></figure>
<h4 id="检验上传下载"><a href="#检验上传下载" class="headerlink" title="检验上传下载"></a>检验上传下载</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 图片 /home/temp/test.jpg</span><br><span class="line"></span><br><span class="line">#上传图片</span><br><span class="line">fdfs_upload_file  /etc/fdfs/client.conf /home/temp/test.jpg</span><br><span class="line"></span><br><span class="line"># 看到group1/M00/00/00字眼即成功了,这个信息后面有用</span><br><span class="line"># group1/M00/00/00/rBEx3l5k7cmAW6eiAAGyE0VtDsM290.jpg</span><br><span class="line"></span><br><span class="line">#下载图片</span><br><span class="line">fdfs_download_file group1/M00/00/00/rBEx3l5k7cmAW6eiAAGyE0VtDsM290.jpg</span><br><span class="line"></span><br><span class="line">#查看当前路径下有没有图片 rBEx3l5k7cmAW6eiAAGyE0VtDsM290.jpg</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<h1 id="fastdfs-nginx-module安装"><a href="#fastdfs-nginx-module安装" class="headerlink" title="fastdfs-nginx-module安装"></a>fastdfs-nginx-module安装</h1><h2 id="Nginx相关"><a href="#Nginx相关" class="headerlink" title="Nginx相关"></a>Nginx相关</h2><h3 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h3><h4 id="源码安装路径"><a href="#源码安装路径" class="headerlink" title="源码安装路径"></a>源码安装路径</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /home/package/nginx/nginx-1.10.1/</span><br></pre></td></tr></table></figure>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure --add-module=/home/package/fdfs_nginx_module/fastdfs-nginx-module/src</span><br><span class="line"></span><br><span class="line">#跳转objs目录编辑Makefile添加头文件</span><br><span class="line">vim ./objs/Makefile</span><br><span class="line"># 添加以下语句</span><br><span class="line">-I usr/include/fastdfs \</span><br><span class="line">-I usr/include/fastcommon \</span><br><span class="line"></span><br><span class="line">#最后编译安装</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h3 id="宝塔nginx安装"><a href="#宝塔nginx安装" class="headerlink" title="宝塔nginx安装"></a>宝塔nginx安装</h3><h4 id="默认安装脚本路径"><a href="#默认安装脚本路径" class="headerlink" title="默认安装脚本路径"></a>默认安装脚本路径</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/www/server/panel/install/nginx.sh</span><br></pre></td></tr></table></figure>
<h4 id="nginx源码位置"><a href="#nginx源码位置" class="headerlink" title="nginx源码位置"></a>nginx源码位置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/www/server/nginx/src/</span><br></pre></td></tr></table></figure>
<h4 id="重新编译宝塔nginx"><a href="#重新编译宝塔nginx" class="headerlink" title="重新编译宝塔nginx"></a>重新编译宝塔nginx</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /www/server/nginx/src/</span><br></pre></td></tr></table></figure>
<h5 id="查看nginx编译参数"><a href="#查看nginx编译参数" class="headerlink" title="查看nginx编译参数"></a>查看nginx编译参数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure>
<p>返回结果（我的）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--user=www --group=www --prefix=/www/server/nginx --add-module=/www/server/nginx/src/ngx_devel_kit --add-module=/www/server/nginx/src/lua_nginx_module --add-module=/www/server/nginx/src/ngx_cache_purge --add-module=/www/server/nginx/src/nginx-sticky-module --with-openssl=/www/server/nginx/src/openssl --with-pcre=pcre-8.43 --with-http_v2_module --with-stream --with-stream_ssl_module --with-stream_ssl_preread_module --with-http_stub_status_module --with-http_ssl_module --with-http_image_filter_module --with-http_gzip_static_module --with-http_gunzip_module --with-ipv6 --with-http_sub_module --with-http_flv_module --with-http_addition_module --with-http_realip_module --with-http_mp4_module --with-ld-opt=-Wl,-E --with-cc-opt=-Wno-error --with-ld-opt=-ljemalloc --with-http_dav_module --add-module=/www/server/nginx/src/nginx-dav-ext-module</span><br></pre></td></tr></table></figure>
<h5 id="添加代码"><a href="#添加代码" class="headerlink" title="添加代码"></a>添加代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--add-module=/home/package/fdfs_nginx_module/fastdfs-nginx-module/src</span><br></pre></td></tr></table></figure>
<h5 id="添加fastDFS模块（以上两部分整合）"><a href="#添加fastDFS模块（以上两部分整合）" class="headerlink" title="添加fastDFS模块（以上两部分整合）"></a>添加fastDFS模块（以上两部分整合）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--user=www --group=www --prefix=/www/server/nginx --add-module=/www/server/nginx/src/ngx_devel_kit --add-module=/www/server/nginx/src/lua_nginx_module --add-module=/www/server/nginx/src/ngx_cache_purge --add-module=/www/server/nginx/src/nginx-sticky-module --with-openssl=/www/server/nginx/src/openssl --with-pcre=pcre-8.43 --with-http_v2_module --with-stream --with-stream_ssl_module --with-stream_ssl_preread_module --with-http_stub_status_module --with-http_ssl_module --with-http_image_filter_module --with-http_gzip_static_module --with-http_gunzip_module --with-ipv6 --with-http_sub_module --with-http_flv_module --with-http_addition_module --with-http_realip_module --with-http_mp4_module --with-ld-opt=-Wl,-E --with-cc-opt=-Wno-error --with-ld-opt=-ljemalloc --with-http_dav_module --add-module=/www/server/nginx/src/nginx-dav-ext-module --add-module=/home/package/fdfs_nginx_module/fastdfs-nginx-module/src</span><br></pre></td></tr></table></figure>
<h5 id="nginx重新编译"><a href="#nginx重新编译" class="headerlink" title="nginx重新编译"></a>nginx重新编译</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure --user=www --group=www --prefix=/www/server/nginx --add-module=/www/server/nginx/src/ngx_devel_kit --add-module=/www/server/nginx/src/lua_nginx_module --add-module=/www/server/nginx/src/ngx_cache_purge --add-module=/www/server/nginx/src/nginx-sticky-module --with-openssl=/www/server/nginx/src/openssl --with-pcre=pcre-8.43 --with-http_v2_module --with-stream --with-stream_ssl_module --with-stream_ssl_preread_module --with-http_stub_status_module --with-http_ssl_module --with-http_image_filter_module --with-http_gzip_static_module --with-http_gunzip_module --with-ipv6 --with-http_sub_module --with-http_flv_module --with-http_addition_module --with-http_realip_module --with-http_mp4_module --with-ld-opt=-Wl,-E --with-cc-opt=-Wno-error --with-ld-opt=-ljemalloc --with-http_dav_module --add-module=/www/server/nginx/src/nginx-dav-ext-module --add-module=/home/package/fdfs_nginx_module/fastdfs-nginx-module/src</span><br></pre></td></tr></table></figure>
<h4 id="make"><a href="#make" class="headerlink" title="make"></a>make</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal error: fdfs_define.h: No such file or directory </span><br><span class="line">fatal error: common_define.h: No such file or directory</span><br></pre></td></tr></table></figure>
<p>vim 打开makefile目录下边的 objs/Makefile </p>
<p>在这个makefile中添加两个头文件 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /www/server/nginx/src/objs/Makefile</span><br><span class="line"></span><br><span class="line"># 添加以下语句</span><br><span class="line">-I usr/include/fastdfs \</span><br><span class="line">-I usr/include/fastcommon \</span><br></pre></td></tr></table></figure>
<h4 id="make-install"><a href="#make-install" class="headerlink" title="make install"></a>make install</h4><h5 id="未安装nginx"><a href="#未安装nginx" class="headerlink" title="未安装nginx"></a>未安装nginx</h5><p>直接make install</p>
<h5 id="已安装"><a href="#已安装" class="headerlink" title="已安装"></a>已安装</h5><p>复制编译后产生的nginx文件，替换旧的nginx文件（自己需提前备份）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp /www/server/nginx/src/objs/nginx /www/server/nginx/sbin/</span><br></pre></td></tr></table></figure>
<h3 id="nginx启动"><a href="#nginx启动" class="headerlink" title="nginx启动"></a>nginx启动</h3><p>启动nginx, 只有一个master没有worker</p>
<p>查看日志文件 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/logs/error.log </span><br><span class="line"></span><br><span class="line">ERROR - file: shared_func.c, line: 968, file  /etc/fdfs/mod_fastdfs.conf not exist </span><br><span class="line">#拷贝fastdfs-nginx-module/src中的mod_fastdfs.conf到/etc/fdfs/中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ERROR - file: ini_file_reader.c, line: 631, include file &quot;http.conf&quot; not exists, line: &quot;#include http.conf&quot;</span><br><span class="line">#从fastDFS的源码安装包中的conf中 将http.conf 拷贝到 /etc/fdfs/</span><br><span class="line">#从nginx的源码安装包中的conf中mime.types拷贝到 /etc/fdfs/</span><br></pre></td></tr></table></figure>
<h1 id="mod-fastdfs-conf-配置文件"><a href="#mod-fastdfs-conf-配置文件" class="headerlink" title="mod_fastdfs.conf 配置文件"></a>mod_fastdfs.conf 配置文件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base_path=/home/fastDFS/storage #log日志目录</span><br><span class="line">tracker_server=公网:22122 #追踪器的地址</span><br><span class="line">storage_server_port=23000 #当前存储节点的端口</span><br><span class="line">group_name=group1 #当前存储节点所属的组</span><br><span class="line">url_have_group_name = true #浏览器访问的时候, url中是否包含组名</span><br><span class="line">store_path_count=1 #当前存储节点存储路径的个数</span><br><span class="line">store_path1 store_path2 #如果有多个, 需要全部写到配置文件中</span><br><span class="line">store_path0=/home/robin/fastDFS/storage #当前存储节点的存储路径</span><br><span class="line">group_count = 1 #整个的fastDFS文件系统一共有多少个组</span><br><span class="line">[group1] #每个组信息</span><br><span class="line">group_name=group1</span><br><span class="line">storage_server_port=23000</span><br><span class="line">store_path_count=1</span><br><span class="line">store_path0=/home/fastDFS/storage</span><br></pre></td></tr></table></figure>
<h1 id="nginx配置文件添加location"><a href="#nginx配置文件添加location" class="headerlink" title="nginx配置文件添加location"></a>nginx配置文件添加location</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location /group1/M00&#123;</span><br><span class="line">    root   /home/fastdfs/storage/data;</span><br><span class="line">    ngx_fastdfs_module;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前上传的图片路径为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">group1/M00/00/00/rBEx3l5k7cmAW6eiAAGyE0VtDsM290.jpg</span><br></pre></td></tr></table></figure>
<p>访问链接</p>
<p><a href="http://39.96.209.253/group1/M00/00/00/rBEx3l5k7cmAW6eiAAGyE0VtDsM290.jpg" target="_blank" rel="noopener">http://39.96.209.253/group1/M00/00/00/rBEx3l5k7cmAW6eiAAGyE0VtDsM290.jpg</a></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>大数据</tag>
        <tag>分布式</tag>
        <tag>FastDFS</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>在山的那边，还是山</title>
    <url>/2020/01/23/2020-01-23/</url>
    <content><![CDATA[<p>人生天地间，忽如远行客。人从诞生起，便是一场走向死亡的旅程。，我们别无选择的被命运推着向前走，不能回头。虽然人生这场旅程中，我们没办法回头，但是上帝赋予了我们每个人选择的权利。尽管每个人会走向同样的终点，但每个人都身处不同的起点，拥有自己道路的选择权，这就注定了每个人在旅程中会遇到不一样的风景。</p>
<p>有人说，我们降临到世上，要么是疯子，要么是傻子。疯子风雨兼程，义无反顾；傻子知足常乐，安之若素。其实这话说的也不错，就像人生的分岔路口上，都会有崎岖的山路，也会有平稳的坦途。选择山路，比较辛苦，随时都有跌落山谷的危险，但沿途能欣赏广阔的风景；选择坦途，比较轻松，不用思考任何风险，但也失去了广阔的风景。就像每个人都会问自己，是想成为马云，还是想成为佛祖。每个人都会有自己的选择，谁也没有资格评论其他人的选择，唯一能做的，就是不忘初心，坚持自己的选择。</p>
<p>我时常会问自己，究竟是选择山路，还是选择坦途。很多时候，我都会犹豫不决，一方面是对挫折的恐惧，一方面又不甘于碌碌无为。但这个时候，上帝总会帮我寻找心中所向往的那片风景。秋招时，因为恐惧面试，而草草的签了三方协议。尽管薪资达不到自己的预期，但还是选择了安稳。本以为从此之后便再也没办法回头，但还是遇到了人生的伯乐，经过心理上克服面试的恐惧，最终成功签约自己心仪的公司。</p>
<p>当我们历经磨难，踏上山巅时，已经欣赏到了更远阔的风景，也收获了沿途克服崎岖的喜悦。但我们的人生没有暂停键，也没有后退键。这时候，我们依旧要向前走，但当我们到达一座山顶时，四周的路只能向下。而山那边，依然是山。我们别无选择继续跨越前方的山。就像我，因为签约了新的公司，必须想办法解约三方协议，而我们作为违约的一方，就必须承担责任，想获得学校一方的同意挺难，因为有很多流程，谁也不想自己太麻烦；以前的公司不会简简单单的帮助我们违约，违约不违约都是要交违约金，而且没违约成功，未来在旧公司里也会备受排挤。而此刻的我，没有回头路，只能继续向前。</p>
<p>当我们选择山路时，往往也会向往安稳的坦途，但身在山路，稍不留神便会跌落谷底。与其后悔，不妨继续享受这沿途的风景。我们之所以害怕山路，其实是对挫折的恐惧。就像我对与学校和公司违约谈判的恐惧，对这个过程中可能遇到的各种麻烦一样。但是任何没有打倒我们的力量，只能让我们的内心变得更强大。因此，此刻正望着另一座山的我，定要把挫折当做使自己变得强大的力量，战胜恐惧，欣赏风景，坚定向前。就像汪国真《热爱生命》中写的那样：</p>
<p>我不去想是否能够成功<br>既然选择了远方<br>便只顾风雨兼程</p>
<p>我不去想能否赢得爱情<br>既然钟情于玫瑰<br>就勇敢地吐露真诚</p>
<p>我不去想身后会不会袭来寒风冷雨<br>既然目标是地平线<br>留给世界的只能是背影</p>
<p>我不去想未来是平坦还是泥泞<br>只要热爱生命<br>一切，都在意料之中</p>
]]></content>
      <categories>
        <category>心路历程</category>
        <category>散文</category>
      </categories>
  </entry>
  <entry>
    <title>爱你所爱，行你所行，听从你心，无问西东</title>
    <url>/2019/12/17/2019-12-17/</url>
    <content><![CDATA[<p>对于这部电影，早有耳闻，毕竟王菲的《无问西东》与毛不易的《无问》都是我时常聆听的歌。只是不知何时起，被生活中的各种琐事困扰，渐渐地，失去了对美好世界的向往，以及静下心来欣赏好电影的热忱。正在迷茫之际，所幸遇到这部电影以及它所传达的救赎之道，又点亮了我内心所向往的那道光。</p>
<p>影片分为了四个小故事，背景分别在当代，文革时代，战火时代，以及那个咆哮的时代。通过职场，爱情，家国，自我救赎，四个主题，以救赎为牵引线，化作了一个故事，共同传达了爱与传承的主旨。</p>
<p>电影首先讲述的是生活在当代尔虞我诈的职场，每天愁眉苦脸的男主张果果，因为上司的设计而背黑锅被迫离职。在新的公司里，因为看到曾经能帮助而未尽力帮助的四胞胎家庭如今生活落魄，决定通过事业帮助这个家庭。在医院看望四胞胎婴儿时，他向婴儿家人承诺会争取四胞胎的手术费。而在对他们提供帮助后，前公司的老总告诉他一些过往的经历劝他小心。他开始怀疑四胞胎的家人从此以后赖上了他。而同时老总给男主提供了一个揭发曾经算计他的上司丑陋罪行的机会。面对心中善恶的审批，男主该如何回应呢。</p>
<p>第二个故事发生在文革前。黄晓明饰演的陈鹏是一个大学的优等生，章子怡饰演的王敏佳与铁政饰演的李想则是医学院的一个学生，三人从小便是相依相伴的孤儿。陈鹏一直喜欢着王敏佳，原本打算为爱放弃事业时，却看到王敏佳和李想两个人暧昧，选择了离开。王敏佳和李想看到师母殴打恩师，写信为恩师打抱不平，却遭到师母的告状。面对李想的前程，王敏佳选择独自承担，却遭到了各个阶级莫须有的罪名，李想自始至终选择沉默。最终在批判大会上含冤死去。</p>
<p>第三个故事讲述的是飞行家的故事，王力宏饰演的沈光耀原本是富家子弟，文武兼备，因为一腔热血，报名空军，却遭到家人的反对，最终选择放下功名，安之若素。之后却看着日军狂轰乱炸，在国与家的面前，他该何去何从。</p>
<p>第四个故事比较简单，由陈楚生饰演的吴岭澜国学与英语成绩优异，然而当时正值实业救国思潮，本是文科好苗子的他选择了理工科，然而却因物理成绩垫底被迫重新作出选择。对于自己所擅长的文科与实用的理科，他该如何选择。</p>
<p>最终，吴岭澜听了泰戈尔的演讲，明白了那些伟人以及引领时代的人其实不一定都是实业家，他们其实时时刻刻都在对生命的价值进行思索。最终他毅然遵从内心，选择了文科，从此当一名教师，传道受业解惑。</p>
<p>而正是吴岭澜的几句话，影响了沈光耀，在日军轰炸同胞，战火迷离之际，他选择了当一名飞行员，为保家卫国献上了自己最绚烂的青春。 在他执行飞行任务时，总不忘将食物从空中撒向贫民区。从自己的村子，到飞机途径的各个村子，都有他所传递的那份爱。</p>
<p>正因为沈光耀的选择，才救助了陈鹏他们所在的村子，造就了陈鹏一村人感恩的心。最终陈鹏为爱返乡，将濒死的王敏佳带回村子，托付给村子救助。因为陈鹏的守护，王敏佳才有了生的希望。</p>
<p>在陈鹏的感染下，李想最终在大雪纷飞的雪地里将食物留给了素不相识的张果果的父母，最终自己却冻死了。而每年，张果果一家不管多忙碌，总会在清明节那天去为李想扫墓。正是因为这份爱与传递，最终感染了张果果，他最终洗涤了心中世俗化的感染，无偿为四胞胎的父母提供了住所与工作，也主动选择放弃揭发曾经算计自己的上司。</p>
<p>满怀热忱的我们，无可避免都得经受现实的洗礼。</p>
<p>还记得王敏佳在批判大会上的那抹笑容。当她环顾四周，心中所盼望的两个男人统统不在，周围全是乌合之众的谩骂，她笑了。正是因为这一抹笑，引来了群众的不满，由谩骂变成了毒打，使王敏佳付出自己的生命。看到这里，我首先想到的是《鬼子来了》中，姜文最后人头落地时的仰天长笑。那三声长笑，看似荒诞，但正是在嘲讽这荒诞的世界，这没有正义，只有灰色的世界。</p>
<p>在理想与现实的十字路口上，我们该何去何从。</p>
<p>影片中，张果果和老总形成了鲜明的对比，是理想与现实的对比。老总在抱怨他曾经帮助过的孩子最终却向自己要房子要工作，而张果果听了老总的劝告，经历了思想斗争之后，却选择主动为四胞胎家庭提供住所与工作。看到这里，我想到了《我不是药神》中程勇由最初为了利益卖药到最后以德报怨主动倒贴钱卖药给穷人的转变。这是一种救赎。能力越大，责任就越大。张果果身为广告公司总监，主动选择将爱传递给那些需要帮助的人，这也是一种救赎。但我们也不能全怪老总，毕竟老总曾经也想过帮助别人，只是没有坚持下去，他所得到的是社会的一次鞭挞，从此被世俗同化，做一条狼。在理想与现实的十字路口，多少人因为社会的一次次的鞭挞而选择向现实妥协，将中心转向了自我，而又有几个人会像道成肉身的耶稣那样以德报怨，选择自己被钉上十字架来替世人赎罪呢。</p>
<p>当我们选择负重前行时，谁来为我们护航呢。</p>
<p>在王敏佳环顾四周，心中充满期盼，却又孤立无援的时候，我又想到了《闻香识女人》，查理在遭到同学的冷眼旁观与学校的威逼利诱之时，在自己的前途与心中的道义选择之时，遵从内心，坚守正义与准则。但不同于查理，查理在被勒令退学，心中充满迷茫之时，有老中校的保护，而王敏佳此刻却一无所有。这让我不禁感叹，其实我们每个人都曾满怀热忱选择拥抱这世界，但当我们被这灰色社会各种折磨之时，谁来像老中校那样保护我们的坚守呢。最终大部分人都被这社会所同化，变成了自己曾经最讨厌的那种人。影片毕竟不是悲剧，所幸剧情最终安排陈鹏回到了王敏佳身边，守护王敏佳对这世界最后的一丝好感。</p>
<p>每个人都认为自己是对的，因此我们需要成长。</p>
<p>沈光耀原本是富家子弟，却选择当一名飞行员保家卫国，同时救济贫民。但刚开始时，他每次都是擅自开飞机为自己学校所在的村子送食物。他的上司罚他，同时也道出了原因，他这样做，看似义举，但每次同样的路线，只会引来敌人的追踪，最终导致村子遭到敌人的狂轰乱炸。看到这里，我不仅揪起了心。我们每个人其实刚开始时都认为自己是对的，就像王敏佳只看到了师母殴打恩师的表象，却忽略了恩师对师母的冷落，因此她将师母抹黑，遭到师母的告发。而同样因为师母的一句话，群众们又谩骂变成毒打，险些让王敏佳丧命。显然，师母当时因为嫉妒与愤怒，导致一个人前程与生命被毁。她其实也是无心之过，也是被这世界摧残的遍体鳞伤，不然也不会在最后在内疚与绝望中选择跳井自杀。有时候，我们自己的一点点微不足道的私欲或自以为是的正义可能会给其他人带来不可弥补的伤害。</p>
<p>成长中的负重前行，方得始终。</p>
<p>最终沈光耀的故事算是最完美的结局。他后来不断改变路线，给村子驱赶饥饿的同时保证了村子的安全。同时，将小义变成了大义，所到之处都有他的带来的食物。人们亲切地称他为晃晃叔叔。</p>
<p>当影片《奇异恩典》想起，我便明白，正值迷茫之际，此电影以救赎之道，为我曾经人生十字路口的选择保驾护航。</p>
]]></content>
      <categories>
        <category>心路历程</category>
        <category>影评</category>
      </categories>
  </entry>
  <entry>
    <title>中国没有汉尼拔</title>
    <url>/2019/12/09/2019-12-09/</url>
    <content><![CDATA[<p>每个人生下来便是羔羊，由牧民圈养着。牧民们为羊儿们提供丰厚的草料，但当它们的毛丰厚了便拔他们的毛，当它们的肉肥了便割他们的肉。有些羊不断提升自己的生产能力，逃出了羊圈，自力更生，从此遭到牧民以及其他羔羊的唾弃；有些羊努力进化成了野牛，起初野牛会保护羊群，但那些曾经意气风发的野牛们最终收获足够多的羔羊认同时，便会变成野牛比尔，同牧民合作，一起宰羊。而大部分的羊，为了一时安稳，看着同类的种种变化，不理不睬，久而久之便成了沉默的羔羊。</p>
<p>常常在耳边听到这样的说法：“如果每个人给我一毛，那我就是亿万富翁。”其实说到底，每个人都懂这一点，关键是如何让别人拔毛给你，而且是每个人。每当听到这样的话，我心中的暗自嘲讽，幸好有个如果，因为当你真的能让所有人给你一毛时，你变会想每人给你更多。</p>
<p>还记得《美国往事》中工人运动的领袖吉米掌权后的腐败嘴脸。那些曾经意气风发的企业家们，用各种福利拉拢用户，挽留用户，就像拼多多……然而不是所有私企都能挽留住用户，就像共享单车……最终收获足够多的用户量时，便同国企合作，让你们离不开他们，还得乖乖拔毛给他们，就像腾讯……</p>
<p>曾经意气风发的马云说过，他创立阿里巴巴就是让那些坐在移动、银行办公室里的人不得安宁。的确，他做到了，也成为了第一个汉尼拔。然而，伴随着的退休，谁也说不清楚什么情况。那个汉尼拔只剩传说了，每个想成为汉尼拔的人最终却变成了野牛比尔。</p>
<p>最近移动20周年庆典，然而却是变了花样的让用户交钱。当客服给用户打电话说庆典时，本以为是福利回馈，没想到又是变了花样的敲诈。这就是和某些私企的差别，私企通常庆典上各种福利回馈用户，国企反而再敲用户一下。</p>
<p>可笑的是每次私企出了问题用户各种骂，国企的话早已麻木了。就像曾经丰巢的1块钱事件。然而因1块钱声讨丰巢，却没人反映移动几十块的敲诈，这不是很讽刺吗。</p>
]]></content>
  </entry>
  <entry>
    <title>浅谈构造函数</title>
    <url>/2019/10/21/2019-10-21/</url>
    <content><![CDATA[<p>说道构造函数，大家可能都不陌生，但构造函数到底是什么作用呢。这个问题就好像我们大家都会用C++，但没几人敢说自己精通C++一样。我们先来看一看最简单的例子吧。</p>
<h2 id="question"><a href="#question" class="headerlink" title="question"></a>question</h2><p>已知类a继承类b且包含类c，求a，b，c的构造顺序。</p>
<h3 id="answer"><a href="#answer" class="headerlink" title="answer"></a>answer</h3><p>b &gt; c &gt; a</p>
<p>这个答案大家肯定知道，但为什么呢，对于该问题一般那些资深C++开发者一眼就能看出你是有自己的理解还是书本式的记忆，因此不要试图用书本式的解释。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>其实构造函数也没那么神秘，就是用来初始化数据，为对象的创建做准备的。这不废话么。有了这个认识，那为什么上面是bca，而不是其他顺序呢。好像没什么必然的联系。但是，以初始化为主的构造函数，那没有数据的话怎么初始化数据呢。因此，a包含c，那么c就是a数据的一部分，没有c的话a就无法初始化。因此c &gt; a。a继承于b，子类和父类的关系根据名称也知道，子类继承了父类的数据，父类也是子类的一部分，因此b &gt; a。abc这三者的关系就好似儿子、父亲和儿子的细胞。没有父亲，就没有儿子的全部，自然也没有儿子的细胞。所以答案自然而然。</p>
<h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><p>直接初始化&gt;初始化列表&gt;构造函数</p>
<h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p>在C++11特性中，出现了RAII的思想，就是构造中分配内存，析构中释放内存。这也是智能指针保证安全性的原因。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title>FastDFS分布式文件系统总结</title>
    <url>/2019/10/03/2019-10-03/</url>
    <content><![CDATA[<h1 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h1><p>首先，什么是分布式存储，简而言之，就是将数据存储到多个存储设备（服务器）上。</p>
<h2 id="分布式与传统网络存储系统区别"><a href="#分布式与传统网络存储系统区别" class="headerlink" title="分布式与传统网络存储系统区别"></a>分布式与传统网络存储系统区别</h2><p>传统的网络存储系统采用集中的存储服务器存放所有数据，存储服务器成为系统性能的瓶颈，也是可靠性和安全性的焦点，不能满足大规模存储应用的需要。<img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-10-03-%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.png" alt></p>
<p>分布式网络存储系统采用可扩展的系统结构，利用多台存储服务器分担存储负荷，利用位置服务器定位存储信息，它不但提高了系统的可靠性、可用性和存取效率，还易于扩展。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-10-03-%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.png" alt></p>
<h1 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h1><p>FastDFS是一款开源的分布式文件系统，通过纯C实现，支持Linux, FreeBSD等Unix系统类Google FS, 不是通用的文件系统，只能够通过专有API访问，目前提供了C，Java和PHP API为互联网应用量身定做，解决大容量文件存储问题，追求高性能和高扩展性 FastDFS可以看做是基于文件的key-value存储系统，称为分布式文件存储服务更为合适。</p>
<p>功能包括：文件存储、文件同步、文件访问（文件上传、文件下载、文件删除）等，解决了大容量存储和负载均衡的问题。</p>
<ul>
<li><p>为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标</p>
</li>
<li><p>可以很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。</p>
<ul>
<li>图片服务器</li>
<li>图床</li>
</ul>
</li>
</ul>
<ol>
<li><p>fastDFS特点:</p>
</li>
<li><ul>
<li>应用层级的文件系统</li>
<li>不能挂载和卸载，也就是不能进行mount操作</li>
</ul>
</li>
<li><p>fastDFS框架中的三个角色</p>
</li>
<li><ul>
<li>追踪器 - tracker</li>
<li>存储节点 - storage</li>
</ul>
</li>
<li><ul>
<li>客户端 - client</li>
</ul>
</li>
<li><p>fastDFS三个角色之间的关系</p>
</li>
<li><ul>
<li><p>Client和Storage主动连接Tracker。</p>
</li>
<li><p>Storage主动向Tracker报告其状态信息</p>
<ul>
<li>磁盘剩余空间</li>
<li>文件同步状况</li>
<li>文件上传下载次数</li>
</ul>
</li>
<li><p>Storage会启动一个单独的线程来完成对一台Tracker的连接和定时报告。</p>
</li>
<li><p>一个组包含的Storage不是通过配置文件设定的，而是通过Tracker获取到的。</p>
</li>
</ul>
</li>
</ol>
<h2 id="FastDFS集群"><a href="#FastDFS集群" class="headerlink" title="FastDFS集群"></a>FastDFS集群</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-10-03-Fast%E9%9B%86%E7%BE%A4.png" alt></p>
<ol>
<li><p>Tracker集群</p>
</li>
<li><ul>
<li>Tracker server之间是相互平等关系同时提供服务</li>
<li>Tracker server不存在单点故障。</li>
<li>客户端请求Tracker       server采用轮询方式，如果请求的tracker无法提供服务则换另一个tracker。</li>
</ul>
</li>
<li><p>Storage集群</p>
</li>
<li><ul>
<li>Storage集群采用了分组存储方式, 由一个或多个组构成</li>
<li>集群存储总容量为集群中所有组的存储容量之和</li>
<li>一个组由一台或多台存储服务器组成，组内的Storage       server之间是平等关系</li>
<li>不同组的Storage       server之间不会相互通信，同组内的Storage server之间会相互连接进行文件同步，从而保证同组内每个storage上的文件完全一致的。</li>
<li>一个组的存储容量为该组内存储服务器容量最小的那个</li>
</ul>
</li>
<li><p>FastDFS的扩容分纵向扩容与横向扩容</p>
</li>
<li><ul>
<li>横向 扩容<ul>
<li>增加容量</li>
<li>添加group组</li>
</ul>
</li>
<li><p>纵向扩容</p>
<ul>
<li>数据备份</li>
<li><p>当前组的最大容量  </p>
<ul>
<li>存储节点中容量最小的那个</li>
</ul>
</li>
<li><p>所有存储节点组名必须一样</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux</tag>
        <tag>大数据</tag>
        <tag>分布式</tag>
        <tag>FastDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>原创位运算版算法解决24点问题</title>
    <url>/2019/09/26/2019-09-26/</url>
    <content><![CDATA[<p>首先说一下什么是24点吧。随机4个数，这四个数能否通过加减乘除得到24。比如1,2,3,3，就可以通过2 <em> 3 </em> (3 + 1) = 24。再比如3,8,8,3，就可以通过8 / (3 - 3 / 8)得到。而1,1,1,1永远无法得到24点。我们如今需要判断当前4个数能否得到24点（当然求具体步骤也可以的，只需要代码中稍微加点东西）</p>
<p>我的方法是采用位运算，也就是二进制表示状态，0001表示第1个数，0010表示第2个数，0100表示第3个数，1000表示第4个数，0011表示第1个数和第2个数间所有的操作，同理1111就表示4个数之间所有的操作，1111可以有1100与0011进行加减乘除操作得到，也可以通过1011和0100得到……我们最后只需看1111里面是否有24即可（保存步骤的话需要自定义结构体，既添加字符状态）。</p>
<p>我们用set容器来存储当前状态下的所有结果（去重），那么set[1]即0001就是保存第一个数，set[2]即0010就是保存第二个数，set[3]即0011就是保存第一个数和第二个数的所有结果……某set可由其他两set的数据得出（例如0011可由0010和0001得到），则每次依次遍历其他两个set中所有元素再将新的结果插入到当前set中，这样从1遍历到15即可。</p>
<p>通过列真值表，00=0,01=0,10=1,11=0，我们可以得到a与!b即可得到想要的结果c，例如1011与!0010得到1001，当然c必须保证c不等于a且c不为0。而为了剪枝，我们也可以让c小于b。因此可以添加以下条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int k = (i &amp; (~j));</span><br><span class="line">if(k != 0 &amp;&amp; k != i &amp;&amp; k &lt; j)</span><br></pre></td></tr></table></figure>
<p>两个数之间加减乘除共有6种结果，a+b,a-b,b-a,a * b, a / b, b / a，因此我们将相应结果存入set（集合为了去重，如果需要详细步骤则可用其他容器，不必用set，因为步骤需要保存状态）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(it = m_set[j].begin(); it != m_set[j].end(); it++)&#123;</span><br><span class="line">    for(it2 = m_set[k].begin(); it2 != m_set[k].end(); it2++)&#123;</span><br><span class="line">        m_set[i].insert((*it) + (*it2));</span><br><span class="line">        m_set[i].insert((*it) * (*it2));</span><br><span class="line">        m_set[i].insert((*it) - (*it2));</span><br><span class="line">        m_set[i].insert((*it2) - (*it));</span><br><span class="line">        if((*it2) != 0) m_set[i].insert((*it) / (*it2));</span><br><span class="line">        if((*it) != 0) m_set[i].insert((*it2) / (*it));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以通过4层循环（因为只有4个数嘛，n范围也就是4）完成24点的判断了。以下是详细代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">set&lt;double&gt;m_set[1 &lt;&lt; 4];</span><br><span class="line">const double ens = 1e-10;</span><br><span class="line">double a[4];</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(cin &gt;&gt; a[0] &gt;&gt; a[1] &gt;&gt; a[2] &gt;&gt; a[3])&#123;</span><br><span class="line">        for(int i = 0; i &lt; 16; ++i)&#123;</span><br><span class="line">            m_set[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; 4; ++i)&#123;</span><br><span class="line">            m_set[1 &lt;&lt; i].insert(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; 16; ++i)&#123;</span><br><span class="line">            for(int j = 1; j &lt; i; ++j)&#123;</span><br><span class="line">                int k = (i &amp; (~j));</span><br><span class="line">                if(k != 0 &amp;&amp; k != i &amp;&amp; k &lt; j)&#123;</span><br><span class="line">                    //cout &lt;&lt; k &lt;&lt; &quot;&amp;~&quot; &lt;&lt; j &lt;&lt; &quot;=&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                    set&lt;double&gt;::iterator it, it2;</span><br><span class="line">                    for(it = m_set[j].begin(); it != m_set[j].end(); it++)&#123;</span><br><span class="line">                        for(it2 = m_set[k].begin(); it2 != m_set[k].end(); it2++)&#123;</span><br><span class="line">                            m_set[i].insert((*it) + (*it2));</span><br><span class="line">                            m_set[i].insert((*it) * (*it2));</span><br><span class="line">                            m_set[i].insert((*it) - (*it2));</span><br><span class="line">                            m_set[i].insert((*it2) - (*it));</span><br><span class="line">                            if((*it2) != 0) m_set[i].insert((*it) / (*it2));</span><br><span class="line">                            if((*it) != 0) m_set[i].insert((*it2) / (*it));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set&lt;double&gt;::iterator it;</span><br><span class="line">        for(it = m_set[15].begin(); it != m_set[15].end(); it++)&#123;</span><br><span class="line">            if(fabs(*it - 24) &lt; ens)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(it != m_set[15].end())&#123;</span><br><span class="line">            cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另附原始递归代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const double ins = 0.0000001;</span><br><span class="line">double val[4];</span><br><span class="line">bool dfs(int cur, double res)&#123;</span><br><span class="line">  double ans = res;</span><br><span class="line">  if(fabs(ans - 24) &lt; ins &amp;&amp; cur == 4)&#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;else if (cur &gt;= 4)&#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  if(dfs(cur + 1, ans + val[cur])</span><br><span class="line">     || dfs(cur + 1, ans - val[cur])</span><br><span class="line">     || dfs(cur + 1, -ans + val[cur])</span><br><span class="line">     || (cur &gt; 0 &amp;&amp; dfs(cur + 1, ans * val[cur]))</span><br><span class="line">     || dfs(cur + 1, cur &gt; 0 ? ans / val[cur] : 1 / val[cur])</span><br><span class="line">     || (ans != 0 &amp;&amp; dfs(cur + 1, val[cur] / ans))</span><br><span class="line">    )&#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    double v[4];</span><br><span class="line">    for(int i = 0; i &lt; 4; ++i)&#123;</span><br><span class="line">    cin &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    bool flag = false;</span><br><span class="line">    for(int i = 0; i &lt; 4; ++i)&#123;</span><br><span class="line">        for(int j = 0; j &lt; 4; ++j)&#123;</span><br><span class="line">            if(j == i)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int k = 0; k &lt; 4; ++k)&#123;</span><br><span class="line">                if(k == i || k == j)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                val[0] = v[i];</span><br><span class="line">                val[1] = v[j];</span><br><span class="line">                val[2] = v[k];</span><br><span class="line">                val[3] = v[6 - i - j - k];</span><br><span class="line">                flag = dfs(0, 0);</span><br><span class="line">                if(flag)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(flag)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>在任务跳转问题上，C#的委托delegate与工厂方法模式的异曲同工之妙</title>
    <url>/2019/08/28/2019-08-28/</url>
    <content><![CDATA[<p>在玩游戏时，常常会有任务跳转。但当跳转类型过多时，对游戏研发者来说，就是一件头疼的事了。之前在做游戏城镇等级模块时，就遇到了任务跳转过多的问题。刚接到任务跳转这个需求时，由于入门未深，便用if-else写的。可以想象一百多行的if-else或者switch是多么壮观啊。。。</p>
<p>但是当我们只为了完成当日任务，而不为长远维护考虑，那未来将是一件可怕的事情。而且那样的代码，像我这样的人看着也不舒服。</p>
<p>最近看了C#高级语法，赫然发现C#中的委托不就是C++中的函数指针嘛。于是，对于上述if-else，便有解了。</p>
<p>我们只需要写一个委托，对应创建一个数组对象，每个跳转类型封装一个方法，再用委托来回调，这样的代码，主方法里只需1行就搞定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">public class UICityRichLevelItem : ScreenBaseHandler</span><br><span class="line">&#123;</span><br><span class="line">    //public RawImage imgIcon;</span><br><span class="line">    public Text textProgress;</span><br><span class="line">    public Text textDegreeOfCompletion;</span><br><span class="line">    public Slider slideProgress;</span><br><span class="line">    public GameObject imgBg;</span><br><span class="line">    public GameObject imgCompleteFinish;</span><br><span class="line">    public GameObject imgCompleteGoto;</span><br><span class="line">    public UI_Event btnGoto;</span><br><span class="line">    public GameObject imgCompleteDelivery;</span><br><span class="line">    public UI_Event btnDelivery;</span><br><span class="line">    private int typeId;</span><br><span class="line">    private int taskId;</span><br><span class="line">    private bool isDelivery;</span><br><span class="line"></span><br><span class="line">    private string TaskDescription;</span><br><span class="line">    private int allNum;</span><br><span class="line">    private int submitId;   //需要提交的id</span><br><span class="line">    private const int NumOfTaskTypes = 9;   //任务种类数量</span><br><span class="line">    private const int DeliveryOfGoodsTaskId = 9;    //提交货物类型id</span><br><span class="line"></span><br><span class="line">    private delegate void JumpTask();</span><br><span class="line">    JumpTask [] jumpTask = new JumpTask[NumOfTaskTypes];</span><br><span class="line"></span><br><span class="line">    public override void Init()</span><br><span class="line">    &#123;</span><br><span class="line">        isDelivery = false;</span><br><span class="line">        allNum = 0;</span><br><span class="line">        submitId = 0;</span><br><span class="line">        btnGoto.onClick = (eventData, ev) =&gt; BtnGotoOnClick();</span><br><span class="line">        btnDelivery.onClick = (eventData, ev) =&gt; BtnDeliveryOnClick();</span><br><span class="line"></span><br><span class="line">        jumpTask[0] = new JumpTask(JumpTaskType_0);</span><br><span class="line">        jumpTask[1] = new JumpTask(JumpTaskType_1);</span><br><span class="line">        jumpTask[2] = new JumpTask(JumpTaskType_2);</span><br><span class="line">        jumpTask[3] = new JumpTask(JumpTaskType_3);</span><br><span class="line">        jumpTask[4] = new JumpTask(JumpTaskType_4);</span><br><span class="line">        jumpTask[5] = new JumpTask(JumpTaskType_5);</span><br><span class="line">        jumpTask[6] = new JumpTask(JumpTaskType_6);</span><br><span class="line">        jumpTask[7] = new JumpTask(JumpTaskType_7);</span><br><span class="line">        jumpTask[8] = new JumpTask(JumpTaskType_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SetItem (TableCityRichEvent.Data next)</span><br><span class="line">    &#123;</span><br><span class="line">        taskId = next.mId;</span><br><span class="line">        typeId = next.mFunctionType;</span><br><span class="line">        if (next.mFunctionParameter.Count == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            allNum = next.mFunctionParameter[0];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            submitId = next.mFunctionParameter[0];</span><br><span class="line">            allNum = next.mFunctionParameter[1];</span><br><span class="line">        &#125;</span><br><span class="line">        TaskDescription = next.mEventsDes;</span><br><span class="line">        textDegreeOfCompletion.text = &quot;0/&quot; + allNum;</span><br><span class="line">        textProgress.text = JointStr(TaskDescription, textDegreeOfCompletion.text);</span><br><span class="line">        slideProgress.maxValue = allNum;</span><br><span class="line">        slideProgress.value = 0;</span><br><span class="line">        if (isDeliveryOfGoodsTask())</span><br><span class="line">        &#123;</span><br><span class="line">            int num = StorageManager.instance.GetAllCommodityUnlockNumById(submitId);</span><br><span class="line">            textDegreeOfCompletion.text = num + &quot;/&quot; + allNum;</span><br><span class="line">            textProgress.text = JointStr(TaskDescription, textDegreeOfCompletion.text);</span><br><span class="line">            slideProgress.value = num &gt; allNum ? allNum : num;</span><br><span class="line">        &#125;</span><br><span class="line">        isCompleted(allNum, (int)slideProgress.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int GetTypeItem()</span><br><span class="line">    &#123;</span><br><span class="line">        return typeId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool HasChecked()</span><br><span class="line">    &#123;</span><br><span class="line">        return isDelivery;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool SetCurNum (int curNum)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isDeliveryOfGoodsTask())</span><br><span class="line">        &#123;</span><br><span class="line">            slideProgress.value = curNum;</span><br><span class="line">            textDegreeOfCompletion.text = curNum + &quot;/&quot; + allNum;</span><br><span class="line">            textProgress.text = JointStr(TaskDescription, textDegreeOfCompletion.text);</span><br><span class="line">        &#125;</span><br><span class="line">        if (curNum &gt;= allNum)</span><br><span class="line">        &#123;</span><br><span class="line">            isDelivery = true;</span><br><span class="line">            slideProgress.value = curNum;</span><br><span class="line">        &#125;</span><br><span class="line">        isCompleted(allNum, curNum);</span><br><span class="line">        return curNum &gt;= allNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private string JointStr(string str1, string str2)</span><br><span class="line">    &#123;</span><br><span class="line">        return str1 + &quot;  &quot; + str2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void isCompleted(int maxx, int cur)</span><br><span class="line">    &#123;</span><br><span class="line">        if (isDeliveryOfGoodsTask())</span><br><span class="line">        &#123;</span><br><span class="line">            imgCompleteDelivery.SetActive(!isDelivery);</span><br><span class="line">            imgCompleteGoto.SetActive(false);</span><br><span class="line">            imgCompleteFinish.SetActive(isDelivery);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            imgCompleteDelivery.SetActive(false);</span><br><span class="line">            imgCompleteGoto.SetActive(maxx &gt; cur);</span><br><span class="line">            imgCompleteFinish.SetActive(maxx &lt;= cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool isDeliveryOfGoodsTask()</span><br><span class="line">    &#123;</span><br><span class="line">        return TaskHash(typeId) == DeliveryOfGoodsTaskId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void BtnGotoOnClick()</span><br><span class="line">    &#123;</span><br><span class="line">        jumpTask[TaskHash(typeId)]();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SetBg(bool flag)</span><br><span class="line">    &#123;</span><br><span class="line">        imgBg.SetActive(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void BtnDeliveryOnClick()</span><br><span class="line">    &#123;</span><br><span class="line">        int num = StorageManager.instance.GetAllCommodityUnlockNumById(submitId);</span><br><span class="line">        if (isDelivery == false &amp;&amp; num &gt;= allNum)</span><br><span class="line">        &#123;</span><br><span class="line">            TCPNetworkAttribute.Instance.ReqRichlevelSubmit(taskId);</span><br><span class="line">            UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">            item.Init();</span><br><span class="line">            //isDelivery = true;</span><br><span class="line">            //SetCurNum(allNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int TaskHash(int id)</span><br><span class="line">    &#123;</span><br><span class="line">        return id / 1000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void JumpTaskType_0()        //默认</span><br><span class="line">    &#123;</span><br><span class="line">        UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">        item.Init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void JumpTaskType_1()        //出航</span><br><span class="line">    &#123;</span><br><span class="line">        if (TaskHash(typeId) == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            int[] types = &#123;</span><br><span class="line">                (int)IntentionType.Fishing,</span><br><span class="line">                (int)IntentionType.Fishing,</span><br><span class="line">                (int)IntentionType.Merchant,</span><br><span class="line">                (int)IntentionType.Explore</span><br><span class="line">            &#125;;   //捕鱼，战峙，贸易，探索</span><br><span class="line">            UISetOut_MainPage.intentionType = (IntentionType)types[typeId % 1000 - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        UISetOut_MainPage config = MenuManager.instance.CreateMenu&lt;UISetOut_MainPage&gt;();</span><br><span class="line">        config.OpenScreen();</span><br><span class="line">        UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">        item.CloseScreen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void JumpTaskType_2()        //建造</span><br><span class="line">    &#123;</span><br><span class="line">        UIBuildingHandle config = MenuManager.instance.CreateMenu&lt;UIBuildingHandle&gt;();</span><br><span class="line">        config.OpenScreen();</span><br><span class="line">        UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">        item.CloseScreen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void JumpTaskType_3()        //更路簿</span><br><span class="line">    &#123;</span><br><span class="line">        UILinkDistrict config = MenuManager.instance.CreateMenu&lt;UILinkDistrict&gt;();</span><br><span class="line">        config.OpenScreen();</span><br><span class="line">        UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">        item.CloseScreen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void JumpTaskType_4()        //易市</span><br><span class="line">    &#123;</span><br><span class="line">        UIMarketHandle config = MenuManager.instance.CreateMenu&lt;UIMarketHandle&gt;();</span><br><span class="line">        config.OpenScreen();</span><br><span class="line">        UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">        item.CloseScreen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void JumpTaskType_5()        //区域解锁</span><br><span class="line">    &#123;</span><br><span class="line">        UIUnLockZoneHandle handle = MenuManager.instance.CreateMenu&lt;UIUnLockZoneHandle&gt;();</span><br><span class="line">        TableLockZone.Data mTableData = null;</span><br><span class="line">        List&lt;TableLockZone.Data&gt; lst_zone_table = TableManager.instance.GetLockZoneAll();</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (; i &lt; lst_zone_table.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mTableData = lst_zone_table[i];</span><br><span class="line">            int id = mTableData.mId;</span><br><span class="line">            if (LockZoneManager.instance.IsReadyZoneUnlock(id))</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; lst_zone_table.Count &amp;&amp; mTableData != null)</span><br><span class="line">        &#123;</span><br><span class="line">            handle.SetZone(mTableData);</span><br><span class="line">            handle.OpenScreen();</span><br><span class="line">        &#125;</span><br><span class="line">        UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">        item.CloseScreen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void JumpTaskType_6()        //船坞</span><br><span class="line">    &#123;</span><br><span class="line">        UIShipHouseHandle config = MenuManager.instance.CreateMenu&lt;UIShipHouseHandle&gt;();</span><br><span class="line">        //config.gameObject.transform.Find(&quot;Canvas&quot;).GetComponent&lt;Canvas&gt;().sortingOrder = 3;</span><br><span class="line">        config.OpenScreen();</span><br><span class="line">        UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">        item.CloseScreen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void JumpTaskType_7()        //广场</span><br><span class="line">    &#123;</span><br><span class="line">        UIPiazzaHandle config = MenuManager.instance.CreateMenu&lt;UIPiazzaHandle&gt;();</span><br><span class="line">        BuildingControl control = BuildingManager.instance.GetBuildingControlByTableId(12);</span><br><span class="line">        config.InitFactory(control);</span><br><span class="line">        config.OpenScreen();</span><br><span class="line">        UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">        item.CloseScreen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void JumpTaskType_8()        //人物等级</span><br><span class="line">    &#123;</span><br><span class="line">        UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">        item.Init();</span><br><span class="line">        item.OpenScreen(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有没有发现，和设计模式中的工厂方法模式有异曲同工之妙呢。日后维护起来也方便许多。</p>
<p>接下来我们详细介绍下C#中的委托吧。</p>
<h1 id="C-委托（Delegate）"><a href="#C-委托（Delegate）" class="headerlink" title="C# 委托（Delegate）"></a>C# 委托（Delegate）</h1><p>C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。<strong>委托（Delegate）</strong> 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。</p>
<p>委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 <strong>System.Delegate</strong> 类。</p>
<h2 id="声明委托（Delegate）"><a href="#声明委托（Delegate）" class="headerlink" title="声明委托（Delegate）"></a>声明委托（Delegate）</h2><p>委托声明决定了可由该委托引用的方法。委托可指向一个与其具有相同标签的方法。</p>
<p>例如，假设有一个委托：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public delegate int MyDelegate (string s);</span><br></pre></td></tr></table></figure>
<p>上面的委托可被用于引用任何一个带有一个单一的 <em>string</em> 参数的方法，并返回一个 <em>int</em> 类型变量。</p>
<p>声明委托的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delegate &lt;return type&gt; &lt;delegate-name&gt; &lt;parameter list&gt;</span><br></pre></td></tr></table></figure>
<h2 id="实例化委托（Delegate）"><a href="#实例化委托（Delegate）" class="headerlink" title="实例化委托（Delegate）"></a>实例化委托（Delegate）</h2><p>一旦声明了委托类型，委托对象必须使用 <strong>new</strong> 关键字来创建，且与一个特定的方法有关。当创建委托时，传递到 <strong>new</strong> 语句的参数就像方法调用一样书写，但是不带有参数。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public delegate void printString(string s);</span><br><span class="line">...</span><br><span class="line">printString ps1 = new printString(WriteToScreen);</span><br><span class="line">printString ps2 = new printString(WriteToFile);</span><br></pre></td></tr></table></figure>
<p>下面的实例演示了委托的声明、实例化和使用，该委托可用于引用带有一个整型参数的方法，并返回一个整型值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">delegate int NumberChanger(int n);</span><br><span class="line">namespace DelegateAppl&#123;</span><br><span class="line">   class TestDelegate</span><br><span class="line">   &#123;  </span><br><span class="line">   		static int num = 10;  </span><br><span class="line">   		public static int AddNum(int p)  &#123; </span><br><span class="line">   				num += p; return num;</span><br><span class="line">   		&#125;</span><br><span class="line">   		public static int MultNum(int q)  &#123;</span><br><span class="line">   				num *= q; return num;</span><br><span class="line">   		&#125;</span><br><span class="line">   		public static int getNum()  &#123;</span><br><span class="line">   				return num;</span><br><span class="line">   		&#125;</span><br><span class="line">   		static void Main(string[] args)  &#123; // 创建委托实例</span><br><span class="line">   				NumberChanger nc1 = new NumberChanger(AddNum);</span><br><span class="line">   				NumberChanger nc2 = new NumberChanger(MultNum); // 使用委托对象调用方法</span><br><span class="line">   				nc1(25);</span><br><span class="line">   				Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum());</span><br><span class="line">   				nc2(5);</span><br><span class="line">   				Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum()); Console.ReadKey();</span><br><span class="line">   		&#125;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Value of Num: 35</span><br><span class="line">Value of Num: 175</span><br></pre></td></tr></table></figure>
<h2 id="委托的多播（Multicasting-of-a-Delegate）"><a href="#委托的多播（Multicasting-of-a-Delegate）" class="headerlink" title="委托的多播（Multicasting of a Delegate）"></a>委托的多播（Multicasting of a Delegate）</h2><p>委托对象可使用 “+” 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。”-“ 运算符可用于从合并的委托中移除组件委托。</p>
<p>使用委托的这个有用的特点，您可以创建一个委托被调用时要调用的方法的调用列表。这被称为委托的 <strong>多播（multicasting）</strong>，也叫组播。下面的程序演示了委托的多播：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">delegate int NumberChanger(int n); namespace DelegateAppl</span><br><span class="line">&#123;</span><br><span class="line">    class TestDelegate</span><br><span class="line">    &#123;</span><br><span class="line">        static int num = 10; public static int AddNum(int p) &#123; num += p; return num; &#125;</span><br><span class="line">        public static int MultNum(int q) &#123; num *= q; return num; &#125;</span><br><span class="line">        public static int getNum() &#123; return num; &#125;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123; // 创建委托实例</span><br><span class="line">            NumberChanger nc;</span><br><span class="line">            NumberChanger nc1 = new NumberChanger(AddNum);</span><br><span class="line">            NumberChanger nc2 = new NumberChanger(MultNum);</span><br><span class="line">            nc = nc1; nc += nc2; // 调用多播</span><br><span class="line">            nc(5);</span><br><span class="line">            Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum());</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Value of Num: 75</span><br></pre></td></tr></table></figure>
<h2 id="委托（Delegate）的用途"><a href="#委托（Delegate）的用途" class="headerlink" title="委托（Delegate）的用途"></a>委托（Delegate）的用途</h2><p>下面的实例演示了委托的用法。委托 <em>printString</em> 可用于引用带有一个字符串作为输入的方法，并不返回任何东西。</p>
<p>我们使用这个委托来调用两个方法，第一个把字符串打印到控制台，第二个把字符串打印到文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.IO;</span><br><span class="line">namespace DelegateAppl</span><br><span class="line">&#123;</span><br><span class="line">    class PrintString</span><br><span class="line">    &#123;</span><br><span class="line">        static FileStream fs; static StreamWriter sw;  // 委托声明</span><br><span class="line">        public delegate void printString(string s);  // 该方法打印到控制台</span><br><span class="line">        public static void WriteToScreen(string str) &#123;</span><br><span class="line">            Console.WriteLine(&quot;The String is: &#123;0&#125;&quot;, str);</span><br><span class="line">        &#125;  // 该方法打印到文件</span><br><span class="line">        public static void WriteToFile(string s)  &#123;</span><br><span class="line">            fs = new FileStream(&quot;c:\\message.txt&quot;, FileMode.Append, FileAccess.Write);</span><br><span class="line">            sw = new StreamWriter(fs); sw.WriteLine(s); sw.Flush(); sw.Close(); fs.Close();</span><br><span class="line">        &#125;  // 该方法把委托作为参数，并使用它调用方法</span><br><span class="line">        public static void sendString(printString ps)  &#123;</span><br><span class="line">            ps(&quot;Hello World&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        static void Main(string[] args)  &#123;</span><br><span class="line">            printString ps1 = new printString(WriteToScreen);</span><br><span class="line">            printString ps2 = new printString(WriteToFile);</span><br><span class="line">            sendString(ps1); sendString(ps2);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The String is: Hello World</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程序人生</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Unity</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>宽敞的心态，宽敞的世界</title>
    <url>/2019/07/28/2019-07-28/</url>
    <content><![CDATA[<p>忽然发现，来上海也有一段时间了。</p>
<p>还记得没来上海时，身边回荡着各种声音，上了年纪的长辈们鼓励我年轻人就应该出去闯一闯；父母则是抱着忧虑的念头，总说大城市生活压力大，骗子多，无时无刻都得防备；朋友们相对而言更担心的是我一个人出远门的安全。那时候，心中荡漾的，不清楚是期待，还是恐惧。</p>
<p>初来上海时，东奔西跑的找房租房，生活上高昂的消费让自己不得不开始学会记录支出，还有工作上初来乍到的各种不适应，总弄得自己身心疲惫；那时候，为最后一个挤上公交地铁而庆幸，为了早起而不得不早睡的无奈。心中徘徊的，应该是厌倦，还有抱怨吧。</p>
<p>现在呢，发现人们口中的大城市，并没有像人们所描述的那么繁华，也没有人们所描述的那样让人苦不堪言。渐渐地，我发现自己爱上了这里。</p>
<p>其实啊，上海没变，世界也没变，只有我们的心态变了。</p>
<p>就像人们议论程序员这个行业，一提到程序员，最多的话题就是996，也就是朝九晚九，每周6天。听到这词，即使没有工作，也难免会让人感觉疲惫。但是，真的如此吗。就像我，工作一段时间，感觉每天都很充实。每周有两天双休，但每次到了双休，玩一天游戏，或者什么也不干，剩下的只有空虚，所以周末能加班就加班，因为加班使自己感到生活的充实与价值。</p>
<p>还记得刚来学校时，因为热爱编程，而报了计算机专业。那时候，没日没夜敲代码是我的快乐。快找实习时，也是没日没夜敲代码，只是感觉到的是苦涩。而工作一段时间后，当我又开始忙碌地敲代码时，感觉到的是充实。同样是敲代码，在学校时因为热爱，在找实习时因为迷茫和环境的影响而决定苦涩，现在，是找到了方向。所以，所谓的忙碌，只不过是旁观者的看法。当一个人真正热爱自己的工作时，别人不要求你加班，你也想自己去加班。</p>
<p>人们都说上海节奏快，但我坚信时代造英雄。</p>
<p>昨天父亲又给我打了个电话，尽管只是平常地问候，但我却草草结束了话题。我后来发现，渐渐地，我越来越不怎么和父亲说话了。因为每次父亲跟我洽谈，总是告诫我一些关于社会让人多么的无奈，或者大城市节奏太快压力太大，亦或是社会上到处都是坏人，即使同一屋檐下也要上一把锁。这并不是我父亲一个人的想法，而是我们那个小城镇普遍的想法。</p>
<p>受我父亲的影响，刚上大学时，因为父亲说西安是贼城，当时我坐个公交都得把包背到前面。但久而久之，我发现并不是所有人都是坏人，那些不美好只不过是世界的冰山一角，但更多地是世界的美好，许多人身上都是有光的。只是这冰山一角给人的心理带来了防备，但当我们以这冰山一角来定义世界时，将必定错过整个世界。</p>
<p>2G时代，将互联网带上中国，成就了搜狐、新浪、网易。3G时代，将互联网带到了生活，成就了百度、阿里、腾讯，号称BAT。4G时代，将互联网带到了人们随身携带的手机，成就了头条、美团、滴滴，号称TMD。如今5G时代的到来，一切皆有可能，如果还停留在旧时代的舒适圈，不肯加快脚步，那么城乡差距就会越来越大。</p>
<p>放宽心态，多看看世界好的一面，那么哪来那么多烦恼呢。</p>
<p>如今，我每周周末都会去公寓周围的大超市去逛逛，有时候什么也不买，仅仅是因为里面的音乐让自己舒心。感受了一周的充实，偶尔给自己放个小假，你会发现，生活并不单调。</p>
<p>追随时代的大步伐，难免会疲惫。偶尔停下脚步，慢下来，感受自己心中所聆听到的声音，你会发现，快节奏的生活，也会有慢下来的情调。</p>
]]></content>
      <categories>
        <category>心路历程</category>
        <category>散文</category>
      </categories>
  </entry>
  <entry>
    <title>风往何处吹</title>
    <url>/2019/07/08/2019-07-08/</url>
    <content><![CDATA[<p>浅悠悠 7-8</p>
<p>我不知道，<br>风在往何处吹，<br>吹散了无根的枝叶，<br>还有七月的蔷薇。</p>
<p>我不知道，<br>风会往何处吹。<br>吹向那紫陌的寂寥，<br>还是霓虹的余辉。</p>
<p>我不知道，<br>风该往何处吹。<br>吹散那远方的清梦，<br>还是脚下的尘灰。</p>
<p>我不知道，<br>风向往何处吹。<br>吹向了温存的故事，<br>还有光阴的慈悲。</p>
<p>我不知道，<br>我什么也不知道。</p>
<p>也许只有风儿知道方向，<br>那我便化作海浪随风依洄。<br>也许风儿也不知道方向，<br>那我将像那尘埃何处可归。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>摘星集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>微信数据分析笔记</title>
    <url>/2019/06/24/2019-06-24/</url>
    <content><![CDATA[<h1 id="6月24日"><a href="#6月24日" class="headerlink" title="6月24日"></a>6月24日</h1><h2 id="项目需求分析"><a href="#项目需求分析" class="headerlink" title="项目需求分析"></a>项目需求分析</h2><p>1、男女性别比例</p>
<p>2、各省好友数量</p>
<p>3、个性签名云图</p>
<h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><h3 id="pyecharts"><a href="#pyecharts" class="headerlink" title="pyecharts"></a>pyecharts</h3><p>一个商业级图表，纯Js图表库。用于生成Echarts图表的类库。</p>
<h3 id="jieba"><a href="#jieba" class="headerlink" title="jieba"></a>jieba</h3><p>中文分词组件。</p>
<h3 id="scipy"><a href="#scipy" class="headerlink" title="scipy"></a>scipy</h3><p>工程设计的Python工具包。包括统计、优化、整合、线性代数模块、傅里叶变换、信号和图像处理、长积分方程求解器等等。</p>
<h3 id="wordcloud"><a href="#wordcloud" class="headerlink" title="wordcloud"></a>wordcloud</h3><p>Python词云展示库，在一段文本中提取关键词进行扁平化的展示，更能吸引目标客户的眼球。</p>
<h3 id="wxpy"><a href="#wxpy" class="headerlink" title="wxpy"></a>wxpy</h3><p>微信个人API</p>
<h3 id="re"><a href="#re" class="headerlink" title="re"></a>re</h3><p>Python的re模块提供了诸多正则表达式模块，使Python拥有了全部的正则表达式功能，库1方便检查一个字符串是否与某种模式匹配。</p>
<h2 id="登录并查看相关信息"><a href="#登录并查看相关信息" class="headerlink" title="登录并查看相关信息"></a>登录并查看相关信息</h2><p>1、登录</p>
<p>bot = Bot() #扫描二维码自动登录</p>
<p>2、获取登录账号的所有好友</p>
<p>bot.friends()</p>
<p>3、获取当前登录账号所关注的公众号</p>
<p>bot.mps()</p>
<p>4、获取当前登录账号群聊列表</p>
<p>bot.groups()</p>
<p>5、搜索好友：</p>
<p>bot.friends().search(‘好友备注名’)[0]</p>
<p>6、搜索好友并发送消息</p>
<p>bot.friends().search(‘好友备注名’)[0].send(‘str’)</p>
<p>7、向文件传输助手发送信息</p>
<p>bot.fle_helper.send(‘str’)</p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>1、每个键值(key:value)对用冒号分隔</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;s = &#123;&apos;name&apos;:&apos;udbs&apos;, &apos;age&apos;:20&#125;</span><br><span class="line">&gt;&gt;&gt;a[&apos;age&apos;]</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt;print(a[&apos;age&apos;])</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<h3 id="访问字典"><a href="#访问字典" class="headerlink" title="访问字典"></a>访问字典</h3><p>字典名[‘key’]</p>
<h3 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h3><p>字典名[‘key’] = ‘value’</p>
<h3 id="删除字典"><a href="#删除字典" class="headerlink" title="删除字典"></a>删除字典</h3><p>1、删除单一元素</p>
<p>格式：del 字典名[‘key’]</p>
<p>2、清空所有元素</p>
<p>格式：字典名.clear()</p>
<p>3、删除字典</p>
<p>格式：del 字典名</p>
<h1 id="6月25日"><a href="#6月25日" class="headerlink" title="6月25日"></a>6月25日</h1><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>open函数，必须先用Python内置的open()函数打开文件，创建一个file对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file object = open(file_name[, access_mode][, buffering])</span><br></pre></td></tr></table></figure>
<h2 id="with-as语句"><a href="#with-as语句" class="headerlink" title="with as语句"></a>with as语句</h2><p>try-finally语句可以处理异常。但较麻烦。</p>
<p>python提供了with语句语法，来构建对资源创建与释放方法，但功能与try相似。with语句后面跟着open方法，如果有返回值，可以使用as语句赋值给变量，退出时自动调用close。</p>
<h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h2><p>re.findall()方法</p>
<p>搜索整个字符串，返回匹配正则表达式的所有内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">re.findall(pattern,string)</span><br></pre></td></tr></table></figure>
<p>re.compile()方法</p>
<p>将正则字符串编译成正则表达式对象，以便后期匹配中复用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">re.compile(&apos;正则表达式&apos;)</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul>
<li>.匹配除了换行符之外的所有字符。</li>
<li>d数字</li>
<li>w字母</li>
</ul>
<p>join()方法</p>
<p>用于将序列中的元素以指定的字符连接生成一个新的字符串</p>
<h1 id="6月26日"><a href="#6月26日" class="headerlink" title="6月26日"></a>6月26日</h1><h2 id="jieba库"><a href="#jieba库" class="headerlink" title="jieba库"></a>jieba库</h2><ol>
<li><p>精确模式：jieba.lcut(str)</p>
<p>试图将语句最精确切分，不存在冗余数据，适合文本分析。</p>
</li>
<li><p>全模式：jieba.lcut(str,cut_all=True)</p>
<p>将与句中所有可能是词的词语都切分出来，速度快，但存在冗余数据</p>
</li>
<li><p>搜索引擎模式：jieba.lcut_for_search(str)</p>
<p>在精确模式的基础上·，对长词再次进行切分。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; str = &apos;手持两把锟斤拷&apos;</span><br><span class="line">&gt;&gt;&gt; jieba.lcut(str)</span><br><span class="line">[&apos;手持&apos;, &apos;两把&apos;, &apos;锟&apos;, &apos;斤&apos;, &apos;拷&apos;]</span><br><span class="line">&gt;&gt;&gt; str = &apos;手持两把锟斤拷，口中直呼烫烫烫。&apos;</span><br><span class="line">&gt;&gt;&gt; jieba.lcut(str)</span><br><span class="line">[&apos;手持&apos;, &apos;两把&apos;, &apos;锟&apos;, &apos;斤&apos;, &apos;拷&apos;, &apos;，&apos;, &apos;口中&apos;, &apos;直呼&apos;, &apos;烫烫&apos;, &apos;烫&apos;, &apos;。&apos;]</span><br><span class="line">&gt;&gt;&gt; jieba.lcut_for_search(str)</span><br><span class="line">[&apos;手持&apos;, &apos;两把&apos;, &apos;锟&apos;, &apos;斤&apos;, &apos;拷&apos;, &apos;，&apos;, &apos;口中&apos;, &apos;直呼&apos;, &apos;烫烫&apos;, &apos;烫&apos;, &apos;。&apos;]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="筛选函数isin-函数"><a href="#筛选函数isin-函数" class="headerlink" title="筛选函数isin()函数"></a>筛选函数isin()函数</h2><h3 id="isin"><a href="#isin" class="headerlink" title="isin()"></a>isin()</h3><p>功能：判断该列元素是否在某一个列表中。是True，否False。</p>
<h2 id="groupby函数和agg函数"><a href="#groupby函数和agg函数" class="headerlink" title="groupby函数和agg函数"></a>groupby函数和agg函数</h2><p>agg基于列的聚合操作</p>
<p>groupby基于行</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb网上购物系统的设计与实现</title>
    <url>/2019/06/02/2019-06-02/</url>
    <content><![CDATA[<p><a href="https://github.com/qian-youyou/ShoppingNet" target="_blank" rel="noopener">GitHub源码</a></p>
<p>1 课题简介    </p>
<p>1.1 背景及研究现状</p>
<p>在互联网高速发展的时代背景下，网络正以一种前所未有的冲击力在影响着人类的活动，包括人类的生产和日常生活。网络的诞生和发展，颠覆了传统的信息传播方式，冲破了存在于传统交流方式中时间和空间的种种壁垒，极大地改变了人类从物质到精神、从形式到内容、从生产到生活的各种活动，并且给人类带来了新的机遇和挑战。网络购物作为电子商务的一种形式正以其高效、低成本的优势，逐步成为新兴的经营模式和理念，人们已经不再满足用途信息的浏览和发布，而是渴望着能够充分享受网络所带来的更加多的便利。网络购物正适应了当今社会快节奏地生活，使顾客足不出户便可以方便快捷轻松地选购自己喜欢的商品。</p>
<p>本次网上购物系统基于课程设计以专业综合设计I的设计成果，对其进行Web服务器端功能的扩展与开发，将其设计成一个具有服务器端交互功能的完整的Web应用系统，并完成系统的测试、服务器端的部署与发布。</p>
<p>1.2 设计内容与设计思路    </p>
<p>网上购物系统主要是对后台管理和前台操作。后台管理是管理员对本网站的维护，通过商品资料(商品添加、商品修改)，等功能达到对网站的管理。前台操作是用户登录到本网站，可以进行用户注册，通过网站的热门商品推荐或商品分类查找功能实现商品搜索，找到自己想要买的商品，装入购物车，提交定单进行购买。</p>
<p>网上购物平台的特点是客户和电子商品信息量很大，管理员需要整理的信息很多，为让管理员轻松、方便、快捷的管理，该平台采用符合购买电子商品基本的原则，满足广大客户的日益增长的数量，并达到操作过程中的直观、方便、实用、安全等要求。</p>
<p>1.3 设计目的及意义</p>
<p>网上购物系统，是在网络上建立一个虚拟的购物商场，使消费者的购物过程变得轻松、快捷、方便，很适合现代人快节奏的生活；同时又有效的控制“商场”运营的成本，开辟了一个新的销售渠道。 </p>
<p>网上购物相较于实体店铺有着其独特的优势，首先相较于实体店铺网上店铺所需要的成本很小很多，网上购物不需要考虑门店等等的费用其次网上购物系统不存在店铺打样的问题延长了经营的时间无需专人看店节约成本的同时还能使得效益更大化。</p>
<p>本系统利用现代化的电子及网络技术，为消费者和企业搭建一个良好的互动平台。让用户享受快捷的购物方式，为企业提供不同于传统销售的崭新的销售模式。 该购物系统是一个中小型的电子商务系统，可以为各类用户提供方便的在线购物环境。用户可以在系统中实现注册、登录、修改个人信息、分类查询商品信息、购物、管理购物车、支付等功能。管理员可以通过后台管理模块实现商品的增删改查、种类的增删改查等，从而实现对于该购物系统的管理。</p>
<p>2 系统分析与设计</p>
<p>2.1 可行性分析    </p>
<p>可行性研究是为了弄清楚系统开发的项目是不是可以实现和值得进行研究的过程，实际上是一次大大简化系统分析和系统设计的过程，所以，进行可执行性的分析是非常必要的，也是很重要的，可行性研究阶段通过对系统目标进行市场调研和技术分析，提出了初步的可行性方案并进行了论证。这里主要从技术可行性、经济可行性以及操作可行性三方面进行分析。</p>
<p>2.1.1 经济可行性</p>
<p>该系统硬件只需要一台PC机，而且配置要求不高。软件方面用到的MySQL是免费开源的，Eclipse也是免费使用的，所以开发成本并不高。而该系统若投入运行之后不仅减少了人力、物力而且可以推动电影行业的发展，所带来的收益是巨大的，因此在经济上也是可行的。</p>
<p>2.1.2 技术可行性</p>
<p>技术可行性要考虑到现有的技术手段和能力能不能完成系统的开发，以免开发到一半出现现有技术无法解决的问题。本系统主要采用的是JAVAWeb和JSP技术。JAVA语言和JSP都是很成熟的技术，也是世界范围内应用最广泛的技术，所以用它们作为后台和前台的语言是没有任何问题的。而且集成开发工具Eclipse可以解决很多方面的问题，创造了良好的开发环境。由于JSP功能强大，而MySQL灵活易维护在开发方面具有方便快捷、使用灵活的特点，以及目前的广泛实际应用，因此使用JAVAWed、MySQL是开发轻平台的最佳组合从而说明本系统在技术方面可行。</p>
<p>硬件方面，科技飞速发展的今天，硬件更新的速度越来越快，容量越来越大，可靠性越来越高，价格越来越低，其硬件平台完全能满足此系统的需要。</p>
<p>2.2 需求分析</p>
<p>2.2.1 系统设计目标</p>
<p>此网络购物平台系统旨在为用户提供一个简易的具备一些基本功能的购物系统，通过这个系统用户可以轻松的获得自己想要的商品。存在两种类型用户，普通用户和管理员用户。普通用户在这个系统中注册过后进行登陆此时可以在平台中进行自由的选购自己想要的商品，将选购好的商品加入购物车，如果需要修改可以在购物车中更改所需的商品数量，当选择完成过后可以确认购买，也可以让所选物品一直处在购物车中，等待下次登陆时依然有效。管理员用户可以对商品进行管理，包括商品上架，商品下架，商品查询，商品修改等。</p>
<p>2.2.2 系统功能需求分析</p>
<p>（1）用户管理：注册会员、登录、管理员用户校验、激活、退出；</p>
<p>（2）商品显示：按分类查询商品、通过首页推荐查询商品、展示热门商品、展示最新商品、提交商品到购物车中等；</p>
<p>（3）购物车管理：向购物车中添加商品、修改购物车中商品数量、删除购物车中商品、我的购物车；</p>
<p>（4）订单管理：通过购物车中商品生成订单、查看我的订单、查看某个订单的详细、订单支付、确认收货。</p>
<p>（5）管理员：订单查询、商品和类别的增删改查。</p>
<p>2.2.3 系统性能需求分析</p>
<p>用户注册部分需要实时检验用户信息是否合格，否则用户提交后才检验，若不合格需重新填写，用户很快会厌倦，因此Ajax是不错的选择。</p>
<p>商品部份应该给用户提供推荐，比如最新商品和最热商品，给用户提供访问便利。</p>
<p>此外，分类部分不常改，且使用频繁，但每次若从数据库中读取会影响效率，因此使用redis缓存数据是个不错的选择，因为大大加快了访问效率。</p>
<p>订单部分由于支付功能需要第三方平台，所以可不必实现。</p>
<p>管理员部分需要对订单具有全权访问权限。</p>
<p>2.3 系统总体设计</p>
<p>2.3.1 系统总体结构设计</p>
<p>本项目采取MVC设计模式，分为model，view，controler三层。本项目包含dao，domain，service，web，utils五打包。</p>
<p>其中web包中包含各种servlet类和前端jsp进行交互，及view层。</p>
<p>Service为业务逻辑层，控制信息的权限以及信息在数据库与前端的交互，及controler层。Dao中主要负责与数据库进行交互，通过各种sql获取或添加信息到数据库，及model层。</p>
<p>Domain为基本类，共三大层创建对象进行层与层间的信息交互，作为信息载体的集合而存在。</p>
<p>Utils包中包含各种工具，例如数据库中的date类型需要string进行转换，或者id的生成，这些工具均包含于utils包中。基本模式如下图：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps1.jpg" alt="img"> </p>
<p>图2-1 系统总体结构设计图</p>
<p>B/S系统架构，简单点就是用户通过访问浏览器输入域名后，转入对应的前端html或jsp，然后通过http或https协议将信息报文传送给服务端，服务端进行相应之后做出一系列对数据或页面的响应。以下是B/S系统架构图。</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps2.jpg" alt="img"> </p>
<p>图2-2 B/S系统框架图</p>
<p>2.3.2 系统功能模块设计</p>
<p>（1）用户注册功能：发送邮件、激活用户、表单的校验、用户的登录功能、自动登录、用户的注销功能</p>
<p>（2）商品模块：首页热门商品和最新商品功能、商品分类、商品的列表（分页）、商品详细信息、浏览记录功能</p>
<p>（3）购物车模块：将商品加入购物车、展示购物车功能</p>
<p>（4）订单模块（多表和事务）：提交订单、展示订单、在线支付</p>
<p>（5）后台的分类的模块：分类信息的增删改查</p>
<p>（6）后台的商品模块：商品的信息的增删改查（文件上传）</p>
<p>（7）后台的订单的模块：所有的订单的信息展示</p>
<p>2.3.3 主要业务流程</p>
<p>用户的注册过程：</p>
<p>是首先进入主界面，点击注册按钮，跳转到注册页面，填写注册信息，ajax判断信息是否合格，然后跳转到注册servlet层，把信息传递给service层，service层通过dao层获取数据库信息，反馈是否成功给servlet层，最终按是否插入成功而跳转到注册成功或失败界面。之后介绍的流程大致如此，及MVC三层模型的传输过程。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps3.jpg" alt="img"></td>
</tr>
</tbody>
</table>
<p>图</p>
<p>2-3 程序包结构图</p>
<p>主界面显示：</p>
<p>首先index.jsp加载head.jsp，然后获取最热商品信息与最新商品信息，并显示在主界面，最后加载footer.jsp。</p>
<p>Head.jsp界面显示：</p>
<p>首先加载首页，然后访问redis数据库判断是否有种类信息，有则读取，无则访问MySQL数据库，读取数据后放到redis中。</p>
<p>用户注册分析：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps4.jpg" alt="img"> </p>
<p>图2-4 用户注册详情</p>
<p>商品设计：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps5.jpg" alt="img"> </p>
<p>图2-5 商品详情</p>
<p>通过浏览器访问商城，就相当于超市访问商品，因此我们需要购物车来装载商品以便对所需物品增删改查。<img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps6.jpg" alt="img"></p>
<p>图2-6 购物车设计</p>
<p>订单业务设计：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps7.jpg" alt="img"> </p>
<p>图2-7 订单业务设计</p>
<p>管理员管理流程：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps8.jpg" alt="img"> </p>
<p>图2-8 管理员管理</p>
<p>2.4 系统数据库设计</p>
<p>2.4.1 数据库概念模型设计</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps9.jpg" alt="img"> </p>
<p>图2-9  E-R图</p>
<p>2.4.2数据库逻辑结构设计</p>
<p>表2-1 category表结构</p>
<table>
<thead>
<tr>
<th>Column Name</th>
<th>Date Type</th>
<th>Width</th>
<th>空值情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cid</td>
<td>varChar</td>
<td>50</td>
<td>主关键字</td>
</tr>
<tr>
<td>Cname</td>
<td>varChar</td>
<td>20</td>
<td>默认为空</td>
</tr>
</tbody>
</table>
<p>表2-2 orderitem表结构</p>
<table>
<thead>
<tr>
<th>Column Name</th>
<th>Date Type</th>
<th>Width</th>
<th>空值情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>itemid</td>
<td>varChar</td>
<td>50</td>
<td>主关键字</td>
</tr>
<tr>
<td>count</td>
<td>int</td>
<td>11</td>
<td>可为空</td>
</tr>
<tr>
<td>subtotal</td>
<td>double</td>
<td>0</td>
<td>可为空</td>
</tr>
<tr>
<td>pid</td>
<td>varchar</td>
<td>50</td>
<td>可为空</td>
</tr>
<tr>
<td>oid</td>
<td>varchar</td>
<td>50</td>
<td>可为空</td>
</tr>
</tbody>
</table>
<p>表2-3 order表</p>
<table>
<thead>
<tr>
<th>Column Name</th>
<th>Date Type</th>
<th>Width</th>
<th>空值情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>varChar</td>
<td>50</td>
<td>主关键字</td>
</tr>
<tr>
<td>ordertime</td>
<td>datetime</td>
<td>0</td>
<td>可为空</td>
</tr>
<tr>
<td>total</td>
<td>double</td>
<td>0</td>
<td>可为空</td>
</tr>
<tr>
<td>state</td>
<td>int</td>
<td>11</td>
<td>可为空</td>
</tr>
<tr>
<td>address</td>
<td>varchar</td>
<td>30</td>
<td>可为空</td>
</tr>
<tr>
<td>name</td>
<td>varchar</td>
<td>20</td>
<td>可为空</td>
</tr>
<tr>
<td>telephone</td>
<td>varchar</td>
<td>20</td>
<td>可为空</td>
</tr>
<tr>
<td>uid</td>
<td>varchar</td>
<td>50</td>
<td>可为空</td>
</tr>
</tbody>
</table>
<p>表2-4 product表</p>
<table>
<thead>
<tr>
<th>Column Name</th>
<th>Date Type</th>
<th>Width</th>
<th>空值情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>pid</td>
<td>varChar</td>
<td>50</td>
<td>主关键字</td>
</tr>
<tr>
<td>pname</td>
<td>Varchar</td>
<td>20</td>
<td>可为空</td>
</tr>
<tr>
<td>Market_price</td>
<td>double</td>
<td>0</td>
<td>可为空</td>
</tr>
<tr>
<td>Shop_price</td>
<td>double</td>
<td>0</td>
<td>可为空</td>
</tr>
<tr>
<td>pimage</td>
<td>varchar</td>
<td>30</td>
<td>可为空</td>
</tr>
<tr>
<td>pdate</td>
<td>date</td>
<td>20</td>
<td>可为空</td>
</tr>
<tr>
<td>Is_hot</td>
<td>int</td>
<td>20</td>
<td>可为空</td>
</tr>
<tr>
<td>pdesc</td>
<td>varchar</td>
<td>255</td>
<td>可为空</td>
</tr>
<tr>
<td>pflag</td>
<td>int</td>
<td>11</td>
<td>可为空</td>
</tr>
<tr>
<td>cid</td>
<td>varchar</td>
<td>50</td>
<td>可为空</td>
</tr>
</tbody>
</table>
<p>表2-5 user表</p>
<table>
<thead>
<tr>
<th>Column Name</th>
<th>Date Type</th>
<th>Width</th>
<th>空值情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>uid</td>
<td>varChar</td>
<td>50</td>
<td>主关键字</td>
</tr>
<tr>
<td>username</td>
<td>Varchar</td>
<td>20</td>
<td>可为空</td>
</tr>
<tr>
<td>password</td>
<td>Varchar</td>
<td>20</td>
<td>可为空</td>
</tr>
<tr>
<td>name</td>
<td>varchar</td>
<td>20</td>
<td>可为空</td>
</tr>
<tr>
<td>email</td>
<td>varchar</td>
<td>30</td>
<td>可为空</td>
</tr>
<tr>
<td>telephone</td>
<td>varchar</td>
<td>20</td>
<td>可为空</td>
</tr>
<tr>
<td>birthday</td>
<td>date</td>
<td>0</td>
<td>可为空</td>
</tr>
<tr>
<td>sex</td>
<td>varchar</td>
<td>10</td>
<td>可为空</td>
</tr>
<tr>
<td>state</td>
<td>int</td>
<td>11</td>
<td>可为空</td>
</tr>
<tr>
<td>code</td>
<td>varchar</td>
<td>50</td>
<td>可为空</td>
</tr>
</tbody>
</table>
<p>2.4.3 数据库关系设计</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps10.jpg" alt="img"> </p>
<p>图2-10 数据库关系图</p>
<p>3  系统详细设计</p>
<p>3.1 系统开发及运行环境</p>
<p>3.1.1 软件环境    </p>
<p>运行环境：Windows操作系统下eclipse</p>
<p>开发语言：JavaWeb</p>
<p>数据库：MySQL，redis</p>
<p>3.1.2 硬件环境    </p>
<p>阿里云服务器。</p>
<p>3.2 系统采用的关键技术</p>
<p>3.2.1页面显示逻辑与业务逻辑相分离</p>
<p><a href="https://baike.baidu.com/item/MVC" target="_blank" rel="noopener">MVC</a>全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p>
<p>3.2.2数据库连接与访问    </p>
<p>C3P0是一个开源的JDBC<a href="https://baike.baidu.com/item/%E8%BF%9E%E6%8E%A5%E6%B1%A0/1699713" target="_blank" rel="noopener">连接池</a>，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。</p>
<p>3.2.3 Ajax异步校验</p>
<p>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</p>
<p>3.3 系统框架的实现</p>
<p>本项目采取MVC设计模式，分为model，view，controler三层。本项目包含dao，domain，service，web，utils五大包。</p>
<p>其中web包中包含各种servlet类和前端jsp进行交互，及view层。</p>
<p>Service为业务逻辑层，控制信息的权限以及信息在数据库与前端的交互，及controler层。Dao中主要负责与数据库进行交互，通过各种sql获取或添加信息到数据库，及model层。</p>
<p>Domain为基本类，共三大层创建对象进行层与层间的信息交互，作为信息载体的集合而存在。</p>
<p>Utils包中包含各种工具，例如数据库中的date类型需要string进行转换，或者id的生成，这些工具均包含于utils包中。</p>
<p>3.3.1 主要的类与接口</p>
<p>表3-1 JSP清单</p>
<table>
<thead>
<tr>
<th>Jsp</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>admin/home.jsp</td>
<td>管理员界面</td>
</tr>
<tr>
<td>index.jsp</td>
<td>主界面</td>
</tr>
<tr>
<td>head.jsp</td>
<td>头界面</td>
</tr>
<tr>
<td>footer.jsp</td>
<td>尾界面</td>
</tr>
<tr>
<td>Product_list.jsp</td>
<td>商品栏界面</td>
</tr>
<tr>
<td>Product_info.jsp</td>
<td>单项商品信息界面</td>
</tr>
<tr>
<td>order_list.jsp</td>
<td>订单栏界面</td>
</tr>
<tr>
<td>order_info.jsp</td>
<td>订单项界面</td>
</tr>
<tr>
<td>cart.jsp</td>
<td>购物车界面</td>
</tr>
<tr>
<td>login.jsp</td>
<td>登陆界面</td>
</tr>
<tr>
<td>register.jsp</td>
<td>注册界面</td>
</tr>
</tbody>
</table>
<p>表3-2 MVC模式清单</p>
<table>
<thead>
<tr>
<th>Servlet</th>
<th>Service</th>
<th>Dao</th>
<th>Utils</th>
<th>Domain</th>
</tr>
</thead>
<tbody>
<tr>
<td>AutoLoginFilter</td>
<td>AdminService</td>
<td>AdminDao</td>
<td>BeanFactory</td>
<td>Cart</td>
</tr>
<tr>
<td>ActiveServlet</td>
<td>ProductService</td>
<td>ProductDao</td>
<td>CommonsUtils</td>
<td>CartItem</td>
</tr>
<tr>
<td>AdminServlet</td>
<td>UserService</td>
<td>UserDao</td>
<td>DataSourceUtils</td>
<td>Category</td>
</tr>
<tr>
<td>BaseServlet</td>
<td>AdminServiceImpl</td>
<td></td>
<td>JedisPoolUtils</td>
<td>Order</td>
</tr>
<tr>
<td>CallbackServlet</td>
<td></td>
<td></td>
<td>MailUtils</td>
<td>OrderItem</td>
</tr>
<tr>
<td>PrdocutServlet</td>
<td></td>
<td></td>
<td>MD5Utils</td>
<td>PageBean</td>
</tr>
<tr>
<td>RegisterServlet</td>
<td></td>
<td></td>
<td>PaymentUtil</td>
<td>Product</td>
</tr>
<tr>
<td>UserServlet</td>
<td></td>
<td></td>
<td></td>
<td>User</td>
</tr>
</tbody>
</table>
<p>3.3.2 系统主要配置文件</p>
<p>c3p0-config.xml负责数据库连接配置。</p>
<p>redis.properties负责redis端口属性配置。</p>
<p>Bean.xml配置AdminServiceImpl的清单。</p>
<p>Web.xml配置jsp清单。</p>
<p>3.4 具体功能模块的实现    </p>
<p>3.4.1前台分类信息展示</p>
<p>在head.jsp中有以下js代码：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps11.jpg" alt="img"> </p>
<p>图3-1 主页head栏</p>
<p>通过Ajax方式，首先访问CategoryServlet中的findCategory()方法，查询并以json格式返回Category的List集合db.cname即是最终导航栏显示的分类信息。</p>
<p>点击某一个分类后，会访问ProductServlet中的findPage()方法，传递当前页数：1和分类ID：cid。</p>
<p>3.4.2分类商品的分页展示</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps12.jpg" alt="img"> </p>
<p>图3-2 分类商品首页图</p>
<p>Dao层查询每页显示的数据（select * from product where cid = ? limit ?,?），Service层调用Dao后再进行条数页数的设置并封装进javabean，返回给servlet。</p>
<p>Servlet中的findPage()方法：</p>
<p>首先获取分类的ID：String cid = request.getParameter(“cid”);</p>
<p>然后获取当前页数：</p>
<p>int pageNumber =Integer.parseInt(request.getParameter(“pageNumber”));</p>
<p>之后设定每页显示的条数，带着参数调用service。将返回的PageBean对象和分类ID存储，供jsp页面使用。</p>
<p>Service层的findPage()方法：</p>
<p>List<product> list = pd.findPage(cid,pageNumber,pageSize);</product></p>
<p>封装的每页显示数据，按总条数和总页数进行封装。然后pageBean按每页显示的数据封装数据。</p>
<p>Servlet将pagebean存到request域中后，在jsp页面通过jstl遍历展示商品信息：</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps13.jpg" alt="img"> </p>
<p>图3-3 产品分类显示</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps14.jpg" alt="img"> </p>
<p>图3-4 产品分类jsp代码</p>
<p>3.4.3单个商品详情</p>
<p>在商品列表页面有：</p>
<p>&lt;ahref=”${pageContext.request.contextPath}/product?method=productList&amp;cid=${cid }¤tPage=${currentPage}”&gt;</p>
<p>这是定义在每个商品图片上的超链接，点击后访问ProductServlet中的findBypid()方法，查询单个商品的详情。</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps15.jpg" alt="img"> </p>
<p>图3-5 产品单件商品信息页面</p>
<p>3.4.4最新和热门商品展示</p>
<p>首先，每个商品有一个是否热门属性和一个上架时间属性。加载主页面时，会从数据库中读取is_hot为1的所有商品作为热门商品，并加载时间最近的商品作为最新商品。href为${pageContext.request.contextPath}/product?method=productInfo&amp;pid=${hotPro.pid}。项目运行后直接访问ProductServlet中的findByNew()方法，查询最新最热商品信息，然后跳转到/jsp/index.jsp页面进行展示。</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps16.jpg" alt="img"> </p>
<p>图3-6 热门商品展示</p>
<p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps17.jpg" alt="img"> </p>
<p>图3-7 最新商品展示</p>
<p>4 系统测试 </p>
<p>4.1 系统测试方法</p>
<p>测试方法采用了边界值，场景分析，等价类，用jmeter进行接测和压测。</p>
<p>4.2 系统测试用例</p>
<p>表4-1 系统测试</p>
<table>
<thead>
<tr>
<th>测试功能</th>
<th>测试用例序号</th>
<th>测试样例</th>
</tr>
</thead>
<tbody>
<tr>
<td>按类别查询商品首页</td>
<td>1</td>
<td>直接查询</td>
</tr>
<tr>
<td>分页展示分类商品</td>
<td>2</td>
<td>按种类添加删除商品信息</td>
</tr>
<tr>
<td>单个商品信息校验</td>
<td>3</td>
<td>修改部分商品信息</td>
</tr>
<tr>
<td>最热与最新商品展示</td>
<td>4</td>
<td>修改最热属性以及日期</td>
</tr>
</tbody>
</table>
<p>4.3 系统测试结果</p>
<p>表4-2 测试结果</p>
<table>
<thead>
<tr>
<th>测试用例序号</th>
<th>测试结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>成功</td>
</tr>
<tr>
<td>2</td>
<td>成功</td>
</tr>
<tr>
<td>3</td>
<td>成功</td>
</tr>
<tr>
<td>4</td>
<td>成功</td>
</tr>
</tbody>
</table>
<p>5 总结</p>
<p>5.1 系统工作总结</p>
<p>​    我们这次首先应用到了MVC框架一开始使用的时候还有点生疏，但是在熟悉了以后，MVC框架的优点现了出来，它把前后台分开进行处理，我们在写后台逻辑的时候不需要考虑前端网页的布局，在写前端网页的时候也不需要在页面中插入后端的业务逻辑，这样让整个开发的过程变得十分明确，包括在查看源码的时候也不会眼花缭乱，当代码发生错误时，调试起来也能够快速的发现错误点，这是相较于之前没有框架使用的时候所没有的优越之处。同时，我们这次还用了C3P0的数据库池连接，它的优势之处就是比原本单纯的JDBC连接更加快捷，速度更快了。</p>
<p>5.2 存在的不足及改进</p>
<p>本系统由于涉及到支付功能，而支付又涉及到现金交易，因此该部分一直没有实现，经查阅资料了解到第三方支付平台的存在，但目前由于第三方支付平台账号问题目前支付功能具体还没有实现。之后会陆续对该部分进行改进。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MVC</tag>
        <tag>JavaWeb</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]unity pro 2019最新破解版 v2019.1.2f1</title>
    <url>/2019/05/29/2019-05-29/</url>
    <content><![CDATA[<p>由于unity更新，之前v2019.1.0a8破解版本更新为v2019.1.2f1，花了很长时间终于找到了破解方法。如下。</p>
<p>unity pro 2019破解版，其除了原程序还附带了破解补丁和许可文件，能够免费帮助用户破解得到一个可无限制免费使用所有功能的unity pro 2019，随后在下文会附上破解安装教程。</p>
<p>unity2019破解版安装说明</p>
<p>1、下载并解压本站提供的包，其包换了unity pro 2019原程序、破解补丁、许可文件。</p>
<p>2、先打开文件夹”addons”双击”UnityHubSetup-1.6.2.exe”依提示进行安装Unity Hub。</p>
<p>3、这里默认路径为【C:\Program Files\Unity Hub】</p>
<p>4、耐心等待安装完成后先不要运行该软件。</p>
<p>5、然后双击”UnitySetup64-2019.1.2f1.exe”依提示进行安装开始安装Unity。</p>
<p>6、这里默认路径为【C:\Program Files\Unity】</p>
<p>7、这里有点慢，请耐心等待安装。</p>
<p>8、安装完成后同样先不要运行该软件。</p>
<p>9、然后将本站提供的文件夹”crack”——“Hub”中的”app.asar”拖至【C:\Program Files\Unity Hub\resources】中并选择复制和替换即可。</p>
<p>10、接着选择”crack”进入到”Unity”选择用户自己需要的版本。</p>
<p>11、例如小编这里选择2019.1.0f2，那么就将文件夹里面的”Unity.exe”拖至【C:\Program Files\Unity\Editor】中并选择复制和替换即可。</p>
<p>12、然后将”2019.1.0f2”文件夹中的”Unity_lic.ulf”许可文件复制到【C:\ProgramData\Unity】中，如果C:驱动器没有ProgramData文件夹，则启用隐藏文件显示。是C:\ProgramData文件夹中没有Unity文件夹，那么就创建一个。</p>
<p>13、运行”Unity Hub”点击”Locate a Version”</p>
<p>14、找到unit.exe文件的路径即【C:\Program Files\Unity\Editor】点击”select sditor”</p>
<p>15、接着需要创建一个用于验证的新项目，点击”new”</p>
<p>16、安装所需的支持模块和附加组件。</p>
<p>17、耐心等待即可，到这里就已经全部破解完成了，用户就可以免费无限制使用unity pro 2019破解版了。</p>
<p><a href="https://pan.baidu.com/s/1Em7dYE8H8Q_EaUhqQIiv-Q?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;traceid=#list/path=%2F" target="_blank" rel="noopener">下载地址</a></p>
<p><a href="http://www.ddooo.com/softdown/144746.htm#dltab" target="_blank" rel="noopener">教程</a></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb课程设计之网上商城</title>
    <url>/2019/05/25/2019-05-25/</url>
    <content><![CDATA[<p>最近一堆课设，总结随便写写吧。</p>
<h1 id="一、功能的演示"><a href="#一、功能的演示" class="headerlink" title="一、功能的演示"></a>一、功能的演示</h1><h3 id="1．用户模块"><a href="#1．用户模块" class="headerlink" title="1．用户模块"></a>1．用户模块</h3><p>用户注册功能</p>
<p>发送邮件</p>
<p>激活用户</p>
<p>表单的校验</p>
<p>用户的登录功能</p>
<p>自动登录</p>
<p>用户的注销功能</p>
<h3 id="2．商品模块"><a href="#2．商品模块" class="headerlink" title="2．商品模块"></a>2．商品模块</h3><p>首页热门商品和最新商品功能</p>
<p>商品分类</p>
<p>商品的列表（分页）</p>
<p>商品详细信息</p>
<p>浏览记录功能</p>
<h3 id="3．购物车模块"><a href="#3．购物车模块" class="headerlink" title="3．购物车模块"></a>3．购物车模块</h3><p>将商品加入购物车</p>
<p>展示购物车功能</p>
<h3 id="4．订单模块（多表和事务）"><a href="#4．订单模块（多表和事务）" class="headerlink" title="4．订单模块（多表和事务）"></a>4．订单模块（多表和事务）</h3><p>提交订单</p>
<p>展示订单</p>
<p>在线支付</p>
<h3 id="5．后台的分类的模块"><a href="#5．后台的分类的模块" class="headerlink" title="5．后台的分类的模块"></a>5．后台的分类的模块</h3><p>分类信息的增删改查</p>
<h3 id="6．后台的商品模块"><a href="#6．后台的商品模块" class="headerlink" title="6．后台的商品模块"></a>6．后台的商品模块</h3><p>商品的信息的增删改查（文件上传）</p>
<h3 id="7．后台的订单的模块"><a href="#7．后台的订单的模块" class="headerlink" title="7．后台的订单的模块"></a>7．后台的订单的模块</h3><p>所有的订单的信息展示</p>
<h1 id="二、一般项目开发流程（公司之间是有差异）"><a href="#二、一般项目开发流程（公司之间是有差异）" class="headerlink" title="二、一般项目开发流程（公司之间是有差异）"></a>二、一般项目开发流程（公司之间是有差异）</h1><p>1）确定项目需求—–拿下一个项目</p>
<p>2）编写《需求说明书》—-不涉及技术，只涉及业务需求</p>
<p>3）编写《概要设计说明书》—– 涉及技术的的宏观的内容，数据库设计，页面原型</p>
<p>4）编写《详细设计说明书》—– 相当于伪代码</p>
<p>5）编码阶段coding—-根据《详细设计说明书》— 单元测试</p>
<p>6）联测—–项目组内部的行为</p>
<p>7）测试组进行全面的专业测试—-《测试报告》</p>
<p>8）上线（测试阶段）</p>
<p>9）维护和二次开发</p>
<h1 id="三、网上商城项目的环境的搭建"><a href="#三、网上商城项目的环境的搭建" class="headerlink" title="三、网上商城项目的环境的搭建"></a>三、网上商城项目的环境的搭建</h1><p>(1) 创建项目Shop</p>
<p>(2) 创建项目的包结构</p>
<p>(3) 导入需要的jar/配置文件/工具/静态页面</p>
<p>(4) 编码</p>
<h1 id="四、业务分析与编码"><a href="#四、业务分析与编码" class="headerlink" title="四、业务分析与编码"></a>四、业务分析与编码</h1><h3 id="1．用户模块—注册"><a href="#1．用户模块—注册" class="headerlink" title="1．用户模块—注册"></a>1．用户模块—注册</h3><h4 id="1-用户注册"><a href="#1-用户注册" class="headerlink" title="(1)用户注册"></a>(1)用户注册</h4><p>基本点注册代码实现</p>
<p>分析：表单提交数据—-&gt;web层收集数据—-&gt;封装数据—–&gt;传递数据—&gt;三层架    构代码</p>
<h4 id="2-用户发送邮件"><a href="#2-用户发送邮件" class="headerlink" title="(2)用户发送邮件"></a>(2)用户发送邮件</h4><h4 id="3-用户激活"><a href="#3-用户激活" class="headerlink" title="(3)用户激活"></a>(3)用户激活</h4><p>邮箱中的链接</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml12844\wps1.jpg" alt="img"></td>
</tr>
</tbody>
</table>
<p>点击时 访问服务端进行激活功能的ActiveServlet</p>
<h4 id="4-表单校验"><a href="#4-表单校验" class="headerlink" title="(4)表单校验"></a>(4)表单校验</h4><h4 id="5-短信验证码"><a href="#5-短信验证码" class="headerlink" title="(5)短信验证码"></a>(5)短信验证码</h4><h4 id="6-图片验证码"><a href="#6-图片验证码" class="headerlink" title="(6)图片验证码"></a>(6)图片验证码</h4><p>前台对表单已经进行进行校验了，后台好需要对数据进行校验吗？—-需要！</p>
<h3 id="2．用户模块—登录"><a href="#2．用户模块—登录" class="headerlink" title="2．用户模块—登录"></a>2．用户模块—登录</h3><h3 id="3．关于servlet的抽取（重构）"><a href="#3．关于servlet的抽取（重构）" class="headerlink" title="3．关于servlet的抽取（重构）"></a>3．关于servlet的抽取（重构）</h3>]]></content>
  </entry>
  <entry>
    <title>戳气球问题</title>
    <url>/2019/05/20/2019-05-20/</url>
    <content><![CDATA[<p>有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p>
<p>现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。</p>
<p>求所能获得硬币的最大数量。</p>
<p>说明:</p>
<p>你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。<br>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100<br>示例:</p>
<p>输入: [3,1,5,8]<br>输出: 167<br>解释: nums = [3,1,5,8] –&gt; [3,5,8] –&gt;   [3,8]   –&gt;  [8]  –&gt; []<br>     coins =  315      +  358    +  138      + 181   = 167</p>
<p>思路：</p>
<p>可以利用区间动态规划，dp[i][j]表示i到j之间的最优解（不包括i，j），那么dp[i][j]就等于max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[j] * nums[k])。</p>
<p>即我们假设求i到j之间的最优解，k为i和j之间的数，那么当前i到j之间以k为基准将要戳k（也就是k是i到j中最后一个戳的）的最优解就等于k左半部分最优解加k右半部分最优解加k、j、i的乘积，遍历k求出最大的一个就好了。当然dp初始值要为0，这样第一次戳i时dp[i-1][i+1]就理所当然等于0 + nums[i+1] <em> nums[i] </em> nums[i - 1] + 0。</p>
<p>nums首部先插入1，再在末尾补1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxCoins(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.empty())&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.insert(nums.begin(), 1);</span><br><span class="line">        nums.push_back(1);</span><br><span class="line">        dp.resize(nums.size(), vector&lt;int&gt;(nums.size(), 0));</span><br><span class="line">        for(int i = 2; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            for(int j = 0; j + i &lt; nums.size(); ++j)&#123;</span><br><span class="line">                for(int k = j + 1; k &lt; j + i; ++k)&#123;</span><br><span class="line">                    dp[j][j + i] = max(dp[j][j + i], dp[j][k] + dp[k][j + i] + nums[k] * nums[j] * nums[j + i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][nums.size() - 1];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt;dp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title>日常笔记</title>
    <url>/2019/05/18/2019-05-18/</url>
    <content><![CDATA[<p>由于写一篇博客很很费劲，经常学习一天的内容写博客就得花费一天，费时费力。所以本篇博客主要记录一些日常琐碎的笔记。</p>
<h1 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h1><h2 id="面向过程C语言"><a href="#面向过程C语言" class="headerlink" title="面向过程C语言"></a>面向过程C语言</h2><h2 id="面向对象C"><a href="#面向对象C" class="headerlink" title="面向对象C++"></a>面向对象C++</h2><h3 id="C与C-的区别"><a href="#C与C-的区别" class="headerlink" title="C与C++的区别"></a>C与C++的区别</h3><p>C为面向过程语言，C++与C不是对立关系，而是包容关系。C++不仅包含面向过程的C，还可以面向对象，也可以泛型编程。简而言之，C++分为面向过程，面向对象，泛型编程模板，STL标准模板库四部分。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="::运算符"></a>::运算符</h3><p>作用域运算符，全局作用域直接加::</p>
<h3 id="namespace命名空间"><a href="#namespace命名空间" class="headerlink" title="namespace命名空间"></a>namespace命名空间</h3><p><strong>用途</strong> 解决名称冲突问题</p>
<ul>
<li>必须在全局作用域下声明</li>
<li>命名空间下可以放入 函数、变量、结构体、类等。</li>
<li>命名空间可以嵌套命名空间</li>
<li>命名空间是开放的，可以随时加入新的成员，添加并合并</li>
<li>匿名命名空间 static</li>
<li>可以起别名</li>
</ul>
<h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><h4 id="using声明"><a href="#using声明" class="headerlink" title="using声明"></a>using声明</h4><p>using std :: X，使用某变量或对象。如果该部分作用域已经存在同样的名称对象，则会产生二义性而报错。</p>
<h4 id="using编译命令"><a href="#using编译命令" class="headerlink" title="using编译命令"></a>using编译命令</h4><p>using namespace X，使用命名空间。跟编译器说的。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const int a = 10；不分配内存，只在编译器符号表中。</p>
<p>const int a = b；分配内存</p>
<p>C++默认const内链接，C外链接即默认extern。</p>
<h3 id="const与define"><a href="#const与define" class="headerlink" title="const与define"></a>const与define</h3><p>const有作用域，有类型。define无作用域，无类型</p>
<h2 id="泛型编程模板与STL"><a href="#泛型编程模板与STL" class="headerlink" title="泛型编程模板与STL"></a>泛型编程模板与STL</h2><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h2 id="系统编程"><a href="#系统编程" class="headerlink" title="系统编程"></a>系统编程</h2><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h2 id="web编程"><a href="#web编程" class="headerlink" title="web编程"></a>web编程</h2><h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h2 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h2><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1>]]></content>
  </entry>
  <entry>
    <title>自底向上优先分析</title>
    <url>/2019/05/13/2019-05-13/</url>
    <content><![CDATA[<ul>
<li>优先分析法<ul>
<li>简单优先分析法<ul>
<li>按一定规则求出该文法所有符号即包括终结符和非终结符之间的优先关系。</li>
<li>实质是一种规范规约。</li>
<li>准确，规范，但效率低。</li>
<li>实用性不大。</li>
</ul>
</li>
<li>算符优先分析法<ul>
<li>只规定算符之间的优先关系，即仅终结符之间的优先关系。</li>
<li>不是规范规约。</li>
<li>不准确规范，但效率高。</li>
<li>采用适当方法加以弥补缺点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="简单优先分析法"><a href="#简单优先分析法" class="headerlink" title="简单优先分析法"></a>简单优先分析法</h1><h2 id="算符与普通-gt-lt-区别"><a href="#算符与普通-gt-lt-区别" class="headerlink" title="算符与普通=,&gt;,&lt;区别"></a>算符与普通=,&gt;,&lt;区别</h2><p>算符有顺序，例如a·=b和b·=a不一样。</p>
<p>普通算符无顺序，例如a&lt;b和b&gt;a一样。</p>
<h2 id="优先关系"><a href="#优先关系" class="headerlink" title="优先关系"></a>优先关系</h2><ul>
<li>X ·= Y(A→…XY…)<ul>
<li>S→bAa。b ·= A，A ·= a。</li>
</ul>
</li>
<li>X ·&lt; Y(A → …XB…, B ⇨ Y…)<ul>
<li>S→bAb，A +⇨ (B, A+⇨a。b ·&lt; (，b ·= a。</li>
</ul>
</li>
<li>X ·&gt; Y(A → …BD…,  B +⇨ …X，D *⇨ Y…)<ul>
<li>S→bAb，A +⇨ …), A+⇨B,A+⇨a。) ·&gt; b，a ·&gt; b， B ·&gt; b。</li>
</ul>
</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol>
<li>在文法符号集V中，任意两个符号之间最多只有一种优先关系成立。</li>
<li>在文法中任意两个产生式没有相同的右部。</li>
</ol>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>将输入符号串a1a…an#依次逐个存入符号栈S中，直到遇到栈顶符号ai的优先性·&gt;下一个带输入符号aj为止。</p>
<p>栈顶当前符号ai为句柄尾，由此向左在栈中找句柄的头符号ak，即找到ak-1&lt;·ak，为止。</p>
<p>由句柄ak…ai在文法产生式中查找右部尾ak…ai的产生式，若找到则用左部代替句柄，若找不到则为出错，断定不合法。</p>
<p>重复1，2，3.直到只剩开始符为止。</p>
<h1 id="算符优先分析法"><a href="#算符优先分析法" class="headerlink" title="算符优先分析法"></a>算符优先分析法</h1><h2 id="优先关系-1"><a href="#优先关系-1" class="headerlink" title="优先关系"></a>优先关系</h2><p>和简单优先分析相比仅有终结符才能有优先级比较。其余优先符关系同于上式。</p>
<ul>
<li>a ·= b(A→…ab…或A→…aBb…)</li>
<li>a ·&lt; b(A → …aB…, B ⇨ b…或B ⇨ Cb…)</li>
<li>a ·&gt; b(A → …Bb…,  B ⇨ …a或B ⇨ …aC)</li>
</ul>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><ol>
<li>若一文法G中<strong>不存在</strong>A→…BC…，其中B,C为非终极符，则G为<strong>算符文法</strong>。</li>
<li>G为不含ε文法，满足算符优先关系。</li>
<li>若a与b之间只存在一种优先关系，则G为算符优先文法。</li>
</ol>
<h2 id="算符优先关系表构造"><a href="#算符优先关系表构造" class="headerlink" title="算符优先关系表构造"></a>算符优先关系表构造</h2><p>FIRSTVT(B) = {b | B +⇨ b…或B +⇨ Cb…}</p>
<p>LASTVT(B) = {a | B +⇨ …a 或B +⇨ …aC}</p>
<ol>
<li>·=：A→…ab…，若或A→…aBb…,则a·=b</li>
<li>·&lt;：A→…aB…，若b∈FIRSTVT(B)，则a·&lt;b</li>
<li>·&gt;：A→…Bb…，若a∈LASTVT(B)，则a·&gt;b</li>
</ol>
<h2 id="算符优先分析算法"><a href="#算符优先分析算法" class="headerlink" title="算符优先分析算法"></a>算符优先分析算法</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/20190513_213009.jpg" alt></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>最少区间覆盖问题</title>
    <url>/2019/05/09/2019-05-09/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有一个包，若干路由器，包在每个路由器处有一个最大跳的步长，问至少几跳能到达终点。每一个数为正整数。</p>
<h2 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h2><p>[2,3,1,1,1]</p>
<p>输出：</p>
<p>2</p>
<p>解释：</p>
<p>0-&gt;1-&gt;4</p>
<h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>贪心</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ans = 0, cnt = 0, maxn = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size() - 1 &amp;&amp; i &lt;= cnt; ++i)&#123;</span><br><span class="line">            if(nums[i] + i &gt; maxn)&#123;</span><br><span class="line">                maxn = nums[i] + i;</span><br><span class="line">            &#125;</span><br><span class="line">            if(maxn &gt;= nums.size() - 1)&#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i == cnt)&#123;</span><br><span class="line">                if(cnt != maxn)&#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt = maxn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>数组记录，及数组记录当前最优值，类似于筛法求素数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int solve(vector&lt;int&gt;v)&#123;</span><br><span class="line">    int len = v.size();</span><br><span class="line">    vector&lt;int&gt;dp(len, inf);</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    for(int i = 0; i &lt; len &amp;&amp; dp[i] != inf; ++i)&#123;</span><br><span class="line">        for(int j = 1; j &lt;= v[i]; ++j)&#123;</span><br><span class="line">            dp[j] = min(dp[j], dp[i] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[len - 1] != inf ? dp[len - 1] : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h2><p>排序，下标为左界，值＋下标为右值，构成区域块，选最少的块覆盖全部区域，覆盖不了等于到不了终点。左值（右值）排序后右值（左值）贪心比较。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>刚拿到该题，以为是做过的题，之前做的是能否到达终点。结果忽略了求最少的步数，写完才发现理解错了。然后就慌了，思路就混乱了。就没有然后了。</p>
<p>还是比较适合笔试题，一个人自在，心里有了包袱就自乱阵脚，好水的题都能出错。</p>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]探索C++虚函数在g++中的实现</title>
    <url>/2019/05/07/2019-05-07/</url>
    <content><![CDATA[<p>为了探索C++虚函数的实现，我们首先编写几个用来测试的类，代码如下：</p>
<p>C++</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void f() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base1::f()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void g() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base2::g()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base1, public Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void f() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Derived::f()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void g() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Derived::g()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void h() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Derived::h()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Derived ins;</span><br><span class="line">    Base1 &amp;b1 = ins;</span><br><span class="line">    Base2 &amp;b2 = ins;</span><br><span class="line">    Derived &amp;d = ins;</span><br><span class="line"></span><br><span class="line">    b1.f();</span><br><span class="line">    b2.g();</span><br><span class="line">    d.f();</span><br><span class="line">    d.g();</span><br><span class="line">    d.h();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码采用了多继承，是为了更多的分析出g++的实现本质，用UML简单的画一下继承关系：</p>
<p>示例代码UML图</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-07-3.png" alt></p>
<p>代码的输出结果和预期的一致，C++实现了虚函数覆盖功能，代码输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Derived::f()</span><br><span class="line">Derived::g()</span><br><span class="line">Derived::f()</span><br><span class="line">Derived::g()</span><br><span class="line">Derived::h()</span><br></pre></td></tr></table></figure>
<h2 id="开始分析！"><a href="#开始分析！" class="headerlink" title="开始分析！"></a>开始分析！</h2><p>我写这篇文章的重点是尝试解释g++编译在底层是如何实现虚函数覆盖和动态绑定的，因此我假定你已经明白基本的虚函数概念以及虚函数表（vtbl）和虚函数表指针（vptr）的概念和在继承实现中所承担的作用，如果你还不清楚这些概念，建议你在继续阅读下面的分析前先补习一下相关知识，陈皓的 <a href="http://blog.csdn.net/haoel/article/details/1948051" target="_blank" rel="noopener">《C++虚函数表解析》</a> 系列是一个不错的选择。</p>
<p>通过本文，我将尝试解答下面这三个问题：</p>
<ol>
<li>g++如何实现虚函数的动态绑定？</li>
<li>vtbl在何时被创建？vptr又是在何时被初始化？</li>
<li>在Linux中运行的C++程序虚拟存储器中，vptr、vtbl存放在虚拟存储的什么位置？</li>
</ol>
<p>首先是第一个问题：</p>
<h3 id="g-如何实现虚函数的动态绑定？"><a href="#g-如何实现虚函数的动态绑定？" class="headerlink" title="g++如何实现虚函数的动态绑定？"></a>g++如何实现虚函数的动态绑定？</h3><p>这个问题乍看简单，大家都知道是通过vptr和vtbl实现的，那就让我们刨根问底的看一看，g++是如何利用vptr和vtbl实现的。</p>
<p>第一步，使用 -fdump-class-hierarchy 参数导出g++生成的类内存结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vtable for Base1</span><br><span class="line">Base1::_ZTV5Base1: 3u entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">4     (int (*)(...))(&amp; _ZTI5Base1)</span><br><span class="line">8     Base1::f</span><br><span class="line"></span><br><span class="line">Class Base1</span><br><span class="line">   size=4 align=4</span><br><span class="line">   base size=4 base align=4</span><br><span class="line">Base1 (0xb6acb438) 0 nearly-empty</span><br><span class="line">    vptr=((&amp; Base1::_ZTV5Base1) + 8u)</span><br><span class="line"></span><br><span class="line">Vtable for Base2</span><br><span class="line">Base2::_ZTV5Base2: 3u entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">4     (int (*)(...))(&amp; _ZTI5Base2)</span><br><span class="line">8     Base2::g</span><br><span class="line"></span><br><span class="line">Class Base2</span><br><span class="line">   size=4 align=4</span><br><span class="line">   base size=4 base align=4</span><br><span class="line">Base2 (0xb6acb474) 0 nearly-empty</span><br><span class="line">    vptr=((&amp; Base2::_ZTV5Base2) + 8u)</span><br><span class="line"></span><br><span class="line">Vtable for Derived</span><br><span class="line">Derived::_ZTV7Derived: 8u entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">4     (int (*)(...))(&amp; _ZTI7Derived)</span><br><span class="line">8     Derived::f</span><br><span class="line">12    Derived::g</span><br><span class="line">16    Derived::h</span><br><span class="line">20    (int (*)(...))-0x000000004</span><br><span class="line">24    (int (*)(...))(&amp; _ZTI7Derived)</span><br><span class="line">28    Derived::_ZThn4_N7Derived1gEv</span><br><span class="line"></span><br><span class="line">Class Derived</span><br><span class="line">   size=8 align=4</span><br><span class="line">   base size=8 base align=4</span><br><span class="line">Derived (0xb6b12780) 0</span><br><span class="line">    vptr=((&amp; Derived::_ZTV7Derived) + 8u)</span><br><span class="line">  Base1 (0xb6acb4b0) 0 nearly-empty</span><br><span class="line">      primary-for Derived (0xb6b12780)</span><br><span class="line">  Base2 (0xb6acb4ec) 4 nearly-empty</span><br><span class="line">      vptr=((&amp; Derived::_ZTV7Derived) + 28u)</span><br></pre></td></tr></table></figure>
<p>如果看不明白这些乱七八糟的输出，没关系（当然能看懂更好），把上面的输出转换成图的形式就清楚了：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-07-2.png" alt></p>
<p>vptr和vtbl</p>
<p>其中有几点尤其值得注意：</p>
<ol>
<li>我用来测试的机器是32位机，所有vptr占4个字节，每个vtbl中的函数指针也是4个字节</li>
<li>每个类的主要（primal）vptr放在类内存空间的起始位置（由于我没有声明任何成员变量，可能看不清楚）</li>
<li>在多继承中，对应各个基类的vptr按继承顺序依次放置在类内存空间中，且子类与第一个基类共用同一个vptr</li>
<li>子类中声明的虚函数除了覆盖各个基类对应函数的指针外，还额外添加一份到第一个基类的vptr中（体现了共用的意义）</li>
</ol>
<p>有了内存布局后，接下来观察g++是如何在这样的内存布局上进行动态绑定的。</p>
<p>g++对每个类的指针或引用对象，如果是其类声明中虚函数，使用位于其内存空间首地址上的vptr寻找找到vtbl进而得到函数地址。如果是父类声明而子类未覆盖的虚函数，使用对应父类的vptr进行寻址。</p>
<p>先来验证一下，使用 objdump -S 得到 b1.f() 的汇编指令：</p>
<p>Assembly (x86)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b1.f();</span><br><span class="line"> 8048734:       8b 44 24 24             mov    0x24(%esp),%eax    # 得到Base1对象的地址</span><br><span class="line"> 8048738:       8b 00                   mov    (%eax),%eax        # 对对象首地址上的vptr进行解引用，得到vtbl地址</span><br><span class="line"> 804873a:       8b 10                   mov    (%eax),%edx        # 解引用vtbl上第一个虚函数的地址</span><br><span class="line"> 804873c:       8b 44 24 24             mov    0x24(%esp),%eax</span><br><span class="line"> 8048740:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 8048743:       ff d2                   call   *%edx              # 调用函数</span><br></pre></td></tr></table></figure>
<p>其过程和我们的分析完全一致，聪明的你可能发现了，b2怎么办呢？Derived类的实例内存首地址上的vptr并不是Base2类的啊！答案实际上是因为g++在引用赋值语句 Base2 &amp;b2 = ins 上动了手脚：</p>
<p>Assembly (x86)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Derived ins;</span><br><span class="line"> 804870d:       8d 44 24 1c             lea    0x1c(%esp),%eax</span><br><span class="line"> 8048711:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 8048714:       e8 c3 01 00 00          call   80488dc &lt;_ZN7DerivedC1Ev&gt;</span><br><span class="line">    Base1 &amp;b1 = ins;</span><br><span class="line"> 8048719:       8d 44 24 1c             lea    0x1c(%esp),%eax</span><br><span class="line"> 804871d:       89 44 24 24             mov    %eax,0x24(%esp)</span><br><span class="line">    Base2 &amp;b2 = ins;</span><br><span class="line"> 8048721:       8d 44 24 1c             lea    0x1c(%esp),%eax   # 获得ins实例地址</span><br><span class="line"> 8048725:       83 c0 04                add    $0x4,%eax         # 添加一个指针的偏移量</span><br><span class="line"> 8048728:       89 44 24 28             mov    %eax,0x28(%esp)   # 初始化引用</span><br><span class="line">    Derived &amp;d = ins;</span><br><span class="line"> 804872c:       8d 44 24 1c             lea    0x1c(%esp),%eax</span><br><span class="line"> 8048730:       89 44 24 2c             mov    %eax,0x2c(%esp)</span><br></pre></td></tr></table></figure>
<p>虽然是指向同一个实例的引用，根据引用类型的不同，g++编译器会为不同的引用赋予不同的地址。例如b2就获得一个指针的偏移量，因此才保证了vptr的正确性。</p>
<p>PS：我们顺便也证明了C++中的引用的真实身份就是指针…</p>
<p>接下来进入第二个问题：</p>
<h3 id="vtbl在何时被创建？vptr又是在何时被初始化？"><a href="#vtbl在何时被创建？vptr又是在何时被初始化？" class="headerlink" title="vtbl在何时被创建？vptr又是在何时被初始化？"></a>vtbl在何时被创建？vptr又是在何时被初始化？</h3><p>既然我们已经知道了g++是如何通过vptr和vtbl来实现虚函数魔法的，那么vptr和vtbl又是在什么时候被创建的呢？</p>
<p>vptr是一个相对容易思考的问题，因为vptr明确的属于一个实例，所以vptr的赋值理应放在类的构造函数中。 g++为每个有虚函数的类在构造函数末尾中隐式的添加了为vptr赋值的操作 。</p>
<p>同样通过生成的汇编代码验证：</p>
<p>Assembly (x86)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Derived : public Base1, public Base2</span><br><span class="line">&#123;</span><br><span class="line"> 80488dc:       55                      push   %ebp</span><br><span class="line"> 80488dd:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 80488df:       83 ec 18                sub    $0x18,%esp</span><br><span class="line"> 80488e2:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 80488e5:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 80488e8:       e8 d3 ff ff ff          call   80488c0 &lt;_ZN5Base1C1Ev&gt;</span><br><span class="line"> 80488ed:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 80488f0:       83 c0 04                add    $0x4,%eax</span><br><span class="line"> 80488f3:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 80488f6:       e8 d3 ff ff ff          call   80488ce &lt;_ZN5Base2C1Ev&gt;</span><br><span class="line"> 80488fb:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 80488fe:       c7 00 48 8a 04 08       movl   $0x8048a48,(%eax)</span><br><span class="line"> 8048904:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 8048907:       c7 40 04 5c 8a 04 08    movl   $0x8048a5c,0x4(%eax)</span><br><span class="line"> 804890e:       c9                      leave</span><br><span class="line"> 804890f:       c3                      ret</span><br></pre></td></tr></table></figure>
<p>可以看到在代码中，Derived类的构造函数为实例的两个vptr赋初值，可是，这两个初值居然是立即数！立即数！立即数！ 这说明了vtbl的生成并不是运行时的，而是在编译期就已经确定了存放在这两个地址上的 ！</p>
<p>这个地址不出意料的属于.rodata（只读数据段），使用 objdump -s -j .rodata 提取出对应的内存观察：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">80489e0 03000000 01000200 00000000 42617365  ............Base</span><br><span class="line"> 80489f0 313a3a66 28290042 61736532 3a3a6728  1::f().Base2::g(</span><br><span class="line"> 8048a00 29004465 72697665 643a3a66 28290044  ).Derived::f().D</span><br><span class="line"> 8048a10 65726976 65643a3a 67282900 44657269  erived::g().Deri</span><br><span class="line"> 8048a20 7665643a 3a682829 00000000 00000000  ved::h()........</span><br><span class="line"> 8048a30 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 8048a40 00000000 a08a0408 34880408 68880408  ........4...h...</span><br><span class="line"> 8048a50 94880408 fcffffff a08a0408 60880408  ............`...</span><br><span class="line"> 8048a60 00000000 c88a0408 08880408 00000000  ................</span><br><span class="line"> 8048a70 00000000 d88a0408 dc870408 37446572  ............7Der</span><br><span class="line"> 8048a80 69766564 00000000 00000000 00000000  ived............</span><br><span class="line"> 8048a90 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 8048aa0 889f0408 7c8a0408 00000000 02000000  ....|...........</span><br><span class="line"> 8048ab0 d88a0408 02000000 c88a0408 02040000  ................</span><br><span class="line"> 8048ac0 35426173 65320000 a89e0408 c08a0408  5Base2..........</span><br><span class="line"> 8048ad0 35426173 65310000 a89e0408 d08a0408  5Base1..........</span><br></pre></td></tr></table></figure>
<p>由于程序运行的机器是小端机，经过简单的转换就可以得到第一个vptr所指向的内存中的第一条数据为0x80488834，如果把这个数据解释为函数地址到汇编文件中查找，会得到：</p>
<p>Assembly (x86)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">08048834 &lt;_ZN7Derived1fEv&gt;:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base1, public Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void f() &#123;</span><br><span class="line"> 8048834:       55                      push   %ebp</span><br><span class="line"> 8048835:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 8048837:       83 ec 18                sub    $0x18,%esp</span><br></pre></td></tr></table></figure>
<p>Bingo！ g++在编译期就为每个类确定了vtbl的内容，并且在构造函数中添加相应代码使vptr能够指向已经填好的vtbl的地址 。</p>
<p>这也同时为我们解答了第三个问题：</p>
<p>在Linux中运行的C++程序虚拟存储器中，vptr、vtbl存放在虚拟存储的什么位置？</p>
<p>直接看图：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-07-1.png" alt></p>
<p>虚函数在虚拟存储器中的位置</p>
<p>图中灰色部分应该是你已经熟悉的，彩色部分内容和相关联的箭头描述了虚函数调用的过程（图中展示的是通过new在堆区创建实例的情况，与示例代码有所区别，小失误，不要在意）： 当调用虚函数时，首先通过位于栈区的实例的指针找到位于堆区中的实例地址，然后通过实例内存开头处的vptr找到位于.rodata段的vtbl，再根据偏移量找到想要调用的函数地址，最后跳转到代码段中的函数地址执行目标函数 。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>研究这些问题的起因是因为公司代码出现了非常奇葩的行为，经过追查定位到虚函数表出了问题，因此才有机会脚踏实地的对虚函数实现进行一番探索。</p>
<p>也许你会想，即使我不明白这些底层原理，也一样可以正常的使用虚函数，也一样可以写出很好的面相对象的代码啊？</p>
<p>这一点儿也没有错，但是，C++作为全宇宙最复杂的程序设计语言，它提供的功能异常强大，无异于武侠小说中锋利无比的屠龙宝刀。但武功不好的菜鸟如果胡乱舞弄宝刀，却很容易反被其所伤。只有了解了C++底层的原理和机制，才能让我们把C++这把屠龙宝刀使用的更加得心应手，变化出更加华丽的招式，成为真正的武林高手。</p>
<h1 id="转"><a href="#转" class="headerlink" title="转"></a>转</h1><p>本文转自<a href="http://blog.kongfy.com/2015/08/%E6%8E%A2%E7%B4%A2c%E8%99%9A%E5%87%BD%E6%95%B0%E5%9C%A8g%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">http://blog.kongfy.com/2015/08/探索c虚函数在g中的实现/</a> </p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>多态</tag>
        <tag>虚函数表</tag>
      </tags>
  </entry>
  <entry>
    <title>自顶向下语法分析指北</title>
    <url>/2019/05/05/2019-05-05/</url>
    <content><![CDATA[<ul>
<li>语法分析<ul>
<li>自顶向下语法分析<ul>
<li>确定分析</li>
<li>不确定分析</li>
</ul>
</li>
<li>自底向上语法分析<ul>
<li>算符优先分析</li>
<li>LR分析</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h1><h2 id="确定分析-LL-1-文法"><a href="#确定分析-LL-1-文法" class="headerlink" title="确定分析(LL(1)文法)"></a>确定分析(LL(1)文法)</h2><h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><p>G[S]:</p>
<p>S -&gt; pA | qB</p>
<p>A -&gt; cAd | a</p>
<p>B -&gt; dB | b</p>
<p>W = pccadd。</p>
<p>推导过程如下：S =&gt; pA =&gt; pcAd =&gt; pccAdd =&gt; pccadd。</p>
<ul>
<li>​          S                      S                          S                          S<br> ​        /    \                    /    \                        /    \                        /    \<br> ​       p      A    =&gt;          p      A        =&gt;          p      A        =&gt;          p      A<pre><code>/   |   \                       /   |   \                      /   |   \
</code></pre>  ​                        c     A     d                c     A     d                c     A     d<pre><code>/   |   \                      /   |   \
</code></pre>  ​                                            c     A     d                c     A     d<br>  ​                                                                       |<pre><code>a
</code></pre></li>
</ul>
<h3 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h3><p>G[S]：</p>
<p>S-&gt;Ap</p>
<p>S-&gt;Bq</p>
<p>A-&gt;a</p>
<p>A-&gt;cA</p>
<p>B-&gt;b</p>
<p>B-&gt;dB</p>
<p>W = ccap，推导过程：</p>
<p>S =&gt; aP =&gt; cAp =&gt; ccAp =&gt; ccap。</p>
<h3 id="FIRST-a"><a href="#FIRST-a" class="headerlink" title="FIRST(a)"></a>FIRST(a)</h3><p>a的开始符号集或首符号集。</p>
<p>例2：FIRST(Ap) = {a, c}。</p>
<p>FIRST(Bq) = {b, d}。</p>
<p>FIRST(S) = {a, b, c, d}。</p>
<p>###FOLLOW(A)</p>
<p>若Aa，a ∈ FOLLOW(A)。若a = ε，则# ∈ FOLLOW(A)。</p>
<h3 id="SELECT-A-gt-a"><a href="#SELECT-A-gt-a" class="headerlink" title="SELECT(A-&gt;a)"></a>SELECT(A-&gt;a)</h3><p>a不为ε，则SELECT(A-&gt;a) = FIRST(a)。</p>
<p>否则，SELECT(A-&gt;a) = FIRST(a) - ε + FOLLOW(A)。</p>
<h3 id="LL-1"><a href="#LL-1" class="headerlink" title="LL(1)"></a>LL(1)</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>第1个L表示从左往右扫描字符串。</p>
<p>第2个L表示采用最左推导。</p>
<p>1表示只需向右看1个字符即可选择哪个产生式。（为了提高效率，最多为2）。</p>
<h4 id="充要条件："><a href="#充要条件：" class="headerlink" title="充要条件："></a>充要条件：</h4><p>SELLECT(A-&gt;a) ∩ SELECT(A-&gt;b) = 空集。（a，b不能同时能ε）。</p>
<p>通俗理解就是a和b不能有相同前缀。</p>
<h4 id="LL-1-文法判别步骤"><a href="#LL-1-文法判别步骤" class="headerlink" title="LL(1)文法判别步骤"></a>LL(1)文法判别步骤</h4><p>求出能推出 ε 的非终结符。（未定，是，否）</p>
<p>计算FIRST集</p>
<p>计算FOLLOW集</p>
<p>计算SELECT集</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="递归子程序法"><a href="#递归子程序法" class="headerlink" title="递归子程序法"></a>递归子程序法</h4><p>对应文法中每个非终结符编写一个递归过程，每个过程的功能是识别由非终结符推出的串，当某非终结符的产生式有多个候选时能够按LL(1)形式可唯一确定地选择某个候选进行推导。</p>
<p>当文法满足LL(1)条件时，构造不带回溯的自上而下分析程序。</p>
<p>该分析程序由一组递归过程组成，每个过程对应文法的一个非终结符。</p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>不是所有的aij的first集的交集都为空，仅针对一个VN的候选式有如此的约定。</p>
<h4 id="预测分析法"><a href="#预测分析法" class="headerlink" title="预测分析法"></a>预测分析法</h4><h5 id="特征"><a href="#特征" class="headerlink" title="特征 :"></a>特征 :</h5><p>根据当前输入符号，为当前要处理的非终结符选择产生式。</p>
<p>表驱动的预测分析器包含：</p>
<ul>
<li>一个输入缓冲区</li>
<li>一个栈</li>
<li>一张分析表</li>
<li>一个输出流</li>
</ul>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-05-1.png" alt></p>
<h5 id="预测分析表M"><a href="#预测分析表M" class="headerlink" title="预测分析表M"></a>预测分析表M</h5><p>预测分析表是一个M[A，a]形式的矩阵。</p>
<p>其中： A为非终结符，a为终结符或#。</p>
<p>M[A，a]中存放着一条关于A的产生式，指出当A面临a时所应采取的候选；</p>
<p>M[A，a]中也可能存放一条“出错标志”，指出Ａ不应该面临a。</p>
<p>例：对于文法G       </p>
<ol>
<li>E→TE’</li>
<li>E’ → +TE’|ε</li>
<li>T →FT’</li>
<li>T’→*FT’| ε</li>
<li>F→(E)|id  </li>
</ol>
<p>其预测分析表为：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-05-2.png" alt="1557056948767"></p>
<p>解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FIRST(E)=&#123; (, id &#125;</span><br><span class="line"></span><br><span class="line">FIRST(E’)=&#123;+, ε&#125;</span><br><span class="line"></span><br><span class="line">FIRST(T’)=&#123; *, ε&#125;</span><br><span class="line"></span><br><span class="line">FIRST(T)=&#123; (, id &#125;</span><br><span class="line"></span><br><span class="line">FIRST(F)=&#123; (, id &#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(E) =&#123;#, )&#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(E’)=&#123;), #&#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(T’)=&#123;+, ),  # &#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(T) =&#123;+, ),  #&#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(F) =&#123;id, ), *,  #&#125;</span><br></pre></td></tr></table></figure>
<h5 id="预测分析器"><a href="#预测分析器" class="headerlink" title="预测分析器"></a>预测分析器</h5><p>预测分析程序的算法：</p>
<ul>
<li><p>输入：串w和文法G的分析表M</p>
</li>
<li><p>输出：如果w属于L（G），则输出w的最左推导，否则报错</p>
</li>
<li><p>方法：开始时，#S在栈里，w#在输入缓冲区</p>
<p>令ip指向w #的第一个符号，令X是栈顶符号，a是ip指向的符号</p>
</li>
</ul>
<p>预测分析器的工作方式：当前栈顶符号X和当前输入符号为a，则语法分析器的动作为：</p>
<ol>
<li>如果X=a≠#，则POP，advance</li>
<li>如果X ∈VN,查M[X，a]表，若M[X，a]=X→UVW,则用WVU替换栈顶；若M[X，a]=error,则调用错误恢复程序。</li>
<li>如果X=a=#,分析成功。</li>
</ol>
<p>句子id+id*id的分析过程：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-05-3.png" alt="1557057317524"></p>
<h2 id="不确定分析（简）"><a href="#不确定分析（简）" class="headerlink" title="不确定分析（简）"></a>不确定分析（简）</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>匹配，匹配不了回溯继续匹配，直到全部匹配不了或匹配成功为止。（非常暴力）</p>
<ol>
<li><p>由于相同左部的产生式的右部FIRST集交集不为空而引起回溯。</p>
<p>S-&gt;xAy</p>
<p>S-&gt;ab|a</p>
</li>
<li><p>由于相同左部非终结符的右部可为 ε ，且非终结符的FOLLOW集中含有其他产生式右部FIRST集的元素。</p>
<p>S-&gt;aAS</p>
<p>S-&gt;b</p>
<p>A-&gt;bAS</p>
<p>A-&gt;ε</p>
</li>
<li><p>由于文法含有左递归。</p>
<p>S-&gt;Sa</p>
<p>S-&gt;b</p>
</li>
</ol>
<h2 id="部分不确定分析转确定分析"><a href="#部分不确定分析转确定分析" class="headerlink" title="部分不确定分析转确定分析"></a>部分不确定分析转确定分析</h2><h3 id="左递归消除"><a href="#左递归消除" class="headerlink" title="左递归消除"></a>左递归消除</h3><h4 id="直接左递归消除"><a href="#直接左递归消除" class="headerlink" title="直接左递归消除"></a>直接左递归消除</h4><p>采用下列变换公式消除直接左递归，把直接左递归改写为右递归。</p>
<p>如：G[S]： S→Sa | b</p>
<p>可改写为：</p>
<p>S→bS’</p>
<p>S’→aS’|ε </p>
<p>改写后的文法所描述的L(G)={ba^n| n&gt;=0}</p>
<p>一般而言，假定关于P的全部产生式是</p>
<p>P→Pa1 | Pa2 | … | Pam | b1 | b2|…|bn 其中，每个a都不等于ε，而每个都不以P开头，那么，消除P的直接左递归性就是改写这些规则：</p>
<p>P→b1P’ | b2P’ | … | bnP’</p>
<p>P’→a1P’ | a2P’ |… | amP’ | ε </p>
<h4 id="间接左递归消除"><a href="#间接左递归消除" class="headerlink" title="间接左递归消除"></a>间接左递归消除</h4><p>间接左递归的消除需先将间接左递归变为直接左递归，然后再按第1种方法消除直接左递归。</p>
<h5 id="代入法"><a href="#代入法" class="headerlink" title="代入法"></a>代入法</h5><p>将一个产生式规则右部的a中的Vn N替换为N的候选式。如果N有n个候选式，右边a重复n次，而且每一次重复都有N的不同候选式来代替N。</p>
<p>例如：N →a | Bc | ε  在S→Nq中的代入结果S→aq | Bcq | q。</p>
<h3 id="回溯消除"><a href="#回溯消除" class="headerlink" title="回溯消除"></a>回溯消除</h3><p>回溯产生的根源：头字符集合的问题。例如A-&gt;ab|a。</p>
<h4 id="提取公因子"><a href="#提取公因子" class="headerlink" title="提取公因子"></a>提取公因子</h4><p>经过反复提取左因子，就能够把每个非终结符（包括新引进者）的所有候选首符集变成为两两不相交。</p>
<p>例：考察文法G[S]:</p>
<p>S → iCtS | iCtSeS | aC → b </p>
<p>解：由于S的前两个候选项中含有左因子iCtS，提取左因子之后，等价文法G’如下：</p>
<p>S → iCtSS’ | a</p>
<p>S’ →eS |ε</p>
<p>C → b</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>语法分析与词法分析指北</title>
    <url>/2019/05/01/2019-05-01/</url>
    <content><![CDATA[<p>程序编译过程：</p>
<p>源程序 -&gt; 词法分析程序 -&gt; <strong>语法分析程序</strong> -&gt; <strong>语义分析程序</strong> -&gt; 中间代码生成程序 -&gt; 代码优化程序 -&gt; 目标代码生成程序 -&gt; 目标程序</p>
<h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><p>例：</p>
<p>&lt;句子&gt; → &lt;主语&gt;&lt;谓语&gt;</p>
<p>&lt;主语&gt; → &lt;代词&gt;&lt;名词&gt;</p>
<p>&lt;代词&gt; → 你 | 我 | 他</p>
<p>&lt;名词&gt; → 老王 | 大学生 | 英语</p>
<p>&lt;谓语&gt; → &lt;动词&gt;&lt;直接宾语&gt;</p>
<p>&lt;动词&gt; → 是 | 学习 | 热爱</p>
<p>&lt;直接宾语&gt; → &lt;代词&gt; | &lt;名词&gt;</p>
<p>“我是大学生”符合以上规则，是句子。“我大学生是”不符合上面规则，不是句子。</p>
<p>&lt;句子&gt; → &lt;主语&gt;&lt;谓语&gt;</p>
<p>→ &lt;代词&gt;&lt;谓语&gt;</p>
<p>→ 我&lt;谓语&gt;</p>
<p>→ 我&lt;动词&gt;&lt;直接宾语&gt;</p>
<p>→ 我是&lt;直接宾语&gt;</p>
<p>→ 我是&lt;名词&gt;</p>
<p>→ 我是大学生</p>
<h2 id="符号和字符串"><a href="#符号和字符串" class="headerlink" title="符号和字符串"></a>符号和字符串</h2><h3 id="字母表"><a href="#字母表" class="headerlink" title="字母表"></a>字母表</h3><p>字母表即符号集，例如汉字的字母表包括汉字，数字标点等，C语言包括if，while之类的保留字组成。</p>
<h3 id="符号串"><a href="#符号串" class="headerlink" title="符号串"></a>符号串</h3><p>由字母表中的符号组成的任何又穷序列（顺序很重要）。例如A = {a, b, c}的符号串有a，b，ab，ba， aa等等。</p>
<h3 id="符号串的头尾，固有头固有尾"><a href="#符号串的头尾，固有头固有尾" class="headerlink" title="符号串的头尾，固有头固有尾"></a>符号串的头尾，固有头固有尾</h3><p>abc的头是 ε, a, ab, abc，除abc外均为固有头。尾是ε, c, bc, abc，除abc外均为固有尾。</p>
<h3 id="符号串方幂"><a href="#符号串方幂" class="headerlink" title="符号串方幂"></a>符号串方幂</h3><p>x = AB。x^0 = ε。x^1 = AB。x^2 = ABAB。x^3 = ABABAB。</p>
<h3 id="符号串的集合"><a href="#符号串的集合" class="headerlink" title="符号串的集合"></a>符号串的集合</h3><p>A = {a, b}。B = {c, d}。AB = {ac, ad, bc, bd}。</p>
<h2 id="文法定义"><a href="#文法定义" class="headerlink" title="文法定义"></a>文法定义</h2><p>G(VN, VT, P, S)。</p>
<p>VN为非终结符（例如&lt;谓语&gt;，可以继续转换。通常用大写字母表示，例如A）</p>
<p>VT为终结符（例如“老王”，可直接匹配，不能再向下转换。通常用小写字母表示，例如a）</p>
<p>P（规则，例如&lt;主语&gt; → &lt;代词&gt;&lt;名词&gt;。又例如S →Aa）。</p>
<p>S起点（例如&lt;句子&gt;就是起点）</p>
<h2 id="文法类型"><a href="#文法类型" class="headerlink" title="文法类型"></a>文法类型</h2><p>3型∈2型∈1型∈0型，3型最严谨，向右兼容。</p>
<h3 id="0型递归文法"><a href="#0型递归文法" class="headerlink" title="0型递归文法"></a>0型递归文法</h3><p>a→b，a至少含1个非终结符，b为任意。</p>
<p>凡是递归可枚举的都是0型，包括A→ε，aA→aa等情况。</p>
<h3 id="1型上下文有关文法"><a href="#1型上下文有关文法" class="headerlink" title="1型上下文有关文法"></a>1型上下文有关文法</h3><p>a→b，a至少含1个非终结符，b不为ε。</p>
<p>0型除去ε的情况就是1型。也就是非终结符不能为ε。</p>
<p>包括aA→aa等情况。</p>
<h3 id="2型上下文无关文法"><a href="#2型上下文无关文法" class="headerlink" title="2型上下文无关文法"></a>2型上下文无关文法</h3><p>a→b，a必须是非终结符（only one）。</p>
<p>不包括aA→aa等情况。</p>
<p>可以A→aa。</p>
<h3 id="3型正规文法"><a href="#3型正规文法" class="headerlink" title="3型正规文法"></a>3型正规文法</h3><p>非终结符转换时头必须有一个终结符。例如：</p>
<p>S→aB</p>
<p>S→bA</p>
<p>A→a</p>
<p>A→aS</p>
<p>A→bAA</p>
<p>B→b</p>
<p>B→bS</p>
<p>B→aBB</p>
<h2 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-01.png" alt></p>
<h2 id="句型分析"><a href="#句型分析" class="headerlink" title="句型分析"></a>句型分析</h2><ul>
<li>自顶向下语法分析（由S向句子推，最终和句子匹配，看能否得到句子）</li>
<li>自底向上语法分析（由句子向S推，最终看能否得到S）</li>
</ul>
<h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>输入源程序；扫描、分解字符串，识别出一个个单词（定义符、标识符、运算符、界符、常数）</p>
<h2 id="词法分析输出"><a href="#词法分析输出" class="headerlink" title="词法分析输出"></a>词法分析输出</h2><p>读入源程序，输出担此符号。单词符号可分为以下5种：</p>
<p>关键字（if，else，while，int等）</p>
<p>标识符（a，fun，val等自定义的变量名）</p>
<p>常数（1，1.2，true，“abc”）</p>
<p>运算符（+，-，=，&lt;=，==）</p>
<p>界符（，；’)’）等。</p>
<p>词法分析输出单词符号常常采用二元组形式（单词种别，单词自身值）。</p>
<h2 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h2><p>扫描阶段：从左向右扫描输入源程序，删除注释、压缩空白字符；</p>
<p>词法分析阶段：按照语言的词法规则识别各类单词，并产生相应的单词符号。</p>
<h2 id="正规文法"><a href="#正规文法" class="headerlink" title="正规文法"></a>正规文法</h2><p>&lt;标识符&gt; → l | l &lt;字母数字&gt;</p>
<p>&lt;字母数字&gt; → l | d |l &lt;字母数字&gt; | d&lt;字母数字&gt;</p>
<p>（l字母，d数字）</p>
<p>例如:</p>
<p>A→aB</p>
<p>A→a</p>
<h2 id="正规式"><a href="#正规式" class="headerlink" title="正规式"></a>正规式</h2><p>a            {a}</p>
<p>a|b            {a,b}</p>
<p>ab            {ab}</p>
<p>(a|b)(a|b)    {aa,ab,ba,bb}</p>
<p>a*            {ε,a,aa,aaa…}</p>
<p>(a|b)*        {ε,a,aab,abaa…所有a,b组成的串}</p>
<p>(a|b)*(aa|bb)(a|b)*        {aaabbaab……}</p>
<h2 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h2><h3 id="确定有穷自动机-DFA"><a href="#确定有穷自动机-DFA" class="headerlink" title="确定有穷自动机(DFA)"></a>确定有穷自动机(DFA)</h3><p>DFA M = （K, ∑, f, S, Z）</p>
<p>K：有穷集，每个元素称为一种状态（图表示就是点集）。</p>
<p>∑：有穷字母表，每个元素称为一个输入符号，所以也叫输入符号表（图表示就是边集）。</p>
<p>f：转换函数，一个节点通过某条边到另一个结点（或自身）。</p>
<p>S：唯一一个初态（起点）</p>
<p>Z：终态集。（就是终点的集合）</p>
<h3 id="不确定有穷自动机-NFA"><a href="#不确定有穷自动机-NFA" class="headerlink" title="不确定有穷自动机(NFA)"></a>不确定有穷自动机(NFA)</h3><p>NFA M = （K, ∑, f, S, Z）</p>
<p>K：有穷集，每个元素称为一种状态（图表示就是点集）。</p>
<p>∑：有穷字母表，每个元素称为一个输入符号，所以也叫输入符号表（图表示就是边集）。</p>
<p>f：转换函数，一个节点通过某一类边到另外许多结点的集合（或自身）。</p>
<p>S：初态集（多个起点）</p>
<p>Z：终态集。（就是终点的集合）</p>
<p>很容易发现，不确定有穷自动机和确定有穷自动机的区别就是DFA每个结点每类单向边只有一条，且起点只有一个，而NFA可以有多条，且起点可以有多个。例如NFA中S—a—&gt;A，S—a,b—&gt;S，S—a,b—&gt;D，但DFA不允许，a，b由S指向其他结点（或自身）的话只能存在一条。</p>
<h2 id="正则式转自动机"><a href="#正则式转自动机" class="headerlink" title="正则式转自动机"></a>正则式转自动机</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-01-1.png" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-01-2.png" alt></p>
<h2 id="正规文法转自动机"><a href="#正规文法转自动机" class="headerlink" title="正规文法转自动机"></a>正规文法转自动机</h2><p>正规文法由于为第3型文法，所以S→aA，S为起点，→为边，a为边名，A为下一个结点。</p>
<h2 id="NFA转DFA"><a href="#NFA转DFA" class="headerlink" title="NFA转DFA"></a>NFA转DFA</h2><p><a href="https://blog.csdn.net/dala_da/article/details/78704560" target="_blank" rel="noopener">参考链接</a></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>词法分析</tag>
        <tag>语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统漫游——&quot;Hello,World&quot;的漫漫计算机旅程</title>
    <url>/2019/04/29/2019-04-29/</url>
    <content><![CDATA[<p>每一个Coder都是从”Hello,World”开始的。那么既然是修仙第一天，那我们就从”Hello,World”开始吧。</p>
<p>本文主要介绍一个简简单单的”Hello,World”程序是如何在计算机系统乃至网络跑起来的。（当然不会写的太复杂啦，毕竟这是一个漫长的过程）。</p>
<p>翠花，上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">	printf(&quot;Hello,World\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位+上下文"></a>信息就是位+上下文</h1><p>hello程序的生命周期是从一个hello.c的源文件开始的。而源程序实际是一个由0、1组成的位（比特）序列，8位一组，称为字节。每个字节表示程序中的某些文本字节。大多数系统以ASCII码表示文本字符。例如以上代码就可以ASII表示为：</p>
<table>
<thead>
<tr>
<th>#</th>
<th>i</th>
<th>n</th>
<th>c</th>
<th>l</th>
<th>u</th>
<th>d</th>
<th>e</th>
<th>SP</th>
<th>&lt;</th>
<th>s</th>
<th>t</th>
<th>d</th>
<th>i</th>
<th>o</th>
<th>.</th>
</tr>
</thead>
<tbody>
<tr>
<td>35</td>
<td>105</td>
<td>110</td>
<td>99</td>
<td>108</td>
<td>117</td>
<td>100</td>
<td>101</td>
<td>32</td>
<td>60</td>
<td>115</td>
<td>116</td>
<td>100</td>
<td>105</td>
<td>111</td>
<td>46</td>
</tr>
<tr>
<td>h</td>
<td>&gt;</td>
<td>\n</td>
<td>i</td>
<td>n</td>
<td>t</td>
<td>SP</td>
<td>m</td>
<td>a</td>
<td>i</td>
<td>n</td>
<td>(</td>
<td>）</td>
<td>{</td>
<td>\n</td>
<td>SP</td>
</tr>
<tr>
<td>104</td>
<td>62</td>
<td>10</td>
<td>105</td>
<td>110</td>
<td>116</td>
<td>32</td>
<td>109</td>
<td>97</td>
<td>105</td>
<td>110</td>
<td>40</td>
<td>41</td>
<td>123</td>
<td>10</td>
<td>32</td>
</tr>
<tr>
<td>SP</td>
<td>SP</td>
<td>SP</td>
<td>p</td>
<td>r</td>
<td>i</td>
<td>n</td>
<td>t</td>
<td>f</td>
<td>(</td>
<td>“</td>
<td>H</td>
<td>e</td>
<td>l</td>
<td>l</td>
<td>o</td>
</tr>
<tr>
<td>32</td>
<td>32</td>
<td>32</td>
<td>112</td>
<td>114</td>
<td>105</td>
<td>110</td>
<td>116</td>
<td>102</td>
<td>40</td>
<td>34</td>
<td>72</td>
<td>101</td>
<td>108</td>
<td>108</td>
<td>111</td>
</tr>
<tr>
<td>,</td>
<td>W</td>
<td>o</td>
<td>r</td>
<td>l</td>
<td>d</td>
<td>\</td>
<td>n</td>
<td>“</td>
<td>)</td>
<td>;</td>
<td>\n</td>
<td>SP</td>
<td>SP</td>
<td>SP</td>
<td>SP</td>
</tr>
<tr>
<td>44</td>
<td>87</td>
<td>111</td>
<td>114</td>
<td>108</td>
<td>100</td>
<td>92</td>
<td>110</td>
<td>34</td>
<td>41</td>
<td>59</td>
<td>10</td>
<td>32</td>
<td>32</td>
<td>32</td>
<td>32</td>
</tr>
<tr>
<td>r</td>
<td>e</td>
<td>t</td>
<td>u</td>
<td>r</td>
<td>n</td>
<td>SP</td>
<td>0</td>
<td>;</td>
<td>\n</td>
<td>}</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>114</td>
<td>101</td>
<td>116</td>
<td>117</td>
<td>114</td>
<td>110</td>
<td>32</td>
<td>48</td>
<td>59</td>
<td>10</td>
<td>125</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>hello.c是以字节序的方式存储在文件中的。系统中的所有信息（磁盘文件，用户信息，网络传输数据等）均由一串比特表示。区分不同数据对象的唯一方式是读这些数据对象时的上下文。比如不同的上下文中，一个同样的字节序列可能表示整数，浮点数，字符串或者机器指令。</p>
<h1 id="程序到可执行文件的过程"><a href="#程序到可执行文件的过程" class="headerlink" title="程序到可执行文件的过程"></a>程序到可执行文件的过程</h1><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F.png" alt></p>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>cpp根据以字符#开头的命令，修改原始C程序。例如上例hello.c中#include&lt;stdio.h&gt;命令告诉预处理器读取系统头文件stdio.h中的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以.i作为文件扩展名。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>ccl将文本文件hello.i翻译成汇编语言hello.s</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">	subq	$8, %rsp</span><br><span class="line">	movl	$.LCO, %edi</span><br><span class="line">	call	puts</span><br><span class="line">	movl	$0, eax</span><br><span class="line">	addq	$8, %rsp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>as将hello.s翻译成机器语言指令，这些指令打包成hello.o中。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>hello程序调用了printf函数，存在于编译好的printf.o中，ld负责合并。它是一个可执行文件，可以被加载入内存，由系统执行。</p>
<h1 id="理解编译系统的好处"><a href="#理解编译系统的好处" class="headerlink" title="理解编译系统的好处"></a>理解编译系统的好处</h1><ul>
<li>优化程序性能。</li>
<li>理解链接时出现的错误。</li>
<li>避免安全漏洞。</li>
</ul>
<h1 id="硬件相关"><a href="#硬件相关" class="headerlink" title="硬件相关"></a>硬件相关</h1><p>Linux下，hello文件的执行过程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux&gt; ./hello</span><br><span class="line">hello,world</span><br><span class="line">linux&gt;</span><br></pre></td></tr></table></figure>
<p>第一行与第三行是shell，shell是一个命令行解释器，它输出一个提示符，等待输入一个命令。如果shell命令行第一个单词不是一个内置shell命令，那么shell会假设这是一个可执行文件的名字，它将加载并运行这个文件。所以上面案例shell加载并执行了当前目录下hello程序，然后等待程序终止。程序完成后，又切换回shell。</p>
<h2 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h2><ul>
<li><strong>总线</strong>：贯穿整个系统的是一组电子管道，即总线。携带信息负责在各个部件间传递。</li>
<li><strong>I/O设备</strong>：系统与外部的联系通道。</li>
<li><strong>主存</strong>：临时存储设备，存储数据共处理器调用或修改。</li>
<li><strong>处理器</strong>：执行存储在主存中指令的引擎。</li>
</ul>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.png" alt></p>
<h2 id="运行hello程序"><a href="#运行hello程序" class="headerlink" title="运行hello程序"></a>运行hello程序</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90%20-%201.png" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90%20-%202.png" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90%20-%203.png" alt></p>
<h1 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h1><p>由上例可发现，系统花费了大量时间把信息从一个敌方搬到另一个地方。hello程序原本在磁盘上，加载时复制到主存，处理机运行时又由主存复杂到处理器。字符串原在主存上，后复制到内存，后复制到显示器。为了提高速度，便引入高速缓存。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.png" alt></p>
<h1 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h1><p>当shell加载和运行hello程序时，以及hello输出消息时，并没直接访问键盘，磁盘或主存，而是通过操作系统。所以说我们可以理解操作系统是应用程序与硬件之间插入的一层软件。</p>
<p>操作系统通过进程，虚拟内存和文件来实现硬件与应用程序间的交互。</p>
<p>进程（处理器+主存+I/O设备）</p>
<p>虚拟内存（主存+I/O设备）</p>
<p>文件（I/O设备）</p>
<h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1.png" alt></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>编译原理</tag>
        <tag>存储器</tag>
      </tags>
  </entry>
  <entry>
    <title>大话存储器与虚拟内存</title>
    <url>/2019/04/27/2019-04-27/</url>
    <content><![CDATA[<h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><p>首先得声明，在引入虚拟存储器之前，存储器通常是将整个进程所有资源引入内存的。</p>
<h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27.png" alt></p>
<h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><h3 id="装入"><a href="#装入" class="headerlink" title="装入"></a>装入</h3><ol>
<li><p>绝对装入方式</p>
<p>编译程序将产生绝对地址的目标代码根据地址将程序和数据存入内存。</p>
<ol>
<li>编程人员要熟悉内存。</li>
<li>程序在内存中不能移动。</li>
<li>不适用于多道程序设计环境。</li>
</ol>
</li>
<li><p>可重定位装入方式（静态）</p>
<p>编译程序将产生相对地址的目标代码，装入时需要地址映射，地址变换只在装入时一次性完成，以后不再改变。</p>
<ol>
<li>适用于多道程序环境。</li>
<li>程序在内存中不能移动。</li>
</ol>
</li>
<li><p><strong>动态运行时装入方式</strong></p>
<p>编译程序将产生相对地址的目标代码，装入时并不立即把相对地址转换为绝对地址，而是把这种地址转换推迟到程序执行时才运行。</p>
<ol>
<li>程序装入内存后可移动。</li>
</ol>
</li>
</ol>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ol>
<li><p>静态链接方式</p>
<p>程序运行前将各目标模块及所需库装配成一个完整模块且不再分开。</p>
</li>
<li><p>装入时动态链接</p>
<p>边装入边链接。（假如没有用到某一模块，也会装入内存，所有才有了方法3）</p>
</li>
<li><p><strong>运行时动态链接</strong></p>
<p>将链接推迟到程序运行时，如果链接到哪一模块，则再将该模块装入内存。（加快装入过程，节省空间）</p>
</li>
</ol>
<h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><ol>
<li>单一连续分配</li>
<li>固定分区分配</li>
<li><strong>动态分区分配</strong></li>
</ol>
<h3 id="基于顺序搜索的动态分区分配算法"><a href="#基于顺序搜索的动态分区分配算法" class="headerlink" title="基于顺序搜索的动态分区分配算法"></a>基于顺序搜索的动态分区分配算法</h3><h4 id="首次适应算法-First-Fit"><a href="#首次适应算法-First-Fit" class="headerlink" title="首次适应算法(First Fit):"></a>首次适应算法(First Fit):</h4><p>从空闲分区表的第一个表目起查找该表，把最先能够满足要求的空闲区分配给作业，这种方法目的在于减少查找时间。为适应这种算法，空闲分区表(空闲区链)中的空闲分区要按地址由低到高进行排序。该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。</p>
<p>特点<br>该算法倾向于优先利用内存中低址部分的空闲分区，从而保留了高址部分的大空闲区，这为以后到达的大作业分配大的内存空间创造了条件。</p>
<p>缺点<br>低址部分不断被划分，会留下许多难以利用的，很小的空闲分区，称为碎片。而每次查找又都是从低址部分开始的，这无疑又会增加查找可用空闲分区时的开销</p>
<h4 id="下次适应（next-fit）算法"><a href="#下次适应（next-fit）算法" class="headerlink" title="下次适应（next fit）算法"></a>下次适应（next fit）算法</h4><p>也称“临近适应”算法，其工作方式和最先适应算法相同（最先适应也称首次适应算法。它总是最先找到的、满足存储要求的那个空闲分区作为分配对象。），不同的是每次找到合适的空闲的分区时就记住它的位置，以便下次就从该位置开始往下查找，而不是每次都像最先适应算法那样从头开始查找。这种算法的总体结果通常要比最先适应算法差。由于它经常会在内存的末尾分配存储分区，使位于存储空间末尾的最大分区被撕裂称小的外部碎片，因此必须经常不断地进行存储紧凑。在该算法中应采取循环查找方式，即最后上个空闲区的大小仍不能满足要求时，应再从第一个空闲区开始查找，故又称为循环造就算法。</p>
<h4 id="最佳适应算法（Best-Fit）："><a href="#最佳适应算法（Best-Fit）：" class="headerlink" title="最佳适应算法（Best Fit）："></a>最佳适应算法（Best Fit）：</h4><p>它从全部空闲区中找出能满足作业要求的、且大小最小的空闲分区，这种方法能使碎片尽量小。为适应此算法，空闲分区表（空闲区链）中的空闲分区要按从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。该算法保留大的空闲区，但造成许多小的空闲区。</p>
<p>Best fit算法等价于装箱问题，举例如下：</p>
<p>装箱问题：有体积为V的箱子N个，体积为Vi的物品M个，求使得物品全部能够装入箱子，箱子数量的最小值。<br>假设 V=6 N=10，V1，V2，…,V10分别为：3 4 4 3 5 1 2 5 3 1。计算过程如下：<br>第一步按物品体积降序排序：5 5 4 4 3 3 3 2 1 1<br>第二步：取未装箱的最大值5装入第一个箱子。<br>第三步：判断第一个箱子是否已满，不满且剩余空间为1，搜寻剩下体积小于等于1的物品填入箱子1，箱子1填满。<br>第四步：重复第二，第三步，直到所有物品装入箱子为止，得到箱子数量为6.<br>6即时本例N的最小值。</p>
<h4 id="最坏适应算法（worst-fit）"><a href="#最坏适应算法（worst-fit）" class="headerlink" title="最坏适应算法（worst fit）"></a>最坏适应算法（worst fit）</h4><p>最坏适应分配算法要扫描整个空闲分区或链表，总是挑选一个最大的空闲分区分割给作业使用。该算法要求将所有的空闲分区按其容量从大到小的顺序形成一空闲分区链，查找时只要看第一个分区能否满足作业要求。</p>
<p>优点：可使剩下的空闲分区不至于太小，产生碎片的几率最小，对中、小作业有利，同时该算法查找效率很高。</p>
<p>缺点：会使存储器中缺乏大的空闲分区。</p>
<p>最坏适应算法与首次适应算法、循环首次适应算法、最佳适应算法一起，也称为顺序搜索法。</p>
<h3 id="基于索引搜索的动态分区分配算法"><a href="#基于索引搜索的动态分区分配算法" class="headerlink" title="基于索引搜索的动态分区分配算法"></a>基于索引搜索的动态分区分配算法</h3><h4 id="快速适应算法（分类搜索法）"><a href="#快速适应算法（分类搜索法）" class="headerlink" title="快速适应算法（分类搜索法）"></a>快速适应算法（分类搜索法）</h4><p>该算法就是将空闲分区根据容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样的系统中存在多个空闲分区链表。同时，在内存总设立一张管理索引表，其中的每一个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。空闲分区的分类是根据进程常用的空间大小进行划分的。</p>
<p>该算法在搜索可分配的空闲分区时分为两步：第一步是根据进程的长度，从索引表中寻找到能容纳它的最小空闲区链表；第二步是从链表中取下第一块进行分配即可。另外，该算法在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。优点是查找效率高。缺点是在分区归还时的算法复杂，系统开销大。此外，该算法在分配空闲分区时，是以进程为单位的，一个分区只属于一个进程，因此在为进程所分配的一个分区中，或多或少的存在一定的浪费。这是典型的以空间换时间的做法。</p>
<h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>该算法规定，无论已分配分区或空闲分区，其大小均为2的k次幂，通常2的m次方是整个可分配内存的大小。假设系统的的可利用空间容量为2的m次方，则当系统开始运行时，整个内存区是一个大小为2的m次方的空闲分区。在系统运行过程中，由于不断地划分，将会形成若个个不连续的空闲分区，将这些分区按分区的大小进行分类。对于具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表，这样，不同大小的空闲分区形成了k个空闲分区链表。</p>
<p>当需要为进程分配一个长度大小为n的存储空间时，首先计算一个i值，使2的i-1次方小于n小于等于2的i次方，然后再空闲分区大小为2的i次方的空闲分区链表中查找。</p>
<p>在伙伴系统中，其分配和回收的时间性能取决于查找空闲分区的位置和分割、合并空闲分区所花费的时间。在回收空闲分区时，需要对空闲分区进行合并，所以其时间性能比快速适应算法差，但由于它采用了索引搜索算法，比顺序搜索算法号。而其空间性能，由于对空闲分区进行合并，减少了空闲分区，提高了空间分区的可使用率，故由于快速适应算法，比顺序搜索法略差。</p>
<p>总结：虽然在当前的操作系统中，主要还是采用离散分配方式的分页和分段机制的虚拟内存机制，因为该机制较伙伴算法更为合理和高效，但在多处理机系统中，伙伴系统仍不失为一种有效的内存分配和释放的方法，目前仍然被广泛使用。</p>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>由于分类搜索算法和伙伴系统算法中，都是将空闲分区根据分区大小进行分类，对于每一类具有相同大小的空闲分区，单独设立一个空闲分区链表。在为进程分配空间时，需要在每一张管理索引表中查找到所需要的空间大小所对应的表项，从中得到对应的空间内分区链表表头指针，从而通过查找一个空闲分区。如果对空闲分区分类比较细，则相应索引表的表项也就较多，因此会显著的增加搜索索引表的表项的时间开销。</p>
<p>哈希算法就是利用哈希快速查找的优点，以及空闲分区在可利用空闲分区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。</p>
<p>当进行空闲分区分配时，根据所需要的空闲 分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略。</p>
<h3 id="动态可重定位分区分配"><a href="#动态可重定位分区分配" class="headerlink" title="动态可重定位分区分配"></a>动态可重定位分区分配</h3><ol>
<li>紧凑</li>
<li>动态重定位</li>
<li>动态重定位分区分配算法</li>
</ol>
<h2 id="离散式存储管理方式"><a href="#离散式存储管理方式" class="headerlink" title="离散式存储管理方式"></a>离散式存储管理方式</h2><h3 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h3><h4 id="连续分配存储管理方式产生的问题"><a href="#连续分配存储管理方式产生的问题" class="headerlink" title="连续分配存储管理方式产生的问题"></a><strong>连续分配存储管理方式产生的问题</strong></h4><p>在分区存储管理中，要求把进程放在一个连续的存储区中，因而会产生许多碎片。</p>
<h4 id="碎片问题的解决方法"><a href="#碎片问题的解决方法" class="headerlink" title="碎片问题的解决方法"></a>碎片问题的解决方法</h4><p>（1）拼接/紧凑技术—-代价较高。</p>
<p>（2）离散分配方式—允许将作业/进程离散放到多个不相邻接的分区中，就可以避免拼接。</p>
<h4 id="离散分配方式"><a href="#离散分配方式" class="headerlink" title="离散分配方式"></a>离散分配方式</h4><p>分页式存储管理：离散分配的基本单位是页</p>
<p>分段式存储管理：离散分配的基本单位是段</p>
<p>段页式存储管理：离散分配的基本单位是段、页</p>
<h4 id="什么是页"><a href="#什么是页" class="headerlink" title="什么是页"></a>什么是页</h4><p>将一个用户进程的地址空间（逻辑）划分成若干个大小相等的区域，称为页或页面,页面大小由地址结构（逻辑）决定 ，并为各页从0开始编号。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-1.png" alt></p>
<h4 id="什么是块"><a href="#什么是块" class="headerlink" title="什么是块"></a>什么是块</h4><p>内存空间也分成若干个与页大小相等的区域，称为（存储、物理）块或页框（frame），同样从0开始编号。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-2.png" alt></p>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>在为进程分配内存时,以块为单位,将进程中若干页装入到多个不相邻的块中,最后一页常装不满一块而出现页内碎片。</p>
<h4 id="页表的出现"><a href="#页表的出现" class="headerlink" title="页表的出现"></a>页表的出现</h4><p>在分页系统中，允许将进程的各个页离散地存储在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表。一个页表中包含若干个表目，1.表目的自然序号对应于用户程序中的页号。2.表目中的块号是该页对应的物理块号。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-3.png" alt></p>
<h4 id="内存地址的获取"><a href="#内存地址的获取" class="headerlink" title="内存地址的获取"></a>内存地址的获取</h4><p>以页号查页表，得到对应页装入内存的块号。即可求出：<strong>内存地址＝物理块号×页大小＋页内地址</strong>。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-4.png" alt></p>
<p>例:在采用页式存储管理的系统中,某作业J的逻辑地址空间为4页(每页2048字节),且已知该作业的页面映像表如下:</p>
<table>
<thead>
<tr>
<th>页号</th>
<th>块号</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>6</td>
</tr>
<tr>
<td>3</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>试借助地址变换图求出有效逻辑地址4865所对应的物理地址.</p>
<p>解:页号  4865/2048=2   页内位移   4865%2048=769，过程如下：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-5.png" alt></p>
<p>从上面我们可以看出：CPU要想获取一个数据时，必须两次访问内存：</p>
<p>1、从内存中的页表中，寻找对应的物理块号，将物理块号与页内地址组合成物理地址。</p>
<p>2、根据组合成的物理地址，来获取数据。</p>
<p>为了提高效率呢，就引进了块表，什么是快表呢？</p>
<p>在地址变换机构中，增设一个具有并行查寻能力的特殊高速缓冲寄存器，称为“联想存储器”或“快表”。</p>
<p>在引入快表的分页存储管理方式中，通过快表查询，可以直接得到逻辑页所对应的物理块号，由此拼接形成实际物理地址，减少了一次内存访问，缩短了进程访问内存的有效时间。但是，由于快表的容量限制，不可能将一个进程的整个页表全部装入快表，所以在快表中查找到所需表项存在着命中率的问题，。总体上来说，还是减少了访问内存的时间。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-6.png" alt></p>
<h3 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h3><h4 id="分段存储管理方式的引入"><a href="#分段存储管理方式的引入" class="headerlink" title="分段存储管理方式的引入"></a>分段存储管理方式的引入</h4><p>引入分段存储管理方式，主要是为了满足用户和程序员的下述一系列需要：</p>
<p>1）<strong>方便编程</strong></p>
<p>通常，用户把自己的作业按照<strong>逻辑关系</strong>划分为若干个段，每个段都是<strong>从0开始</strong>编址，并有自己的<strong>名字</strong>和<strong>长度</strong>。</p>
<p>因此，希望要访问的逻辑地址是由<strong>段名</strong>（段号）和<strong>段内偏移量</strong>（段内地址）决定的。</p>
<p>2）<strong>信息共享</strong></p>
<p>在实现对<strong>程序和数据的共享</strong>时，是以<strong>信息的逻辑单位为基础的</strong>。比如共享某个例程和函数，分页系统中的“页”只是存放信息的<strong>物理单位</strong>（块），</p>
<p>并无完整的意义，不便于实现共享，然而<strong>段却是信息的逻辑单位</strong>。</p>
<p>3）<strong>信息保护</strong></p>
<p>信息保护同样是<strong>对信息的逻辑单位进行保护</strong>，因此，分段管理方式能更有效和方便的实现信息保护功能。</p>
<p>4）<strong>动态增长</strong></p>
<p>在实际应用中，往往有些段，特别是数据段，在使用过程中会<strong>不断地增长</strong>，而事先又无法确切地知道数据段会增长到多大。前面的几种存储</p>
<p>管理方式都难以应付这种动态增长的情况，分段存储管理方式能较好的解决这一问题。</p>
<p>5）<strong>动态链接</strong></p>
<p>动态链接是指<strong>在作业运行之前</strong>，并不把几个目标程序段链接起来。<strong>要运行时</strong>，先将<strong>主程序</strong>所对应的目标程序装入内存并启动运行，当运行过程</p>
<p>中又需要调用某段时，才将该段（目标程序）调入内存并进行链接。<strong>可见，动态链接也要求以段作为管理的单位。</strong></p>
<h4 id="分段和段表"><a href="#分段和段表" class="headerlink" title="分段和段表"></a>分段和段表</h4><p>在分段存储管理方式中，作业的地址空间被划分为若干个段，<strong>每个段</strong> 定义了一组<strong>逻辑信息</strong>。每个段都有自己的名字，通常可用一个<strong>段号</strong>来</p>
<p>代替<strong>段名</strong>，<strong>每个段都从0开始编址</strong>，并采用<strong>一段连续的地址空间</strong>。段的长度由相应的逻辑信息组的长度决定，因而<strong>各段长度不等</strong>。整个作业的</p>
<p>地址空间分成多个段，是<strong>二维的</strong>。</p>
<p>在<strong>动态分区</strong>（可变分区）分配方式中，系统为<strong>整个进程</strong>分配一个连续的内存空间。而在分段式存储管理系统中，则是为<strong>每个分段</strong>分配一个</p>
<p>连续的分区，而进程中的各个段可以离散地装入内存中不同的分区中。为使程序能正常运行，即能从物理内存中找出每个逻辑段所对应的位置，</p>
<p>应像分页系统那样，<strong>在系统中为每个进程建立一张段映射表</strong>，简称“<strong>段表</strong>”。</p>
<p>每个段在表中占有一个表项，其中记录了该段在内存中的<strong>起始地址</strong>（“基址”）和<strong>段长</strong>（字节）。段表一般放在内存中。在配置了段表后，</p>
<p>执行中的进程可通过查找段表找到每个段所对应的内存区。可见，段表是用于实现从<strong>逻辑段</strong>到<strong>物理内存区</strong>的映射。</p>
<h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p>为了实现从进程的逻辑地址到物理地址的变换功能，在系统中设置了<strong>段表寄存器</strong>，用于存放<strong>段表始址</strong> 和<strong>段表长度TL</strong>。在进行地址变换时，</p>
<p>系统将逻辑地址中的<strong>段号S（0～TL-1）</strong>与<strong>段表长度TL</strong>进行比较。–  若S&gt;=TL，表示<strong>段号太大，</strong>是访问越界，于是产生越界中断信号；</p>
<p>若未越界，则根据段表的始址和该段的段号，计算出该段<strong>对应段表项的位置</strong>（段表的始址+段号x段表项的长度），从中读出该段在内存的</p>
<p>起始地址，然后再检查段内地址d是否超过该段的<strong>段长SL</strong>。若超过，即d&gt;SL,同样发出越界中断信号；若未越界，则将该段的<strong>基址</strong>与<strong>段内地址d</strong></p>
<p>相加，即可得到要访问的<strong>内存物理地址</strong>。</p>
<p>像分页系统一样，当段表放在内存中时，每当要访问一个数据，都需<strong>访问两次内存</strong>（第一次是得到物理地址，第二次是从地址中取数据），</p>
<p>从而极大地降低了计算机的速率。解决方法是再<strong>增设一个联想存储器</strong>（TLB），用于保存最近常用的段表项。一般情况下是段比页大，因而</p>
<p><strong>段表项</strong>的数目比页表项的数目少，需要的TLB也相对较小，可以显著的减少存取数据的时间。</p>
<h4 id="分页和分段的主要区别"><a href="#分页和分段的主要区别" class="headerlink" title="分页和分段的主要区别"></a>分页和分段的主要区别</h4><p>分页和分段系统都采用<strong>离散</strong>分配方式，且都要通过<strong>地址映射机构来</strong>实现地址变换。但在概念上两者完全不同，主要表现在3个方面：</p>
<p>– 1）页是信息的<strong>物理**</strong>单位<strong>，分页是为实现离散分配方式，消减外部碎片，提高内存的利用率。</strong>分页仅仅是由于系统管理的需要而不是用户的需要。**</p>
<p>段则是信息的<strong>逻辑单位</strong>，它含有一组其意义相对完整的信息。<strong>分段的目的是为了更好的满足用户的需要。</strong></p>
<p>– 2）页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；</p>
<p>而<strong>段的长度不固定</strong>，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</p>
<p>– 3）<strong>分页</strong>的作业地址空间是<strong>一维的</strong>，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而<strong>分段</strong>的作业地址空间<strong>是二维的</strong>，</p>
<p>程序员在标识一个地址时，既需给出<strong>段名</strong>，又需给出<strong>段内地址</strong>。</p>
<h4 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h4><p><strong>段的共享：即允许若干个进程共享一个或多个分段。</strong></p>
<p><strong>可重入代码</strong>（Reentrant Code）又称为“纯代码”（Pure Code），是一种<strong>允许多个进程同时访问的代码</strong>。为使各个进程所执行的代码完全相同，</p>
<p>绝对不允许可重入代码在执行中有任何改变。因此，<strong>可重入代码</strong>是一种<strong>不允许任何进程对它进行修改的代码</strong>。</p>
<p>—- 但事实上，大多数代码在执行时都可能有些改变，例如，用于控制程序执行次数的变量以及指针、信号量及数组等。为此，在每个进程中，都必</p>
<p>须配以局部数据区，把在执行中可能改变的部分拷贝到该数据区，这样，程序在执行时，只需对该数据区（属于该进程私有）中的内容进行修改，并</p>
<p>不去改变共享的代码，这时的可共享代码即成为可重入码。</p>
<h3 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h3><p>用户程序<strong>先分段</strong>，每个段内部<strong>再分页（内部原理同基本的分页、分段相同）</strong></p>
<p><strong><img src="http://img.blog.csdn.net/20131031091950640?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></strong></p>
<h4 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h4><p>分三部分：段号、段内页号、页内地址</p>
<p><img src="http://img.blog.csdn.net/20131031091956234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<h4 id="地址映射（逻辑地址—-gt-物理地址）"><a href="#地址映射（逻辑地址—-gt-物理地址）" class="headerlink" title="地址映射（逻辑地址—&gt;物理地址）"></a>地址映射（逻辑地址—&gt;物理地址）</h4><p>³ <strong>逻辑地址</strong>—– &gt;段号、段内页号、业内地址</p>
<p>³ 段表寄存器— &gt;段表始址</p>
<p>³ 段号+段表始址—- &gt;页表始址</p>
<p>³ 页表始址+段内页号—–&gt;存储块号</p>
<p>³ 块号+页内地址——&gt;<strong>物理地址</strong></p>
<p> <img src="http://img.blog.csdn.net/20131031092005921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<h4 id="地址变换原理及步骤"><a href="#地址变换原理及步骤" class="headerlink" title="地址变换原理及步骤"></a>地址变换原理及步骤</h4><p><img src="http://img.blog.csdn.net/20131031092012156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>请看上图，给出逻辑地址的段号、页号、页内地址，开始进行地址变换：</p>
<p>1)       在被调进程的PCB中取出段表始址和段表长度，装入段表寄存器</p>
<p>2)       段号与控制寄存器的页表长度比较，若页号大于等于段表长度，发生地址越界中断，停止调用，否则继续</p>
<p>3)       由段号结合段表始址求出页表始址和页表大小</p>
<p>4)       页号与段表的页表大小比较，若页号大于等于页表大小，发生地址越界中断，停止调用，否则继续</p>
<p>5)       由页表始址结合段内页号求出存储块号</p>
<p>6)       存储块号&amp;页内地址，即得物理地址</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在页式、段式存储管理中，为获得一条指令或数据，须两次访问内存；而段页式则须三次访问内存。</p>
<h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><p>常规存储器要求将一个作业全部装入内存方能执行。而虚拟存储器允许将一个作业分多次调入内存。如果采用连续分配方式，则需将作业装入一个连续的内存区域中。所以，虚拟存储器抖毫无例外建立在离散分配管理方式之上。</p>
<ol>
<li>请求分页存储管理方式。</li>
<li>请求分段存储管理方式。</li>
</ol>
<h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>请求分页系统是建立在基本分页系统的基础上，为了能支持虚拟存储器功能而</p>
<p>添加了请求调页功能和页面置换功能。</p>
<h3 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h3><p>在请求分页系统中所须要的主要数据结构是<strong>页表</strong>。其基本作用仍然是<strong>将用户地址空间中的逻辑地址变换为内存空间中的物理地址</strong>。因为仅仅将应用程序的一部分调入内存，另一部分仍在盘上，故须在页表中再添加若干项，供程序(数据)在换进、换出时參考。在请求分页系统中的每个页表项例如以下所看到的： </p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-0.png" alt="img"></p>
<ul>
<li><p>状态位 P：指示该页是否已调入内存。 供程序访问时参考</p>
</li>
<li><p>访问字段 A：记录本页在一段时间内被访问的次数或最近未被访问的时间。 供选择页面换出时参考</p>
</li>
<li><p>修改位 M：表示该页在调入内存后是否被修改过。若修改过，则置换该页时需重写该页至外存。 供置换页面时参考</p>
</li>
<li><p>外存地址：指出该页在外存上的地址。供调入该页时参考</p>
</li>
</ul>
<h3 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h3><p>在请求分页系统中，每当所要訪问的页面不在内存时，<strong>便产生一缺页中断，请求OS将所缺之页调入内存</strong>。缺页中断作为中断，它们相同须要经历诸如保护CPU环境、分析中断原因、转入缺页中断处理程序进行处理、恢复CPU环境等几个步骤。但缺页中断又是一种特殊的中断，它与一般的中断相比，有着明显的差别，主要表如今以下两个方面：<br>(1) 在指令运行期间产生和处理中断信号。通常，<strong>CPU都是在一条指令运行完后，才检查是否有中断请求到达</strong>。若有，便去响应，否则，继续运行下一条指令。然而，缺页中断是在指令运行期间，发现所要訪问的指令或数据不在内存时所产生和处理的。 </p>
<p>(2) 一条指令在运行期间，可能产生多次缺页中断。在下图中示出了一个样例。如在运行一条指令COPY A TO B时，可能要产生6次缺页中断，当中指令本身跨了两个页面，A和B又分别各是一个数据块，也都跨了两个页面。基于这些特征，系统中的硬件机构应能保存多次中断时的状态，并保证最后能返回到中断前产生缺页中断的指令处继续运行。 </p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-7.png" alt="img"></p>
<h3 id="地址变换机构-1"><a href="#地址变换机构-1" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，再为实现虚拟存储器而添加了某些功能而形成的，如产生和处理缺页中断，以及从内存中换出一页的功能等等。下图表示出了请求分页系统中的地址变换过程。在进行地址变换时，首先去检索快表，试图从中找出所要訪问的页。若找到，便改动页表项中的訪问位。对于写指令，还须将改动位置成“1”，然后利用页表项中给出的物理块号和页内地址形成物理地址。地址变换过程到此结束。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-8.png" alt="img"></p>
<h3 id="请求分页存储管理"><a href="#请求分页存储管理" class="headerlink" title="请求分页存储管理"></a>请求分页存储管理</h3><p>例：一个采用请求分页存储管理的计算机系统，其内存（实存）容量为 256M 字节，虚拟内存容量（给用户的最大地址空间）为 4G 字节，页面大小为 4K 字节，试问：</p>
<p>实存物理地址应设为多少位？<br>256M = 2^28，所以为28位</p>
<p>实存中有多少物理块？<br>256M/4K = 64K</p>
<p>实存中最大块号是多少？<br>64K-1</p>
<p>虚存地址应设多少位？<br>4G = 2^32，所以为32位</p>
<p>虚拟地址空间最多可以有多少页？<br>4G/4K = 1M</p>
<p>页内最大偏移量是多少？ </p>
<p>4k-1 = 4*1024-1 = 4095</p>
<h3 id="请求分页中的内存分配"><a href="#请求分页中的内存分配" class="headerlink" title="请求分页中的内存分配"></a>请求分页中的内存分配</h3><h4 id="最小物理块数的确定"><a href="#最小物理块数的确定" class="headerlink" title="最小物理块数的确定"></a>最小物理块数的确定</h4><p>最小物理块数指能保证进程正常运行所需的最小的物理块数，最小物理块数与计算机的硬件结构有关，取决于指令的格式、功能和寻址方式。</p>
<p>采用直接寻址方式，所需的最少物理块数为 2。一块是用于存放指令，另一块用于存放数据。</p>
<p>间接寻址时，至少要求有三个物理块。 （间接寻址中一些物理块放的是其它物理块的块号）</p>
<h4 id="物理块的分配策略"><a href="#物理块的分配策略" class="headerlink" title="物理块的分配策略"></a>物理块的分配策略</h4><h5 id="固定分配局部置换"><a href="#固定分配局部置换" class="headerlink" title="固定分配局部置换"></a>固定分配局部置换</h5><p>为每个进程分配固定数目 n 的物理块，在整个运行中都不改变。如出现缺页则从该进程的页面中置换一页。</p>
<p>每个进程分配多少个物理块难以确定.</p>
<p>若太少，会频繁地出现缺页中断，降低了系统的吞吐量。</p>
<p>若太多，内存中驻留的进程数目减少，可能造成 CPU空闲或其它资源空闲的情况。</p>
<h5 id="可变分配全局置换"><a href="#可变分配全局置换" class="headerlink" title="可变分配全局置换"></a>可变分配全局置换</h5><p>为每个进程分配一定数目的物理块，但 OS 自留一空闲块队列，若发现缺页，则从空闲块队列中分配一空闲块与该进程，并调入缺页于其中。当空闲块队列用完时，OS 才从内存中任选择一页置换。</p>
<h5 id="可变分配局部置换"><a href="#可变分配局部置换" class="headerlink" title="可变分配局部置换"></a>可变分配局部置换</h5><p>为每个进程分配一定数目的物理块，若发现缺页，则从该进程的页面中置换一页，不会影响其它进程的运行。根据进程缺页率高低，则可增加或减少分配给该进程的物理块。</p>
<h3 id="页面调入策略"><a href="#页面调入策略" class="headerlink" title="页面调入策略"></a>页面调入策略</h3><h4 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h4><h5 id="预调页策略"><a href="#预调页策略" class="headerlink" title="预调页策略"></a>预调页策略</h5><p>预调页：将预计在不久之后便会被访问的页面预先调入内存。</p>
<p>进程的页一般存放在外存的一个连续区域中。一次调入若干个相邻的页会比一次调入一页更高效。</p>
<p>但如果调入的一批页面中的大多数都未被访问，则浪费了内存。</p>
<h5 id="请求调页策略"><a href="#请求调页策略" class="headerlink" title="请求调页策略"></a>请求调页策略</h5><p>当进程在运行中发生缺页时，就立即提出请求，由系统将缺页调入内存。但这种策略每次仅调入一页，须花费较大的系统开销，增加了启动磁盘 I/O 的频率。</p>
<h5 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h5><p>在请求分页系统中，外存分成了按离散分配方式存放文件的文件区和按连续分配方式存放对换页的对换区。进程发出缺页请求时，从何处将缺页调入内存呢？</p>
<p>对换区：如果系统有足够的对换区空间，运行前可将与进程相关的文件从文件区复制至对换区，以后缺页时全部从对换区调页。</p>
<p>文件区：如果系统没有足够的对换区空间，凡是不会被修改的文件，直接从文件区调页，不必回写（换出） 。对可能会修改的文件第一次直接从文件区调页，换出时换至对换区，以后从对换区调页。</p>
<p>UNIX 方式：凡未运行过的页面均从文件区调页，运行过的页面和换出的页面均从对换区调页。</p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换算法（OPT）（理想置换算法）"><a href="#最佳置换算法（OPT）（理想置换算法）" class="headerlink" title="最佳置换算法（OPT）（理想置换算法）"></a>最佳置换算法（OPT）（理想置换算法）</h4><p>从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。 </p>
<p>最佳置换算法可以用来评价其他算法。假定系统为某进程分配了三个物理块，并考虑有以下页面号引用串：<br>    7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1<br>进程运行时，先将7, 0, 1三个页面依次装入内存。进程要访问页面2时，产生缺页中断，根据最佳置换算法，选择第18次访问才需调入的页面7予以淘汰。然后，访问页面0时，因为已在内存中所以不必产生缺页中断。访问页面3时又会根据最佳置换算法将页面1淘汰……依此类推，如图3-26所示。从图中可以看出釆用最佳置换算法时的情况。<br>可以看到，发生缺页中断的次数为9，页面置换的次数为6。</p>
<table>
<thead>
<tr>
<th>访问页面</th>
<th>7</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>3</th>
<th>0</th>
<th>4</th>
<th>2</th>
<th>3</th>
<th>0</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>1</th>
<th>7</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理块1</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>2</td>
<td></td>
<td>2</td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td>7</td>
<td></td>
<td></td>
</tr>
<tr>
<td>物理块2</td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td>0</td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>物理块3</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td>3</td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>缺页否</td>
<td>√</td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h4><p>是最简单的页面置换算法。这种算法的基本思想是：当需要淘汰一个页面时，总是选择驻留主存时间最长的页面进行淘汰，即先进入主存的页面先淘汰。其理由是：最早调入主存的页面不再被使用的可能性最大。 </p>
<table>
<thead>
<tr>
<th>访问页面</th>
<th>7</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>3</th>
<th>0</th>
<th>4</th>
<th>2</th>
<th>3</th>
<th>0</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>1</th>
<th>7</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理块1</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>2</td>
<td></td>
<td>2</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>0</td>
<td></td>
<td></td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td>物理块2</td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>物理块3</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>缺页否</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<p>这里仍用上面的实例，釆用FIFO算法进行页面置换。进程访问页面2时，把最早进入内存的页面7换出。然后访问页面3时，再把2, 0, 1中最先进入内存的页换出。由图 3-27可以看出，利用FIFO算法时进行了 12次页面置换，比最佳置换算法正好多一倍。<br>FIFO算法还会产生当所分配的物理块数增大而页故障数不减反增的异常现象，这是由 Belady于1969年发现，故称为Belady异常，如图3-28所示。只有FIFO算法可能出现Belady 异常，而LRU和OPT算法永远不会出现Belady异常。</p>
<table>
<thead>
<tr>
<th>访问页面</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理块1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td></td>
<td></td>
<td>,5’</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>物理块2</td>
<td></td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td>3</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>物理块3</td>
<td></td>
<td></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>缺页否</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>物理块2*</td>
<td></td>
<td>2</td>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>物理块3*</td>
<td></td>
<td></td>
<td>3</td>
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>物理块4*</td>
<td></td>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>3</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>缺页否</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<p><strong>注意：内存的页面中“最老“的页面，会被新的网页直接覆盖，而不是“最老“的页面先出队，然后新的网页从队尾入队。</strong></p>
<h4 id="最近最久未使用（LRU）算法"><a href="#最近最久未使用（LRU）算法" class="headerlink" title="最近最久未使用（LRU）算法"></a>最近最久未使用（LRU）算法</h4><p>这种算法的基本思想是：利用局部性原理，根据一个作业在执行过程中过去的页面访问历史来推测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访问。所以，这种算法的实质是：当需要淘汰一个页面时，总是选择在最近一段时间内最久不用的页面予以淘汰。 </p>
<p>再对上面的实例釆用LRU算法进行页面置换，如图3-29所示。进程第一次对页面2访问时，将最近最久未被访问的页面7置换出去。然后访问页面3时，将最近最久未使用的页面1换出。</p>
<table>
<thead>
<tr>
<th>访问页面</th>
<th>7</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>3</th>
<th>0</th>
<th>4</th>
<th>2</th>
<th>3</th>
<th>0</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>1</th>
<th>7</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理块1</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>2</td>
<td></td>
<td>2</td>
<td></td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>0</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>物理块2</td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td>0</td>
<td></td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td>0</td>
<td></td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>物理块3</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td>3</td>
<td></td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td>2</td>
<td></td>
<td>7</td>
<td></td>
<td></td>
</tr>
<tr>
<td>缺页否</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
</tr>
</tbody>
</table>
<p>实际上，LRU算法根据各页以前的情况，是“向前看”的，而最佳置换算法则根据各页以后的使用情况，是“向后看”的。<br>***LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类的算法。理论上可以证明，堆栈类算法不可能出现Belady异常。FIFO算法基于队列实现，不是堆栈类算法。</p>
<h4 id="时钟-CLOCK-置换算法"><a href="#时钟-CLOCK-置换算法" class="headerlink" title="时钟(CLOCK)置换算法"></a>时钟(CLOCK)置换算法</h4><p>LRU算法的性能接近于OPT,但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。<br>简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。<br>CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都处于以下四种情况之一：</p>
<ol>
<li>最近未被访问，也未被修改(u=0, m=0)。</li>
<li>最近被访问，但未被修改(u=1, m=0)。</li>
<li>最近未被访问，但被修改(u=0, m=1)。</li>
<li>最近被访问，被修改(u=1, m=1)。</li>
</ol>
<p>算法执行如下操作步骤：</p>
<ol>
<li>从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧(u=0, m=0)用于替换。</li>
<li>如果第1)步失败，则重新扫描，查找(u=0, m=1)的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0。</li>
<li>如果第2)步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复第1步，并且如果有必要，重复第2步。这样将可以找到供替换的帧。</li>
</ol>
<p>改进型的CLOCK算法优于简单CLOCK算法之处在于替换时首选没有变化的页。由于修改过的页在被替换之前必须写回，因而这样做会节省时间。</p>
<p>例题：</p>
<p>在5个页框上使用LRU页面替换算法，当页框初始为空时，引用序列为0、1、7、8、6、2、3、7、2、9、8、1、0、2，系统将发生（C）次缺页</p>
<p>​    A、13            B、12           C、11          D、8</p>
<p>解析：内存中驻留5个页框：</p>
<table>
<thead>
<tr>
<th>访问页面</th>
<th>0</th>
<th>1</th>
<th>7</th>
<th>8</th>
<th>6</th>
<th>2</th>
<th>3</th>
<th>7</th>
<th>2</th>
<th>9</th>
<th>8</th>
<th>1</th>
<th>0</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>页框1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>页框2</td>
<td></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>页框3</td>
<td></td>
<td></td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>页框4</td>
<td></td>
<td></td>
<td></td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td>页框5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>是否缺页</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y(换页)</td>
<td>Y(换页)</td>
<td>N</td>
<td>N</td>
<td>Y(换页)</td>
<td>Y(换页)</td>
<td>Y(换页)</td>
<td>Y(换页)</td>
<td>N</td>
</tr>
</tbody>
</table>
<p> LRU是堆栈类的算法，最后访问的页面放在栈顶，可以得到答案为C。</p>
<p>编程思路：</p>
<p>1,用结构体成员记录访问的顺序，换页时选取times最大的那个替换掉。</p>
<p>struct LRU { int data; </p>
<p>　　　　　　　int times;};记录访问次序</p>
<p>struct queue{  LRU *p; int front; int rear</p>
<p>}Qe;</p>
<p>(1)队列未满时，依次添加新访问的页面，并Qe.p[i++].times++</p>
<p>(2)队列满了 a, 新访问的页面在队列中，times设为0，之前在它前面的LRU.times++</p>
<p>​                b, 新访问的页面不在队列中，需替换掉times最大的页面，并设新页面times=0，对列中其它页面times++</p>
<p>2,用队列中存放的位置表示最后访问时间（用线性表涉及大量元素移动，用链表好些）</p>
<p>队列未满时，依次压入；队列满，则查看对列中是否存在，若存在，将其移动到队尾，若不存在，删除队首页面，并在队尾加入新页面。</p>
<h2 id="抖动与工作集"><a href="#抖动与工作集" class="headerlink" title="抖动与工作集"></a>抖动与工作集</h2><h3 id="页面抖动（颠簸）"><a href="#页面抖动（颠簸）" class="headerlink" title="页面抖动（颠簸）"></a>页面抖动（颠簸）</h3><p>在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。</p>
<p>频繁的发生缺页中断（抖动），其主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目。虚拟内存技术可以在内存中保留更多的进程以提髙系统效率。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。但如果管理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。</p>
<h3 id="工作集（驻留集）"><a href="#工作集（驻留集）" class="headerlink" title="工作集（驻留集）"></a>工作集（驻留集）</h3><p>工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。</p>
<p>工作集模型的原理是：让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。</p>
<p>正确选择工作集的大小，对存储器的利用率和系统吞吐量的提嵩，都将产生重要影响。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>虚拟存储器</tag>
        <tag>分页</tag>
        <tag>分段</tag>
      </tags>
  </entry>
  <entry>
    <title>向死而生，知菜而后勇</title>
    <url>/2019/04/24/2019-04-24/</url>
    <content><![CDATA[<p>不知不觉间，搭建的博客已经有一周年了，首先为自己的博客庆个生吧(^人^)嘿嘿。</p>
<p>回首一年间，太多感慨已成云烟，就不多说了（其实是忘得差不多了QYQ）。那就回首一月间吧(￣_￣|||)</p>
<p>回首一月间，可谓一直在找实习从未间断。说到体验的话，可以说是起起伏伏，体验感极差。说到经历的话，可以一句话来形容，便是以腾讯起，以腾讯终。当然，不是以腾讯录用而终，而是以被腾讯pass为终QYQ</p>
<p>这一个月里，虽然各种面试东跑西跑面的身心疲惫，但总的来说还是有收获的，至少让自己认清自己很菜qyq，当然这是开玩笑的啦。首先现在的我已经清楚未来要去的敌方以及要走的路了，而且在其中收获的面试经验是无法替代的。</p>
<p>还记得三月初腾讯们各种投简历带的我还不明白为什么要找实习便也跟着一起投。还记得第一次收到腾讯的面试通知，既兴奋又恐惧，当时还很稚嫩的我（丢不丢脸啊）收面试官小哥哥的照顾竟然莫名其妙过了。还记得西山居经历四次面试本来以为稳了，结果因为没有什么面试经验导致实习时间上的问题最终被刷，之后好长一段时间恐惧面试，不想面试。直到前两天腾讯正式批二面结束后，状态变为了HR面试，当时那个兴奋与感激啊，结果没过两天就又由HR面试变成了初试（嘿嘿，面试本就是大起大落，大落最差不过从头再来，所以说只要没拿到offer就不存在稳不稳）。不过渐渐的，我也明白了实习的意义。其实当初找实习纯粹是被氛围带起的，经过这么多面试之后，一方面发现自己还有很多方面需要学习与总结，另一方面渐渐也发现其实实不实习都无关紧要，做项目的话自己也可以做嘛，只要自己实力够强。而找实习后反而有点浪费学习时间，反正暂时也找不到，不如静下心来好好学习，自己做项目积累经验吧，为秋招做好准备。毕竟这样就可以做自己想做的产品了（偷笑）</p>
<p>现在制定计划，并以今天为起点，抓紧学习，之后就不找实习了，直接面向秋招。</p>
<p>目标：C++，设计模式，Linux网络编程，操作系统，TCP/IP，编译原理，数据库，计算机组成原理。</p>
<p>重点学习内容：C++，Linux系统编程与网络编程，操作系统，计算机网络，编译原理，数据库。</p>
<p>项目：聊天室项目，云盘项目，内存池项目，5V5游戏项目</p>
<p>目前的资源：C++primer，Effictive C++，深入理解计算机系统，图解TCP/IP，图解HTTP，LINUX高性能服务器编程，HeadFirst设计模式，STL源码剖析，编程之美，Linux鸟哥的私房菜，UNIX环境高级编程，计算机网络，计算机操作系统，计算机组成原理等等。</p>
<p>计划：</p>
<p>4月末——计算机网络，计算机操作系统，黑马课程复习。</p>
<p>5月——EffictiveC++，HeadFirst设计模式，Linux高性能服务器编程，计算机网络，编译原理，计算机操作系统，计算机组成原理，黑马课程巩固。</p>
<p>6月——C++primer，STL源码剖析，深入了解计算机系统，编程之美。</p>
<p>7月——8月——项目，二遍课程复习</p>
<p>附上这一个月的心路历程（我的三体的一首词）</p>
<p>天才如我<br>蠢材如我<br>在梦里醒着<br>世人庸庸碌碌<br>求而不得<br>不多我一个<br>放纵了 颓废了<br>也当消解疑惑<br>笑命运管窥蠡测<br>沉迷过 入魔过 倾塌过<br>又能如何<br>这一杯谢你敬我<br>终将真相挑破<br>暗夜里挣不脱重重枷锁<br>百死也容易<br>难的是苟活<br>尘世中以血肉对撞漩涡<br>谁不是生于毫末<br>偏贪恋天地宏阔<br>第几道轮回都捱过<br>换浮生片刻<br>甘心不甘心<br>说来好似是心魔<br>可我陷了便陷了<br>就执念了生死存亡<br>表象声色<br>神明或虫豸<br>活下的才算幸运儿</p>
<p>借酒来遮<br>借梦来躲<br>借命来挥霍<br>如人饮水冷暖<br>各有所获<br>谁也别干涉<br>这世界 那世界<br>不过一念之隔<br>五十年等个结果<br>遗忘的 铭记的 美化的<br>也这么过<br>究竟谁是谁寄托<br>那就放下忐忑<br>来路来去处去都还不错<br>虚无如永生<br>年岁算偷得<br>到如今又哪敢贪求更多<br>纵然我生于毫末<br>也看了天地宏阔<br>下一道轮回该如何<br>便由它如何<br>真实里真实<br>虽惋惜不曾窥破<br>总有来者后来者<br>大道不离生死存亡<br>表象声色<br>神明或虫豸<br>时光中颠倒几回合</p>
<p>你也不必问我<br>这一生这条路值不值得<br>观者谈因果<br>后人论功过<br>横竖我听不见他们评说<br>面目虽扭曲映射<br>看去还不算太丑恶<br>至于鬓角那点斑驳<br>就一笑而过<br>倒也算有幸<br>在命途最后时刻<br>领教太悬殊强弱<br>扑面加身烧熔骨骼、<br>演化烟火<br>若蝉声戛然<br>先蹈此辙、<br>死神裙下客从来多<br>螳螂黄雀你又作哪个<br>宇宙再宏阔<br>真理共微尘一色<br>不都是死路上讨得生活</p>
<p>天才如我<br>蠢材如我<br>在梦里醒着<br>世人庸庸碌碌<br>求而不得<br>不多我一个<br>放纵了 颓废了<br>也当消解疑惑<br>笑命运管窥蠡测<br>沉迷过 入魔过 倾塌过<br>又能如何<br>这一杯谢你敬我<br>终将真相挑破<br>暗夜里挣不脱重重枷锁<br>百死也容易<br>难的是苟活<br>尘世中以血肉对撞漩涡<br>谁不是生于毫末<br>偏贪恋天地宏阔<br>第几道轮回都捱过<br>换浮生片刻<br>甘心不甘心<br>说来好似是心魔<br>可我陷了便陷了<br>就执念了生死存亡<br>表象声色<br>神明或虫豸<br>活下的才算幸运儿</p>
<p>借酒来遮<br>借梦来躲<br>借命来挥霍<br>如人饮水冷暖<br>各有所获<br>谁也别干涉<br>这世界 那世界<br>不过一念之隔<br>五十年等个结果<br>遗忘的 铭记的 美化的<br>也这么过<br>究竟谁是谁寄托<br>那就放下忐忑<br>来路来去处去都还不错<br>虚无如永生<br>年岁算偷得<br>到如今又哪敢贪求更多<br>纵然我生于毫末<br>也看了天地宏阔<br>下一道轮回该如何<br>便由它如何<br>真实里真实<br>虽惋惜不曾窥破<br>总有来者后来者<br>大道不离生死存亡<br>表象声色<br>神明或虫豸<br>时光中颠倒几回合</p>
<p>你也不必问我<br>这一生这条路值不值得<br>观者谈因果<br>后人论功过<br>横竖我听不见他们评说<br>面目虽扭曲映射<br>看去还不算太丑恶<br>至于鬓角那点斑驳<br>就一笑而过<br>倒也算有幸<br>在命途最后时刻<br>领教太悬殊强弱<br>扑面加身烧熔骨骼、<br>演化烟火<br>若蝉声戛然<br>先蹈此辙、<br>死神裙下客从来多<br>螳螂黄雀你又作哪个<br>宇宙再宏阔<br>真理共微尘一色<br>不都是死路上讨得生活</p>
]]></content>
      <categories>
        <category>心路历程</category>
        <category>散文</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title>进程的描述与控制VS处理机调度与死锁</title>
    <url>/2019/04/22/2019-04-22/</url>
    <content><![CDATA[<p>成也进程，败也进程，不为成败，只为进程。</p>
<h1 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h1><h2 id="前驱图"><a href="#前驱图" class="headerlink" title="前驱图"></a>前驱图</h2><p>每个结点可用来表示一个进程或进程段，乃至一条语句，结点间的有向边则表示两个结点间存在偏序或前趋关系。<img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-22-1.png" alt></p>
<p>例如上图P1与P2之间有前趋关系，所以P1与P2只能顺序执行。再如P2与P3之间没有前趋关系，所以P2与P3可以并发执行。</p>
<p>说白了就是有向无环图，可以利用拓扑排序进行执行。</p>
<h2 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h2><p>简单理解，进程就是程序段+数据段+PCB。</p>
<h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>由于多道程序环境下，程序的执行属于并发执行，此时它们将失去封闭性，并且具有间断性，以及运行结果不可在现性的特征。由此决定了程序是不能参与并发执行的，否则，程序的运行便失去了意义。为了能使程序并发执行，并且对并发执行的程序加以描述和控制，人们引入了进程。</p>
<p>为使每个并发执行程序（含数据）都能独立运行，在操作系统中加入一个专门的数据结构——进程控制块（Process Control Block，PCB）</p>
<p>系统利用PCB描述进程的基本情况和活动过程。一般情况下，我们把进程实体简称为进程，所谓创建进程就是创建进程实体中的PCB；撤销进程就是撤销进程的PCB。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>进程是程序的一次执行。</li>
<li>进程是一个程序及其数据在处理机尚顺序执行是所发生的活动。</li>
<li>进程是具有独立功能的程序在一个数据集合上执行的过程，<strong>它是系统执行资源分配和调度的一个独立单位</strong>。</li>
</ul>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li><strong>动态性</strong>：进程是进程实体的执行过程，由创建而生，调度而执行，撤销而亡。进程实体具有生命周期，而程序仅是一组有序命令的集合，存在于某种介质之上，因而是静态的。</li>
<li><strong>并发性</strong>：多个进程实体同存于内存之中，且能在一段时间同时运行。程序没有PCB，因而不能并发。</li>
<li><strong>独立性</strong>：进程实体是一个能独立运行，独立获得资源，独立接受调度的基本单位。而程序没有PCB，固不能执行以上操作。</li>
<li><strong>异步性</strong>：进程是按异步方式运行的，即按各自独立的、不可预知的速度推进，因而结果不可再现。为此，OS中引入进程的概念，并配置相应的同步机制。</li>
</ul>
<h3 id="状态及转换"><a href="#状态及转换" class="headerlink" title="状态及转换"></a>状态及转换</h3><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-22.png" alt></p>
<h4 id="三基态："><a href="#三基态：" class="headerlink" title="三基态："></a>三基态：</h4><ul>
<li><strong>就绪状态</strong>：进程已处于准备好运行的状态，只差CPU，在就绪队列等待调度。</li>
<li><strong>执行状态</strong>：进程已获得CPU，并立即执行。</li>
<li><strong>阻塞状态</strong>：正在运行的进程由于发生某种事件（I/O请求，申请缓冲区失败等）暂时无法继续执行，而让受阻进程处于暂停状态。进入阻塞队列。阻塞时进程自身的主动行为。</li>
</ul>
<h4 id="创建与终止状态："><a href="#创建与终止状态：" class="headerlink" title="创建与终止状态："></a>创建与终止状态：</h4><ul>
<li><strong>创建状态</strong>：申请空白PCB，并向PCB填写控制和管理进程的信息，然后分配资源，最后转入就绪队列中。</li>
<li><strong>终止状态</strong>：等待操作系统善后处理，然后PCB清零，返还系统。</li>
</ul>
<h4 id="挂起状态："><a href="#挂起状态：" class="headerlink" title="挂起状态："></a>挂起状态：</h4><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-22.jpg" alt></p>
<p>当操作作用于某个进程时，该进程处于静止状态。</p>
<h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><ol>
<li>终端用户需要。例如运行时改bug。</li>
<li>父进程请求。</li>
<li>符合调节需要。</li>
<li>操作系统需要。例如检查运行情况。</li>
</ol>
<h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><h4 id="PCB中的信息"><a href="#PCB中的信息" class="headerlink" title="PCB中的信息"></a>PCB中的信息</h4><ol>
<li><strong>进程描述符</strong>：进程标识符用于唯一标识进程。</li>
<li><strong>处理机状态</strong>：进程切换时保留现场以及现场恢复。</li>
<li><strong>进程调度信息</strong>：进程状态及相关进程调度信息。</li>
<li><strong>进程控制信息</strong>：用于进程控制所需信息。</li>
</ol>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制一般由OS原语实现。</p>
<h3 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h3><ol>
<li>支撑功能<ul>
<li>中断处理。</li>
<li>始终处理。</li>
<li>原语操作。原语由若干指令组成，用于完成一定功能的过程。原子操作，一个操作中所有行动要么全做，要么不做。</li>
</ul>
</li>
<li>资源管理功能<ul>
<li>进程管理。</li>
<li>存储器管理。</li>
<li>设备管理。</li>
</ul>
</li>
</ol>
<h3 id="进程的创建与终止"><a href="#进程的创建与终止" class="headerlink" title="进程的创建与终止"></a>进程的创建与终止</h3><p>创建原语：Creat</p>
<p>终止原语：Holt</p>
<h3 id="进程的阻塞与唤醒"><a href="#进程的阻塞与唤醒" class="headerlink" title="进程的阻塞与唤醒"></a>进程的阻塞与唤醒</h3><p>阻塞原语：block</p>
<p>唤醒原语：wakeup</p>
<h3 id="进程的挂起与激活"><a href="#进程的挂起与激活" class="headerlink" title="进程的挂起与激活"></a>进程的挂起与激活</h3><p>挂起原语：suspend</p>
<p>激活原语：active</p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h3><ol>
<li>关中断</li>
<li>利用Test-and-Set指令实现互斥</li>
<li>利用Swap指令实现进程互斥</li>
</ol>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ol>
<li>整型信号量</li>
<li>记录型信号量</li>
<li>AND型信号量</li>
<li>信号量集</li>
</ol>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>信号量机制功能强大，但使用时对信号量的操作分散，而且难以控制，读写和维护都很困难。因此后来又提出了一种集中式同步进程——管程。其基本思想是将共享变量和对它们的操作集中在一个模块中，操作系统或并发程序就由这样的模块构成。这样模块之间联系清晰，便于维护和修改，易于保证正确性。 </p>
<h3 id="经典进程同步问题"><a href="#经典进程同步问题" class="headerlink" title="经典进程同步问题"></a>经典进程同步问题</h3><p>生产者-消费者问题</p>
<p>读者-写者问题</p>
<p>哲学家进餐问题</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ol>
<li><p>共享存储器系统</p>
</li>
<li><p>管道（pipe）通信系统</p>
</li>
<li><p>消息传递系统</p>
<ul>
<li><p>消息传递的实际功能以一对原语的形式提供：</p>
<ul>
<li>send(destination,message)</li>
<li>receive(source,message)</li>
</ul>
<p>这是进程间进程消息传递所需要的最小操作集。</p>
<p>一个进程以消息的形式给另一个指定的目标进程发送消息；</p>
<p>进程通过执行receive原语接收消息，receive原语中指明发送消息的源进程和消息。</p>
</li>
</ul>
</li>
<li><p>客户机-服务机系统</p>
<ul>
<li>套接字socket</li>
</ul>
</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>作为调度和分派的基本单位。</p>
<p>每个线程有一个线程控制块TCB。</p>
<h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h1><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><p>无论是在批处理系统还是分时系统中，用户进程数一般都多于处理机数、这将导致它们互相争夺处理机。另外，系统进程也同样需要使用处理机。这就要求进程调度程序按一定的策略，动态地把处理机分配给处于就绪队列中的某一个进程，以使之执行。</p>
<h3 id="处理机调度层次"><a href="#处理机调度层次" class="headerlink" title="处理机调度层次"></a>处理机调度层次</h3><p><strong>高级、中级和低级调度作业从提交开始直到完成，往往要经历下述三级调度：</strong></p>
<p>高级调度：(High-Level Scheduling)又称为作业调度，它决定把外存上后备作业调入内存运行；</p>
<p>低级调度：(Low-Level Scheduling)又称为进程调度，它决定把就绪队列的某进程获得CPU；</p>
<p>中级调度：(Intermediate-Level Scheduling)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。把不能正常运行的进程调至外存等待。</p>
<h4 id="处理机调度算法"><a href="#处理机调度算法" class="headerlink" title="处理机调度算法"></a>处理机调度算法</h4><p>CPU利用率 = CPU有效工作时间 / (CPU有效工作时间 + CPU空闲等待时间)</p>
<h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><p>周转时间Ti = 完成时间 - 到达时间</p>
<p>平均周转时间T = 1/n( T1 + …… + Ti + …… + Tn )</p>
<p>带权周转时间为周转时间/运行时间（越小越好）</p>
<h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><p>响应时间快，均衡性好。</p>
<h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><p>考虑截至时间，提高可预测性。</p>
<h3 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h3><h4 id="作业（Job）"><a href="#作业（Job）" class="headerlink" title="作业（Job）"></a>作业（Job）</h4><p>程序的集合+数据的集合+作业说明书+JCB。</p>
<p>三个状态：后备状态，运行状态，收容状态。</p>
<p>三个阶段：收容阶段（创建JCB），运行阶段，完成阶段（回收JCB）。</p>
<h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><ol>
<li>接纳多少作业</li>
<li>接纳哪些作业</li>
</ol>
<h4 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a>作业调度算法</h4><h5 id="先来先服务算法（first-come-first-served，FCFS）"><a href="#先来先服务算法（first-come-first-served，FCFS）" class="headerlink" title="先来先服务算法（first-come first-served，FCFS）"></a>先来先服务算法（first-come first-served，FCFS）</h5><p>系统按照作业到达的优先顺序调度。</p>
<p>不利于短作业。</p>
<h5 id="短作业优先算法（short-job-first，SJF）"><a href="#短作业优先算法（short-job-first，SJF）" class="headerlink" title="短作业优先算法（short job first，SJF）"></a>短作业优先算法（short job first，SJF）</h5><p>系统以作业长短为优先级。</p>
<p>不利于长作业，容易出现进程饥饿现象。</p>
<h5 id="优先级调度算法（priority-scheduling-algorithm，PSA）"><a href="#优先级调度算法（priority-scheduling-algorithm，PSA）" class="headerlink" title="优先级调度算法（priority-scheduling algorithm，PSA）"></a>优先级调度算法（priority-scheduling algorithm，PSA）</h5><p>根据作业紧迫程度，由外界赋予优先级。</p>
<h5 id="高响应比有限调度算法（Highest-Rseponse-Ratio-Next，HRRN）"><a href="#高响应比有限调度算法（Highest-Rseponse-Ratio-Next，HRRN）" class="headerlink" title="高响应比有限调度算法（Highest Rseponse Ratio Next，HRRN）"></a>高响应比有限调度算法（Highest Rseponse Ratio Next，HRRN）</h5><p>动态优先级，根据长短赋初值，根据等待时间加权。作业越短，初值越大，等待时间越长，加权越大。</p>
<p>Rp = 响应时间/要求服务时间</p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><h4 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h4><h5 id="剥夺方式"><a href="#剥夺方式" class="headerlink" title="剥夺方式"></a>剥夺方式</h5><p>当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程。剥夺原则有：优先权原则、短进程优先原则、时间片原则。</p>
<h5 id="非剥夺方式"><a href="#非剥夺方式" class="headerlink" title="非剥夺方式"></a>非剥夺方式</h5><p>分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理机分配给另一个进程。</p>
<h4 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h4><ol>
<li>保存处理机现场信息。</li>
<li>按某种算法选取进程。</li>
<li>把处理器分配给进程。</li>
</ol>
<h4 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h4><p>进程调度也称为低级调度，它所调度的对象为进程（或者内核级线程），而进程调度算法主要有以下几种：</p>
<h5 id="基于时间片的轮转调度算法"><a href="#基于时间片的轮转调度算法" class="headerlink" title="基于时间片的轮转调度算法"></a>基于时间片的轮转调度算法</h5><p>它的原理通俗来讲就是队列中每一个进程都获得了一定的执行时间，从几ms到几百ms，当一个执行时间结束，计时器会发出一个信号，此时正在执行的进程将被中断，同时此进程将被放在队列的末尾，然后执行这时候的队列的队首进程，因此队列中每一个进程都将获得一定时间执行。</p>
<h5 id="先来先服务调度算法（FCFS）"><a href="#先来先服务调度算法（FCFS）" class="headerlink" title="先来先服务调度算法（FCFS）"></a>先来先服务调度算法（FCFS）</h5><p>先来先服务调度算法是一种最简单的调度算法，可用于作业调度，也可用于进程调度。</p>
<h5 id="短作业优先调度算法（SJ-P-F）"><a href="#短作业优先调度算法（SJ-P-F）" class="headerlink" title="短作业优先调度算法（SJ(P)F）"></a>短作业优先调度算法（SJ(P)F）</h5><p>短作业（进程）优先调度算法是指短作业或者短进程的优先调度算法，它们分别作用于作业调度和进程调度，它是先来先服务调度算法的一种优化版本。</p>
<h5 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h5><p>为了解决在短作业优先调度算法中进程的紧迫程度问题，我们引入高优先权优先调度算法，高优先权调度算法的方法也很简单，就是在队列中选取优先权最高的进程装入内存，该算法又分为以下两类：</p>
<p>①非抢占式优先权算法<br>如果系统已经分配好一个优先权最高的进程，它会一直被执行，直到结束或者因为某事件放弃执行，此时系统才会选择另外一个优先权最高的进程，这种调度算法主要被用于批处理系统中。</p>
<p>②抢占式优先权算法<br>系统在队列中把一个优先权最高的进程执行，但如果在执行中又出现一个优先权更高的进程，此时当前进程被停止，换入另外一个优先权更高的进程，这种调度算法主要被用于要求比较严格的实时系统，以及对性能要求较高的批处理和分时系统中。</p>
<p>优先权的类型：</p>
<p>优先权的类型被分为静态优先权和动态优先权。</p>
<p>静态优先权就是给定某个整形数字来表示进程的优先级，数字越小表示优先级越高，数字越大，进程优先级越低。</p>
<p>动态优先权随着进程的创建而被创建，可以随着进程的推进或者等待时间而变化。</p>
<h5 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h5><p>进程就绪队列由一个拆成多个，不同类型进程分配不同就绪队列，不同就绪队列采用不同算法。一个就绪队列可以设置不同优先级，不同就绪队列本身也可设优先级。</p>
<p>系统根据不同的用户选用不同的调度策略。</p>
<h5 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h5><p>设置多个就绪队列，每个队列的优先级逐渐降低，同时每个队列的执行时间也各不相同，优先级越高的队列，执行时间越短，优先级越低的队列，执行时间越长。<br>当一个进程进入内存后，首先进入第一个队列的末尾，按照先来先服务的调度算法进行调度，如果在第一个队列的执行时间内未执行完成，此时把此进程放入第二个队列的末尾，按照之前的方法进行执行，直到在某一个队列的队首执行完成。</p>
<p>当第一个队列全部执行完成，此时系统才会执行第二个队列，但是如果此时又有新的进程进入，此时执行完毕这个时间段，立刻把此进程分配给新的作业。</p>
<h5 id="根据公平原则的调度算法"><a href="#根据公平原则的调度算法" class="headerlink" title="根据公平原则的调度算法"></a>根据公平原则的调度算法</h5><p>公平分配每个进程相同的处理机时间，或按进程比例公平分配用户相同的处理机时间。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="锁与信号量"><a href="#锁与信号量" class="headerlink" title="锁与信号量"></a>锁与信号量</h3><p>锁强调于资源，信号量强调于执行次序。</p>
<h3 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h3><p>重用性资源与消耗性资源</p>
<p>可抢占性资源与不可抢占资源</p>
<h3 id="死锁起因"><a href="#死锁起因" class="headerlink" title="死锁起因"></a>死锁起因</h3><p>源于多个进程对资源的争夺，不仅对<strong>不可抢占资源</strong>金进行争夺时容易产生死锁，而且对<strong>消耗性资源</strong>抢夺也会产生死锁。还有就是进程推进不当引起死锁。</p>
<h3 id="死锁产生必要条件"><a href="#死锁产生必要条件" class="headerlink" title="死锁产生必要条件"></a>死锁产生必要条件</h3><ol>
<li>互斥条件（不能破坏该条件）</li>
<li>请求与保持条件</li>
<li>不可抢占条件</li>
<li>循环等待条件</li>
</ol>
<h3 id="处理死锁的方法"><a href="#处理死锁的方法" class="headerlink" title="处理死锁的方法"></a>处理死锁的方法</h3><p>以下四种方法从上往下防范程度逐渐减弱，但资源利用率与并发程度逐渐提高。</p>
<h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><h5 id="破坏”请求保持条件“"><a href="#破坏”请求保持条件“" class="headerlink" title="破坏”请求保持条件“"></a>破坏”请求保持条件“</h5><ol>
<li>一次性分配所有需要的资源。</li>
<li>用到时再调用资源，用完即释放资源。</li>
</ol>
<h5 id="破坏”不可抢占条件“"><a href="#破坏”不可抢占条件“" class="headerlink" title="破坏”不可抢占条件“"></a>破坏”不可抢占条件“</h5><p>调用资源时如果资源被占用，则必须释放已有所有资源，用时再调用。</p>
<h5 id="破坏”循环等待条件“"><a href="#破坏”循环等待条件“" class="headerlink" title="破坏”循环等待条件“"></a>破坏”循环等待条件“</h5><p>先给进程编号并排序，再按照顺序分配资源。</p>
<h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><p><strong>银行家算法的数据结构</strong><br>可利用资源向量（Available）：系统还可以分配的资源</p>
<p>最大需求矩阵（Max）：进程的最大资源需要</p>
<p>分配矩阵（Alloction）：进程已经获得的资源</p>
<p>需求矩阵（Need）：进程还需要获得的资源</p>
<p><strong>银行家算法</strong></p>
<p>假设 P1 进程提出请求 K 个资源</p>
<p>如果 K &lt;= Need，就继续步骤；否则出错，因为请求资源 K 不能超过还需要获得的资源</p>
<p>如果 K &lt;= Available，就继续步骤；否则出错，因为请求资源 K 不能超过系统还可以分配的资源 </p>
<p>Available系统试探分配资源，并修改下列数据</p>
<p>Available = Available - K；表示分配给 P1 K 个资源后，还剩多少系统可分配资源</p>
<p>Allocation = Allocation + K；表示 P1 已经获得的资源</p>
<p>Need = Need - K；表示进程 P1 还需要获得的资源</p>
<p>此时系统执行安全性算法，计算进程是否处于安全性状态</p>
<p>PS：此时是执行的试探分配，为的是检查进程是否处于安全状态，不处于则试探分配作废</p>
<p><strong>安全性算法</strong></p>
<p>安全性算法是银行家算法在第五步执行的子算法，用于检查进程的安全状态</p>
<p>两个向量</p>
<p>工作向量（Work）：系统提供给进程的各类资源数目</p>
<p>Finish：表示系统是否有足够的资源分配给进程，这是一个布尔值。初始化为 false。</p>
<p><strong>算法描述</strong></p>
<p>在进程集合中找到下述条件的进程</p>
<p>Finish[ i ] = false;</p>
<p>Need &lt;= Work</p>
<p>进程执行完毕</p>
<p>Work = Work + Allocation</p>
<p>Finish [ i ] = true</p>
<p>返回继续执行 1 ，寻找其他的进程分配资源</p>
<p>若所有的 Finish 为 true 则安全</p>
<h4 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h4><p>资源分配图。</p>
<h4 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h4><p>杀死进程。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
        <tag>线程</tag>
        <tag>死锁</tag>
        <tag>进程调度</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]HashMap实现原理及源码分析</title>
    <url>/2019/04/20/2019-04-20-1/</url>
    <content><![CDATA[<p>　　哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。</p>
<h1 id="一、什么是哈希表"><a href="#一、什么是哈希表" class="headerlink" title="一、什么是哈希表"></a>一、什么是哈希表</h1><p>　　在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能</p>
<p>　　<strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</p>
<p>　　<strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</p>
<p>　　<strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</p>
<p>　　<strong>哈希表</strong>：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p>
<p>　　我们知道，数据结构的物理存储结构只有两种：<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。</p>
<p>　　比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p>
<p>　　　　　　　　<strong>存储位置 = f(关键字)</strong></p>
<p>　　其中，这个函数f一般称为<strong>哈希函数</strong>，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：</p>
<p>　　<img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161113180447499-1953916974.png" alt="img"></p>
<p>　　查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p>
<p>　　<strong>哈希冲突</strong></p>
<p>　　然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的<strong>哈希冲突</strong>，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 <strong>计算简单</strong>和<strong>散列地址分布均匀,</strong>但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是<strong>数组+链表</strong>的方式，</p>
<h1 id="二、HashMap实现原理"><a href="#二、HashMap实现原理" class="headerlink" title="二、HashMap实现原理"></a>二、HashMap实现原理</h1><p>　HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组&#123;&#125;，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。</span><br><span class="line">transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure>
<p> Entry是HashMap中的一个静态内部类。代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;//存储指向下一个Entry的引用，单链表结构</span><br><span class="line">    int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates new entry.</span><br><span class="line">     */</span><br><span class="line">    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 所以，HashMap的整体结构如下</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161113235348670-746615111.png" alt="img">　　</p>
<p>　　<strong>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</strong></p>
<p>其他几个重要字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//实际存储的key-value键值对的个数</span><br><span class="line">transient int size;</span><br><span class="line">//阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到</span><br><span class="line">int threshold;</span><br><span class="line">//负载因子，代表了table的填充度有多少，默认是0.75</span><br><span class="line">final float loadFactor;</span><br><span class="line">//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException</span><br><span class="line">transient int modCount;</span><br></pre></td></tr></table></figure>
<p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值</p>
<p>initialCapacity默认为16，loadFactory默认为0.75</p>
<p>我们看下其中一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">　　　　　//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230)</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        this.loadFactor = loadFactor;</span><br><span class="line">        threshold = initialCapacity;</span><br><span class="line">　　　　　</span><br><span class="line">        init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>　　从上面这段代码我们可以看出，<strong>在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组</strong></p>
<p>　　OK,接下来我们来看看put操作的实现吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    //如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)</span><br><span class="line">    if (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">   //如果key为null，存储位置为table[0]或table[0]的冲突链上</span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀</span><br><span class="line">    int i = indexFor(hash, table.length);//获取在table中的实际位置</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">    //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span><br><span class="line">    addEntry(hash, key, value, i);//新增一个entry</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 先来看看inflateTable这个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void inflateTable(int toSize) &#123;</span><br><span class="line">        int capacity = roundUpToPowerOf2(toSize);//capacity一定是2的次幂</span><br><span class="line">        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1</span><br><span class="line">        table = new Entry[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>　　inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int roundUpToPowerOf2(int number) &#123;</span><br><span class="line">       // assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span><br><span class="line">       return number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">               ? MAXIMUM_CAPACITY</span><br><span class="line">               : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;</span><br><span class="line">   &#125;[​](javascript:void(0);)</span><br></pre></td></tr></table></figure>
<p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.</p>
<p>hash函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀</span><br><span class="line">final int hash(Object k) &#123;</span><br><span class="line">        int h = hashSeed;</span><br><span class="line">        if (0 != h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">            return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　/**</span><br><span class="line"> * 返回数组下标</span><br><span class="line"> */</span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1  0  0  1  0</span><br><span class="line">&amp;   0  1  1  1  1</span><br><span class="line">__________________</span><br><span class="line">    0  0  0  1  0    = 2</span><br></pre></td></tr></table></figure>
<p>　　最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）</p>
<p>所以最终存储位置的确定流程是这样的：</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161115133556388-1098209938.png" alt="img"></p>
<p>再来看看addEntry的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">            resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容</span><br><span class="line">            hash = (null != key) ? hash(key) : 0;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>　　通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p>
<h1 id="三、为何HashMap的数组长度一定是2的次幂？"><a href="#三、为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="三、为何HashMap的数组长度一定是2的次幂？"></a>三、为何HashMap的数组长度一定是2的次幂？</h1><p>我们来继续看上面提到的resize方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">       Entry[] oldTable = table;</span><br><span class="line">       int oldCapacity = oldTable.length;</span><br><span class="line">       if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">       transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">       table = newTable;</span><br><span class="line">       threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">        int newCapacity = newTable.length;</span><br><span class="line">　　　　　//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）</span><br><span class="line">        for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            while(null != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                if (rehash) &#123;</span><br><span class="line">                    e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                int i = indexFor(e.hash, newCapacity);</span><br><span class="line">　　　　　　　　　 //将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>　　这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p>
<p>　　hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p>
<p>　　<img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161115215812138-679881037.png" alt="img"></p>
<p> 还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如：</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161116001404732-625340289.png" alt="img"></p>
<p>　　我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161116001717560-1455096254.png" alt="img"></p>
<p>　　如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。</p>
<p>get方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">　　　　 //如果key为null,则直接去table[0]处去检索即可。</span><br><span class="line">       if (key == null)</span><br><span class="line">           return getForNullKey();</span><br><span class="line">       Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">       return null == entry ? null : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">            </span><br><span class="line">        if (size == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //通过key的hashcode值计算hash值</span><br><span class="line">        int hash = (key == null) ? 0 : hash(key);</span><br><span class="line">        //indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != null;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash == hash &amp;&amp; </span><br><span class="line">                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                return e;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>　　可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。</p>
<h1 id="四、重写equals方法需同时重写hashCode方法"><a href="#四、重写equals方法需同时重写hashCode方法" class="headerlink" title="四、重写equals方法需同时重写hashCode方法"></a>四、重写equals方法需同时重写hashCode方法</h1><p>　　关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by chengxiao on 2016/11/15.</span><br><span class="line"> */</span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    private static class Person&#123;</span><br><span class="line">        int idCard;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Person(int idCard, String name) &#123;</span><br><span class="line">            this.idCard = idCard;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object o) &#123;</span><br><span class="line">            if (this == o) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (o == null || getClass() != o.getClass())&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            Person person = (Person) o;</span><br><span class="line">            //两个对象是否等值，通过idCard来确定</span><br><span class="line">            return this.idCard == person.idCard;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String []args)&#123;</span><br><span class="line">        HashMap&lt;Person,String&gt; map = new HashMap&lt;Person, String&gt;();</span><br><span class="line">        Person person = new Person(1234,&quot;乔峰&quot;);</span><br><span class="line">        //put到hashmap中去</span><br><span class="line">        map.put(person,&quot;天龙八部&quot;);</span><br><span class="line">        //get取出，从逻辑上讲应该能输出“天龙八部”</span><br><span class="line">        System.out.println(&quot;结果:&quot;+map.get(new Person(1234,&quot;萧峰&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">结果：null</span><br></pre></td></tr></table></figure>
<p>　　如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）</p>
<p>　　所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>　　本文描述了HashMap的实现原理，并结合源码做了进一步的分析，也涉及到一些源码细节设计缘由，最后简单介绍了为什么重写equals的时候需要重写hashCode方法。希望本篇文章能帮助到大家，同时也欢迎讨论指正，谢谢支持！</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>C++常用知识点STL总结</title>
    <url>/2019/04/20/2019-04-20/</url>
    <content><![CDATA[<h1 id="STL标准模板库"><a href="#STL标准模板库" class="headerlink" title="STL标准模板库"></a>STL标准模板库</h1><h2 id="六大组件简介"><a href="#六大组件简介" class="headerlink" title="六大组件简介"></a>六大组件简介</h2><p>STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。</p>
<p><strong>容器：</strong>各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。</p>
<p><strong>算法：</strong>各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.</p>
<p><strong>迭代器：</strong>扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-&gt; , operator++,operator–等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。</p>
<p><strong>仿函数：</strong>行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template</p>
<p><strong>适配器：</strong>一种用来修饰容器或者仿函数或迭代器接口的东西。</p>
<p><strong>空间配置器：</strong>负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.</p>
<p>STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。</p>
<h2 id="STL优点"><a href="#STL优点" class="headerlink" title="STL优点"></a>STL优点</h2><p>STL 是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p>
<p>STL 的一个重要特性是将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”,以使算法可以和容器交互运作</p>
<p>程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就 OK 了。这样他们就可以把精力放在程序开发的别的方面。</p>
<p>STL 具有高可重用性，高性能，高移植性，跨平台的优点。</p>
<ul>
<li><p><strong>高可重用性</strong>：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</p>
</li>
<li><p><strong>高性能</strong>：如 map 可以高效地从十万条记录里面查找出指定的记录，因为 map 是采用红黑树的变体实现的。</p>
</li>
<li><p><strong>高移植性</strong>：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。</p>
</li>
</ul>
<h1 id="STL常用三大组件"><a href="#STL常用三大组件" class="headerlink" title="STL常用三大组件"></a>STL常用三大组件</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h3><p>序列式容器强调值的排序，序列式容器中的<strong>每个元素均有固定的位置</strong>，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。</p>
<h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><p>关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间<strong>没有严格的物理上的顺序关系</strong>，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set/multiset容器 Map/multimap容器。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="质变算法"><a href="#质变算法" class="headerlink" title="质变算法"></a>质变算法</h3><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等。</p>
<h3 id="非质变算法"><a href="#非质变算法" class="headerlink" title="非质变算法"></a>非质变算法</h3><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等中会更改。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>提供一种方法，使之能够<strong>依序寻访某个容器所含的各个元素</strong>，而又无需暴露该容器的内部表示方式。</p>
<p>迭代器的种类:</p>
<table>
<thead>
<tr>
<th>输入迭代器</th>
<th>提供对数据的只读访问</th>
<th>只读，支持++、==、！=</th>
</tr>
</thead>
<tbody>
<tr>
<td>输出迭代器</td>
<td>提供对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>提供读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、！=</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>提供读写操作，并能向前和向后操作</td>
<td>读写，支持++、–，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody>
</table>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//STL 中的容器 算法 迭代器</span><br><span class="line">void test01()&#123;</span><br><span class="line">	vector&lt;int&gt; v; //STL 中的标准容器之一 ：动态数组</span><br><span class="line">	v.push_back(1); //vector 容器提供的插入数据的方法</span><br><span class="line">	v.push_back(5);</span><br><span class="line">	v.push_back(3);</span><br><span class="line">	v.push_back(7);</span><br><span class="line">	//迭代器</span><br><span class="line">	vector&lt;int&gt;::iterator pStart = v.begin(); //vector 容器提供了 begin()方法 返回指向第一个元素的迭代器</span><br><span class="line">	vector&lt;int&gt;::iterator pEnd = v.end(); //vector 容器提供了 end()方法 返回指向最后一个元素下一个位置的迭代器</span><br><span class="line">	//通过迭代器遍历</span><br><span class="line">	while (pStart != pEnd)&#123;</span><br><span class="line">		cout &lt;&lt; *pStart &lt;&lt; &quot; &quot;;</span><br><span class="line">		pStart++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	//算法 count 算法 用于统计元素的个数</span><br><span class="line">	int n = count(pStart, pEnd, 5);</span><br><span class="line">	cout &lt;&lt; &quot;n:&quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//STL 容器不单单可以存储基础数据类型，也可以存储类对象</span><br><span class="line">class Teacher</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Teacher(int age) :age(age)&#123;&#125;;</span><br><span class="line">	~Teacher()&#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	vector&lt;Teacher&gt; v; //存储 Teacher 类型数据的容器</span><br><span class="line">	Teacher t1(10), t2(20), t3(30);</span><br><span class="line">	v.push_back(t1);</span><br><span class="line">	v.push_back(t2);</span><br><span class="line">	v.push_back(t3);</span><br><span class="line">	vector&lt;Teacher&gt;::iterator pStart = v.begin();</span><br><span class="line">	vector&lt;Teacher&gt;::iterator pEnd = v.end();</span><br><span class="line">	//通过迭代器遍历</span><br><span class="line">	while (pStart != pEnd)&#123;</span><br><span class="line">		cout &lt;&lt; pStart-&gt;age &lt;&lt; &quot; &quot;;</span><br><span class="line">		pStart++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//存储 Teacher 类型指针</span><br><span class="line">void test03()&#123;</span><br><span class="line">	vector&lt;Teacher*&gt; v; //存储 Teacher 类型指针</span><br><span class="line">	Teacher* t1 = new Teacher(10);</span><br><span class="line">	Teacher* t2 = new Teacher(20);</span><br><span class="line">	Teacher* t3 = new Teacher(30);</span><br><span class="line">	v.push_back(t1);</span><br><span class="line">	v.push_back(t2);</span><br><span class="line">	v.push_back(t3);</span><br><span class="line">	//拿到容器迭代器</span><br><span class="line">	vector&lt;Teacher*&gt;::iterator pStart = v.begin();</span><br><span class="line">	vector&lt;Teacher*&gt;::iterator pEnd = v.end();</span><br><span class="line">	//通过迭代器遍历</span><br><span class="line">	while (pStart != pEnd)&#123;</span><br><span class="line">		cout &lt;&lt; (*pStart)-&gt;age &lt;&lt; &quot; &quot;;</span><br><span class="line">		pStart++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//容器嵌套容器 难点(不理解，可以跳过)</span><br><span class="line">void test04()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt; vector&lt;int&gt; &gt; v;</span><br><span class="line">	vector&lt;int&gt;v1;</span><br><span class="line">	vector&lt;int&gt;v2;</span><br><span class="line">	vector&lt;int&gt;v3;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; 5;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.push_back(i);</span><br><span class="line">		v2.push_back(i * 10);</span><br><span class="line">		v3.push_back(i * 100);</span><br><span class="line">	&#125;</span><br><span class="line">	v.push_back(v1);</span><br><span class="line">	v.push_back(v2);</span><br><span class="line">	v.push_back(v3);</span><br><span class="line"></span><br><span class="line">	for (vector&lt; vector&lt;int&gt; &gt;::iterator it = v.begin(); it != v.end();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		for (vector&lt;int&gt;::iterator subIt = (*it).begin(); subIt != (*it).end(); subIt ++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; *subIt &lt;&lt; &quot; &quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">	//test01();</span><br><span class="line">	//test02();</span><br><span class="line">	//test03();</span><br><span class="line">	test04();</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h1><h2 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h2><ul>
<li><strong>String和char*</strong>：<ul>
<li>Char*是一个指针，String是一个类。</li>
<li>string封装了char*，管理这个字符串，是一个char*型的容器。</li>
</ul>
</li>
<li>String封装了很多实用的成员方法：<ul>
<li>查找find，拷贝copy，删除delete，替换replace，插入insert。</li>
</ul>
</li>
<li>不用考虑内存释放和越界：<ul>
<li>string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</li>
</ul>
</li>
</ul>
<h3 id="string构造函数"><a href="#string构造函数" class="headerlink" title="string构造函数"></a>string构造函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string();//创建一个空的字符串 例如: string str;      </span><br><span class="line">string(const string&amp; str);//使用一个string对象初始化另一个string对象</span><br><span class="line">string(const string&amp; str, size_t pos, size_t n);//使用一个string对象的pos位及后n位初始化另一个对象</span><br><span class="line">string(const string&amp; str, size_t n);//使用一个string对象的前n位初始化另一个对象</span><br><span class="line">string(const char* s);//使用字符串s初始化</span><br><span class="line">string(size_t n, char c);//使用n个字符c初始化</span><br></pre></td></tr></table></figure>
<h3 id="string赋值操作"><a href="#string赋值操作" class="headerlink" title="string赋值操作"></a>string赋值操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string&amp; operator=(const char* s);//char*类型字符串 赋值给当前的字符串</span><br><span class="line">string&amp; operator=(const string &amp;s);//把字符串s赋给当前的字符串</span><br><span class="line">string&amp; operator=(char c);//字符赋值给当前的字符串</span><br><span class="line">string&amp; assign(const char *s);//把字符串s赋给当前的字符串</span><br><span class="line">string&amp; assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串</span><br><span class="line">string&amp; assign(const string &amp;s);//把字符串s赋给当前字符串</span><br><span class="line">string&amp; assign(int n, char c);//用n个字符c赋给当前字符串</span><br><span class="line">string&amp; assign(const string &amp;s, int start, int n);//将s从start开始n个字符赋值给字符串</span><br></pre></td></tr></table></figure>
<h3 id="string获取字符操作"><a href="#string获取字符操作" class="headerlink" title="string获取字符操作"></a>string获取字符操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char&amp; operator[](int n);//通过[]方式取字符</span><br><span class="line">char&amp; at(int n);//通过at方法获取字符</span><br></pre></td></tr></table></figure>
<h3 id="string拼接操作"><a href="#string拼接操作" class="headerlink" title="string拼接操作"></a>string拼接操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string&amp; operator+=(const string&amp; str);//重载+=操作符</span><br><span class="line">string&amp; operator+=(const char* str);//重载+=操作符</span><br><span class="line">string&amp; operator+=(const char c);//重载+=操作符</span><br><span class="line">string&amp; append(const char *s);//把字符串s连接到当前字符串结尾</span><br><span class="line">string&amp; append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾</span><br><span class="line">string&amp; append(const string &amp;s);//同operator+=()</span><br><span class="line">string&amp; append(const string &amp;s, int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾</span><br><span class="line">string&amp; append(int n, char c);//在当前字符串结尾添加n个字符c</span><br></pre></td></tr></table></figure>
<h3 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a>string查找和替换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找</span><br><span class="line">int find(const char* s, int pos = 0) const;  //查找s第一次出现位置,从pos开始查找</span><br><span class="line">int find(const char* s, int pos, int n) const;  //从pos位置查找s的前n个字符第一次位置</span><br><span class="line">int find(const char c, int pos = 0) const;  //查找字符c第一次出现位置</span><br><span class="line">int rfind(const string&amp; str, int pos = npos) const;//查找str最后一次位置,从pos开始查找</span><br><span class="line">int rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找</span><br><span class="line">int rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置</span><br><span class="line">int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置</span><br><span class="line">string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str</span><br><span class="line">string&amp; replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串s</span><br></pre></td></tr></table></figure>
<h3 id="string比较操作"><a href="#string比较操作" class="headerlink" title="string比较操作"></a>string比较操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。</span><br><span class="line">比较区分大小写，比较时参考字典顺序，排越前面的越小。</span><br><span class="line">大写的A比小写的a小。</span><br><span class="line">*/</span><br><span class="line">int compare(const string &amp;s) const;//与字符串s比较</span><br><span class="line">int compare(const char *s) const;//与字符串s比较</span><br></pre></td></tr></table></figure>
<h3 id="string子串"><a href="#string子串" class="headerlink" title="string子串"></a>string子串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串</span><br></pre></td></tr></table></figure>
<h3 id="string插入和删除"><a href="#string插入和删除" class="headerlink" title="string插入和删除"></a>string插入和删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string&amp; insert(int pos, const char* s); //插入字符串</span><br><span class="line">string&amp; insert(int pos, const string&amp; str); //插入字符串</span><br><span class="line">string&amp; insert(int pos, int n, char c);//在指定位置插入n个字符c</span><br><span class="line">string&amp; erase(int pos, int n = npos);//删除从Pos开始的n个字符</span><br></pre></td></tr></table></figure>
<h3 id="string和c-type转换"><a href="#string和c-type转换" class="headerlink" title="string和c-type转换"></a>string和c-type转换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//string 转 char*</span><br><span class="line">string str = &quot;itcast&quot;;</span><br><span class="line">const char* cstr = str.c_str();</span><br><span class="line">//char* 转 string </span><br><span class="line">char* s = &quot;itcast&quot;;</span><br><span class="line">string str(s);</span><br></pre></td></tr></table></figure>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>在c++中存在一个从const char*到string的隐式类型转换，却不存在从一个string对象到C_string的自动类型转换。对于string类型的字符串，可以通过c_str()函数返回string对象对应的C_string。</p>
<p>通常，程序员在整个程序中应坚持使用string类对象，直到必须将内容转化为char*时才将其转换为C_string。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>为了修改string字符串的内容，下标操作符[]和at都会返回字符的引用。但当字符串的内存被重新分配之后，可能发生错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string s = &quot;abcdefg&quot;;</span><br><span class="line">char&amp; a = s[2];</span><br><span class="line">char&amp; b = s[3];</span><br><span class="line"></span><br><span class="line">a = &apos;1&apos;;</span><br><span class="line">b = &apos;2&apos;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (int*)s.c_str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s = &quot;pppppppppppppppppppppppp&quot;;</span><br><span class="line"></span><br><span class="line">//a = &apos;1&apos;;</span><br><span class="line">//b = &apos;2&apos;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (int*)s.c_str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">ab12efg</span><br><span class="line">0x6dfed4</span><br><span class="line">pppppppppppppppppppppppp</span><br><span class="line">0x1816b0</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><h3 id="vector与Array数组"><a href="#vector与Array数组" class="headerlink" title="vector与Array数组"></a>vector与Array数组</h3><p>Array是静态空间，一旦配置了就不能改变，要换大一点或者小一点的空间得由自己来，首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。</p>
<p>Vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。因此vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必害怕空间不足而一开始就要求一个大块头的array了。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-vector_1.png" alt></p>
<h3 id="vector迭代器"><a href="#vector迭代器" class="headerlink" title="vector迭代器"></a>vector迭代器</h3><p>Vector维护一个线性空间，所以不论元素的型别如何，普通指针都可以作为vector的迭代器，所以vector提供的是随机访问迭代器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="vector的数据结构"><a href="#vector的数据结构" class="headerlink" title="vector的数据结构"></a><strong>vector的数据结构</strong></h3><p>Vector所采用线性连续空间，它以两个迭代器Myfirst和Mylast分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器_Myend指向整块连续内存空间的尾端。</p>
<p>为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求大一些，以备将来可能的扩充，这便是<strong>容量</strong>的概念。换句话说，<strong>一个vector的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个vector容器就得另觅居所。</strong></p>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>所谓动态增加大小，并不是在原空间之后续接新空间(因为无法保证原空间之后尚有可配置的空间)，而是分配一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了。</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数</span><br><span class="line">vector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。</span><br><span class="line">vector(n, elem);//构造函数将n个elem拷贝给本身。</span><br><span class="line">vector(const vector &amp;vec);//拷贝构造函数。</span><br><span class="line"></span><br><span class="line">//例子 使用第二个构造函数 我们可以...</span><br><span class="line">int arr[] = &#123;2,3,4,1,9&#125;;</span><br><span class="line">vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int));</span><br></pre></td></tr></table></figure>
<h4 id="vector常用赋值操作"><a href="#vector常用赋值操作" class="headerlink" title="vector常用赋值操作"></a>vector常用赋值操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。</span><br><span class="line">assign(n, elem);//将n个elem拷贝赋值给本身。</span><br><span class="line">vector&amp; operator=(const vector  &amp;vec);//重载等号操作符</span><br><span class="line">swap(vec);// 将vec与本身的元素互换。</span><br></pre></td></tr></table></figure>
<h4 id="vector大小操作"><a href="#vector大小操作" class="headerlink" title="vector大小操作"></a>vector大小操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size();//返回容器中元素的个数</span><br><span class="line">empty();//判断容器是否为空</span><br><span class="line">resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。</span><br><span class="line">capacity();//容器的容量</span><br><span class="line">reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。</span><br></pre></td></tr></table></figure>
<h4 id="vector数据存取操作"><a href="#vector数据存取操作" class="headerlink" title="vector数据存取操作"></a>vector数据存取操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</span><br><span class="line">operator[];//返回索引idx所指的数据，越界时，运行直接报错</span><br><span class="line">front();//返回容器中第一个数据元素</span><br><span class="line">back();//返回容器中最后一个数据元素</span><br></pre></td></tr></table></figure>
<h4 id="vector插入和删除操作"><a href="#vector插入和删除操作" class="headerlink" title="vector插入和删除操作"></a>vector插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele.</span><br><span class="line">push_back(ele); //尾部插入元素ele</span><br><span class="line">pop_back();//删除最后一个元素</span><br><span class="line">erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素</span><br><span class="line">erase(const_iterator pos);//删除迭代器指向的元素</span><br><span class="line">clear();//删除容器中所有元素</span><br></pre></td></tr></table></figure>
<h3 id="巧用swap收缩内存空间"><a href="#巧用swap收缩内存空间" class="headerlink" title="巧用swap收缩内存空间"></a>巧用swap收缩内存空间</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	for (int i = 0; i &lt; 100000;i ++)&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	//此时 通过resize改变容器大小</span><br><span class="line">	v.resize(10);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	//容量没有改变</span><br><span class="line">	vector&lt;int&gt;(v).swap(v);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reserve预留空间"><a href="#reserve预留空间" class="headerlink" title="reserve预留空间"></a>reserve预留空间</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line"></span><br><span class="line">	//预先开辟空间</span><br><span class="line">	v.reserve(100000);</span><br><span class="line"></span><br><span class="line">	int* pStart = NULL;</span><br><span class="line">	int count = 0;</span><br><span class="line">	for (int i = 0; i &lt; 100000;i ++)&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">		if (pStart != &amp;v[0])&#123;</span><br><span class="line">			pStart = &amp;v[0];</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;count:&quot; &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h2><h3 id="deque与vector"><a href="#deque与vector" class="headerlink" title="deque与vector"></a>deque与vector</h3><p>Deque容器和vector容器最大的差异，一在于deque允许使用常数项时间对头端进行元素的插入和删除操作。二在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。也因此，deque没有必须要提供所谓的空间保留(reserve)功能.</p>
<p>虽然deque容器也提供了Random Access Iterator,但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用vector，而不是deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque.</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-deque_1.png" alt></p>
<h3 id="deque容器实现原理"><a href="#deque容器实现原理" class="headerlink" title="deque容器实现原理"></a><strong>deque容器实现原理</strong></h3><p>Deque容器是连续的空间，至少逻辑上看来如此，连续现行空间总是令我们联想到array和vector,array无法成长，vector虽可成长，却只能向尾端成长，而且其成长其实是一个假象，事实上(1) 申请更大空间 (2)原数据复制新空间 (3)释放原空间 三步骤，如果不是vector每次配置新的空间时都留有余裕，其成长假象所带来的代价是非常昂贵的。</p>
<p>Deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。Deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p>
<p>既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。Deque代码的实现远比vector或list都多得多。</p>
<p>Deque采取一块所谓的map(注意，不是STL的map容器)作为主控，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是deque的存储空间的主体。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-deque_2.png" alt></p>
<h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><h4 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deque&lt;T&gt; deqT;//默认构造形式</span><br><span class="line">deque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。</span><br><span class="line">deque(n, elem);//构造函数将n个elem拷贝给本身。</span><br><span class="line">deque(const deque &amp;deq);//拷贝构造函数。</span><br></pre></td></tr></table></figure>
<h4 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。</span><br><span class="line">assign(n, elem);//将n个elem拷贝赋值给本身。</span><br><span class="line">deque&amp; operator=(const deque &amp;deq); //重载等号操作符 </span><br><span class="line">swap(deq);// 将deq与本身的元素互换</span><br></pre></td></tr></table></figure>
<h4 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a>deque大小操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deque.size();//返回容器中元素的个数</span><br><span class="line">deque.empty();//判断容器是否为空</span><br><span class="line">deque.resize(num);//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。</span><br></pre></td></tr></table></figure>
<h4 id="deque双端插入和删除操作"><a href="#deque双端插入和删除操作" class="headerlink" title="deque双端插入和删除操作"></a>deque双端插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push_back(elem);//在容器尾部添加一个数据</span><br><span class="line">push_front(elem);//在容器头部插入一个数据</span><br><span class="line">pop_back();//删除容器最后一个数据</span><br><span class="line">pop_front();//删除容器第一个数据</span><br></pre></td></tr></table></figure>
<h4 id="deque数据存取"><a href="#deque数据存取" class="headerlink" title="deque数据存取"></a>deque数据存取</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">at(idx);//返回索引idx所指的数据，如果idx越界，抛出out_of_range。</span><br><span class="line">operator[];//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</span><br><span class="line">front();//返回第一个数据。</span><br><span class="line">back();//返回最后一个数据</span><br></pre></td></tr></table></figure>
<h4 id="deque插入操作"><a href="#deque插入操作" class="headerlink" title="deque插入操作"></a>deque插入操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span><br><span class="line">insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</span><br><span class="line">insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</span><br></pre></td></tr></table></figure>
<h4 id="deque删除操作"><a href="#deque删除操作" class="headerlink" title="deque删除操作"></a>deque删除操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clear();//移除容器的所有数据</span><br><span class="line">erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</span><br><span class="line">erase(pos);//删除pos位置的数据，返回下一个数据的位置。</span><br></pre></td></tr></table></figure>
<h2 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h2><p>stack容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不允许有遍历行为。</p>
<p>有元素推入栈的操作称为:push,将元素推出stack的操作称为pop.<img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-stack_1.png" alt></p>
<h3 id="stack迭代器"><a href="#stack迭代器" class="headerlink" title="stack迭代器"></a>stack迭代器</h3><p>Stack所有元素的进出都必须符合”先进后出”的条件，只有stack顶端的元素，才有机会被外界取用。Stack不提供遍历功能，也不提供迭代器。</p>
<h3 id="stack常用API"><a href="#stack常用API" class="headerlink" title="stack常用API"></a><strong>stack常用API</strong></h3><h4 id="stack构造函数"><a href="#stack构造函数" class="headerlink" title="stack构造函数"></a>stack构造函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stack&lt;T&gt; stkT;//stack采用模板类实现， stack对象的默认构造形式： </span><br><span class="line">stack(const stack &amp;stk);//拷贝构造函数</span><br></pre></td></tr></table></figure>
<h4 id="stack赋值操作"><a href="#stack赋值操作" class="headerlink" title="stack赋值操作"></a>stack赋值操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stack&amp; operator=(const stack &amp;stk);//重载等号操作符</span><br></pre></td></tr></table></figure>
<h4 id="stack数据存取操作"><a href="#stack数据存取操作" class="headerlink" title="stack数据存取操作"></a>stack数据存取操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push(elem);//向栈顶添加元素</span><br><span class="line">pop();//从栈顶移除第一个元素</span><br><span class="line">top();//返回栈顶元素</span><br></pre></td></tr></table></figure>
<h4 id="stack大小操作"><a href="#stack大小操作" class="headerlink" title="stack大小操作"></a>stack大小操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">empty();//判断堆栈是否为空</span><br><span class="line">size();//返回堆栈的大小</span><br></pre></td></tr></table></figure>
<h2 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h2><p>Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口，queue容器允许从一端新增元素，从另一端移除元素。<img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-queue_1.png" alt></p>
<h3 id="queue迭代器"><a href="#queue迭代器" class="headerlink" title="queue迭代器"></a>queue迭代器</h3><p>Queue所有元素的进出都必须符合”先进先出”的条件，只有queue的顶端元素，才有机会被外界取用。Queue不提供遍历功能，也不提供迭代器。</p>
<h3 id="queue常用API"><a href="#queue常用API" class="headerlink" title="queue常用API"></a>queue常用API</h3><h4 id="queue构造函数"><a href="#queue构造函数" class="headerlink" title="queue构造函数"></a>queue构造函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queue&lt;T&gt; queT;//queue采用模板类实现，queue对象的默认构造形式：</span><br><span class="line">queue(const queue &amp;que);//拷贝构造函数</span><br></pre></td></tr></table></figure>
<h4 id="queue存取、插入和删除操作"><a href="#queue存取、插入和删除操作" class="headerlink" title="queue存取、插入和删除操作"></a>queue存取、插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push(elem);//往队尾添加元素</span><br><span class="line">pop();//从队头移除第一个元素</span><br><span class="line">back();//返回最后一个元素</span><br><span class="line">front();//返回第一个元素</span><br></pre></td></tr></table></figure>
<h4 id="queue赋值操作"><a href="#queue赋值操作" class="headerlink" title="queue赋值操作"></a>queue赋值操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queue&amp; operator=(const queue &amp;que);//重载等号操作符</span><br></pre></td></tr></table></figure>
<h4 id="queue大小操作"><a href="#queue大小操作" class="headerlink" title="queue大小操作"></a>queue大小操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">empty();//判断队列是否为空</span><br><span class="line">size();//返回队列的大小</span><br></pre></td></tr></table></figure>
<h2 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h2><p>List容器是一个双向链表。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-list_1.png" alt></p>
<p>相较于vector的连续线性空间，list就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。</p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出。</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素。</li>
<li>链表灵活，但是空间和时间额外耗费较大。</li>
</ul>
<h3 id="list迭代器"><a href="#list迭代器" class="headerlink" title="list迭代器"></a>list迭代器</h3><p>由于list是一个双向链表，迭代器必须能够具备前移、后移的能力，所以list容器提供的是Bidirectional Iterators.</p>
<p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效。这在vector是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效，甚至List元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。</p>
<h3 id="list容器的数据结构"><a href="#list容器的数据结构" class="headerlink" title="list容器的数据结构"></a><strong>list容器的数据结构</strong></h3><p>list容器不仅是一个双向链表，而且还是一个循环的双向链表。</p>
<h3 id="list常用API"><a href="#list常用API" class="headerlink" title="list常用API"></a><strong>list常用API</strong></h3><h4 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list&lt;T&gt; lstT;//list采用采用模板类实现,对象的默认构造形式：</span><br><span class="line">list(beg,end);//构造函数将[beg, end)区间中的元素拷贝给本身。</span><br><span class="line">list(n,elem);//构造函数将n个elem拷贝给本身。</span><br><span class="line">list(const list &amp;lst);//拷贝构造函数。</span><br></pre></td></tr></table></figure>
<h4 id="list数据元素插入和删除操作"><a href="#list数据元素插入和删除操作" class="headerlink" title="list数据元素插入和删除操作"></a>list数据元素插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push_back(elem);//在容器尾部加入一个元素</span><br><span class="line">pop_back();//删除容器中最后一个元素</span><br><span class="line">push_front(elem);//在容器开头插入一个元素</span><br><span class="line">pop_front();//从容器开头移除第一个元素</span><br><span class="line">insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</span><br><span class="line">insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</span><br><span class="line">insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</span><br><span class="line">clear();//移除容器的所有数据</span><br><span class="line">erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</span><br><span class="line">erase(pos);//删除pos位置的数据，返回下一个数据的位置。</span><br><span class="line">remove(elem);//删除容器中所有与elem值匹配的元素。</span><br></pre></td></tr></table></figure>
<h4 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size();//返回容器中元素的个数</span><br><span class="line">empty();//判断容器是否为空</span><br><span class="line">resize(num);//重新指定容器的长度为num，</span><br><span class="line">若容器变长，则以默认值填充新位置。</span><br><span class="line">如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">resize(num, elem);//重新指定容器的长度为num，</span><br><span class="line">若容器变长，则以elem值填充新位置。</span><br><span class="line">如果容器变短，则末尾超出容器长度的元素被删除。</span><br></pre></td></tr></table></figure>
<h4 id="list赋值操作"><a href="#list赋值操作" class="headerlink" title="list赋值操作"></a>list赋值操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。</span><br><span class="line">assign(n, elem);//将n个elem拷贝赋值给本身。</span><br><span class="line">list&amp; operator=(const list &amp;lst);//重载等号操作符</span><br><span class="line">swap(lst);//将lst与本身的元素互换。</span><br></pre></td></tr></table></figure>
<h4 id="list数据的存取"><a href="#list数据的存取" class="headerlink" title="list数据的存取"></a>list数据的存取</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">front();//返回第一个元素。</span><br><span class="line">back();//返回最后一个元素。</span><br></pre></td></tr></table></figure>
<h4 id="list反转排序"><a href="#list反转排序" class="headerlink" title="list反转排序"></a>list反转排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reverse();//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</span><br><span class="line">sort(); //list排序</span><br></pre></td></tr></table></figure>
<h2 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set/multiset容器"></a>set/multiset容器</h2><h3 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h3><p>Set的特性是<strong>所有元素都会根据元素的键值自动被排序</strong>。Set的元素不像map那样可以同时拥有实值和键值，set的元素即是键值又是实值。Set不允许两个元素有相同的键值。</p>
<p>我们可以通过set的迭代器改变set元素的值吗？不行，因为set元素值就是其键值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织。换句话说，set的iterator是一种const_iterator.</p>
<p>set拥有和list某些相同的性质，当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效，被删除的那个元素的迭代器必然是一个例外。</p>
<h3 id="multiset容器"><a href="#multiset容器" class="headerlink" title="multiset容器"></a>multiset容器</h3><p>multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。</p>
<h3 id="set-multiset数据结构"><a href="#set-multiset数据结构" class="headerlink" title="set/multiset数据结构"></a>set/multiset数据结构</h3><p>set和multiset的底层实现是红黑树，红黑树为平衡二叉树的一种。</p>
<h3 id="set常用API"><a href="#set常用API" class="headerlink" title="set常用API"></a>set常用API</h3><h4 id="set构造函数"><a href="#set构造函数" class="headerlink" title="set构造函数"></a>set构造函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set&lt;T&gt; st;//set默认构造函数：</span><br><span class="line">mulitset&lt;T&gt; mst; //multiset默认构造函数: </span><br><span class="line">set(const set &amp;st);//拷贝构造函数</span><br></pre></td></tr></table></figure>
<h4 id="set赋值操作"><a href="#set赋值操作" class="headerlink" title="set赋值操作"></a>set赋值操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set&amp; operator=(const set &amp;st);//重载等号操作符</span><br><span class="line">swap(st);//交换两个集合容器</span><br></pre></td></tr></table></figure>
<h4 id="set大小操作"><a href="#set大小操作" class="headerlink" title="set大小操作"></a>set大小操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size();//返回容器中元素的数目</span><br><span class="line">empty();//判断容器是否为空</span><br></pre></td></tr></table></figure>
<h4 id="set插入和删除操作"><a href="#set插入和删除操作" class="headerlink" title="set插入和删除操作"></a>set插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert(elem);//在容器中插入元素。</span><br><span class="line">clear();//清除所有元素</span><br><span class="line">erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span><br><span class="line">erase(beg, end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span><br><span class="line">erase(elem);//删除容器中值为elem的元素。</span><br></pre></td></tr></table></figure>
<h4 id="set查找操作"><a href="#set查找操作" class="headerlink" title="set查找操作"></a>set查找操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</span><br><span class="line">count(key);//查找键key的元素个数</span><br><span class="line">lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。</span><br><span class="line">upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。</span><br><span class="line">equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。</span><br></pre></td></tr></table></figure>
<p><strong>set的返回值    指定set排序规则:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//插入操作返回值</span><br><span class="line">void test01()&#123;</span><br><span class="line"></span><br><span class="line">	set&lt;int&gt; s;</span><br><span class="line">	pair&lt;set&lt;int&gt;::iterator,bool&gt; ret = s.insert(10);</span><br><span class="line">	if (ret.second)&#123;</span><br><span class="line">		cout &lt;&lt; &quot;插入成功:&quot; &lt;&lt; *ret.first &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		cout &lt;&lt; &quot;插入失败:&quot; &lt;&lt; *ret.first &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ret = s.insert(10);</span><br><span class="line">	if(ret.second)&#123;</span><br><span class="line">		cout &lt;&lt; &quot;插入成功:&quot; &lt;&lt; *ret.first &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		cout &lt;&lt; &quot;插入失败:&quot; &lt;&lt; *ret.first &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct MyCompare02&#123;</span><br><span class="line">	bool operator()(int v1,int v2)&#123;</span><br><span class="line">		return v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//set从大到小</span><br><span class="line">void test02()&#123;</span><br><span class="line"></span><br><span class="line">	srand((unsigned int)time(NULL));</span><br><span class="line">	//我们发现set容器的第二个模板参数可以设置排序规则，默认规则是less&lt;_Kty&gt;</span><br><span class="line">	set&lt;int, MyCompare02&gt; s;</span><br><span class="line">	for (int i = 0; i &lt; 10;i++)&#123;</span><br><span class="line">		s.insert(rand() % 100);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for (set&lt;int, MyCompare02&gt;::iterator it = s.begin(); it != s.end(); it ++)&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//set容器中存放对象</span><br><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	Person(string name,int age)&#123;</span><br><span class="line">		this-&gt;mName = name;</span><br><span class="line">		this-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	string mName;</span><br><span class="line">	int mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct MyCompare03&#123;</span><br><span class="line">	bool operator()(const Person&amp; p1,const Person&amp; p2)&#123;</span><br><span class="line">		return p1.mAge &gt; p2.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test03()&#123;</span><br><span class="line">	set&lt;Person, MyCompare03&gt; s;</span><br><span class="line"></span><br><span class="line">	Person p1(&quot;aaa&quot;, 20);</span><br><span class="line">	Person p2(&quot;bbb&quot;, 30);</span><br><span class="line">	Person p3(&quot;ccc&quot;, 40);</span><br><span class="line">	Person p4(&quot;ddd&quot;, 50);</span><br><span class="line"></span><br><span class="line">	s.insert(p1);</span><br><span class="line">	s.insert(p2);</span><br><span class="line">	s.insert(p3);</span><br><span class="line">	s.insert(p4);</span><br><span class="line"></span><br><span class="line">	for (set&lt;Person, MyCompare03&gt;::iterator it = s.begin(); it != s.end(); it++)&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Name:&quot; &lt;&lt; it-&gt;mName &lt;&lt; &quot; Age:&quot; &lt;&lt; it-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对组-pair"><a href="#对组-pair" class="headerlink" title="对组(pair)"></a>对组(pair)</h3><p>对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问。</p>
<p>类模板：template \<class t1, class t2> struct pair.</class></p>
<p>如何创建对组?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//第一种方法创建一个对组</span><br><span class="line">pair&lt;string, int&gt; pair1(string(&quot;name&quot;), 20);</span><br><span class="line">cout &lt;&lt; pair1.first &lt;&lt; endl; //访问pair第一个值</span><br><span class="line">cout &lt;&lt; pair1.second &lt;&lt; endl;//访问pair第二个值</span><br><span class="line">//第二种</span><br><span class="line">pair&lt;string, int&gt; pair2 = make_pair(&quot;name&quot;, 30);</span><br><span class="line">cout &lt;&lt; pair2.first &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pair2.second &lt;&lt; endl;</span><br><span class="line">//pair=赋值</span><br><span class="line">pair&lt;string, int&gt; pair3 = pair2;</span><br><span class="line">cout &lt;&lt; pair3.first &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pair3.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map/multimap容器"></a>map/multimap容器</h2><h3 id="map-multimap基本概念"><a href="#map-multimap基本概念" class="headerlink" title="map/multimap基本概念"></a>map/multimap基本概念</h3><p>Map的特性是，所有元素都会根据元素的键值自动排序。Map所有的元素都是pair,同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。</p>
<p>我们可以通过map的迭代器改变map的键值吗？答案是不行，因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织。如果想要修改元素的实值，那么是可以的。</p>
<p>Map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。</p>
<p>Multimap和map的操作类似，唯一区别multimap键值可重复。</p>
<p>Map和multimap都是以红黑树为底层实现机制。</p>
<h3 id="map-multimap常用API"><a href="#map-multimap常用API" class="headerlink" title="map/multimap常用API"></a>map/multimap常用API</h3><h4 id="map构造函数"><a href="#map构造函数" class="headerlink" title="map构造函数"></a>map构造函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map&lt;T1, T2&gt; mapTT;//map默认构造函数: </span><br><span class="line">map(const map &amp;mp);//拷贝构造函数</span><br></pre></td></tr></table></figure>
<h4 id="map赋值操作"><a href="#map赋值操作" class="headerlink" title="map赋值操作"></a>map赋值操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map&amp; operator=(const map &amp;mp);//重载等号操作符</span><br><span class="line">swap(mp);//交换两个集合容器</span><br></pre></td></tr></table></figure>
<h4 id="map大小操作"><a href="#map大小操作" class="headerlink" title="map大小操作"></a>map大小操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size();//返回容器中元素的数目</span><br><span class="line">empty();//判断容器是否为空</span><br></pre></td></tr></table></figure>
<h4 id="map插入数据元素操作"><a href="#map插入数据元素操作" class="headerlink" title="map插入数据元素操作"></a>map插入数据元素操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map.insert(...); //往容器插入元素，返回pair&lt;iterator,bool&gt;</span><br><span class="line">map&lt;int, string&gt; mapStu;</span><br><span class="line">// 第一种 通过pair的方式插入对象</span><br><span class="line">mapStu.insert(pair&lt;int, string&gt;(3, &quot;小张&quot;));</span><br><span class="line">// 第二种 通过pair的方式插入对象</span><br><span class="line">mapStu.inset(make_pair(-1, &quot;校长&quot;));</span><br><span class="line">// 第三种 通过value_type的方式插入对象</span><br><span class="line">mapStu.insert(map&lt;int, string&gt;::value_type(1, &quot;小李&quot;));</span><br><span class="line">// 第四种 通过数组的方式插入值</span><br><span class="line">mapStu[3] = &quot;小刘&quot;;</span><br><span class="line">mapStu[5] = &quot;小王&quot;;</span><br></pre></td></tr></table></figure>
<h4 id="map删除操作"><a href="#map删除操作" class="headerlink" title="map删除操作"></a>map删除操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clear();//删除所有元素</span><br><span class="line">erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span><br><span class="line">erase(beg,end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span><br><span class="line">erase(keyElem);//删除容器中key为keyElem的对组。</span><br></pre></td></tr></table></figure>
<h4 id="map查找操作"><a href="#map查找操作" class="headerlink" title="map查找操作"></a>map查找操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();</span><br><span class="line">count(keyElem);//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</span><br><span class="line">lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。</span><br><span class="line">upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。</span><br><span class="line">equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。</span><br></pre></td></tr></table></figure>
<h2 id="STL容器使用时机"><a href="#STL容器使用时机" class="headerlink" title="STL容器使用时机"></a>STL容器使用时机</h2><table>
<thead>
<tr>
<th></th>
<th>vector</th>
<th>deque</th>
<th>list</th>
<th>set</th>
<th>multiset</th>
<th>map</th>
<th>multimap</th>
</tr>
</thead>
<tbody>
<tr>
<td>典型内存结构</td>
<td>单端数组</td>
<td>双端数组</td>
<td>双向链表</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
</tr>
<tr>
<td>可随机存取</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>对key而言：不是</td>
<td>否</td>
</tr>
<tr>
<td>元素搜寻速度</td>
<td>慢</td>
<td>慢</td>
<td>非常慢</td>
<td>快</td>
<td>快</td>
<td>对key而言：快</td>
<td>对key而言：快</td>
</tr>
<tr>
<td>元素安插移除</td>
<td>尾端</td>
<td>头尾两端</td>
<td>任何位置</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<ul>
<li>vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。</li>
<li>deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</li>
<li>vector与deque的比较：<ul>
<li>一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置    却是不固定的。</li>
<li>二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</li>
<li>三：deque支持头部的快速插入与快速移除，这是deque的优点。</li>
</ul>
</li>
<li>list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</li>
<li>set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。 </li>
<li>map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</li>
</ul>
<h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象，也叫仿函数(functor),其实就是重载“()”操作符，使得类对象可以像函数那样调用。</p>
<p>注意:</p>
<p>1.函数对象(仿函数)是一个类，不是一个函数。</p>
<p>2.函数对象(仿函数)重载了”() ”操作符使得它可以像函数一样调用。</p>
<p>分类:假定某个类有一个重载的operator()，而且重载的operator()要求获取一个参数，我们就将这个类称为“一元仿函数”（unary functor）；相反，如果重载的operator()要求获取两个参数，就将这个类称为“二元仿函数”（binary functor）。</p>
<p>函数对象的作用主要是什么？STL提供的算法往往都有两个版本，其中一个版本表现出最常用的某种运算，另一版本则允许用户通过template参数的形式来指定所要采取的策略。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//函数对象是重载了函数调用符号的类</span><br><span class="line">class MyPrint</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	MyPrint()</span><br><span class="line">	&#123;</span><br><span class="line">		m_Num = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int m_Num;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	void operator() (int num)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		m_Num++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//函数对象</span><br><span class="line">//重载了()操作符的类实例化的对象，可以像普通函数那样调用,可以有参数 ，可以有返回值</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	myPrint(20);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 函数对象超出了普通函数的概念，可以保存函数的调用状态</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	myPrint(20);</span><br><span class="line">	myPrint(20);</span><br><span class="line">	myPrint(20);</span><br><span class="line">	cout &lt;&lt; myPrint.m_Num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void doBusiness(MyPrint print,int num)</span><br><span class="line">&#123;</span><br><span class="line">	print(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数对象作为参数</span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">	//参数1：匿名函数对象</span><br><span class="line">	doBusiness(MyPrint(),30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>1、函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题。</p>
<p>2、函数对象超出普通函数的概念，函数对象可以有自己的状态</p>
<p>3、函数对象可内联编译，性能好。用函数指针几乎不可能</p>
<p>4、模版函数对象使函数对象具有通用性，这也是它的优势之一 </p>
<h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><p>谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数)。如果operator接受一个参数，那么叫做一元谓词,如果接受两个参数，那么叫做二元谓词，谓词可作为一个判断式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class GreaterThenFive</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	bool operator()(int num)</span><br><span class="line">	&#123;</span><br><span class="line">		return num &gt; 5;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//一元谓词</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	for (int i = 0; i &lt; 10;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 vector&lt;int&gt;::iterator it =  find_if(v.begin(), v.end(), GreaterThenFive());</span><br><span class="line">	 if (it == v.end())</span><br><span class="line">	 &#123;</span><br><span class="line">		 cout &lt;&lt; &quot;没有找到&quot; &lt;&lt; endl;</span><br><span class="line">	 &#125;</span><br><span class="line">	 else</span><br><span class="line">	 &#123;</span><br><span class="line">		 cout &lt;&lt; &quot;找到了: &quot; &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//二元谓词</span><br><span class="line">class MyCompare</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	bool operator()(int num1, int num2)</span><br><span class="line">	&#123;</span><br><span class="line">		return num1 &gt; num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	v.push_back(10);</span><br><span class="line">	v.push_back(40);</span><br><span class="line">	v.push_back(20);</span><br><span class="line">	v.push_back(90);</span><br><span class="line">	v.push_back(60);</span><br><span class="line"></span><br><span class="line">	//默认从小到大</span><br><span class="line">	sort(v.begin(), v.end());</span><br><span class="line">	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;</span><br><span class="line">	//使用函数对象改变算法策略，排序从大到小</span><br><span class="line">	sort(v.begin(), v.end(),MyCompare());</span><br><span class="line">	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h2><p>STL内建了一些函数对象。分为:算数类函数对象,关系运算类函数对象，逻辑运算类仿函数。这些仿函数所产生的对象，用法和一般函数完全相同，当然我们还可以产生无名的临时对象来履行函数功能。使用内建函数对象，需要引入头文件 #include\<functional>。</functional></p>
<ul>
<li><p>6个算数类函数对象,除了negate是一元运算，其他都是二元运算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt; T plus&lt;T&gt;//加法仿函数</span><br><span class="line">template&lt;class T&gt; T minus&lt;T&gt;//减法仿函数</span><br><span class="line">template&lt;class T&gt; T multiplies&lt;T&gt;//乘法仿函数</span><br><span class="line">template&lt;class T&gt; T divides&lt;T&gt;//除法仿函数</span><br><span class="line">template&lt;class T&gt; T modulus&lt;T&gt;//取模仿函数</span><br><span class="line">template&lt;class T&gt; T negate&lt;T&gt;//取反仿函数</span><br></pre></td></tr></table></figure>
</li>
<li><p>6个关系运算类函数对象,每一种都是二元运算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt; bool equal_to&lt;T&gt;//等于</span><br><span class="line">template&lt;class T&gt; bool not_equal_to&lt;T&gt;//不等于</span><br><span class="line">template&lt;class T&gt; bool greater&lt;T&gt;//大于</span><br><span class="line">template&lt;class T&gt; bool greater_equal&lt;T&gt;//大于等于</span><br><span class="line">template&lt;class T&gt; bool less&lt;T&gt;//小于</span><br><span class="line">template&lt;class T&gt; bool less_equal&lt;T&gt;//小于等于</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑运算类运算函数,not为一元运算，其余为二元运算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt; bool logical_and&lt;T&gt;//逻辑与</span><br><span class="line">template&lt;class T&gt; bool logical_or&lt;T&gt;//逻辑或</span><br><span class="line">template&lt;class T&gt; bool logical_not&lt;T&gt;//逻辑非</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>内建函数对象举例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//取反仿函数</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	negate&lt;int&gt; n;</span><br><span class="line">	cout &lt;&lt; n(50) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//加法仿函数</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	plus&lt;int&gt; p;</span><br><span class="line">	cout &lt;&lt; p(10, 20) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//大于仿函数</span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	srand((unsigned int)time(NULL));</span><br><span class="line">	for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">		v.push_back(rand() % 100);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	sort(v.begin(), v.end(), greater&lt;int&gt;());</span><br><span class="line"></span><br><span class="line">	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数对象适配器"><a href="#函数对象适配器" class="headerlink" title="函数对象适配器"></a>函数对象适配器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//函数适配器bind1st bind2nd</span><br><span class="line">//现在我有这个需求 在遍历容器的时候，我希望将容器中的值全部加上100之后显示出来，怎么做？</span><br><span class="line">//我们直接给函数对象绑定参数 编译阶段就会报错</span><br><span class="line">//for_each(v.begin(), v.end(), bind2nd(myprint(),100));</span><br><span class="line">//如果我们想使用绑定适配器,需要我们自己的函数对象继承binary_function 或者 unary_function</span><br><span class="line">//根据我们函数对象是一元函数对象 还是二元函数对象</span><br><span class="line">class MyPrint :public binary_function&lt;int,int,void&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void operator()(int v1,int v2) const</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;v1 = : &quot; &lt;&lt; v1 &lt;&lt; &quot; v2 = :&quot; &lt;&lt;v2  &lt;&lt; &quot; v1+v2 = :&quot; &lt;&lt; (v1 + v2) &lt;&lt; endl;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//1、函数适配器</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt;v;</span><br><span class="line">	for (int i = 0; i &lt; 10; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;请输入起始值：&quot; &lt;&lt; endl;</span><br><span class="line">	int x;</span><br><span class="line">	cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">	for_each(v.begin(), v.end(), bind1st(MyPrint(), x));</span><br><span class="line">	//for_each(v.begin(), v.end(), bind2nd( MyPrint(),x ));</span><br><span class="line">&#125;</span><br><span class="line">//总结：  bind1st和bind2nd区别?</span><br><span class="line">//bind1st ： 将参数绑定为函数对象的第一个参数</span><br><span class="line">//bind2nd ： 将参数绑定为函数对象的第二个参数</span><br><span class="line">//bind1st bind2nd将二元函数对象转为一元函数对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class GreaterThenFive:public unary_function&lt;int,bool&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	bool operator ()(int v) const</span><br><span class="line">	&#123;</span><br><span class="line">		return v &gt; 5;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//2、取反适配器</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	vector &lt;int&gt; v;</span><br><span class="line">	for (int i = 0; i &lt; 10;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">// 	vector&lt;int&gt;::iterator it =  find_if(v.begin(), v.end(), GreaterThenFive()); //返回第一个大于5的迭代器</span><br><span class="line">//	vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(),  not1(GreaterThenFive())); //返回第一个小于5迭代器</span><br><span class="line">	//自定义输入</span><br><span class="line">	vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), not1 ( bind2nd(greater&lt;int&gt;(),5)));</span><br><span class="line">	if (it == v.end())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;没找到&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;找到&quot; &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//排序  二元函数对象</span><br><span class="line">	sort(v.begin(), v.end(), not2(less&lt;int&gt;()));</span><br><span class="line">	for_each(v.begin(), v.end(), [](int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//not1 对一元函数对象取反</span><br><span class="line">//not2 对二元函数对象取反</span><br><span class="line"></span><br><span class="line">void MyPrint03(int v,int v2)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; v + v2&lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//3、函数指针适配器   ptr_fun</span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">	vector &lt;int&gt; v;</span><br><span class="line">	for (int i = 0; i &lt; 10; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	// ptr_fun( )把一个普通的函数指针适配成函数对象</span><br><span class="line">	for_each(v.begin(), v.end(), bind2nd( ptr_fun( MyPrint03 ), 100));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//4、成员函数适配器</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person(string name, int age)</span><br><span class="line">	&#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">		m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//打印函数</span><br><span class="line">	void ShowPerson()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;成员函数:&quot; &lt;&lt; &quot;Name:&quot; &lt;&lt; m_Name &lt;&lt; &quot; Age:&quot; &lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void Plus100()</span><br><span class="line">	&#123;</span><br><span class="line">		m_Age += 100;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	string m_Name;</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void MyPrint04(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt;  p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test04()</span><br><span class="line">&#123;</span><br><span class="line">	vector &lt;Person&gt;v;</span><br><span class="line">	Person p1(&quot;aaa&quot;, 10);</span><br><span class="line">	Person p2(&quot;bbb&quot;, 20);</span><br><span class="line">	Person p3(&quot;ccc&quot;, 30);</span><br><span class="line">	Person p4(&quot;ddd&quot;, 40);</span><br><span class="line">	v.push_back(p1);</span><br><span class="line">	v.push_back(p2);</span><br><span class="line">	v.push_back(p3);</span><br><span class="line">	v.push_back(p4);</span><br><span class="line"></span><br><span class="line">	//for_each(v.begin(), v.end(), MyPrint04);</span><br><span class="line">	//利用 mem_fun_ref 将Person内部成员函数适配</span><br><span class="line">	for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::ShowPerson));</span><br><span class="line">// 	for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::Plus100));</span><br><span class="line">// 	for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::ShowPerson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test05()&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person*&gt; v1;</span><br><span class="line">	//创建数据</span><br><span class="line">	Person p1(&quot;aaa&quot;, 10);</span><br><span class="line">	Person p2(&quot;bbb&quot;, 20);</span><br><span class="line">	Person p3(&quot;ccc&quot;, 30);</span><br><span class="line">	Person p4(&quot;ddd&quot;, 40);</span><br><span class="line"></span><br><span class="line">	v1.push_back(&amp;p1);</span><br><span class="line">	v1.push_back(&amp;p2);</span><br><span class="line">	v1.push_back(&amp;p3);</span><br><span class="line">	v1.push_back(&amp;p4);</span><br><span class="line"></span><br><span class="line">	for_each(v1.begin(), v1.end(), mem_fun(&amp;Person::ShowPerson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果容器存放的是对象指针，  那么用mem_fun</span><br><span class="line">//如果容器中存放的是对象实体，那么用mem_fun_ref</span><br></pre></td></tr></table></figure>
<h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><p>算法主要是由头文件\<algorithm> \<functional> \<numeric>组成。</numeric></functional></algorithm></p>
<p>\<algorithm>是所有STL头文件中最大的一个,其中常用的功能涉及到比较，交换，查找，遍历，复制，修改，反转，排序，合并等…</algorithm></p>
<p>\<numeric>体积很小，只包括在几个序列容器上进行的简单运算的模板函数.</numeric></p>
<p>\<functional> 定义了一些模板类,用以声明函数对象。</functional></p>
<h2 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    遍历算法 遍历容器元素</span><br><span class="line">	@param beg 开始迭代器</span><br><span class="line">	@param end 结束迭代器</span><br><span class="line">	@param _callback  函数回调或者函数对象</span><br><span class="line">	@return 函数对象</span><br><span class="line">*/</span><br><span class="line">for_each(iterator beg, iterator end, _callback);</span><br><span class="line">/*</span><br><span class="line">	transform算法 将指定容器区间元素搬运到另一容器中</span><br><span class="line">	注意 : transform 不会给目标容器分配内存，所以需要我们提前分配好内存</span><br><span class="line">	@param beg1 源容器开始迭代器</span><br><span class="line">	@param end1 源容器结束迭代器</span><br><span class="line">	@param beg2 目标容器开始迭代器</span><br><span class="line">	@param _cakkback 回调函数或者函数对象</span><br><span class="line">	@return 返回目标容器迭代器</span><br><span class="line">*/</span><br><span class="line">transform(iterator beg1, iterator end1, iterator beg2, _callbakc)</span><br></pre></td></tr></table></figure>
<h3 id="for-each"><a href="#for-each" class="headerlink" title="for_each:"></a>for_each:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"></span><br><span class="line">template&lt;class _InIt,class _Fn1&gt; inline</span><br><span class="line">void for_each(_InIt _First, _InIt _Last, _Fn1 _Func)</span><br><span class="line">&#123;</span><br><span class="line">	for (; _First != _Last; ++_First)</span><br><span class="line">		_Func(*_First);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//普通函数</span><br><span class="line">void print01(int val)&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">//函数对象</span><br><span class="line">struct print001&#123;</span><br><span class="line">	void operator()(int val)&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//for_each算法基本用法</span><br><span class="line">void test01()&#123;</span><br><span class="line">	</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	for (int i = 0; i &lt; 10;i++)&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//遍历算法</span><br><span class="line">	for_each(v.begin(), v.end(), print01);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	for_each(v.begin(), v.end(), print001());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct print02&#123;</span><br><span class="line">	print02()&#123;</span><br><span class="line">		mCount = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	void operator()(int val)&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">		mCount++;</span><br><span class="line">	&#125;</span><br><span class="line">	int mCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//for_each返回值</span><br><span class="line">void test02()&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	print02 p = for_each(v.begin(), v.end(), print02());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p.mCount &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct print03 : public binary_function&lt;int, int, void&gt;&#123;</span><br><span class="line">	void operator()(int val,int bindParam) const&#123;</span><br><span class="line">		cout &lt;&lt; val + bindParam &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//for_each绑定参数输出</span><br><span class="line">void test03()&#123;</span><br><span class="line">	</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for_each(v.begin(), v.end(), bind2nd(print03(),100));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="transform"><a href="#transform" class="headerlink" title="transform:"></a>transform:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//transform 将一个容器中的值搬运到另一个容器中</span><br><span class="line">/*</span><br><span class="line">	template&lt;class _InIt, class _OutIt, class _Fn1&gt; inline </span><br><span class="line">	_OutIt _Transform(_InIt _First, _InIt _Last,_OutIt _Dest, _Fn1 _Func)</span><br><span class="line">	&#123;	</span><br><span class="line"></span><br><span class="line">		for (; _First != _Last; ++_First, ++_Dest)</span><br><span class="line">			*_Dest = _Func(*_First);</span><br><span class="line">		return (_Dest);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template&lt;class _InIt1,class _InIt2,class _OutIt,class _Fn2&gt; inline</span><br><span class="line">	_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1,_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)</span><br><span class="line">	&#123;	</span><br><span class="line">		for (; _First1 != _Last1; ++_First1, ++_First2, ++_Dest)</span><br><span class="line">			*_Dest = _Func(*_First1, *_First2);</span><br><span class="line">		return (_Dest);</span><br><span class="line">	&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">struct transformTest01&#123;</span><br><span class="line">	int operator()(int val)&#123;</span><br><span class="line">		return val + 100;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct print01&#123;</span><br><span class="line">	void operator()(int val)&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;int&gt; vSource;</span><br><span class="line">	for (int i = 0; i &lt; 10;i ++)&#123;</span><br><span class="line">		vSource.push_back(i + 1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//目标容器</span><br><span class="line">	vector&lt;int&gt; vTarget;</span><br><span class="line">	//给vTarget开辟空间</span><br><span class="line">	vTarget.resize(vSource.size());</span><br><span class="line">	//将vSource中的元素搬运到vTarget</span><br><span class="line">	vector&lt;int&gt;::iterator it = transform(vSource.begin(), vSource.end(), vTarget.begin(), transformTest01());</span><br><span class="line">	//打印</span><br><span class="line">	for_each(vTarget.begin(), vTarget.end(), print01()); cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将容器1和容器2中的元素相加放入到第三个容器中</span><br><span class="line">struct transformTest02&#123;</span><br><span class="line">	int operator()(int v1,int v2)&#123;</span><br><span class="line">		return v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;int&gt; vSource1;</span><br><span class="line">	vector&lt;int&gt; vSource2;</span><br><span class="line">	for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">		vSource1.push_back(i + 1);	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//目标容器</span><br><span class="line">	vector&lt;int&gt; vTarget;</span><br><span class="line">	//给vTarget开辟空间</span><br><span class="line">	vTarget.resize(vSource1.size());</span><br><span class="line">	transform(vSource1.begin(), vSource1.end(), vSource2.begin(),vTarget.begin(), transformTest02());</span><br><span class="line">	//打印</span><br><span class="line">	for_each(vTarget.begin(), vTarget.end(), print01()); cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">	find算法 查找元素</span><br><span class="line">	@param beg 容器开始迭代器</span><br><span class="line">	@param end 容器结束迭代器</span><br><span class="line">	@param value 查找的元素</span><br><span class="line">	@return 返回查找元素的位置</span><br><span class="line">*/</span><br><span class="line">find(iterator beg, iterator end, value)</span><br><span class="line">/*</span><br><span class="line">	find_if算法 条件查找</span><br><span class="line">	@param beg 容器开始迭代器</span><br><span class="line">	@param end 容器结束迭代器</span><br><span class="line">	@param  callback 回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">	@return bool 查找返回true 否则false</span><br><span class="line">*/</span><br><span class="line">find_if(iterator beg, iterator end, _callback);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	adjacent_find算法 查找相邻重复元素</span><br><span class="line">	@param beg 容器开始迭代器</span><br><span class="line">	@param end 容器结束迭代器</span><br><span class="line">	@param  _callback 回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">	@return 返回相邻元素的第一个位置的迭代器</span><br><span class="line">*/</span><br><span class="line">adjacent_find(iterator beg, iterator end, _callback);</span><br><span class="line">/*</span><br><span class="line">	binary_search算法 二分查找法</span><br><span class="line">	注意: 在无序序列中不可用</span><br><span class="line">	@param beg 容器开始迭代器</span><br><span class="line">	@param end 容器结束迭代器</span><br><span class="line">	@param value 查找的元素</span><br><span class="line">	@return bool 查找返回true 否则false</span><br><span class="line">*/</span><br><span class="line">bool binary_search(iterator beg, iterator end, value);</span><br><span class="line">/*</span><br><span class="line">	count算法 统计元素出现次数</span><br><span class="line">	@param beg 容器开始迭代器</span><br><span class="line">	@param end 容器结束迭代器</span><br><span class="line">	@param  value回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">	@return int返回元素个数</span><br><span class="line">*/</span><br><span class="line">count(iterator beg, iterator end, value);</span><br><span class="line">/*</span><br><span class="line">	count算法 统计元素出现次数</span><br><span class="line">	@param beg 容器开始迭代器</span><br><span class="line">	@param end 容器结束迭代器</span><br><span class="line">	@param  callback 回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">	@return int返回元素个数</span><br><span class="line">*/</span><br><span class="line">count_if(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure>
<h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">	merge算法 容器元素合并，并存储到另一容器中</span><br><span class="line">	@param beg1 容器1开始迭代器</span><br><span class="line">	@param end1 容器1结束迭代器</span><br><span class="line">	@param beg2 容器2开始迭代器</span><br><span class="line">	@param end2 容器2结束迭代器</span><br><span class="line">	@param dest  目标容器开始迭代器</span><br><span class="line">*/</span><br><span class="line">merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line">/*</span><br><span class="line">	sort算法 容器元素排序</span><br><span class="line">	注意:两个容器必须是有序的</span><br><span class="line">	@param beg 容器1开始迭代器</span><br><span class="line">	@param end 容器1结束迭代器</span><br><span class="line">	@param _callback 回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">*/</span><br><span class="line">sort(iterator beg, iterator end, _callback)</span><br><span class="line">/*</span><br><span class="line">	sort算法 对指定范围内的元素随机调整次序</span><br><span class="line">	@param beg 容器开始迭代器</span><br><span class="line">	@param end 容器结束迭代器</span><br><span class="line">*/</span><br><span class="line">random_shuffle(iterator beg, iterator end)</span><br><span class="line">/*</span><br><span class="line">	reverse算法 反转指定范围的元素</span><br><span class="line">	@param beg 容器开始迭代器</span><br><span class="line">	@param end 容器结束迭代器</span><br><span class="line">*/</span><br><span class="line">reverse(iterator beg, iterator end)</span><br></pre></td></tr></table></figure>
<h2 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">	copy算法 将容器内指定范围的元素拷贝到另一容器中</span><br><span class="line">	@param beg 容器开始迭代器</span><br><span class="line">	@param end 容器结束迭代器</span><br><span class="line">	@param dest 目标起始迭代器</span><br><span class="line">*/</span><br><span class="line">copy(iterator beg, iterator end, iterator dest)</span><br><span class="line">/*</span><br><span class="line">	replace算法 将容器内指定范围的旧元素修改为新元素</span><br><span class="line">	@param beg 容器开始迭代器</span><br><span class="line">	@param end 容器结束迭代器</span><br><span class="line">	@param oldvalue 旧元素</span><br><span class="line">	@param oldvalue 新元素</span><br><span class="line">*/</span><br><span class="line">replace(iterator beg, iterator end, oldvalue, newvalue)</span><br><span class="line">/*</span><br><span class="line">	replace_if算法 将容器内指定范围满足条件的元素替换为新元素</span><br><span class="line">	@param beg 容器开始迭代器</span><br><span class="line">	@param end 容器结束迭代器</span><br><span class="line">	@param callback函数回调或者谓词(返回Bool类型的函数对象)</span><br><span class="line">	@param oldvalue 新元素</span><br><span class="line">*/</span><br><span class="line">replace_if(iterator beg, iterator end, _callback, newvalue)</span><br><span class="line">/*</span><br><span class="line">	swap算法 互换两个容器的元素</span><br><span class="line">	@param c1容器1</span><br><span class="line">	@param c2容器2</span><br><span class="line">*/</span><br><span class="line">swap(container c1, container c2)</span><br></pre></td></tr></table></figure>
<h2 id="常用算数生成算法"><a href="#常用算数生成算法" class="headerlink" title="常用算数生成算法"></a>常用算数生成算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">	accumulate算法 计算容器元素累计总和</span><br><span class="line">	@param beg 容器开始迭代器</span><br><span class="line">	@param end 容器结束迭代器</span><br><span class="line">	@param value累加值</span><br><span class="line">*/</span><br><span class="line">accumulate(iterator beg, iterator end, value)</span><br><span class="line">/*</span><br><span class="line">	fill算法 向容器中添加元素</span><br><span class="line">	@param beg 容器开始迭代器</span><br><span class="line">	@param end 容器结束迭代器</span><br><span class="line">	@param value t填充元素</span><br><span class="line">*/</span><br><span class="line">fill(iterator beg, iterator end, value)</span><br></pre></td></tr></table></figure>
<h2 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">	set_intersection算法 求两个set集合的交集</span><br><span class="line">	注意:两个集合必须是有序序列</span><br><span class="line">	@param beg1 容器1开始迭代器</span><br><span class="line">	@param end1 容器1结束迭代器</span><br><span class="line">	@param beg2 容器2开始迭代器</span><br><span class="line">	@param end2 容器2结束迭代器</span><br><span class="line">	@param dest  目标容器开始迭代器</span><br><span class="line">	@return 目标容器的最后一个元素的迭代器地址</span><br><span class="line">*/</span><br><span class="line">set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line">/*</span><br><span class="line">	set_union算法 求两个set集合的并集</span><br><span class="line">	注意:两个集合必须是有序序列</span><br><span class="line">	@param beg1 容器1开始迭代器</span><br><span class="line">	@param end1 容器1结束迭代器</span><br><span class="line">	@param beg2 容器2开始迭代器</span><br><span class="line">	@param end2 容器2结束迭代器</span><br><span class="line">	@param dest  目标容器开始迭代器</span><br><span class="line">	@return 目标容器的最后一个元素的迭代器地址</span><br><span class="line">*/</span><br><span class="line">set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line">/*</span><br><span class="line">	set_difference算法 求两个set集合的差集</span><br><span class="line">	注意:两个集合必须是有序序列</span><br><span class="line">	@param beg1 容器1开始迭代器</span><br><span class="line">	@param end1 容器1结束迭代器</span><br><span class="line">	@param beg2 容器2开始迭代器</span><br><span class="line">	@param end2 容器2结束迭代器</span><br><span class="line">	@param dest  目标容器开始迭代器</span><br><span class="line">	@return 目标容器的最后一个元素的迭代器地址</span><br><span class="line">*/</span><br><span class="line">set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer题解及源码(C++完整版)</title>
    <url>/2019/04/13/2019-04-13/</url>
    <content><![CDATA[<p>GitHub源码地址：<a href="https://github.com/qian-youyou/jzOffer" target="_blank" rel="noopener">https://github.com/qian-youyou/jzOffer</a></p>
<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数字，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p>
<p>　　例如，我们要在上述的二维数组中查找数字7的步骤如下图所示：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-003.png" alt="img"></p>
<p>　　（矩阵中加阴影背景的区域是下一步查找的范围）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">        int y = array.size();</span><br><span class="line">        int x = array[0].size();</span><br><span class="line">        int j = x - 1;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(j &gt;=0 &amp;&amp; i &lt; y)&#123;</span><br><span class="line">            if(array[i][j] == target)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            while(j &gt;= 0 &amp;&amp; array[i][j] &gt; target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            while(i &lt; y &amp;&amp; array[i][j] &lt; target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>将长度为1的空格替换为长度为3的“%20”，字符差的产度变长。如果允许我们开辟一个新的数组来存放替换空格后的字符串，那么这道题目就非常简 单。设置两个指针分别指向新旧字符串首元素，遍历原字符串，如果碰到空格就在新字符串上填入“%20”，否则就复制元字符串上的内容。但是如果面试官要求在原先的字符串上操作，并且保证原字符串有足够长的空间来存放替换后的字符串，那么我们就得另想方法。如果从前往后替换字符串，那么保存在空格后面的字符串肯定会被覆盖，那么我们就考虑从后往前进行替换。首先遍历原字符串，找出字符串的长度以及其中的空格数量，根据原字符串的长度和空格的数量我们可以求出最后新字符串的长度。设置两个指针point1和point2分别指向原字符串和新字符串的末尾位置。如果point1指向内容不为空格，那么将内容赋值给point2指向的位置，如果point1指向为空格，那么从point2开始赋值“02%”直到point1==point2时表明字符串中的所有空格都已经替换完毕。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	void replaceSpace(char *str,int length) &#123;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for(int i = 0; i &lt; length; i++)&#123;</span><br><span class="line">            if(str[i] == &apos; &apos;)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int j = length + cnt * 2;</span><br><span class="line">        for(int i = length; j&gt;=0 &amp;&amp; i &gt;= 0; i--)&#123;</span><br><span class="line">            if(str[i] != &apos; &apos;)&#123;</span><br><span class="line">                str[j--] = str[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                str[j--] = &apos;0&apos;;</span><br><span class="line">                str[j--] = &apos;2&apos;;</span><br><span class="line">                str[j--] = &apos;%&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>遍历一遍链表，将每个结点value入栈。最后依次从栈中取出元素即可。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*  struct ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        struct ListNode *next;</span><br><span class="line">*        ListNode(int x) :</span><br><span class="line">*              val(x), next(NULL) &#123;</span><br><span class="line">*        &#125;</span><br><span class="line">*  &#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        stack&lt;int&gt;s;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        while(p != NULL)&#123;</span><br><span class="line">            s.push(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!s.empty())&#123;</span><br><span class="line">            v.push_back(s.top());</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p><strong>在二叉树的前序遍历序列中，第一个数字总是树的根结点的值</strong>。但在中序遍历序列中，根结点的值在序列的中间，左子树的结点的值位于根结点的值的左边，而右子树的结点的值位于根结点的值的右边。因此我们需要扫描中序遍历序列，才能找到根结点的值。</p>
<p>　　如下图所示，前序遍历序列的第一个数字1就是根结点的值。扫描中序遍历序列，就能确定根结点的值的位置。根据中序遍历特点，在根结点的值1前面的3个数字都是左子树结点的值，位于1后面的数字都是右子树结点的值。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-004.png" alt="img"></p>
<p>　　同样，在前序遍历的序列中，根结点后面的3个数字就是3个左子树结点的值，再后面的所有数字都是右子树结点的值。这样我们就在前序遍历和中序遍历两个序列中，分别找到了左右子树对应的子序列。</p>
<p>　　既然我们已经分别找到了左、右子树的前序遍历序列和中序遍历序列，我们可以用同样的方法分别去构建左右子树。也就是说，接下来的事情可以用递归的方法去完成。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">        if(pre.size() == 0 || vin.size() == 0)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* T;</span><br><span class="line">        int index = 0;</span><br><span class="line">        buildTree(T, pre, vin, 0, 0, pre.size(), index);</span><br><span class="line">        return T;</span><br><span class="line">    &#125;</span><br><span class="line">    void buildTree(TreeNode* &amp;T, vector&lt;int&gt; pre,vector&lt;int&gt; vin, int cur, int left, int right, int &amp;index)&#123;</span><br><span class="line">        T = new TreeNode(pre[cur]);</span><br><span class="line">        ++index;</span><br><span class="line">        int i;</span><br><span class="line">        for(i = left; i &lt; right; i++)&#123;</span><br><span class="line">            if(vin[i] == pre[cur])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &gt; left &amp;&amp; i &lt; right)&#123;</span><br><span class="line">            buildTree(T-&gt;left, pre, vin, cur + 1, left, i, index);</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &lt; right - 1)&#123;</span><br><span class="line">            buildTree(T-&gt;right, pre, vin, index, i + 1, right, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>用stack1来实现队列的push操作，用stack2来实现队列的pop操作，当stack2为空时，将stack1的数据全部压入stack2，等待队列的pop操作。 </p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        if(stack1.empty())&#123;</span><br><span class="line">            while(!stack2.empty())&#123;</span><br><span class="line">                stack1.push(stack2.top());</span><br><span class="line">                stack2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if(stack2.empty())&#123;</span><br><span class="line">            while(!stack1.empty())&#123;</span><br><span class="line">                stack2.push(stack1.top());</span><br><span class="line">                stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!stack2.empty())&#123;</span><br><span class="line">            int ans =  stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>由于数组非递减，那么旋转后的除了最小元素以外其他元素一定大于等于上一个元素，最小元素小于等于它上一个元素。遍历一遍查找哪个元素比上一元素小即可。若遍历完也没有，就输出第一个元素。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        int len = rotateArray.size();</span><br><span class="line">        if(!len)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (len == 1)&#123;</span><br><span class="line">            return rotateArray[0];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; len; i++)&#123;</span><br><span class="line">            if(rotateArray[i] &lt; rotateArray[i - 1])&#123;</span><br><span class="line">                return rotateArray[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39</p>
<h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>斐波那契数列。F(N) = F(N - 1) + F(N - 2)</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        int a[40];</span><br><span class="line">        a[0] = 0;</span><br><span class="line">        a[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt; 40; i++)&#123;</span><br><span class="line">            a[i] = a[i-1] + a[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return a[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>斐波那契数列。假设青蛙在第N阶，且第N-1阶跳法与第N-2阶跳法已经求出，则第N阶就是N-1阶的跳法加上第N-2阶的跳法。F(N) = F(N - 1) + F(N - 2)。</p>
<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int number) &#123;</span><br><span class="line">        if(number &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt;v(number + 1);</span><br><span class="line">        v[0] = 1;</span><br><span class="line">        v[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt;= number; i++)&#123;</span><br><span class="line">            v[i] = v[i-1] + v[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return v[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>第N阶等于第1阶 + 第2阶 + …… + 第N-1阶。即2^(n-1)。</p>
<h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int quick_pow(int n)&#123;</span><br><span class="line">        int ans = 2, res = 1;</span><br><span class="line">        while(n)&#123;</span><br><span class="line">            if(n &amp; 1)&#123;</span><br><span class="line">                res *= ans;</span><br><span class="line">            &#125;</span><br><span class="line">            ans *= ans;</span><br><span class="line">            n &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        number = quick_pow(number - 1);</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><p>骨牌最最简单的问题。依旧是斐波那契数列。</p>
<h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rectCover(int number) &#123;</span><br><span class="line">        if(number &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt;v(number + 1);</span><br><span class="line">        v[0] = 1;</span><br><span class="line">        v[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt;= number; i++)&#123;</span><br><span class="line">            v[i] = v[i-1] + v[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return v[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<h2 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h2><p>位运算。时间复杂度为有几个1就执行几次。</p>
<h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     int  NumberOf1(int n) &#123;</span><br><span class="line">         int cnt = 0;</span><br><span class="line">         while(n)&#123;</span><br><span class="line">             cnt++;</span><br><span class="line">             n = n &amp; (n - 1);</span><br><span class="line">         &#125;</span><br><span class="line">         return cnt;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<h2 id="解析-11"><a href="#解析-11" class="headerlink" title="解析"></a>解析</h2><p>快速幂。</p>
<h2 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double quick_pow(double base, int n)&#123;</span><br><span class="line">        double ans = 1;</span><br><span class="line">        while(n)&#123;</span><br><span class="line">            if(n&amp;1)&#123;</span><br><span class="line">                ans *= base;</span><br><span class="line">            &#125;</span><br><span class="line">            base*=base;</span><br><span class="line">            n&gt;&gt;=1;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    double Power(double base, int exponent) &#123;</span><br><span class="line">        if(exponent &gt;= 0)&#123;</span><br><span class="line">            return quick_pow(base, exponent);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return pow(base, exponent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<h2 id="解析-12"><a href="#解析-12" class="headerlink" title="解析"></a>解析</h2><p>奇数储存于一个数组，偶数储存于一个数组。最后合并。</p>
<h2 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reOrderArray(vector&lt;int&gt; &amp;array) &#123;</span><br><span class="line">        const int len = array.size();</span><br><span class="line">        int a[len], b[len];</span><br><span class="line">        int aa = 0;</span><br><span class="line">        int bb = 0;</span><br><span class="line">        for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">            if(array[i]%2)&#123;</span><br><span class="line">                a[aa++] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                b[bb++] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; aa; i++)&#123;</span><br><span class="line">            array[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        bb = 0;</span><br><span class="line">        for(int i = aa; i &lt; len; i++)&#123;</span><br><span class="line">            array[i] = b[bb++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p>
<h2 id="解析-13"><a href="#解析-13" class="headerlink" title="解析"></a>解析</h2><p>两个指针，一个指针先走k步，然后两个指针同时走，这样第1个指针走到头，第2给个指针刚好剩k个结点。</p>
<h2 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct ListNode *next;</span><br><span class="line">	ListNode(int x) :</span><br><span class="line">			val(x), next(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">        ListNode* p = pListHead;</span><br><span class="line">        ListNode* q = pListHead;</span><br><span class="line">        unsigned int cnt = 0;</span><br><span class="line">        while(p != NULL)&#123;</span><br><span class="line">            if(cnt &gt;= k)&#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ++cnt;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cnt &lt; k)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        return q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<h2 id="解析-14"><a href="#解析-14" class="headerlink" title="解析"></a>解析</h2><p>将前一个节点与后一个节点断开，然后让前一个节点指向后一个节点，这个过程就需要节点引用（可以理解为指针）来确定记录当前操作节点的前一个节点和后一个节点。 </p>
<h2 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct ListNode *next;</span><br><span class="line">	ListNode(int x) :</span><br><span class="line">			val(x), next(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line">        ListNode* p = NULL;</span><br><span class="line">        ListNode* q = pHead;</span><br><span class="line">        while(q)&#123;</span><br><span class="line">            pHead = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            pHead-&gt;next = p;</span><br><span class="line">            p = pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        return pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<h2 id="解析-15"><a href="#解析-15" class="headerlink" title="解析"></a>解析</h2><p>归并排序基本操作。</p>
<h2 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct ListNode *next;</span><br><span class="line">	ListNode(int x) :</span><br><span class="line">			val(x), next(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool check(ListNode *a, ListNode *b)&#123;</span><br><span class="line">        if(a == NULL || b == NULL)&#123;</span><br><span class="line">            if(a != NULL)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return a-&gt;val &lt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    void fun(ListNode* &amp;p, ListNode* &amp;pHead)&#123;</span><br><span class="line">        ListNode* tmp = pHead;</span><br><span class="line">        pHead = pHead-&gt;next;</span><br><span class="line">        p-&gt;next = tmp;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pHead = NULL;</span><br><span class="line">        ListNode* p = pHead;</span><br><span class="line">        while(pHead1 != NULL || pHead2 != NULL)&#123;</span><br><span class="line">            if(check(pHead1, pHead2))&#123;</span><br><span class="line">                if(!pHead)&#123;</span><br><span class="line">                    pHead = pHead1;</span><br><span class="line">                    p = pHead;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    fun(p, pHead1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(!pHead)&#123;</span><br><span class="line">                    pHead = pHead2;</span><br><span class="line">                    p = pHead;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    fun(p, pHead2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<h2 id="解析-16"><a href="#解析-16" class="headerlink" title="解析"></a>解析</h2><p>递归设计思路：</p>
<p>A、判断子树根值是否相等。</p>
<p>A1、如果是相等，需要一个可以判断该根左右孩子结点是否相等的递归函数。</p>
<p>A2、如果不等，找大树的左右孩子结点当根结点，递归到A步骤。</p>
<h2 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct TreeNode *left;</span><br><span class="line">	struct TreeNode *right;</span><br><span class="line">	TreeNode(int x) :</span><br><span class="line">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool dfs(TreeNode* pRoot1, TreeNode* pRoot2)&#123;</span><br><span class="line">        if(pRoot1 == NULL || pRoot2 == NULL)&#123;</span><br><span class="line">            if(pRoot2 == NULL)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pRoot1-&gt;val == pRoot2-&gt;val)&#123;</span><br><span class="line">            if(dfs(pRoot1-&gt;left, pRoot2-&gt;left))&#123;</span><br><span class="line">                if(dfs(pRoot1-&gt;right, pRoot2-&gt;right))&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pRoot1 == NULL || pRoot2 == NULL)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pRoot1-&gt;val == pRoot2-&gt;val)&#123;</span><br><span class="line">            if(dfs(pRoot1, pRoot2))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bool flag = HasSubtree(pRoot1-&gt;left, pRoot2)||HasSubtree(pRoot1-&gt;right, pRoot2);</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">    	    8</span><br><span class="line">    	   /  \</span><br><span class="line">    	  6   10</span><br><span class="line">    	 / \  / \</span><br><span class="line">    	5  7 9 11</span><br><span class="line">    	镜像二叉树</span><br><span class="line">    	    8</span><br><span class="line">    	   /  \</span><br><span class="line">    	  10   6</span><br><span class="line">    	 / \  / \</span><br><span class="line">    	11 9 7  5</span><br></pre></td></tr></table></figure>
<h2 id="解析-17"><a href="#解析-17" class="headerlink" title="解析"></a>解析</h2><p>递归：</p>
<p>A：遍历左子树。</p>
<p>B：遍历右子树。</p>
<p>C：左子树和右子树交换。</p>
<h2 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct TreeNode *left;</span><br><span class="line">	struct TreeNode *right;</span><br><span class="line">	TreeNode(int x) :</span><br><span class="line">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void Mirror(TreeNode *pRoot) &#123;</span><br><span class="line">        if(pRoot == NULL)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pRoot-&gt;left != NULL)&#123;</span><br><span class="line">            Mirror(pRoot-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        if(pRoot-&gt;right != NULL)&#123;</span><br><span class="line">            Mirror(pRoot-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *tmp = pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<h2 id="解析-18"><a href="#解析-18" class="headerlink" title="解析"></a>解析</h2><p>用vis数组储存访问状态。每次直线走n-1个，如果vis已访问就改变方向。</p>
<h2 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt;ans;</span><br><span class="line">        const int len1 = matrix.size();</span><br><span class="line">        if(!len1)&#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        const int len2 = matrix[0].size();</span><br><span class="line">        vector&lt;bool&gt;vis(len1*len2, false);</span><br><span class="line">        int a[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">        bool flag = true;</span><br><span class="line">        int x = 0, y = 0;</span><br><span class="line">        ans.push_back(matrix[x][y]);</span><br><span class="line">        vis[0] = true;</span><br><span class="line">        while(flag)&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">            for(int i = 0; i &lt; 4; ++i)&#123;</span><br><span class="line">                while(x + a[i][0] &gt;= 0 &amp;&amp; x + a[i][0] &lt; len1 &amp;&amp; y + a[i][1] &gt;= 0 &amp;&amp; y + a[i][1] &lt; len2 &amp;&amp; !vis[(x + a[i][0]) * len2 + y + a[i][1]])&#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    x += a[i][0];</span><br><span class="line">                    y += a[i][1];</span><br><span class="line">                    ans.push_back(matrix[x][y]);</span><br><span class="line">                    vis[x*len2 + y] = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h1><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<h2 id="解析-19"><a href="#解析-19" class="headerlink" title="解析"></a>解析</h2><p>两个栈，一个储存最小值，一个储存源数据。弹出的话两个一起弹出。</p>
<h2 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int value) &#123;</span><br><span class="line">        StackInt.push(value);</span><br><span class="line">        if(StackMin.empty())</span><br><span class="line">            StackMin.push(value);</span><br><span class="line">        else if(StackMin.top()&lt;value)</span><br><span class="line">            StackMin.push(StackMin.top());</span><br><span class="line">        else</span><br><span class="line">            StackMin.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    void pop() &#123;</span><br><span class="line">        if(!StackInt.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            StackInt.pop();</span><br><span class="line">            StackMin.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int top() &#123;</span><br><span class="line">        return StackInt.top();</span><br><span class="line">    &#125;</span><br><span class="line">    int min() &#123;</span><br><span class="line">        return StackMin.top();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; StackInt;</span><br><span class="line">    stack&lt;int&gt; StackMin;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h1><h2 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<h2 id="解析-20"><a href="#解析-20" class="headerlink" title="解析"></a>解析</h2><p>栈模拟一遍即可。</p>
<h2 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        int len = pushV.size(), i = 0, j = 0;</span><br><span class="line">        while(i &lt; len &amp;&amp; j &lt; len)&#123;</span><br><span class="line">            while(s.empty() || i &lt; len &amp;&amp; s.top() != popV[j])&#123;</span><br><span class="line">                s.push(pushV[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            while(j &lt; len &amp;&amp; !s.empty() &amp;&amp; s.top() == popV[j])&#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j &lt; len)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h1><h2 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<h2 id="解析-21"><a href="#解析-21" class="headerlink" title="解析"></a>解析</h2><p>广度优先遍历。queue储存数据。</p>
<h2 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct TreeNode *left;</span><br><span class="line">	struct TreeNode *right;</span><br><span class="line">	TreeNode(int x) :</span><br><span class="line">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        if(root == NULL)&#123;</span><br><span class="line">            return v;</span><br><span class="line">        &#125;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            TreeNode* tmp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            v.push_back(tmp-&gt;val);</span><br><span class="line">            if(tmp-&gt;left != NULL)&#123;</span><br><span class="line">                q.push(tmp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            if(tmp-&gt;right != NULL)&#123;</span><br><span class="line">                q.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h1><h2 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<h2 id="解析-22"><a href="#解析-22" class="headerlink" title="解析"></a>解析</h2><p>对于一个二叉树的后序遍历序列来说，最后一个数一定是根节点，然后前面的数中，从最开始到第一个大于根节点的数都是左子树中的数，而后面到倒数第二个数应该都是大于根节点的，是右子树，如果后面的数中有小于根节点的，那么说明这个序列不是二叉搜索树的后序遍历序列。</p>
<h2 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool check(vector&lt;int&gt; &amp;sequence, int left, int right)&#123;</span><br><span class="line">        bool flag = false;</span><br><span class="line">        if(left &gt;= right)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int mindle = left;</span><br><span class="line">        int cur = sequence[right];</span><br><span class="line">        for(int i = left; i &lt; right; ++i)&#123;</span><br><span class="line">            if(!flag &amp;&amp; sequence[i] &gt; cur)&#123;</span><br><span class="line">                flag = true;</span><br><span class="line">                mindle = i;</span><br><span class="line">            &#125;else if(flag &amp;&amp; sequence[i] &lt; cur)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = check(sequence, left, mindle - 1) &amp;&amp; check(sequence, mindle, right - 1);</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">    bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123;</span><br><span class="line">        const int len = sequence.size();</span><br><span class="line">        if(!len)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return check(sequence, 0, len - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><h2 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
<h2 id="解析-23"><a href="#解析-23" class="headerlink" title="解析"></a>解析</h2><p>首先思考节点值的和为输入的整数，<strong>每条路径都一定是从根节点到叶子节点</strong>，在数据结构中从根节点到叶子节点的遍历称之为深度优先遍历DFS。因此整个过程可以采用先序遍历方式的DFS，即<strong>根节点》左子树》右子树</strong>。随后考虑一次遍历完成后的处理，当一次遍历完成后，如果输入整数值恰好等于节点值之和，则输出这条路径并且回退一个节点；如果不等于则直接回退一个节点，即回退到当前节点的父节点，如果该父节点有右孩子，则继续遍历，否则继续回退。考虑回退到根节点，此时如果它有右孩子，则继续遍历，否则整个DFS结束。 </p>
<h2 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct TreeNode *left;</span><br><span class="line">	struct TreeNode *right;</span><br><span class="line">	TreeNode(int x) :</span><br><span class="line">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; buffer;</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123;</span><br><span class="line">        if(root==NULL)&#123;</span><br><span class="line">            return buffer;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        if((expectNumber-root-&gt;val)==0 &amp;&amp; root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)&#123;</span><br><span class="line">            buffer.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        FindPath(root-&gt;left,expectNumber-root-&gt;val);</span><br><span class="line">        FindPath(root-&gt;right,expectNumber-root-&gt;val);</span><br><span class="line">        if(tmp.size()!=0)&#123;</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        return buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h1><h2 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<h2 id="解析-24"><a href="#解析-24" class="headerlink" title="解析"></a>解析</h2><p>第一步仍然是根据原始链表的每个结点N创建对应的N’。（把N’链接在N的后面）</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-005.png" alt="img"></p>
<p>第二步设置复制出来的结点的Sibling。（把N’的Sibling指向N的Sibling）</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-006.png" alt="img"></p>
<p>第三步把这个长链表拆分成两个链表：把奇数位置的结点用Next链接起来就是原始链表，偶数数值的则是复制链表。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-007.png" alt="img"></p>
<h2 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct RandomListNode &#123;</span><br><span class="line">    int label;</span><br><span class="line">    struct RandomListNode *next, *random;</span><br><span class="line">    RandomListNode(int x) :</span><br><span class="line">            label(x), next(NULL), random(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    RandomListNode* Clone(RandomListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        RandomListNode *pHead2 = pHead, *p2, *tmp = pHead;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            p2 = new RandomListNode(tmp-&gt;label);</span><br><span class="line">            p2-&gt;next = tmp-&gt;next;</span><br><span class="line">            tmp-&gt;next = p2;</span><br><span class="line">            tmp = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pHead)&#123;</span><br><span class="line">            pHead2 = pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = pHead;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            if(tmp-&gt;random)&#123;</span><br><span class="line">                tmp-&gt;next-&gt;random = tmp-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = pHead;</span><br><span class="line">        p2 = pHead2;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            tmp-&gt;next = tmp-&gt;next-&gt;next;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">            if(p2-&gt;next)&#123;</span><br><span class="line">                p2-&gt;next = p2-&gt;next-&gt;next;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return pHead2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h1><h2 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h2 id="解析-25"><a href="#解析-25" class="headerlink" title="解析"></a>解析</h2><p>步骤1：递归左子树，使左子树为有序双向链表。</p>
<p>步骤2：递归右子树，使右子树为有序双向链表。</p>
<p>步骤3：左子树尾节点和根节点连接，右子树头节点和根节点连接。返回左子树头节点或根节点。</p>
<h2 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct TreeNode *left;</span><br><span class="line">	struct TreeNode *right;</span><br><span class="line">	TreeNode(int x) :</span><br><span class="line">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* Convert(TreeNode* pRootOfTree)&#123;</span><br><span class="line">        if(pRootOfTree)&#123;</span><br><span class="line">            TreeNode* left = Convert(pRootOfTree-&gt;left);</span><br><span class="line">            TreeNode* right = Convert(pRootOfTree-&gt;right);</span><br><span class="line">            TreeNode* tail = left;</span><br><span class="line">            if(right)&#123;</span><br><span class="line">                right-&gt;left = pRootOfTree;</span><br><span class="line">                pRootOfTree-&gt;right = right;</span><br><span class="line">            &#125;</span><br><span class="line">            if(left)&#123;</span><br><span class="line">                while(tail-&gt;right)&#123;</span><br><span class="line">                    tail = tail-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                tail-&gt;right = pRootOfTree;</span><br><span class="line">                pRootOfTree-&gt;left = tail;</span><br><span class="line">                return left;</span><br><span class="line">            &#125;</span><br><span class="line">            return pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><h2 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</span><br></pre></td></tr></table></figure>
<h2 id="解析-26"><a href="#解析-26" class="headerlink" title="解析"></a>解析</h2><p>把一个字符串看成两部分组成：第一部分为第一个字符，第二部分为后面的所有字符。</p>
<p>求整个字符串的排列，可以看出两步：首先求所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字符交换；然后固定第一个字符，求后面所有字符的排序。此时仍把后面的字符看成两部分，第一个字符和后面的字符，然后重复上述步骤。（递归）</p>
<p>在后面的在线测试中，要求输入字符串可能有重复的字符，输出按照字典顺序，排序即可。</p>
<h2 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt;v;</span><br><span class="line">    void dfs(string str, int cur)&#123;</span><br><span class="line">        if(cur &lt; str.size() - 1)&#123;</span><br><span class="line">            for(int i = cur; i &lt; str.size(); ++i)&#123;</span><br><span class="line">                if(i == cur || str[i] != str[cur])&#123;</span><br><span class="line">                    swap(str[cur], str[i]);</span><br><span class="line">                    dfs(str, cur + 1);</span><br><span class="line">                    swap(str[cur], str[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            v.push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; Permutation(string str) &#123;</span><br><span class="line">        dfs(str, 0);</span><br><span class="line">        sort(v.begin(), v.end());</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h1><h2 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h2 id="解析-27"><a href="#解析-27" class="headerlink" title="解析"></a>解析</h2><ul>
<li>当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；</li>
<li>如果下一个数字和我们之前保存的数字不同，则次数减1。</li>
<li>如果次数为零，我们需要保存下一个数字，并把次数设为1。</li>
<li>最后遍历一遍，统计该数出现的次数。</li>
</ul>
<h2 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        const int len = numbers.size();</span><br><span class="line">        if(!len)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = numbers[0], cnt = 1;</span><br><span class="line">        for(int i = 1; i &lt; len; ++i)&#123;</span><br><span class="line">            if(numbers[i] == ans)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(!cnt)&#123;</span><br><span class="line">                    ans = numbers[i];</span><br><span class="line">                    cnt = 1;</span><br><span class="line">                &#125;</span><br><span class="line">                --cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = 0;</span><br><span class="line">        for(int i = 0; i &lt; len; ++i)&#123;</span><br><span class="line">            if(numbers[i] == ans)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cnt &lt;= len / 2)&#123;</span><br><span class="line">            ans = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h1><h2 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<h2 id="解析-28"><a href="#解析-28" class="headerlink" title="解析"></a>解析</h2><p>建一个容量k的大根堆。</p>
<h2 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        priority_queue&lt;int&gt;que;</span><br><span class="line">        int len = input.size();</span><br><span class="line">        if(len &lt; k)&#123;</span><br><span class="line">            return v;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; len; ++i)&#123;</span><br><span class="line">            que.push(input[i]);</span><br><span class="line">            while(que.size() &gt; k)&#123;</span><br><span class="line">                que.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!que.empty())&#123;</span><br><span class="line">            v.push_back(que.top());</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h1><h2 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h2><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>
<h2 id="解析-29"><a href="#解析-29" class="headerlink" title="解析"></a>解析</h2><p>直接遍历，如果上一个数加上这个数变小了就不加，否则加上。</p>
<h2 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">        int len = array.size();</span><br><span class="line">        int ans = array[0];</span><br><span class="line">        for(int i = 1; i &lt; len; ++i)&#123;</span><br><span class="line">            array[i] = max(array[i], array[i] + array[i - 1]);</span><br><span class="line">            ans = max(ans, array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="整数中1出现的次数（从1到n整数中1出现的次数）"></a>整数中1出现的次数（从1到n整数中1出现的次数）</h1><h2 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h2><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>
<h2 id="解析-30"><a href="#解析-30" class="headerlink" title="解析"></a>解析</h2><p>总结一下以上的算法，可以看到，当计算右数第 i 位包含的 x 的个数时：</p>
<ul>
<li>取第 i位左边(高位)的数字，乘以 10i-1，得到基础值 a</li>
<li>取第 i 位数字，计算修正值</li>
<li>如果大于 x , 则结果为 a + 10i-1</li>
<li>如果小于 x，则结果为 a</li>
<li>如果等于 x，则取第 i 位右边(低位)数字，设为 b，最后结果为 a + b + 1</li>
</ul>
<h2 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int NumberOf1Between1AndN_Solution(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        int cnt = n, ans = 0, res = 1;</span><br><span class="line">        while(cnt)&#123;</span><br><span class="line">            if(cnt % 10)&#123;</span><br><span class="line">                if(cnt % 10 &gt; 1)&#123;</span><br><span class="line">                    ans += res;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    ans += n % res + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            cnt /= 10;</span><br><span class="line">            ans += cnt * res;</span><br><span class="line">            res *= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h1><h2 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h2 id="解析-31"><a href="#解析-31" class="headerlink" title="解析"></a>解析</h2><p>sort排序即可，cmp由我们写，可以转成字符串，然后利用字符串进行比较。</p>
<h2 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(int a, int b)&#123;</span><br><span class="line">        string str1 = to_string(a);</span><br><span class="line">        string str2 = to_string(b);</span><br><span class="line">        return str1 + str2 &lt; str2 + str1;</span><br><span class="line">    &#125;</span><br><span class="line">    string PrintMinNumber(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        int tmp;</span><br><span class="line">        string str;</span><br><span class="line">        int len = numbers.size();</span><br><span class="line">        sort(numbers.begin(), numbers.end(), cmp);</span><br><span class="line">        for(int i = 0; i &lt; len; ++i)&#123;</span><br><span class="line">            while(numbers[i] == 0)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            str += to_string(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><h2 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h2><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h2 id="解析-32"><a href="#解析-32" class="headerlink" title="解析"></a>解析</h2><p>优先队列+集合+选择性插入</p>
<h2 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;que;</span><br><span class="line">        que.push(1);</span><br><span class="line">        int i = 0;</span><br><span class="line">        int MAXN = 0;</span><br><span class="line">        set&lt;int&gt;s;</span><br><span class="line">        while(!que.empty())&#123;</span><br><span class="line">            int ans = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            if(s.count(ans)||ans &lt; 0)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            s.insert(ans);</span><br><span class="line">            ++i;</span><br><span class="line">            s.insert(ans);</span><br><span class="line">            if(i == index)&#123;</span><br><span class="line">                return ans;</span><br><span class="line">            &#125;</span><br><span class="line">            if(que.size() &lt; index)&#123;</span><br><span class="line">                que.push(ans*2);</span><br><span class="line">                que.push(ans*3);</span><br><span class="line">                que.push(ans*5);</span><br><span class="line">                MAXN = max(MAXN, ans * 5);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(ans*2&lt;MAXN)&#123;</span><br><span class="line">                    que.push(ans*2);</span><br><span class="line">                &#125;</span><br><span class="line">                if(ans*3&lt;MAXN)&#123;</span><br><span class="line">                    que.push(ans*3);</span><br><span class="line">                &#125;</span><br><span class="line">                if(ans*5&lt;MAXN)&#123;</span><br><span class="line">                    que.push(ans*5);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h1><h2 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p>
<h2 id="解析-33"><a href="#解析-33" class="headerlink" title="解析"></a>解析</h2><p>哈希表，可用map统计。</p>
<h2 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FirstNotRepeatingChar(string str) &#123;</span><br><span class="line">        map&lt;char, int&gt;m;</span><br><span class="line">        for(int i = 0; i &lt; str.length(); i++)&#123;</span><br><span class="line">            m[str[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; str.length(); i++)&#123;</span><br><span class="line">            if(m[str[i]] == 1)&#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h1><h2 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题目保证输入的数组中没有的相同的数字数据范围：	对于%50的数据,size&lt;=10^4	对于%75的数据,size&lt;=10^5	对于%100的数据,size&lt;=2*10^5</span><br></pre></td></tr></table></figure>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,2,3,4,5,6,7,0</span><br></pre></td></tr></table></figure>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<h2 id="解析-34"><a href="#解析-34" class="headerlink" title="解析"></a>解析</h2><p>归并排序。先把数组分割成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。如果对排序算法很熟悉，我们不难发现这个过程实际上就是归并排序。 </p>
<h2 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    const long long mod = 1e9 + 7;</span><br><span class="line">    int my_merge(vector&lt;int&gt; &amp;data, int left, int mindle, int right)&#123;</span><br><span class="line">        vector&lt;int&gt;A(mindle - left + 1);</span><br><span class="line">        vector&lt;int&gt;B(right - mindle);</span><br><span class="line">        long long ans = 0;</span><br><span class="line">        for(int i = left; i &lt;= mindle; ++i)&#123;</span><br><span class="line">            A[i - left] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = mindle + 1; i &lt;= right; ++i)&#123;</span><br><span class="line">            B[i - mindle - 1] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int x = 0, y = 0;</span><br><span class="line">        for(int i = left; i &lt;= right; ++i)&#123;</span><br><span class="line">            if(x &gt;= A.size())&#123;</span><br><span class="line">                data[i] = B[y++];</span><br><span class="line">            &#125;else if(y &gt;= B.size())&#123;</span><br><span class="line">                data[i] = A[x++];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(A[x] &gt; B[y])&#123;</span><br><span class="line">                    data[i] = B[y++];</span><br><span class="line">                    ans += A.size() - x;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    data[i] = A[x++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans %= mod;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int mergeSort(vector&lt;int&gt;&amp;data, int left, int right)&#123;</span><br><span class="line">        long long ans = 0;</span><br><span class="line">        if(left &lt; right)&#123;</span><br><span class="line">            int mindle = (left + right) / 2;</span><br><span class="line">            ans += mergeSort(data, left, mindle);</span><br><span class="line">            ans += mergeSort(data, mindle + 1, right);</span><br><span class="line">            ans += my_merge(data, left, mindle, right);</span><br><span class="line">        &#125;</span><br><span class="line">        ans %= mod;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int InversePairs(vector&lt;int&gt; data) &#123;</span><br><span class="line">        int ans = mergeSort(data, 0, data.size() - 1);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h1><h2 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个链表，找出它们的第一个公共结点。</p>
<h2 id="解析-35"><a href="#解析-35" class="headerlink" title="解析"></a>解析</h2><p>如果两链表有交点，则必然是“Y”型或“V”型。</p>
<p>如何判断两个单向链表有没有公共结点？如果两个链表有一个公共结点，那么 该公共结点之后的所有结点都是重合的。那么，它们的最后一个结点必然是重合的。因此，我们判断两个链表是不是有重合的部分，只要分别遍历两个链表到最后一 个结点。如果两个尾结点是一样的，说明它们用重合；否则两个链表没有公共的结点。</p>
<p>在上面的思路中，顺序遍历两个链表到尾结点的时候，我们不能保证在两个链表上同时到达尾结点。这是因为两个链表不一定长度一样。但如果假设一个链表比另一个长l个结点，我们先在长的链表上遍历l个结点，之后再同步遍历，这个时候我们就能保证同时到达最后一个结点了。由于两个链表从第一个公共结点考试到链表的尾结点，这一部分是重合的。因此，它们肯定也是同时到达第一公共结点的。于是在遍历中，第一个相同的结点就是第一个公共的结点。</p>
<p>在这个思路中，我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历若干次之后，再同步遍历两个链表，知道找到相同的结点，或者一直到链表结束。此时，如果第一个链表的长度为m，第二个链表的长度为n，该方法的时间复杂度为O(m+n)。</p>
<h2 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct ListNode *next;</span><br><span class="line">	ListNode(int x) :</span><br><span class="line">			val(x), next(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* fun(ListNode* &amp;pHead, ListNode* p)&#123;</span><br><span class="line">        ListNode* q = pHead;</span><br><span class="line">        while(p != NULL)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return q;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123;</span><br><span class="line">        ListNode* p1 = pHead1;</span><br><span class="line">        ListNode* p2 = pHead2;</span><br><span class="line">        while(p1 != NULL &amp;&amp; p2 != NULL)&#123;</span><br><span class="line">            if(p1 == p2)&#123;</span><br><span class="line">                return p1;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p1 == NULL &amp;&amp; p2 == NULL)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(p1 != NULL)&#123;</span><br><span class="line">                p1 = fun(pHead1, p1);</span><br><span class="line">                p2 = pHead2;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                p2 = fun(pHead2, p2);</span><br><span class="line">                p1 = pHead1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return FindFirstCommonNode(p1, p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h1><h2 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计一个数字在排序数组中出现的次数。</p>
<h2 id="解析-36"><a href="#解析-36" class="headerlink" title="解析"></a>解析</h2><p>我的方法直接遍历。更高效的方法是二分查找两遍，先找到该数字的左边界，再找到该数字的右边界，然后下标相减。</p>
<h2 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for(int i = 0; i &lt; data.size(); ++i)&#123;</span><br><span class="line">            if(data[i] == k)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><h2 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h2 id="解析-37"><a href="#解析-37" class="headerlink" title="解析"></a>解析</h2><p>遍历一遍即可。</p>
<h2 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct TreeNode *left;</span><br><span class="line">	struct TreeNode *right;</span><br><span class="line">	TreeNode(int x) :</span><br><span class="line">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int TreeDepth(TreeNode* pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        if(pRoot != NULL)&#123;</span><br><span class="line">            cnt += max(TreeDepth(pRoot-&gt;left), TreeDepth(pRoot-&gt;right)) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><h2 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<h2 id="解析-38"><a href="#解析-38" class="headerlink" title="解析"></a>解析</h2><p>递归判断左子树深度和右子树深度差是否不大于1。</p>
<h2 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsBalanced_Solution(TreeNode* pRoot) &#123;</span><br><span class="line">        if(pRoot == NULL)</span><br><span class="line">            return true;</span><br><span class="line">        int leftDepth = getDepth(pRoot -&gt; left);</span><br><span class="line">        int rightDepth = getDepth(pRoot -&gt; right);</span><br><span class="line">        if(leftDepth &gt; rightDepth + 1 || leftDepth + 1 &lt; rightDepth)</span><br><span class="line">            return false;</span><br><span class="line">        else</span><br><span class="line">            return IsBalanced_Solution(pRoot -&gt; left) &amp;&amp; IsBalanced_Solution(pRoot -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    int getDepth(TreeNode* pRoot)&#123;</span><br><span class="line">        if(pRoot == NULL)</span><br><span class="line">            return 0;</span><br><span class="line">        int leftDepth = getDepth(pRoot -&gt; left);</span><br><span class="line">        int rightDepth = getDepth(pRoot -&gt; right);</span><br><span class="line">        return leftDepth &gt; rightDepth ? leftDepth + 1 : rightDepth + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h1><h2 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h2 id="解析-39"><a href="#解析-39" class="headerlink" title="解析"></a>解析</h2><p>我用的map。可以用位运算。</p>
<h2 id="代码-39"><a href="#代码-39" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123;</span><br><span class="line">        int len = data.size();</span><br><span class="line">        bool flag = false;</span><br><span class="line">        map&lt;int, int&gt;m;</span><br><span class="line">        for(int i = 0; i &lt; len; ++i)&#123;</span><br><span class="line">            m[data[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; len; ++i)&#123;</span><br><span class="line">            if(m[data[i]] == 1)&#123;</span><br><span class="line">                if(flag)&#123;</span><br><span class="line">                    *num2 = data[i];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    *num1 = data[i];</span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="和为S的连续正数序列"><a href="#和为S的连续正数序列" class="headerlink" title="和为S的连续正数序列"></a>和为S的连续正数序列</h1><h2 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h2><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</span><br></pre></td></tr></table></figure>
<h2 id="解析-40"><a href="#解析-40" class="headerlink" title="解析"></a>解析</h2><p>在序列首部各定义指针left, right，如果和超过s，left往右移，如果和小于s，right往右移。 </p>
<h2 id="代码-40"><a href="#代码-40" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">        vector&lt;int&gt; v;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt;ans;</span><br><span class="line">        for(int i = 1; i &lt;= sum; ++i)&#123;</span><br><span class="line">            v.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        int left = 1, right = 1;</span><br><span class="line">        int cnt = 1;</span><br><span class="line">        while(right &lt; sum &amp;&amp; left &lt; sum)&#123;</span><br><span class="line">            if(cnt == sum)&#123;</span><br><span class="line">                ans.push_back(vector&lt;int&gt;(v.begin() + left - 1, v.begin() + right));</span><br><span class="line">            &#125;</span><br><span class="line">            if(cnt &gt; sum)&#123;</span><br><span class="line">                cnt -= left;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;else if(cnt &lt;= sum)&#123;</span><br><span class="line">                ++right;</span><br><span class="line">                cnt += right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="和为S的两个数字"><a href="#和为S的两个数字" class="headerlink" title="和为S的两个数字"></a>和为S的两个数字</h1><h2 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对应每个测试案例，输出两个数，小的先输出。</span><br></pre></td></tr></table></figure>
<h2 id="解析-41"><a href="#解析-41" class="headerlink" title="解析"></a>解析</h2><p>在序列首尾各定义指针p1, p2，如果和超过s，p2往中间移，如果和小于s，p1往中间移。 </p>
<h2 id="代码-41"><a href="#代码-41" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = array.size() - 1;</span><br><span class="line">        while(left &lt; right)&#123;</span><br><span class="line">            if(array[left] + array[right] == sum)&#123;</span><br><span class="line">                v.push_back(array[left]);</span><br><span class="line">                v.push_back(array[right]);</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if(array[left] + array[right] &gt; sum)&#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h1><h2 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<h2 id="解析-42"><a href="#解析-42" class="headerlink" title="解析"></a>解析</h2><p>先取余，再字符串分割。</p>
<h2 id="代码-42"><a href="#代码-42" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string LeftRotateString(string str, int n) &#123;</span><br><span class="line">        unsigned int len = str.size();</span><br><span class="line">        if(!len)&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        n %= len;</span><br><span class="line">        string str2 = str.substr(size_t(n)) + str.substr(0, n);</span><br><span class="line">        return str2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="翻转单词顺序列"><a href="#翻转单词顺序列" class="headerlink" title="翻转单词顺序列"></a>翻转单词顺序列</h1><h2 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<h2 id="解析-43"><a href="#解析-43" class="headerlink" title="解析"></a>解析</h2><p>用栈储存单词，存完了再输出。</p>
<h2 id="代码-43"><a href="#代码-43" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string ReverseSentence(string str) &#123;</span><br><span class="line">        stack&lt;string&gt;s;</span><br><span class="line">        istringstream istring;</span><br><span class="line">        istring.str(str);</span><br><span class="line">        string tmp;</span><br><span class="line">        while(istring &gt;&gt; tmp)&#123;</span><br><span class="line">            s.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        if(!s.empty())&#123;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(str.size())&#123;</span><br><span class="line">                return str;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!s.empty())&#123;</span><br><span class="line">            tmp += &quot; &quot; + s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="扑克牌顺子"><a href="#扑克牌顺子" class="headerlink" title="扑克牌顺子"></a>扑克牌顺子</h1><h2 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h2><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
<h2 id="解析-44"><a href="#解析-44" class="headerlink" title="解析"></a>解析</h2><p>暴力做的。</p>
<h2 id="代码-44"><a href="#代码-44" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsContinuous( vector&lt;int&gt; numbers ) &#123;</span><br><span class="line">        if(numbers.empty())&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int cnt = 0, cur = 0;</span><br><span class="line">        sort(numbers.begin(), numbers.end());</span><br><span class="line">        for(int i = 0; i &lt; numbers.size(); ++i)&#123;</span><br><span class="line">            if(numbers[i] == 0)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(cur)&#123;</span><br><span class="line">                    while(numbers[i] != cur + 1)&#123;</span><br><span class="line">                        cur += 1;</span><br><span class="line">                        --cnt;</span><br><span class="line">                        if(cnt &lt; 0)&#123;</span><br><span class="line">                            return false;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur += 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    cur = numbers[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="孩子们的游戏-圆圈中最后剩下的数"><a href="#孩子们的游戏-圆圈中最后剩下的数" class="headerlink" title="孩子们的游戏(圆圈中最后剩下的数)"></a>孩子们的游戏(圆圈中最后剩下的数)</h1><h2 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h2><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<h2 id="解析-45"><a href="#解析-45" class="headerlink" title="解析"></a>解析</h2><p>现在我们把他们的编号做一下转换：</p>
<p>k –&gt; 0<br>k+1 –&gt; 1<br>k+2 –&gt; 2<br>…<br>…<br>k-2 –&gt; n-2<br>k-1 –&gt; n-1<br>解x’ —-&gt; 解为x<br>注意&lt; x’就是最终的解 &gt;</p>
<p>变换后就完完全全成为了(n-1)个人报数的子问题，假如我们知道这个子问题的解：例如x是最终的胜利者，那么根据上面这个表把这个x变回去不刚好就是n个人情况的解吗？！！变回去的公式很简单，相信大家都可以推出来：x’=(x+k)%n</p>
<p>如何知道(n-1)个人报数的问题的解？对，只要知道(n-2)个人的解就行了。(n-2)个人的解呢？当然是先求(n-3)的情况 —- 这显然就是一个倒推问题！下面举例说明：</p>
<p>假设现在是6个人（编号从0到5）报数，报到（2-1）的退出，即 &lt; m=2&gt;。那么第一次编号为1的人退出圈子，从他之后的人开始算起，序列变为2,3,4,5,0，即问题变成了这5个人报数的问题，将序号做一下转换：<br>2 –&gt;0<br>3 –&gt;1<br>4 –&gt;2<br>5 –&gt;3<br>0 –&gt;4<br>现在假设x为0,1,2,3,4的解，x’设为那么原问题的解（这里注意，2,3,4,5,0的解就是0,1,2,3,4,5的解，因为1出去了，结果还是一个），根据观察发现，x与x’关系为x’=(x+m)%n，因此只要求出x，就可以求x’。x怎么求出呢？继续推导吧。0,1,2,3,4,，同样是第二个1出列，变为（2,3,4,0），转换下为<br>2 –&gt;0<br>3 –&gt;1<br>4 –&gt;2<br>0 –&gt;3<br>很简单，同样的道理，公式又出来了，x=(x”+m)%5，这里变成5了。即求n-1个人的问题就是找出n-2的人的解，n-2就是要找出n-3，等等<br>因此，就可以回去看上面的推导过程了。</p>
<p>好了，思路出来了，下面写递推公式：<br>令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]</p>
<p>递推公式<br>f[1]=0;<br>f[i]=(f[i-1]+m)%i; (i&gt;1)</p>
<p>有了这个公式，我们要做的就是从1-n顺序算出f[i]的数值，最后结果是f[n]。因为实际生活中编号总是从1开始，我们输出f[n]+1<br>由于是逐级递推，不需要保存每个f[i]。</p>
<h2 id="代码-45"><a href="#代码-45" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int LastRemaining_Solution(int n, int m)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n + m == 0)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int s = 0;</span><br><span class="line">        for(int i = 2; i &lt;= n; ++i)&#123;</span><br><span class="line">            s = (s + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="求1-2-3-…-n"><a href="#求1-2-3-…-n" class="headerlink" title="求1+2+3+…+n"></a>求1+2+3+…+n</h1><h2 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h2 id="解析-46"><a href="#解析-46" class="headerlink" title="解析"></a>解析</h2><p>利用逻辑运算符&amp;&amp;的性质。</p>
<h2 id="代码-46"><a href="#代码-46" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        return fun(n);</span><br><span class="line">    &#125;</span><br><span class="line">    int fun(int n)&#123;</span><br><span class="line">        n &amp;&amp; (n += fun(n-1));</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h1><h2 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<h2 id="解析-47"><a href="#解析-47" class="headerlink" title="解析"></a>解析</h2><p>位运算，先异或，再右移。</p>
<h2 id="代码-47"><a href="#代码-47" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Add(int num1, int num2)</span><br><span class="line">    &#123;</span><br><span class="line">        while(num2)&#123;</span><br><span class="line">            int a1 = num1 ^ num2;</span><br><span class="line">            int a2 = num1 &amp; num2;</span><br><span class="line">            a2 &lt;&lt;= 1;</span><br><span class="line">            num1 = a1;</span><br><span class="line">            num2 = a2;</span><br><span class="line">        &#125;</span><br><span class="line">        return num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h1><h2 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
<h3 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个字符串,包括数字字母符号,可以为空</span><br></pre></td></tr></table></figure>
<h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果是合法的数值表达则返回该数字，否则返回0</span><br></pre></td></tr></table></figure>
<h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+2147483647</span><br><span class="line">    1a33</span><br></pre></td></tr></table></figure>
<h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2147483647</span><br><span class="line">    0</span><br></pre></td></tr></table></figure>
<h2 id="解析-48"><a href="#解析-48" class="headerlink" title="解析"></a>解析</h2><p>暴力</p>
<h2 id="代码-48"><a href="#代码-48" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int StrToInt(string str) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for(int i = 0; i &lt; str.length(); i++)&#123;</span><br><span class="line">            while(str[i] == &apos; &apos;)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(str[i] &lt;= &apos;9&apos; &amp;&amp; str[i] &gt;= &apos;0&apos;)&#123;</span><br><span class="line">                ans *= 10;</span><br><span class="line">                ans += str[i] - &apos;0&apos;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(!flag)&#123;</span><br><span class="line">                    if(str[i] == &apos;-&apos;)&#123;</span><br><span class="line">                        flag = -1;</span><br><span class="line">                    &#125;else if(str[i] == &apos;+&apos;)&#123;</span><br><span class="line">                        flag = 1;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        return 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            ans *= flag;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h1><h2 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<h2 id="解析-49"><a href="#解析-49" class="headerlink" title="解析"></a>解析</h2><p>0~n-1正常的排序应该是A[i]=i；因此可以通过交换的方式，将它们都各自放回属于自己的位置；</p>
<p>从头到尾扫描数组A，当扫描到下标为i的数字m时，首先比较这个数字m是不是等于i，</p>
<p>如果是，则继续扫描下一个数字；</p>
<p>如果不是，则判断它和A[m]是否相等，如果是，则找到了第一个重复的数字（在下标为i和m的位置都出现了m）；如果不是，则把A[i]和A[m]交换，即把m放回属于它的位置；</p>
<p>重复上述过程，直至找到一个重复的数字；</p>
<p>时间复杂度：O(n)，空间复杂度：O(1)</p>
<p>注：张氏排序法</p>
<h2 id="代码-49"><a href="#代码-49" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // Parameters:</span><br><span class="line">    //        numbers:     an array of integers</span><br><span class="line">    //        length:      the length of array numbers</span><br><span class="line">    //        duplication: (Output) the duplicated number in the array number</span><br><span class="line">    // Return value:       true if the input is valid, and there are some duplications in the array number</span><br><span class="line">    //                     otherwise false</span><br><span class="line">    bool duplicate(int numbers[], int length, int* duplication) &#123;</span><br><span class="line">        for(int i = 0; i &lt; length; ++i)&#123;</span><br><span class="line">            while(numbers[i] != i)&#123;</span><br><span class="line">                if(numbers[i] == numbers[numbers[i]])&#123;</span><br><span class="line">                    *duplication = numbers[i];</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(numbers[i], numbers[numbers[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h1><h2 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p>
<h2 id="解析-50"><a href="#解析-50" class="headerlink" title="解析"></a>解析</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-002.png" alt></p>
<p>B[i]的值可以看做下图的矩阵中每行的乘积。</p>
<p>下三角用连乘可以很容易求得，先算下三角中的连乘，即先计算出B[i]中的一部分，然后将上三角中的数也乘进去。这样一来就只需要两个循环就可以解决这个问题。时间复杂度是O(n);</p>
<p>其实你只需要知道这个是形成一个矩阵，然后每一行是用来计算B[i],每一行的内容则是A[0]到A[n-1]。利用上三角和下三角进行计算。</p>
<h2 id="代码-50"><a href="#代码-50" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        vector&lt;int&gt;B(A.size(), 1);</span><br><span class="line">        int tmp = 1;</span><br><span class="line">        for(int i = 0; i &lt; A.size() - 1; ++i)&#123;</span><br><span class="line">            tmp *= A[i];</span><br><span class="line">            B[i + 1] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = 1;</span><br><span class="line">        for(int i = A.size() - 1; i &gt; 0; --i)&#123;</span><br><span class="line">            tmp *= A[i];</span><br><span class="line">            B[i - 1] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h1><h2 id="题目描述-51"><a href="#题目描述-51" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<h2 id="解析-51"><a href="#解析-51" class="headerlink" title="解析"></a>解析</h2><p>“.”按任意字符匹配。如果模式串遇到*字符则有两种状态，第一匹配字符，则字符串后移一位，模式串不变，第二，模式串后移俩位和字符串后移一位，第三，忽略星号。 </p>
<h2 id="代码-51"><a href="#代码-51" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool match(char* str, char* pattern)&#123;</span><br><span class="line">        if(str[0] == 0 &amp;&amp; pattern[0] == 0)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if(pattern[0] &amp;&amp; pattern[1] == &apos;*&apos; &amp;&amp; match(str, pattern + 2))&#123;</span><br><span class="line">                return true;</span><br><span class="line">        &#125;else if(str[0] &amp;&amp; pattern[0] == &apos;.&apos; || str[0] == pattern[0])&#123;</span><br><span class="line">            if(match(str + 1, pattern + 1))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else if(pattern[1] == &apos;*&apos; &amp;&amp; match(str + 1, pattern))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h1><h2 id="题目描述-52"><a href="#题目描述-52" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<h2 id="解析-52"><a href="#解析-52" class="headerlink" title="解析"></a>解析</h2><p>暴力</p>
<h2 id="代码-52"><a href="#代码-52" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumeric(char* string)</span><br><span class="line">    &#123;</span><br><span class="line">        int len = strlen(string);</span><br><span class="line">        int cur = 0;</span><br><span class="line">        bool a = false, b = false, c = false, ans = true;</span><br><span class="line">        while(string[cur] == &apos; &apos;)&#123;</span><br><span class="line">            ++cur;</span><br><span class="line">        &#125;</span><br><span class="line">        for(; cur &lt; len; ++cur)&#123;</span><br><span class="line">            if(string[cur] &gt;= &apos;0&apos; &amp;&amp; string[cur] &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                ans = true;</span><br><span class="line">                a = true;</span><br><span class="line">            &#125;else if(string[cur] == &apos;+&apos; || string[cur] == &apos;-&apos;)&#123;</span><br><span class="line">                if(a)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    a = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(string[cur] == &apos;e&apos; || string[cur] == &apos;E&apos;)&#123;</span><br><span class="line">                if(b)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    b = true;</span><br><span class="line">                    a = false;</span><br><span class="line">                    ans = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(string[cur] == &apos;.&apos;)&#123;</span><br><span class="line">                if(c || b)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    c = true;</span><br><span class="line">                    ans = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="字符流中第一个不重复的字符"><a href="#字符流中第一个不重复的字符" class="headerlink" title="字符流中第一个不重复的字符"></a>字符流中第一个不重复的字符</h1><h2 id="题目描述-53"><a href="#题目描述-53" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<h3 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果当前字符流没有存在出现一次的字符，返回#字符。</span><br></pre></td></tr></table></figure>
<h2 id="解析-53"><a href="#解析-53" class="headerlink" title="解析"></a>解析</h2><p>哈希表。</p>
<h2 id="代码-53"><a href="#代码-53" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  //Insert one char from stringstream</span><br><span class="line">    Solution():cur(0)&#123;&#125;</span><br><span class="line">    void Insert(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        str += ch;</span><br><span class="line">        ++mp[ch];</span><br><span class="line">        while(cur &lt; str.size() &amp;&amp; mp[str[cur]] &gt; 1)&#123;</span><br><span class="line">            ++cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  //return the first appearence once char in current stringstream</span><br><span class="line">    char FirstAppearingOnce()</span><br><span class="line">    &#123;</span><br><span class="line">        if(cur &gt;= str.size())&#123;</span><br><span class="line">            return &apos;#&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        return str[cur];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    map&lt;char, int&gt;mp;</span><br><span class="line">    string str;</span><br><span class="line">    int cur;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a>链表中环的入口结点</h1><h2 id="题目描述-54"><a href="#题目描述-54" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<h2 id="解析-54"><a href="#解析-54" class="headerlink" title="解析"></a>解析</h2><p><a href="https://www.cnblogs.com/fankongkong/p/7007869.html" target="_blank" rel="noopener">转</a>：a、第一步，找环中相汇点。分别用fast，slow指向链表头部，slow每次走一步，fast每次走二步，直到fast==slow找到在环中的相汇点。</p>
<p>b、第二步，找环的入口。接上步，当fast==slow时，fast所经过节点数为2x,slow所经过节点数为x,设环中有n个节点，fast比slow<strong>多走r圈</strong>有<strong>2x=rn+x; x=rn;</strong>（r为圈数，n为一圈的结点数）</p>
<p>可以看出slow实际走了多个环的步数，再让fast指向链表头部，slow位置不变。</p>
<p>假设链表开头到环接口的距离是y，那么x-y表示slow指针走过的除链表开头y在环中走过的距离，那么slow再走y步，此时fast结点与slow结点相遇，fast == slow ，<strong>x-y+y=x = rn</strong>，即此时slow指向环的入口。</p>
<h2 id="代码-54"><a href="#代码-54" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* EntryNodeOfLoop(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pFast = pHead;</span><br><span class="line">        ListNode* pSlow = pHead;</span><br><span class="line">        do&#123;</span><br><span class="line">            if(pSlow &amp;&amp; pSlow-&gt;next)&#123;</span><br><span class="line">                pSlow = pSlow-&gt;next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pFast &amp;&amp; pFast-&gt;next &amp;&amp; pFast-&gt;next-&gt;next)&#123;</span><br><span class="line">                pFast = pFast-&gt;next-&gt;next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;while(pFast != pSlow);</span><br><span class="line">        pFast = pHead;</span><br><span class="line">        while(pFast != pSlow)&#123;</span><br><span class="line">            pFast = pFast-&gt;next;</span><br><span class="line">            pSlow = pSlow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pSlow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h1><h2 id="题目描述-55"><a href="#题目描述-55" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h2 id="解析-55"><a href="#解析-55" class="headerlink" title="解析"></a>解析</h2><p>不多说了，因为是排序的链表。</p>
<h2 id="代码-55"><a href="#代码-55" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">		if (pHead == NULL) &#123;</span><br><span class="line">			return NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		ListNode* preNode = NULL;</span><br><span class="line">		ListNode* node = pHead;</span><br><span class="line">		while (node != NULL) &#123;</span><br><span class="line">			if (node-&gt;next != NULL &amp;&amp; node-&gt;val == node-&gt;next-&gt;val) &#123;</span><br><span class="line">				int value = node-&gt;val;</span><br><span class="line">				while (node-&gt;next != NULL &amp;&amp; node-&gt;next-&gt;val == value) &#123;</span><br><span class="line">					node = node-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">				if (preNode == NULL) &#123;</span><br><span class="line">					pHead = node-&gt;next;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					preNode-&gt;next = node-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				preNode = node;</span><br><span class="line">			&#125;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		return pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的下一个结点"><a href="#二叉树的下一个结点" class="headerlink" title="二叉树的下一个结点"></a>二叉树的下一个结点</h1><h2 id="题目描述-56"><a href="#题目描述-56" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h2 id="解析-56"><a href="#解析-56" class="headerlink" title="解析"></a>解析</h2><p>我们可发现分成两大类：1、有右子树的，那么下个结点就是右子树最左边的点；（eg：D，B，E，A，C，G） 2、没有右子树的，也可以分成两类，a)是父节点左孩子（eg：N，I，L） ，那么父节点就是下一个节点 ； b)是父节点的右孩子（eg：H，J，K，M）找他的父节点的父节点的父节点…直到当前结点是其父节点的左孩子位置。如果没有eg：M，那么他就是尾节点。  </p>
<h2 id="代码-56"><a href="#代码-56" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeLinkNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeLinkNode *left;</span><br><span class="line">    struct TreeLinkNode *right;</span><br><span class="line">    struct TreeLinkNode *next;</span><br><span class="line">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeLinkNode* GetNext(TreeLinkNode* pNode)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pNode == NULL)&#123;</span><br><span class="line">            return pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pNode-&gt;right)&#123;</span><br><span class="line">            TreeLinkNode* p = pNode-&gt;right;</span><br><span class="line">            while(p-&gt;left)&#123;</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            TreeLinkNode* p = pNode-&gt;next;</span><br><span class="line">            while(p &amp;&amp; p-&gt;right == pNode)&#123;</span><br><span class="line">                pNode = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h1><h2 id="题目描述-57"><a href="#题目描述-57" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<h2 id="解析-57"><a href="#解析-57" class="headerlink" title="解析"></a>解析</h2><p>【分析1】首先我们需要明确一下镜像二叉树的概念，简单来说就是左子树与右子树对调。而根据树的递归定义可以，左子树和右子树的定义也是递归而言的。</p>
<p>【分析2】接下来我们需要明确两棵二叉树什么时候相同。显然，根结点的值相等，左右子树相同，则这两颗二叉树相同。显然，在判断两棵二叉树是否相同时也需要递归地进行判断。</p>
<p>【分析3】题目中并不是想让我们判断任意两棵二叉树是否相同，而是要求我们判断一棵二叉树和它的镜像二叉树是否相同。因此我们判断相同的条件不就很明显的变成了：根结点对应的值相等，原二叉树Root的左子树与其镜像二叉树Root’的右子树相同，且原二叉树Root的右子树与其镜像二叉树Root’的左子树相同。如此递归下去。直到① 如果Root和Root’均为空，则返回true；② 如果Root为空或者Root’为空，则返回false；③ 如果Root对应的值与Root’对应的值不相等，则返回false。</p>
<h2 id="代码-57"><a href="#代码-57" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool check(TreeNode* pRoot_1, TreeNode* pRoot_2)&#123;</span><br><span class="line">        return pRoot_1-&gt;val == pRoot_2-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isSymmetrical(TreeNode* pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pRoot == NULL)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return dfs(pRoot-&gt;left, pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    bool dfs(TreeNode* pRoot_1, TreeNode* pRoot_2)&#123;</span><br><span class="line">        if(pRoot_1 == NULL || pRoot_2 == NULL)&#123;</span><br><span class="line">            if(pRoot_1 == NULL &amp;&amp; pRoot_2 == NULL)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(check(pRoot_1, pRoot_2))&#123;</span><br><span class="line">            if(dfs(pRoot_1-&gt;left, pRoot_2-&gt;right))&#123;</span><br><span class="line">                return dfs(pRoot_1-&gt;right, pRoot_2-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a>按之字形顺序打印二叉树</h1><h2 id="题目描述-58"><a href="#题目描述-58" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<h2 id="解析-58"><a href="#解析-58" class="headerlink" title="解析"></a>解析</h2><p>广度优先遍历。两个栈代替队列储存数据。</p>
<h2 id="代码-58"><a href="#代码-58" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt;que;</span><br><span class="line">        stack&lt;TreeNode*&gt;stk;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt;vv;</span><br><span class="line">        if(!pRoot)&#123;</span><br><span class="line">            return vv;</span><br><span class="line">        &#125;</span><br><span class="line">        que.push(pRoot);</span><br><span class="line">        while(!que.empty() || !stk.empty())&#123;</span><br><span class="line">            vector&lt;int&gt;v;</span><br><span class="line">            if(!que.empty())&#123;</span><br><span class="line">                while(!que.empty())&#123;</span><br><span class="line">                    TreeNode* tmp = que.top();</span><br><span class="line">                    que.pop();</span><br><span class="line">                    v.push_back(tmp-&gt;val);</span><br><span class="line">                    if(tmp-&gt;left)&#123;</span><br><span class="line">                        stk.push(tmp-&gt;left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(tmp-&gt;right)&#123;</span><br><span class="line">                        stk.push(tmp-&gt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                while(!stk.empty())&#123;</span><br><span class="line">                    TreeNode* tmp = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    v.push_back(tmp-&gt;val);</span><br><span class="line">                    if(tmp-&gt;right)&#123;</span><br><span class="line">                        que.push(tmp-&gt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(tmp-&gt;left)&#123;</span><br><span class="line">                        que.push(tmp-&gt;left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vv.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        return vv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a>把二叉树打印成多行</h1><h2 id="题目描述-59"><a href="#题目描述-59" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<h2 id="解析-59"><a href="#解析-59" class="headerlink" title="解析"></a>解析</h2><p>带属性的广度优先遍历。</p>
<h2 id="代码-59"><a href="#代码-59" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">            vector&lt;vector&lt;int&gt; &gt; vv;</span><br><span class="line">            vector&lt;int&gt; ve;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            queue&lt;int&gt; dque;</span><br><span class="line">            int depth=0;</span><br><span class="line">            que.push(pRoot);</span><br><span class="line">            dque.push(depth);</span><br><span class="line">            TreeNode *node;</span><br><span class="line">            while(!que.empty())&#123;</span><br><span class="line">                node=que.front();</span><br><span class="line">                if(depth!=dque.front())&#123;</span><br><span class="line">                    vv.push_back(ve);</span><br><span class="line">                    ve.clear();</span><br><span class="line">                    depth=dque.front();</span><br><span class="line">                &#125;</span><br><span class="line">                que.pop();</span><br><span class="line">                dque.pop();</span><br><span class="line">                if(node)&#123;</span><br><span class="line">                    que.push(node-&gt;left);</span><br><span class="line">                    que.push(node-&gt;right);</span><br><span class="line">                    dque.push(depth+1);</span><br><span class="line">                    dque.push(depth+1);</span><br><span class="line">                    ve.push_back(node-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return vv;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h1><h2 id="题目描述-60"><a href="#题目描述-60" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<h2 id="解析-60"><a href="#解析-60" class="headerlink" title="解析"></a>解析</h2><p> 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。</p>
<p>序列化可以基于 先序、中序、后序、按层 的二叉树遍历方式来进行修改。原理都是一样的（即遍历顺序不同而已，对每个结点的处理都是一样的），序列化的结果是一个字符串，序列化时通过  某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p>
<p>这里以先序遍历的方式进行序列化举例：</p>
<p>先序序列化二叉树==定义一个stringbuilder保存序列过程中的结果：<strong>按照先序遍历方式遍历二叉树，若结点非空则把 “结点值!” append到builder中；若结点空则把  “#!” append到builder中；</strong>最后用builder生成字符串就是序列化结果。    </p>
<h2 id="代码-60"><a href="#代码-60" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    char* Serialize(TreeNode *root) &#123;</span><br><span class="line">        string str;</span><br><span class="line">        if(root)&#123;</span><br><span class="line">            str = to_string(root-&gt;val);</span><br><span class="line">            str = str + &quot;,&quot; + Serialize(root-&gt;left);</span><br><span class="line">            str = str + &quot;,&quot; + Serialize(root-&gt;right);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            str = &quot;#&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        char* ret = new char[str.size()];</span><br><span class="line">        strcpy(ret,str.c_str());</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* dfs(char * &amp;str) &#123;</span><br><span class="line">        if(*str == &apos;,&apos;)&#123;</span><br><span class="line">            ++str;</span><br><span class="line">        &#125;</span><br><span class="line">        if(str)&#123;</span><br><span class="line">            TreeNode* Tree = new TreeNode(0);</span><br><span class="line">            if(str &amp;&amp; *str &gt;= &apos;0&apos; &amp;&amp; *str &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                while(*str &gt;= &apos;0&apos; &amp;&amp; *str &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                    Tree-&gt;val *= 10;</span><br><span class="line">                    Tree-&gt;val += *str - &apos;0&apos;;</span><br><span class="line">                    ++str;</span><br><span class="line">                &#125;</span><br><span class="line">                Tree-&gt;left = dfs(str);</span><br><span class="line">                Tree-&gt;right = dfs(str);</span><br><span class="line">                return Tree;</span><br><span class="line">            &#125;else if(*str == &apos;#&apos;)&#123;</span><br><span class="line">                ++str;</span><br><span class="line">                return NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* Deserialize(char * str)&#123;</span><br><span class="line">        return dfs(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉搜索树的第k个结点"><a href="#二叉搜索树的第k个结点" class="headerlink" title="二叉搜索树的第k个结点"></a>二叉搜索树的第k个结点</h1><h2 id="题目描述-61"><a href="#题目描述-61" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p>
<h2 id="解析-61"><a href="#解析-61" class="headerlink" title="解析"></a>解析</h2><p>搜索树按从小到大的顺序排列正好就是中序遍历； 所以按照中序遍历查找，第k个节点就是结果。 </p>
<h2 id="代码-61"><a href="#代码-61" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int cnt;</span><br><span class="line">    TreeNode* KthNode(TreeNode* pRoot, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt = 0;</span><br><span class="line">        return dfs(pRoot, k);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* dfs(TreeNode* pRoot, int k)&#123;</span><br><span class="line">        if(pRoot == NULL)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pRoot-&gt;left)&#123;</span><br><span class="line">            TreeNode* tmp = dfs(pRoot-&gt;left, k);</span><br><span class="line">            if(tmp)&#123;</span><br><span class="line">                return tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++cnt;</span><br><span class="line">        if(cnt == k)&#123;</span><br><span class="line">            return pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pRoot-&gt;right)&#123;</span><br><span class="line">            TreeNode* tmp = dfs(pRoot-&gt;right, k);</span><br><span class="line">            if(tmp)&#123;</span><br><span class="line">                return tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h1><h2 id="题目描述-62"><a href="#题目描述-62" class="headerlink" title="题目描述"></a>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<h2 id="解析-62"><a href="#解析-62" class="headerlink" title="解析"></a>解析</h2><p>最大堆和最小堆结合。最大堆储存前n/2个数，最小堆储存后n/2个数。偶数个数据，那么中位数可以由大小堆堆顶的数得到，如果数据的数目是奇数，那么输出最大堆堆顶。 </p>
<h2 id="代码-62"><a href="#代码-62" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void Insert(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        if(max_que.size() == min_que.size())&#123;</span><br><span class="line">            if(max_que.empty() || max_que.top() &gt;= num || min_que.top() &gt;= num)&#123;</span><br><span class="line">                max_que.push(num);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                max_que.push(min_que.top());</span><br><span class="line">                min_que.pop();</span><br><span class="line">                min_que.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(max_que.top() &gt;= num)&#123;</span><br><span class="line">                min_que.push(max_que.top());</span><br><span class="line">                max_que.pop();</span><br><span class="line">                max_que.push(num);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                min_que.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double GetMedian()</span><br><span class="line">    &#123; </span><br><span class="line">        if(max_que.size() == min_que.size())&#123;</span><br><span class="line">            return (min_que.top() + max_que.top()) / 2.0;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return max_que.top();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;min_que;</span><br><span class="line">    priority_queue&lt;int&gt;max_que;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h1><h2 id="题目描述-63"><a href="#题目描述-63" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h2 id="解析-63"><a href="#解析-63" class="headerlink" title="解析"></a>解析</h2><p>我们可以用STL中的deque，以数组{2,3,4,2,6,2,5,1}为例，来细说整体思路。</p>
<p>数组的第一个数字是2，把它存入队列中。第二个数字是3，比2大，所以2不可能是滑动窗口中的最大值，因此把2从队列里删除，再把3存入队列中。第三个数字是4，比3大，同样的删3存4。此时滑动窗口中已经有3个数字，而它的最大值4位于队列的头部。</p>
<p>第四个数字2比4小，但是当4滑出之后它还是有可能成为最大值的，所以我们把2存入队列的尾部。下一个数字是6，比4和2都大，删4和2，存6。就这样依次进行，最大值永远位于队列的头部。</p>
<p>但是我们怎样判断滑动窗口是否包括一个数字？应该在队列里存入数字在数组里的下标，而不是数值。当一个数字的下标与当前处理的数字的下标之差大于或者相等于滑动窗口大小时，这个数字已经从窗口中滑出，可以从队列中删除。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-001.png" alt></p>
<h2 id="代码-63"><a href="#代码-63" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)&#123;</span><br><span class="line">        deque&lt;int&gt;dq, vis;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        for(unsigned int i = 0; i &lt; num.size(); ++i)&#123;</span><br><span class="line">            if(!vis.empty() &amp;&amp; i - vis.front() &gt;= size)&#123;</span><br><span class="line">                dq.pop_front();</span><br><span class="line">                vis.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            while(!dq.empty() &amp;&amp; dq.back() &lt;= num[i])&#123;</span><br><span class="line">                    dq.pop_back();</span><br><span class="line">                    vis.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.push_back(num[i]);</span><br><span class="line">            vis.push_back(i);</span><br><span class="line">            if(i &gt;= size - 1)&#123;</span><br><span class="line">                v.push_back(dq.front());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h1><h2 id="题目描述-64"><a href="#题目描述-64" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<h2 id="解析-64"><a href="#解析-64" class="headerlink" title="解析"></a>解析</h2><p>dfs(回溯)。创建一个状态数组对访问的字符进行标记。首先，遍历这个矩阵，如果矩阵中某字符和目标字符首字母相等，则以该字符为起点dfs深搜，否则继续遍历。一直重复这个过程，直到路径字符串上所有字符都在矩阵中找到格式的位置。</p>
<h2 id="代码-64"><a href="#代码-64" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool dfs(char* matrix, int x, int y, char* str, int cur, int rows, int cols)&#123;</span><br><span class="line">        if(x &lt; 0 || y &lt; 0 || x &gt;= rows || y &gt;= cols || vis[x * cols + y] == true || str[cur] != matrix[x * cols + y])&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x * cols + y] = true;</span><br><span class="line">        if(cur &gt;= len - 1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; 4; ++i)&#123;</span><br><span class="line">            if(dfs(matrix, x + road[i][0], y + road[i][1], str, cur + 1, rows, cols) == true)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x * cols + y] = false;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool hasPath(char* matrix, int rows, int cols, char* str)&#123;</span><br><span class="line">        if(matrix[0] == 0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        len = strlen(str);</span><br><span class="line">        vis.resize(cols * rows, false);</span><br><span class="line">        for(int i = 0; i &lt; rows; ++i)&#123;</span><br><span class="line">            for(int j = 0; j &lt; cols; ++j)&#123;</span><br><span class="line">                if(matrix[i* cols + j] == str[0])&#123;</span><br><span class="line">                    if(dfs(matrix, i, j, str, 0, rows, cols) == true)&#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int len;</span><br><span class="line">    vector&lt;bool&gt;vis;</span><br><span class="line">    int road[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h1><h2 id="题目描述-65"><a href="#题目描述-65" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<h2 id="解析-65"><a href="#解析-65" class="headerlink" title="解析"></a>解析</h2><p>dfs(回溯)。创建一个状态数组对访问的格子进行标记，但是这里需要计算所有能够走的格子总数，实际上只需要对下一个进行访问的格子进行计算，进行从上、下、左、右四个方向进行递归，就可以计算出可以达到的格子总数了。 </p>
<h2 id="代码-65"><a href="#代码-65" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int movingCount(int threshold, int rows, int cols)&#123;</span><br><span class="line">        vis.resize(rows * cols, false);</span><br><span class="line">        return dfs(threshold, rows, cols, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int dfs(int threshold, int rows, int cols, int x, int y)&#123;</span><br><span class="line">        if(x &lt; 0 || y &lt; 0 || x &gt;= rows || y &gt;= cols || vis[x * cols + y] || threshold &lt; check(x) + check(y))&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x * cols + y] = true;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        for(int i = 0; i &lt; 4; ++i)&#123;</span><br><span class="line">            ans += dfs(threshold, rows, cols, x + road[i][0], y + road[i][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int check(int num)&#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        while(num)&#123;</span><br><span class="line">            res += num % 10;</span><br><span class="line">            num /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;bool&gt;vis;</span><br><span class="line">    int road[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>训练之路</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>字符串</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
        <tag>树</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]STL四种智能指针</title>
    <url>/2019/03/30/2019-03-30/</url>
    <content><![CDATA[<p>STL一共给我们提供了四种智能指针：auto_ptr、unique_ptr、shared_ptr和weak_ptr，auto_ptr是C++98提供的解决方案，C+11已将其摒弃，并提出了unique_ptr作为auto_ptr替代方案。虽然auto_ptr已被摒弃，但在实际项目中仍可使用，但建议使用较新的unique_ptr，因为unique_ptr比auto_ptr更加安全，后文会详细叙述。shared_ptr和weak_ptr则是C+11从准标准库Boost中引入的两种智能指针。此外，Boost库还提出了boost::scoped_ptr、boost::scoped_array、boost::intrusive_ptr 等智能指针，虽然尚未得到C++标准采纳，但是实际开发工作中可以使用。</p>
<p>#1.unique_ptr</p>
<p>unique_ptr由C++11引入，旨在替代不安全的auto_ptr。unique_ptr是一种定义在\&lt; memory&gt;中的智能指针。它持有对对象的独有权——两个unique_ptr不能指向一个对象，即unique_ptr不共享它的所管理的对象。它无法复制到其他unique_ptr，无法通过值传递到函数，也无法用于需要副本的任何标准模板库 （STL）算法。只能移动 unique_ptr，即对资源管理权限可以实现转移。这意味着，内存资源所有权可以转移到另一个unique_ptr，并且原始 unique_ptr 不再拥有此资源。实际使用中，建议将对象限制为由一个所有者所有，因为多个所有权会使程序逻辑变得复杂。因此，当需要智能指针用于纯 C++ 对象时，可使用 unique_ptr，而当构造 unique_ptr 时，可使用 make_unique Helper 函数。</p>
<p>下图演示了两个 unique_ptr 实例之间的所有权转换。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-03-30.png" alt></p>
<p>unique_ptr与原始指针一样有效，并可用于 STL 容器。将 unique_ptr 实例添加到 STL 容器运行效率很高，因为通过 unique_ptr 的移动构造函数，不再需要进行复制操作。unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权，unique_ptr还可能没有对象，这种情况被称为empty。</p>
<p>unique_ptr的基本操作有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//智能指针的创建  </span><br><span class="line">unique_ptr&lt;int&gt; u_i; //创建空智能指针</span><br><span class="line">u_i.reset(new int(3)); //&quot;绑定”动态对象  </span><br><span class="line">unique_ptr&lt;int&gt; u_i2(new int(4));//创建时指定动态对象</span><br><span class="line">unique_ptr&lt;T,D&gt; u(d);	//创建空unique_ptr,执行类型为T的对象，用类型为D的对象d来替代默认的删除器delete</span><br><span class="line"></span><br><span class="line">//所有权的变化  </span><br><span class="line">int *p_i = u_i2.release(); //释放所有权  </span><br><span class="line">unique_ptr&lt;string&gt; u_s(new string(&quot;abc&quot;));  </span><br><span class="line">unique_ptr&lt;string&gt; u_s2 = std::move(u_s); //所有权转移(通过移动语义)，u_s所有权转移后，变成“空指针” </span><br><span class="line">u_s2.reset(u_s.release());//所有权转移</span><br><span class="line">u_s2=nullptr;//显式销毁所指对象，同时智能指针变为空指针。与u_s2.reset()等价</span><br></pre></td></tr></table></figure>
<h1 id="2-auto-ptr"><a href="#2-auto-ptr" class="headerlink" title="2.auto_ptr"></a>2.auto_ptr</h1><p>auto_ptr 同样是STL中智能指针家族的成员之一，由C++98引入，定义在头文件\<memory>。其功能和用法类似于unique_ptr，由 new expression 获得对象，在 auto_ptr 对象销毁时，他所管理的对象也会自动被 delete 掉。</memory></p>
<p>auto_ptr从C++98使用至今，为何从C++11开始，引入unique_ptr来替代auto_ptr呢？原因主要有如下几点：<br>（1）基于安全考虑<br>先来看下面的赋值语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_ptr&lt; string&gt; ps (new string (&quot;I reigned lonely as a cloud.”）;</span><br><span class="line">auto_ptr&lt;string&gt; vocation; </span><br><span class="line">vocaticn = ps;</span><br></pre></td></tr></table></figure>
<p>上述赋值语句将完成什么工作呢？如果ps和vocation是常规指针，则两个指针将指向同一个string对象。这是不能接受的，因为程序将试图删除同一个对象两次，一次是ps过期时，另一次是vocation过期时。要避免这种问题，方法有多种：<br>（1）定义陚值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中的一个对象是另一个对象的副本，缺点是浪费空间，所以智能指针都未采用此方案。<br>（2）建立所有权（ownership）概念。对于特定的对象，只能有一个智能指针可拥有，这样只有拥有对象的智能指针的析构函数会删除该对象。然后让赋值操作转让所有权。这就是用于auto_ptr和unique_ptr 的策略，但unique_ptr的策略更严格。<br>（3）创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1,。当减为0时才调用delete。这是shared_ptr采用的策略。</p>
<p>当然，同样的策略也适用于复制构造函数，即auto_ptr\<string> vocation(ps)时也需要上面的策略。每种方法都有其用途，但为何要摒弃auto_ptr呢？</string></p>
<p>下面举个例子来说明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># include &lt;iostream&gt;</span><br><span class="line"># include &lt;string&gt;</span><br><span class="line"># include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	auto_ptr&lt;string&gt; films[5] =&#123;</span><br><span class="line">	auto_ptr&lt;string&gt; (new string(&quot;Fowl Balls&quot;)),</span><br><span class="line">	auto_ptr&lt;string&gt; (new string(&quot;Duck Walks&quot;)),</span><br><span class="line">	auto_ptr&lt;string&gt; (new string(&quot;Chicken Runs&quot;)),</span><br><span class="line">	auto_ptr&lt;string&gt; (new string(&quot;Turkey Errors&quot;)),</span><br><span class="line">	auto_ptr&lt;string&gt; (new string(&quot;Goose Eggs&quot;))</span><br><span class="line">	&#125;;</span><br><span class="line">    auto_ptr&lt;string&gt; pwin;</span><br><span class="line">    pwin = films[2]; // films[2] loses ownership. 将所有权从films[2]转让给pwin，此时films[2]不再引用该字符串从而变成空指针</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;The nominees for best avian baseballl film are\n&quot;;</span><br><span class="line">for(int i = 0; i &lt; 5; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; *films[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 	cout &lt;&lt; &quot;The winner is &quot; &lt;&lt; *pwin &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行下发现程序崩溃了，原因在上面注释已经说的很清楚，films[2]已经是空指针了，下面输出访问空指针当然会崩溃了。但这里如果把auto_ptr换成shared_ptr或unique_ptr后，程序就不会崩溃，原因如下：</p>
<p>使用shared_ptr时运行正常，因为shared_ptr采用引用计数，pwin和films[2]都指向同一块内存，在释放空间时因为事先要判断引用计数值的大小因此不会出现多次删除一个对象的错误。</p>
<p>使用unique_ptr时编译出错，与auto_ptr一样，unique_ptr也采用所有权模型，但在使用unique_ptr时，程序不会等到运行阶段崩溃，而在编译期因下述代码行出现错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; pwin;</span><br><span class="line">pwin = films[2]; 					//films[2] loses ownership</span><br></pre></td></tr></table></figure>
<p>指导你发现潜在的内存错误。这就是为何要摒弃auto_ptr的原因，一句话总结就是：避免因潜在的内存问题导致程序崩溃。</p>
<p>从上面可见，unique_ptr比auto_ptr更加安全，因为auto_ptr有拷贝语义，拷贝后原象变得无效，再次访问原对象时会导致程序崩溃；unique_ptr则禁止了拷贝语义，但提供了移动语义，即可以使用std::move()进行控制权限的转移，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; upt(new string(&quot;lvlv&quot;));</span><br><span class="line">unique_ptr&lt;string&gt; upt1(upt);	//编译出错，已禁止拷贝</span><br><span class="line">unique_ptr&lt;string&gt; upt1=upt;	//编译出错，已禁止拷贝</span><br><span class="line">unique_ptr&lt;string&gt; upt1=std::move(upt);  //控制权限转移</span><br><span class="line"></span><br><span class="line">auto_ptr&lt;string&gt; apt(new string(&quot;lvlv&quot;));</span><br><span class="line">auto_ptr&lt;string&gt; apt1(apt);	//编译通过</span><br><span class="line">auto_ptr&lt;string&gt; apt1=apt;	//编译通过</span><br></pre></td></tr></table></figure>
<p>这里要注意，在使用std::move将unique_ptr的控制权限转移后，不能够再通过unique_ptr来访问和控制资源了，否则同样会出现程序崩溃。我们可以在使用unique_ptr访问资源前，使用成员函数get()进行判空操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; upt1=std::move(upt);  						//控制权限转移</span><br><span class="line">if(upt.get()!=nullptr)											//判空操作更安全</span><br><span class="line">&#123;</span><br><span class="line">	//do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）unique_ptr不仅安全，而且灵活<br>如果unique_ptr 是个临时右值，编译器允许拷贝语义。参考如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; demo(const char * s)</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;string&gt; temp (new string (s))； </span><br><span class="line">    return temp；</span><br><span class="line">&#125;</span><br><span class="line">//假设编写了如下代码：</span><br><span class="line">unique_ptr&lt;string&gt; ps;</span><br><span class="line">ps = demo(&apos;Uniquely special&quot;)；</span><br></pre></td></tr></table></figure>
<p>demo()返回一个临时unique_ptr，然后ps接管了临时对象unique_ptr所管理的资源，而返回时临时的 unique_ptr 被销毁，也就是说没有机会使用 unique_ptr 来访问无效的数据，换句话来说，这种赋值是不会出现任何问题的，即没有理由禁止这种赋值。实际上，编译器确实允许这种赋值。相对于auto_ptr任何情况下都允许拷贝语义，这正是unique_ptr更加灵活聪明的地方。</p>
<p>（3）扩展auto_ptr不能完成的功能<br>（3.1）unique_ptr可放在容器中，弥补了auto_ptr不能作为容器元素的缺点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//方式一：</span><br><span class="line">vector&lt;unique_ptr&lt;string&gt;&gt; vs &#123; new string&#123;“Doug”&#125;, new string&#123;“Adams”&#125; &#125;;  </span><br><span class="line"></span><br><span class="line">//方式二：</span><br><span class="line">vector&lt;unique_ptr&lt;string&gt;&gt;v;  </span><br><span class="line">unique_ptr&lt;string&gt; p1(new string(&quot;abc&quot;));</span><br></pre></td></tr></table></figure>
<p>（3.2）管理动态数组，因为unique_ptr有unique_ptr&lt;X[]&gt;重载版本，销毁动态对象时调用delete[]。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;int[]&gt; p (new int[3]&#123;1,2,3&#125;);  </span><br><span class="line">p[0] = 0;// 重载了operator[]</span><br></pre></td></tr></table></figure>
<p>（3.3）自定义资源删除操作(Deleter)。unique_ptr默认的资源删除操作是delete/delete[]，若需要，可以进行自定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void end_connection(connection *p) &#123; disconnect(*p); &#125; //资源清理函数  </span><br><span class="line"></span><br><span class="line">//资源清理器的“类型” </span><br><span class="line">unique_ptr&lt;connection, decltype(end_connection)*&gt; p(&amp;c, end_connection);// 传入函数名，会自动转换为函数指针</span><br></pre></td></tr></table></figure>
<p>综上所述，基于unique_ptr的安全性和扩充的功能，unique_ptr成功的将auto_ptr取而代之。</p>
<h1 id="3-shared-ptr"><a href="#3-shared-ptr" class="headerlink" title="3.shared_ptr"></a>3.shared_ptr</h1><h2 id="3-1shared-ptr简介"><a href="#3-1shared-ptr简介" class="headerlink" title="3.1shared_ptr简介"></a>3.1shared_ptr简介</h2><p>shared_ptr 是一个标准的共享所有权的智能指针，允许多个指针指向同一个对象，定义在 memory 文件中，命名空间为 std。shared_ptr最初实现于Boost库中，后由C++11引入到C++ STL。shared_ptr利用引用计数的方式实现了对所管理的对象的所有权的分享，即允许多个shared_ptr共同管理同一个对象。像shared_ptr这种智能指针，《Effective C++》称之为“引用计数型智能指针”（reference-counting smart pointer，RCSP）。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的)，在使用引用计数的机制上提供了可以共享所有权的智能指针，当然这需要额外的开销：<br>（1）shared_ptr 对象除了包括一个所拥有对象的指针外，还必须包括一个引用计数代理对象的指针；<br>（2）时间上的开销主要在初始化和拷贝操作上， *和-&gt;操作符重载的开销跟auto_ptr是一样；<br>（3）开销并不是我们不使用shared_ptr的理由,，永远不要进行不成熟的优化，直到性能分析器告诉你这一点。</p>
<h2 id="3-2通过辅助类模拟实现shared-ptr"><a href="#3-2通过辅助类模拟实现shared-ptr" class="headerlink" title="3.2通过辅助类模拟实现shared_ptr"></a>3.2通过辅助类模拟实现shared_ptr</h2><p>（1）基础对象类<br>首先，我们来定义一个基础对象类Point类，为了方便后面我们验证智能指针是否有效，我们为Point类创建如下接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int x, y;</span><br><span class="line">public:</span><br><span class="line">    Point(int xVal = 0, int yVal = 0) :x(xVal), y(yVal) &#123; &#125;</span><br><span class="line">    int getX() const &#123; return x; &#125;</span><br><span class="line">    int getY() const &#123; return y; &#125;</span><br><span class="line">    void setX(int xVal) &#123; x = xVal; &#125;</span><br><span class="line">    void setY(int yVal) &#123; y = yVal; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>（2）辅助类<br>在创建智能指针类之前，我们先创建一个辅助类。这个类的所有成员皆为私有类型，因为它不被普通用户所使用。为了只为智能指针使用，还需要把智能指针类声明为辅助类的友元。这个辅助类含有两个数据成员：计数count与基础对象指针。也即辅助类用以封装使用计数与基础对象指针。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RefPtr</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    friend class SmartPtr;      </span><br><span class="line">    RefPtr(Point *ptr):p(ptr),count(1)&#123; &#125;</span><br><span class="line">    ~RefPtr()&#123;delete p;&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">int count;   </span><br><span class="line">Point *p;                                                      </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>（3）为基础对象类实现智能指针类<br>引用计数是实现智能指针的一种通用方法。智能指针将一个计数器与类指向的对象相关联，引用计数跟踪共有多少个类对象共享同一指针。它的具体做法如下：<br>（3.1）当创建智能指针类的新对象时，初始化指针，并将引用计数设置为1；<br>（3.2）当能智能指针类对象作为另一个对象的副本时，拷贝构造函数复制副本的指向辅助类对象的指针，并增加辅助类对象对基础类对象的引用计数（加1）；<br>（3.3）使用赋值操作符对一个智能指针类对象进行赋值时，处理复杂一点：先使左操作数的引用计数减1（为何减1：因为指针已经指向别的地方），如果减1后引用计数为0，则释放指针所指对象内存。然后增加右操作数所指对象的引用计数（为何增加：因为此时做操作数指向对象即右操作数指向对象）。<br>（3.4）完成析构函数：调用析构函数时，析构函数先使引用计数减1，如果减至0则delete对象。</p>
<p>做好前面的准备后，我们可以为基础对象类Point书写一个智能指针类了。根据引用计数实现关键点，我们可以写出如下智能指针类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SmartPtr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    SmartPtr(Point *ptr) :rp(new RefPtr(ptr))&#123;&#125; </span><br><span class="line">    SmartPtr(const SmartPtr &amp;sp):rp(sp.rp)&#123;++rp-&gt;count;&#125;</span><br><span class="line">    </span><br><span class="line">//重载赋值运算符</span><br><span class="line">SmartPtr&amp; operator=(const SmartPtr&amp; rhs) </span><br><span class="line">&#123;</span><br><span class="line">        ++rhs.rp-&gt;count;    </span><br><span class="line">        if (--rp-&gt;count == 0)    </span><br><span class="line">            delete rp;</span><br><span class="line">        rp = rhs.rp;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    //重载-&gt;操作符</span><br><span class="line">    Point* operator-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">	    return rp-&gt;p;</span><br><span class="line">    &#125;</span><br><span class="line">    //重载*操作符</span><br><span class="line">    Point&amp; operator*()</span><br><span class="line">    &#123;</span><br><span class="line">	    return *(rp-&gt;p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">~SmartPtr()</span><br><span class="line">&#123;       </span><br><span class="line">    if (--rp-&gt;count == 0)   </span><br><span class="line">        delete rp;</span><br><span class="line">    else </span><br><span class="line">        cout &lt;&lt; &quot;还有&quot; &lt;&lt; rp-&gt;count &lt;&lt; &quot;个指针指向基础对象&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    RefPtr *rp;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>（4）智能指针类的使用与测试<br>至此，我们的智能指针类就完成了，我们可以来看看如何使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //定义一个基础对象类指针</span><br><span class="line">    Point *pa = new Point(10, 20);</span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<p>//定义三个智能指针类对象，对象都指向基础类对象pa<br>//使用花括号控制三个智能指针的生命周期，观察计数的变化<br>{<br>    SmartPtr sptr1(pa);//此时计数count=1<br>    cout &lt;&lt;”sptr1:”&lt;<sptr1->getX()&lt;&lt;”,”&lt;<sptr1->getY()&lt;&lt;endl;<br>    {<br>        SmartPtr sptr2(sptr1); //调用拷贝构造函数，此时计数为count=2<br>        cout&lt;&lt;”sptr2:” &lt;<sptr2->getX()&lt;&lt;”,”&lt;<sptr2->getY()&lt;&lt;endl;<br>        {<br>            SmartPtr sptr3=sptr1; //调用赋值操作符，此时计数为conut=3<br>            cout&lt;&lt;”sptr3:”&lt;&lt;(<em>sptr3).getX()&lt;&lt;”,”&lt;&lt;(</em>sptr3).getY()&lt;&lt;endl;<br>        }<br>        //此时count=2<br>    }<br>    //此时count=1；<br>}<br>//此时count=0；pa对象被delete掉<br>cout &lt;&lt; pa-&gt;getX ()&lt;&lt; endl;<br>system(“pause”);<br>return 0;<br>​<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></sptr2-></sptr2-></sptr1-></sptr1-></p>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sptr1:10,20</span><br><span class="line">sptr2:10,20</span><br><span class="line">sptr3:10,20</span><br><span class="line">还有2个指针指向基础对象</span><br><span class="line">还有1个指针指向基础对象</span><br><span class="line">7244864</span><br></pre></td></tr></table></figure>
<p>如期，在离开大括号后，共享基础对象的指针从3-&gt;2-&gt;1-&gt;0变换，最后计数为0时，pa对象被delete，此时使用getX()已经获取不到原来的值。</p>
<p>（5）对智能指针的改进<br>目前这个智能指针只能用于管理Point类的基础对象，如果此时定义了个矩阵的基础对象类，那不是还得重新写一个属于矩阵类的智能指针类吗？但是矩阵类的智能指针类设计思想和Point类一样啊，就不能借用吗？答案当然是能，那就是使用模板技术。为了使我们的智能指针适用于更多的基础对象类，我们有必要把智能指针类通过模板来实现。这里贴上上面的智能指针类的模板版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//模板类作为友元时要先有声明</span><br><span class="line">template &lt;typename T&gt; class SmartPtr;</span><br><span class="line"></span><br><span class="line">//辅助类</span><br><span class="line">template &lt;typename T&gt; class RefPtr</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    //该类成员访问权限全部为private，因为不想让用户直接使用该类</span><br><span class="line">    friend class SmartPtr&lt;T&gt;;      //定义智能指针类为友元，因为智能指针类需要直接操纵辅助类</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<p>//构造函数的参数为基础对象的指针<br>RefPtr(T *ptr) :p(ptr), count(1) { }</p>
<p>//析构函数<br>~RefPtr() { delete p; }<br>//引用计数<br>int count;   </p>
<p>//基础对象指针<br>T *p;<br>​<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//智能指针类</span><br><span class="line">template &lt;typename T&gt; class SmartPtr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    SmartPtr(T *ptr) :rp(new RefPtr&lt;T&gt;(ptr)) &#123; &#125;      //构造函数</span><br><span class="line">    SmartPtr(const SmartPtr&lt;T&gt; &amp;sp) :rp(sp.rp) &#123; ++rp-&gt;count; &#125;  //复制构造函数</span><br><span class="line">    SmartPtr&amp; operator=(const SmartPtr&lt;T&gt;&amp; rhs)       //重载赋值操作符</span><br><span class="line">    &#123;</span><br><span class="line">        ++rhs.rp-&gt;count;        //首先将右操作数引用计数加1，</span><br><span class="line">        if (--rp-&gt;count == 0)   //然后将引用计数减1，可以应对自赋值</span><br><span class="line">            delete rp;</span><br><span class="line">        rp = rhs.rp;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure></p>
<p>T &amp; operator <em>()        //重载</em>操作符<br>{<br>    return <em>(rp-&gt;p);<br>}<br>T</em> operator -&gt;()       //重载-&gt;操作符<br>{<br>    return rp-&gt;p;<br>}<br>~SmartPtr()            //析构函数<br>{<br>    if (–rp-&gt;count == 0)    //当引用计数减为0时，删除辅助类对象指针，从而删除基础对象<br>        delete rp;<br>    else<br>    {<br>        cout &lt;&lt; “还有” &lt;&lt; rp-&gt;count &lt;&lt; “个指针指向基础对象” &lt;&lt; endl;<br>    }<br>}<br>​<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private:</span><br><span class="line">    RefPtr&lt;T&gt; *rp;  //辅助类对象指针</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在使用智能指针类模板来共享其它类型的基础对象，以int为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//定义一个基础对象类指针</span><br><span class="line">    int* ia = new int(10);</span><br><span class="line">    &#123;</span><br><span class="line">        SmartPtr&lt;int&gt; sptr1(ia);</span><br><span class="line">        cout &lt;&lt;&quot;sptr1:&quot;&lt;&lt;*sptr1&lt;&lt;endl;</span><br><span class="line">        &#123;</span><br><span class="line">            SmartPtr&lt;int&gt; sptr2(sptr1); </span><br><span class="line">            cout &lt;&lt;&quot;sptr2:&quot;&lt;&lt;*sptr2&lt;&lt;endl;</span><br><span class="line">			*sptr2=5;</span><br><span class="line">            &#123;</span><br><span class="line">                SmartPtr&lt;int&gt; sptr3=sptr1; </span><br><span class="line">                cout &lt;&lt;&quot;sptr3:&quot;&lt;&lt;*sptr3&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //此时count=0；pa对象被delete掉</span><br><span class="line">    cout&lt;&lt;*ia&lt;&lt;endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sptr1:10</span><br><span class="line">sptr2:10</span><br><span class="line">sptr3:5</span><br><span class="line">还有2个指针指向基础对象</span><br><span class="line">还有1个指针指向基础对象</span><br><span class="line">3968064</span><br></pre></td></tr></table></figure>
<h1 id="4-weak-ptr"><a href="#4-weak-ptr" class="headerlink" title="4.weak_ptr"></a>4.weak_ptr</h1><h2 id="4-1weak-ptr简介"><a href="#4-1weak-ptr简介" class="headerlink" title="4.1weak_ptr简介"></a>4.1weak_ptr简介</h2><p>weak_ptr被设计为与shared_ptr共同工作，可以从一个shared_ptr或者另一个weak_ptr对象构造而来。weak_ptr是为了配合shared_ptr而引入的一种智能指针，它更像是shared_ptr的一个助手而不是智能指针，因为它不具有普通指针的行为，没有重载operator*和-&gt;，因此取名为weak，表明其是功能较弱的智能指针。它的最大作用在于协助shared_ptr工作，可获得资源的观测权，像旁观者那样观测资源的使用情况。观察者意味着weak_ptr只对shared_ptr 进行引用，而不改变其引用计数，当被观察的shared_ptr失效后，相应的weak_ptr也相应失效。</p>
<h2 id="4-2用法"><a href="#4-2用法" class="headerlink" title="4.2用法"></a>4.2用法</h2><p>使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0，但更快，表示被观测的资源(也就是shared_ptr管理的资源)已经不复存在。weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr管理的对象， 从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。总结来说，weak_ptr的基本用法总结如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">weak_ptr&lt;T&gt; w;	 	//创建空weak_ptr,可以指向类型为T的对象。</span><br><span class="line">weak_ptr&lt;T&gt; w(sp);	//与shared_ptr指向相同的对象，shared_ptr引用计数不变。T必须能转换为sp指向的类型。</span><br><span class="line">w=p;				//p可以是shared_ptr或weak_ptr，赋值后w与p共享对象。</span><br><span class="line">w.reset();			//将w置空。</span><br><span class="line">w.use_count();		//返回与w共享对象的shared_ptr的数量。</span><br><span class="line">w.expired();		//若w.use_count()为0，返回true，否则返回false。</span><br><span class="line">w.lock();			//如果expired()为true，返回一个空shared_ptr，否则返回非空shared_ptr。</span><br></pre></td></tr></table></figure>
<p>下面是一个简单的使用示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># include &lt; assert.h&gt;</span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"># include &lt;memory&gt;</span><br><span class="line"># include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	shared_ptr&lt;int&gt; sp(new int(10));</span><br><span class="line">	assert(sp.use_count() == 1);</span><br><span class="line">	weak_ptr&lt;int&gt; wp(sp); //从shared_ptr创建weak_ptr</span><br><span class="line">	assert(wp.use_count() == 1);</span><br><span class="line">	if (!wp.expired())//判断weak_ptr观察的对象是否失效</span><br><span class="line">	&#123;</span><br><span class="line">		shared_ptr&lt;int&gt; sp2 = wp.lock();//获得一个shared_ptr</span><br><span class="line">		*sp2 = 100;</span><br><span class="line">		assert(wp.use_count() == 2);</span><br><span class="line">	&#125;</span><br><span class="line">	assert(wp.use_count()== 1);</span><br><span class="line">	cout&lt;&lt;&quot;int:&quot;&lt;&lt;*sp&lt;&lt;endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int：100</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，尽管以shared_ptr来构造weak_ptr，但是weak_ptr内部的引用计数并没有什么变化。</p>
<h2 id="4-3weak-ptr的作用"><a href="#4-3weak-ptr的作用" class="headerlink" title="4.3weak_ptr的作用"></a>4.3weak_ptr的作用</h2><p>现在要说的问题是，weak_ptr到底有什么作用呢？从上面那个例子看来，似乎没有任何作用。其实weak_ptr可用于打破循环引用。引用计数是一种便利的内存管理机制，但它有一个很大的缺点，那就是不能管理循环引用的对象。一个简单的例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># include &lt;iostream&gt;</span><br><span class="line"># include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">class Woman;  </span><br><span class="line">class Man</span><br><span class="line">&#123;  </span><br><span class="line">private:  </span><br><span class="line">    //std::weak_ptr&lt;Woman&gt; _wife;  </span><br><span class="line">    std::shared_ptr&lt;Woman&gt; _wife;  </span><br><span class="line">public:  </span><br><span class="line">    void setWife(std::shared_ptr&lt;Woman&gt; woman)</span><br><span class="line">    &#123;  </span><br><span class="line">        _wife = woman;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<p>void doSomthing()<br>{<br>    if(_wife.lock())<br>    {<br>    }<br>}  </p>
<p>~Man()<br>{<br>    std::cout &lt;&lt; “kill man\n”;<br>}<br>​<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">class Woman</span><br><span class="line">&#123;  </span><br><span class="line">private:  </span><br><span class="line">    //std::weak_ptr&lt;Man&gt; _husband;  </span><br><span class="line">    std::shared_ptr&lt;Man&gt; _husband;  </span><br><span class="line">public:  </span><br><span class="line">    void setHusband(std::shared_ptr&lt;Man&gt; man)</span><br><span class="line">    &#123;  </span><br><span class="line">        _husband = man;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ~Woman()</span><br><span class="line">    &#123;  </span><br><span class="line">        std::cout &lt;&lt;&quot;kill woman\n&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;  </span><br><span class="line">    std::shared_ptr&lt;Man&gt; m(new Man());  </span><br><span class="line">    std::shared_ptr&lt;Woman&gt; w(new Woman());  </span><br><span class="line">    if(m &amp;&amp; w)</span><br><span class="line">    &#123;  </span><br><span class="line">        m-&gt;setWife(w);  </span><br><span class="line">        w-&gt;setHusband(m);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Man类内部会引用一个Woman，Woman类内部也引用一个Man。当一个man和一个woman是夫妻的时候，他们直接就存在了相互引用问题。man内部有个用于管理wife生命期的shared_ptr变量，也就是说wife必定是在husband去世之后才能去世。同样的，woman内部也有一个管理husband生命期的shared_ptr变量，也就是说husband必须在wife去世之后才能去世。这就是循环引用存在的问题：husband的生命期由wife的生命期决定，wife的生命期由husband的生命期决定，最后两人都死不掉，违反了自然规律，导致了内存泄漏。</p>
<p>一般来讲，解除这种循环引用有下面三种可行的方法：<br>（1）当只剩下最后一个引用的时候需要手动打破循环引用释放对象。<br>（2）当parent的生存期超过children的生存期的时候，children改为使用一个普通指针指向parent。<br>（3）使用弱引用的智能指针打破这种循环引用。<br>虽然这三种方法都可行，但方法1和方法2都需要程序员手动控制，麻烦且容易出错。这里主要介绍一下第三种方法，使用弱引用的智能指针std:weak_ptr来打破循环引用。</p>
<p>weak_ptr对象引用资源时不会增加引用计数，但是它能够通过lock()方法来判断它所管理的资源是否被释放。做法就是上面的代码注释的地方取消注释，取消Woman类或者Man类的任意一个即可，也可同时取消注释，全部换成弱引用weak_ptr。</p>
<p>另外很自然地一个问题是：既然weak_ptr不增加资源的引用计数，那么在使用weak_ptr对象的时候，资源被突然释放了怎么办呢？不用担心，因为不能直接通过weak_ptr来访问资源。那么如何通过weak_ptr来间接访问资源呢？答案是在需要访问资源的时候weak_ptr为你生成一个shared_ptr，shared_ptr能够保证在shared_ptr没有被释放之前，其所管理的资源是不会被释放的。创建shared_ptr的方法就是lock()成员函数。</p>
<p>注意： shared_ptr实现了operator bool() const方法来判断一个管理的资源是否被释放。</p>
<p>5.如何选择智能指针<br>上文简单地介绍了C++标准模板库STL中四种智能指针，当然，除了STL中的智能指针，C++准标准库Boost中的智能指针，比如boost::scoped_ptr、boost::shared_array、boost:: intrusive_ptr也可以在实际编程实践中拿来使用，但这里不做进一步的介绍，有兴趣的读者可以参考：C++ 智能指针详解。</p>
<p>在了解STL中的四种智能指针后，大家可能会想另一个问题：在实际应用中，应使用哪种智能指针呢？</p>
<p>下面给出几个使用指南。<br>（1）如果程序要使用多个指向同一个对象的指针，应选择shared_ptr。这样的情况包括：<br>（1.1）有一个指针数组，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素；<br>（1.2）两个对象都包含指向第三个对象的指针；<br>（1.3）STL容器包含指针。很多STL算法都支持复制和赋值操作，这些操作可用于shared_ptr，但不能用于unique_ptr（编译器发出warning）和auto_ptr（行为不确定）。如果你的编译器没有提供shared_ptr，可使用Boost库提供的shared_ptr。<br>（2）如果程序不需要多个指向同一个对象的指针，则可使用unique_ptr。如果函数使用new分配内存，并返还指向该内存的指针，将其返回类型声明为unique_ptr是不错的选择。这样，所有权转让给接受返回值的unique_ptr，而该智能指针将负责调用delete。可将unique_ptr存储到STL容器中，只要不调用将一个unique_ptr复制或赋值给另一个的算法（如sort()）。例如，可在程序中使用类似于下面的代码段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;int&gt; make_int(int n)</span><br><span class="line">&#123;</span><br><span class="line">    return unique_ptr&lt;int&gt;(new int(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show(unique_ptr&lt;int&gt; &amp;p1)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *a &lt;&lt; &apos; &apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    vector&lt;unique_ptr&lt;int&gt; &gt; vp(size);</span><br><span class="line">    for(int i = 0; i &lt; vp.size(); i++)</span><br><span class="line">		vp[i] = make_int(rand() % 1000);       //copy temporary unique_ptr</span><br><span class="line">    vp.push_back(make_int(rand() % 1000));     //ok because arg is temporary</span><br><span class="line">    for_each(vp.begin(), vp.end(), show);      //use for_each()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中push_back调用没有问题，因为它返回一个临时unique_ptr，该unique_ptr被赋给vp中的一个unique_ptr。另外，如果按值而不是按引用给show()传递对象，for_each()将非法，因为这将导致使用一个来自vp的非临时unique_ptr初始化pi，而这是不允许的。前面说过，编译器将发现错误使用unique_ptr的企图。</p>
<p>在unique_ptr为右值时，可将其赋给shared_ptr，这与将一个unique_ptr赋给另一个unique_ptr需要满足的条件相同，即unique_ptr必须是一个临时的对象。与前面一样，在下面的代码中，make_int()的返回类型为unique_ptr\&lt; int&gt;：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;int&gt; pup(make_int(rand() % 1000));   	// ok</span><br><span class="line">shared_ptr&lt;int&gt; spp(pup);                    	// not allowed, pup as lvalue</span><br><span class="line">shared_ptr&lt;int&gt; spr(make_int(rand() % 1000));    	// ok</span><br></pre></td></tr></table></figure>
<p>模板shared_ptr包含一个显式构造函数，可用于将右值unique_ptr转换为shared_ptr。shared_ptr将接管原来归unique_ptr所有的对象。</p>
<p>在满足unique_ptr要求的条件时，也可使用auto_ptr，但unique_ptr是更好的选择。如果你的编译器没有unique_ptr，可考虑使用Boost库提供的scoped_ptr，它与unique_ptr类似。</p>
<p>参考文献</p>
<p>[1]Stanley B.Lippman著,王刚，杨巨峰译.C++ Primer（第五版）.2013:400-422</p>
<p>[2]Scott Meyers著，侯捷译.Effective C++中文版（第三版）.2011：61-77</p>
<p>[3]C++智能指针简单剖析</p>
<p>[4]shared_ptr基于引用计数智能指针实现</p>
<p>[5] C++中智能指针的设计和使用</p>
<p>[6]C++11智能指针之unique_ptr</p>
<p>[7]Boost智能指针——weak_ptr</p>
<p>[8]std::shared_ptr 和 std::weak_ptr的用法以及引用计数的循环引用问题</p>
<p>作者：Dablelv<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/k346k346/article/details/81478223" target="_blank" rel="noopener">https://blog.csdn.net/k346k346/article/details/81478223</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言实现Linux下读取指定目录下普通文件的个数</title>
    <url>/2019/03/16/2019-03-16-1/</url>
    <content><![CDATA[<h2 id="打开一个目录"><a href="#打开一个目录" class="headerlink" title="打开一个目录"></a>打开一个目录</h2><ul>
<li>DIR <em>opendir(const char </em>name);</li>
<li><ul>
<li>参数: 目录名</li>
<li>返回值: 指向目录的指针</li>
</ul>
</li>
<li>FILE* fp = fopen（）</li>
<li>fread（buf， len， len，fp）；</li>
</ul>
<h2 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct dirent</span><br><span class="line">&#123;</span><br><span class="line">    ino_t d_ino;                         // 此目录进入点的inode</span><br><span class="line">    ff_t d_off;                             // 目录文件开头至此目录进入点的位移</span><br><span class="line">    signed short int d_reclen; // d_name 的长度, 不包含NULL 字符</span><br><span class="line">    unsigned char d_type;      // d_name 所指的文件类型 </span><br><span class="line">    har d_name[256];	       // 文件名</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>d_type<ul>
<li>DT_BLK - 块设备</li>
<li>DT_CHR - 字符设备</li>
<li>DT_DIR - 目录</li>
<li>DT_LNK - 软连接</li>
<li>DT_FIFO - 管道</li>
<li>DT_REG - 普通文件</li>
<li>DT_SOCK - 套接字</li>
<li>DT_UNKNOWN - 未知 </li>
</ul>
</li>
<li>struct dirent <em>readdir(DIR      </em>dirp);<ul>
<li>参数: opendir的返回值</li>
<li>返回值: 目录项结构体 </li>
</ul>
</li>
</ul>
<h2 id="关闭目录"><a href="#关闭目录" class="headerlink" title="关闭目录"></a>关闭目录</h2><ul>
<li>int closedir(DIR *dirp);</li>
</ul>
<p>独立完成递归读目录中指定类型文件个数的操作. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">int get_file_num(char* root)&#123;</span><br><span class="line">	int total = 0;</span><br><span class="line">	DIR* dir = NULL;</span><br><span class="line">	// 打开目录</span><br><span class="line">	dir = opendir(root);</span><br><span class="line">	// 循环从目录中读文件</span><br><span class="line"></span><br><span class="line">	char path[1024];</span><br><span class="line">	// 定义记录xiang指针</span><br><span class="line">	struct dirent* ptr = NULL;</span><br><span class="line">	while( (ptr = readdir(dir)) != NULL)&#123;</span><br><span class="line">		// 跳过. he ..</span><br><span class="line">		if(strcmp(ptr-&gt;d_name, &quot;.&quot;) == 0 || strcmp(ptr-&gt;d_name, &quot;..&quot;) == 0)&#123;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		// 判断是不是目录</span><br><span class="line">		if(ptr-&gt;d_type == DT_DIR)&#123;</span><br><span class="line">			sprintf(path, &quot;%s/%s&quot;, root, ptr-&gt;d_name);</span><br><span class="line">			// 递归读目录</span><br><span class="line">			total += get_file_num(path);</span><br><span class="line">		&#125;</span><br><span class="line">		// 如果是普通文件</span><br><span class="line">		if(ptr-&gt;d_type == DT_REG)&#123;</span><br><span class="line">			total ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	closedir(dir);</span><br><span class="line">	return total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">	if(argc &lt; 2)&#123;</span><br><span class="line">		printf(&quot;./a.out path&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int total = get_file_num(argv[1]);</span><br><span class="line">	printf(&quot;%s has regfile number: %d\n&quot;, argv[1], total);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件和目录操作函数总结</title>
    <url>/2019/03/16/2019-03-16/</url>
    <content><![CDATA[<h1 id="01-文件IO"><a href="#01-文件IO" class="headerlink" title="01-文件IO"></a>01-文件IO</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br></pre></td></tr></table></figure>
<h2 id="open-close"><a href="#open-close" class="headerlink" title="open/close"></a>open/close</h2><ul>
<li><p>函数原型:</p>
<ul>
<li>int open(const char *pathname,        int flags);</li>
<li>int open(const char *pathname,        int flags, mode_t mode);</li>
</ul>
</li>
<li><p>参数:</p>
<ul>
<li><p>flags</p>
<ul>
<li><p>必选项 O_RDONLY, O_WRONLY, O_RDWR</p>
</li>
<li><p>可选项 </p>
<ul>
<li><p>创建文件: O_CREAT</p>
<ul>
<li>创建文件时检测文件是否存在: O_EXCL</li>
<li>如果文件存在, 返回-1</li>
<li>必须与O_CREAT一起使用</li>
</ul>
</li>
<li><p>追加文件:  O_APPEND</p>
</li>
<li><p>文件截断:  O_TRUNC</p>
</li>
<li><p>设置非阻塞: O_NONBLOCK</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>mode  – 指定0777</p>
<ul>
<li><p>八进制数</p>
</li>
<li><p>最终权限: mode &amp; ~umaks</p>
</li>
<li><p>umask 0002</p>
<ul>
<li>000000010</li>
<li>~</li>
<li>111111101</li>
<li>111111111</li>
<li>&amp;</li>
<li>111111101</li>
<li>775</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><ul>
<li><p>函数原型: ssize_t read(int fd, void *buf, size_t count);</p>
<ul>
<li><p>参数:</p>
<ul>
<li>fd – open的返回值</li>
<li>buf - 缓冲区, 存放读取的数据</li>
<li>count – 缓冲区的最大容量 sizeof(buf)</li>
</ul>
</li>
<li><p>返回值:</p>
<ul>
<li>-1: 失败</li>
<li>>0: 读出的字节数</li>
<li>=0: 文件读完了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><ul>
<li><p>函数原型: ssize_t write(int fd, const void *buf, size_t count);</p>
<ul>
<li><p>参数:</p>
<ul>
<li>fd: 文件描述符, open 返回值</li>
<li>buf: 要往文件中写的数据</li>
<li>count: 有效数据的长度</li>
</ul>
</li>
<li><p>返回值:</p>
<ul>
<li>-1: 失败</li>
<li>>0: 写入的字节数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h2><ul>
<li><p>函数原型: off_t lseek(int fd, off_t offset, int whence);</p>
<ul>
<li>SEEK_SET</li>
<li>SEEK_CUR</li>
<li>SEEK_END</li>
</ul>
</li>
<li><p>使用:</p>
<ul>
<li>文件指针移动到头部:</li>
<li>lseek(fd, 0, SEEK_SET);</li>
</ul>
</li>
<li><p>获取文件指针当前的位置:</p>
<ul>
<li>int len = lseek(fd, 0, SEEK_CUR);</li>
</ul>
</li>
<li><p>获取文件长度:</p>
<ul>
<li>int len = lseek(fd, 0, SEEK_END);</li>
</ul>
</li>
<li><p>文件拓展</p>
<ul>
<li>文件原大小100k， 拓展为1100k</li>
<li><p>lseek(fd, 1000, SEE_END);</p>
</li>
<li><p>最后做一次写操作write(fd, “a”, 1);</p>
</li>
</ul>
</li>
</ul>
<h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><ul>
<li><p>阻塞和非阻塞是文件的属性还是read函数的属性?</p>
<ul>
<li><p>文件的属性</p>
</li>
<li><p>普通文件：hello.c</p>
<ul>
<li>默认不阻塞</li>
</ul>
</li>
<li><p>终端设备：/dev/tty</p>
<ul>
<li>默认阻塞</li>
<li>管道</li>
<li>套接字</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="02-stat-lstat函数"><a href="#02-stat-lstat函数" class="headerlink" title="02-stat/lstat函数"></a>02-stat/lstat函数</h1><h2 id="获取文件属性"><a href="#获取文件属性" class="headerlink" title="获取文件属性"></a>获取文件属性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>st_mode – 16位整数</p>
</li>
<li><p>0-2 bit – 其他人权限</p>
<ul>
<li>S_IROTH      00004  读权限</li>
<li>S_IWOTH    00002  写权限</li>
<li>S_IXOTH      00001  执行权限</li>
<li>S_IRWXO     00007         掩码, 过滤        st_mode中除其他人权限以外的信息</li>
<li>3-5 bit – 所属组权限<ul>
<li>S_IRGRP      00040  读权限</li>
<li>S_IWGRP    00020  写权限</li>
<li>S_IXGRP      00010   执行权限</li>
<li>S_IRWXG    00070  掩码, 过滤        st_mode中除所属组权限以外的信息</li>
</ul>
</li>
<li>6-8 bit – 文件所有者权限<ul>
<li>S_IRUSR      00400    读权限</li>
<li>S_IWUSR    00200    写权限</li>
<li>S_IXUSR      00100     执行权限</li>
<li>S_IRWXU   00700     掩码, 过滤        st_mode中除文件所有者权限以外的信息</li>
</ul>
</li>
<li>12-15 bit – 文件类型<ul>
<li>S_IFSOCK         0140000 套接字</li>
<li>S_IFLNK            0120000 符号链接（软链接）</li>
<li>S_IFREG            0100000 普通文件</li>
<li>S_IFBLK             0060000 块设备</li>
<li>S_IFDIR             0040000 目录</li>
<li>S_IFCHR           0020000 字符设备</li>
<li>S_IFIFO             0010000 管道</li>
<li>S_IFMT        0170000 掩码,过滤        st_mode中除文件类型以外的信息(st_mode &amp; S_IFMT) ==  S_IFREG</li>
</ul>
</li>
</ul>
</li>
<li><p>int stat(const char <em>path,      struct stat </em>buf);</p>
</li>
<li><p>int lstat(const char <em>path,      struct stat </em>buf);</p>
<ul>
<li>lstat读取的链接文件本身的属性</li>
<li><p>stat读取的是连接文件指向的文件的属性</p>
<ul>
<li>追踪，穿透</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="03-文件属性函数"><a href="#03-文件属性函数" class="headerlink" title="03-文件属性函数"></a>03-文件属性函数</h1><h2 id="测试当前用户指定文件是否具有某种属性"><a href="#测试当前用户指定文件是否具有某种属性" class="headerlink" title="测试当前用户指定文件是否具有某种属性"></a>测试当前用户指定文件是否具有某种属性</h2><ul>
<li><p>当前用户, 使用哪个用户调用这个函数, 这个用户就是当前用户</p>
</li>
<li><p>int access(const char *pathname,      int mode);</p>
</li>
<li><ul>
<li>参数:<ul>
<li>pathname: 文件名</li>
<li>mode: 4种权限</li>
<li>R_OK – 读 </li>
<li>W_OK – 写 </li>
<li>X_OK – 执行 </li>
<li>F_OK – 文件是否存在</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>返回值:</li>
<li>0 - 有某种权限, 或者文件存在</li>
<li>1 - 没有, 或文件不存在</li>
</ul>
</li>
</ul>
<h2 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h2><ul>
<li><p>int chmod(const char *filename,       int mode);</p>
<ul>
<li><ul>
<li><p>参数:</p>
</li>
<li><ul>
<li>filename: 文件名</li>
<li>mode: 文件权限, 八进制数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="修改文件所有者和所属组"><a href="#修改文件所有者和所属组" class="headerlink" title="修改文件所有者和所属组"></a>修改文件所有者和所属组</h2><ul>
<li><p>int chown(const char *path,       uid_t owner, gid_t group);</p>
<ul>
<li><p>函数参数:</p>
</li>
<li><ul>
<li><p>path – 文件路径</p>
</li>
<li><p>owner – 整形值, 用户ID </p>
</li>
<li><ul>
<li>/etc/passwd</li>
</ul>
</li>
<li><p>group – …..,        组ID                </p>
</li>
<li><ul>
<li>/etc/group</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="修改文件大小"><a href="#修改文件大小" class="headerlink" title="修改文件大小"></a>修改文件大小</h2><ul>
<li><p>int truncate(const char *path,       off_t length);</p>
</li>
<li><p>参数: </p>
</li>
<li><ul>
<li>path – 文件名</li>
<li>length – 文件的最终大小<ul>
<li>\1. 比原来小, 删掉后边的部分</li>
<li>\2. 比原来大, 向后拓展</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="04-目录操作相关函数"><a href="#04-目录操作相关函数" class="headerlink" title="04-目录操作相关函数"></a>04-目录操作相关函数</h1><ol>
<li><h2 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h2></li>
</ol>
<ul>
<li>int rename(const char <em>oldpath, const char </em>newpath);</li>
</ul>
<ol start="2">
<li><h2 id="修改当前进程-应用程序-的路径-cd"><a href="#修改当前进程-应用程序-的路径-cd" class="headerlink" title="修改当前进程(应用程序)的路径 cd"></a>修改当前进程(应用程序)的路径 cd</h2></li>
</ol>
<ul>
<li><p>int chdir(const char *path);</p>
<ul>
<li>参数: 切换的路径</li>
</ul>
</li>
</ul>
<ol start="3">
<li><h2 id="获取当前进程的工作目录-pwd"><a href="#获取当前进程的工作目录-pwd" class="headerlink" title="获取当前进程的工作目录 pwd"></a>获取当前进程的工作目录 pwd</h2></li>
</ol>
<ul>
<li><p>char <em>getcwd(char </em>buf, size_t size);</p>
<ul>
<li><p>返回值:</p>
<ul>
<li>成功: 当前的工作目录</li>
<li>失败: NULL</li>
</ul>
</li>
<li><p>参数:</p>
<ul>
<li>buf: 缓冲区, 存储当前的工作目录</li>
<li>size: 缓冲区大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li><h2 id="创建目录-mkdir"><a href="#创建目录-mkdir" class="headerlink" title="创建目录 mkdir"></a>创建目录 mkdir</h2></li>
</ol>
<ul>
<li><p>int mkdir(const char *pathname,       mode_t mode);</p>
<ul>
<li>参数:<ul>
<li>pathname: 创建的目录名</li>
<li>mode: 目录权限, 八进制的数, 实际权限: mode &amp; ~umask</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="5">
<li><h2 id="删除一个空目录"><a href="#删除一个空目录" class="headerlink" title="删除一个空目录"></a>删除一个空目录</h2></li>
</ol>
<ul>
<li><p>int rmdir(const char       *pathname);</p>
<ul>
<li>参数: 空目录的名字</li>
</ul>
</li>
</ul>
<h1 id="05-目录遍历相关函数"><a href="#05-目录遍历相关函数" class="headerlink" title="05-目录遍历相关函数"></a>05-目录遍历相关函数</h1><ol>
<li><h2 id="打开一个目录"><a href="#打开一个目录" class="headerlink" title="打开一个目录"></a>打开一个目录</h2><ul>
<li><p>DIR <em>opendir(const char </em>name);</p>
</li>
<li><ul>
<li>参数: 目录名</li>
<li>返回值: 指向目录的指针</li>
</ul>
</li>
<li><p>FILE* fp = fopen（）</p>
</li>
<li><p>fread（buf， len， len，fp）；</p>
</li>
</ul>
</li>
<li><h2 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct dirent</span><br><span class="line">&#123;</span><br><span class="line">    ino_t d_ino;                         // 此目录进入点的inode</span><br><span class="line">    ff_t d_off;                             // 目录文件开头至此目录进入点的位移</span><br><span class="line">    signed short int d_reclen; // d_name 的长度, 不包含NULL 字符</span><br><span class="line">    unsigned char d_type;      // d_name 所指的文件类型 </span><br><span class="line">    har d_name[256];	       // 文件名</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>d_type</p>
<ul>
<li>DT_BLK - 块设备</li>
<li>DT_CHR - 字符设备</li>
<li>DT_DIR - 目录</li>
<li>DT_LNK - 软连接</li>
<li>DT_FIFO - 管道</li>
<li>DT_REG - 普通文件</li>
<li>DT_SOCK - 套接字</li>
<li>DT_UNKNOWN - 未知 </li>
</ul>
</li>
<li><p>struct dirent <em>readdir(DIR      </em>dirp);</p>
<ul>
<li>参数: opendir的返回值</li>
<li>返回值: 目录项结构体 </li>
</ul>
</li>
</ul>
<ol start="3">
<li><h2 id="关闭目录"><a href="#关闭目录" class="headerlink" title="关闭目录"></a>关闭目录</h2><ul>
<li>int closedir(DIR *dirp);</li>
</ul>
</li>
<li><h2 id="独立完成递归读目录中指定类型文件个数的操作"><a href="#独立完成递归读目录中指定类型文件个数的操作" class="headerlink" title="独立完成递归读目录中指定类型文件个数的操作."></a>独立完成递归读目录中指定类型文件个数的操作.</h2></li>
</ol>
<h1 id="06-dup-dup2-fcntl"><a href="#06-dup-dup2-fcntl" class="headerlink" title="06-dup-dup2-fcntl"></a>06-dup-dup2-fcntl</h1><ol>
<li><p>复制文件描述符</p>
<ul>
<li><p>int dup(int oldfd);</p>
</li>
<li><ul>
<li><p>oldfd - 要复制的文件描述符</p>
</li>
<li><p>返回值: 新的文件描述符</p>
</li>
<li><p>dup调用成功:</p>
</li>
<li><ul>
<li>有两个文件描述符指向同一个文件</li>
</ul>
</li>
<li><p>返回值: 取最小的且没被占用的文件描述符</p>
</li>
</ul>
</li>
<li><p>int dup2(int oldfd, int newfd);</p>
</li>
<li><ul>
<li><p>oldfd -》hello</p>
</li>
<li><p>newfd -》world</p>
</li>
<li><ul>
<li><p>假设newfd已经指向了一个文件，首先断开close与那个文件的链接，newfd指向oldfd指向的文件</p>
</li>
<li><ul>
<li>文件描述符重定向</li>
</ul>
</li>
<li><ul>
<li>oldfd和newfd指向同一个文件</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>newfd没有被占用，newfd指向oldfd指向的文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>改变已经打开的文件的属性: fcntl</p>
</li>
</ol>
<ul>
<li><p>变参函数</p>
</li>
<li><p>复制一个已有的文件描述符</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int ret = fcntl(fd, F_DUPFD);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>获取/设置文件状态标志</p>
</li>
<li><ul>
<li>open 的flags参数</li>
</ul>
</li>
</ul>
<ol>
<li>获取文件状态标识</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int flag = fcntl(fd, F_GETFL)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>设置文件状态标识</li>
</ol>
<ul>
<li>flag = flag      | O_APPEND;</li>
<li><p>fcntl(fd,      F_SETFL, flag)</p>
</li>
<li><p>可以更改的几个标识: O_APPEND、O_NONBLOCK （常用）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>操作系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>春招实习面经</title>
    <url>/2019/03/15/2019-03-15/</url>
    <content><![CDATA[<h1 id="3-15腾讯提前批一面（35分钟）"><a href="#3-15腾讯提前批一面（35分钟）" class="headerlink" title="3.15腾讯提前批一面（35分钟）"></a>3.15腾讯提前批一面（35分钟）</h1><p>第一次电话面试，而且是腾讯的，真的感觉特别紧张。虽然面试官小哥哥人特别好，一直在缓解气氛，但总体还是感觉状态不是很好。不管结果怎么样，先记录下这次所涉及到的知识点吧。</p>
<h2 id="自我介绍："><a href="#自我介绍：" class="headerlink" title="自我介绍："></a>自我介绍：</h2><p>有点紧张，把大概经历说了一下。</p>
<h2 id="为什么投腾讯，以及企业文化："><a href="#为什么投腾讯，以及企业文化：" class="headerlink" title="为什么投腾讯，以及企业文化："></a>为什么投腾讯，以及企业文化：</h2><p>谈到了百度狼性文化，其实之前看过一些相关的企业文化，但没有太深入取看。整体感觉有点不好。</p>
<h2 id="问题1：C-和Python有什么区别-各有什么特点。"><a href="#问题1：C-和Python有什么区别-各有什么特点。" class="headerlink" title="问题1：C++和Python有什么区别?各有什么特点。"></a>问题1：C++和Python有什么区别?各有什么特点。</h2><p>答：有点记不太清楚怎么回答的了。总之答得很不专业。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>程序有两种执行方式，解释执行和编译执行。<br>PYTHON是一种脚本语言，是解释执行的，不需要经过编译，所以很方便快捷，且能够很好地跨平台，写一些小工具小程序特别合适。<br>而C++则是一种需要编译后运行语言，在特定的机器上编译后在特定的机上运行，运行效率高，安全稳定。但编译后的程序一般是不跨平台的。 </p>
<p>学习一种编程语言不能看它热不热。而是要看它在某个领域的作用。就像汇编，虽然现在不热了，但是它在某些行业内还是很吃香的。PYTHON确实很强大，但在三五年内，不会作为一种主流的编程语言。至少在Windows程序开发领域内不会。 </p>
<p>A、解释程序<br>所谓解释程序是高级语言翻译程序的一种，它将源语言(如BASIC)书写的源程序作为输入，解释一句后就提交计算机执行一句，并不形成目标程序。就像外语翻译中的“口译”一样，说一句翻一句，不产生全文的翻译文本。这种工作方式非常适合于人通过终端设备与计算机会话，如在终端上打一条命令或语句，解释程序就立即将此语句解释成一条或几条指令并提交硬件立即执行且将执行结果反映到终端，从终端把命令打入后，就能立即得到计算结果。这的确是很方便的，很适合于一些小型机的计算问题。但解释程序执行速度很慢，例如源程序中出现循环，则解释程序也重复地解释并提交执行这一组语句，这就造成很大浪费。<br>B、编译程序<br>这是一类很重要的语言处理程序，它把高级语言(如FORTRAN、COBOL、Pascal、C等)源程序作为输入，进行翻译转换，产生出机器语言的目标程序，然后再让计算机去执行这个目标程序，得到计算结果。<br>编译程序工作时，先分析，后综合，从而得到目标程序。所谓分析，是指词法分析和语法分析；所谓综合是指代码优化，存储分配和代码生成。为了完成这些分析综合任务，编译程序采用对源程序进行多次扫描的办法，每次扫描集中完成一项或几项任务，也有一项任务分散到几次扫描去完成的。下面举一个四遍扫描的例子：第一遍扫描做词法分析；第二遍扫描做语法分析；第三遍扫描做代码优化和存储分配；第四遍扫描做代码生成。<br>值得一提的是，大多数的编译程序直接产生机器语言的目标代码，形成可执行的目标文件，但也有的编译程序则先产生汇编语言一级的符号代码文件，然后再调用汇编程序进行翻译加工处理，最后产生可执行的机器语言目标文件。<br>在实际应用中，对于需要经常使用的有大量计算的大型题目，采用招待速度较快的编译型的高级语言较好，虽然编译过程本身较为复杂，但一旦形成目标文件，以后可多次使用。相反，对于小型题目或计算简单不太费机时的题目，则多选用解释型的会话式高级语言，如BASIC，这样可以大大缩短编程及调试的时</p>
<h4 id="简短概述"><a href="#简短概述" class="headerlink" title="简短概述"></a>简短概述</h4><p>解释执行:<br>由解释器根据输入的数据当场执行而不生成任何的目标程序<br>编译执行: </p>
<p>先将源代码编译成目标语言(如:机器语言)之后通过连接程序连接到生成的目标程序进行执行</p>
<h2 id="问题2：网络传输-层的协议，概述UDP与TCP。"><a href="#问题2：网络传输-层的协议，概述UDP与TCP。" class="headerlink" title="问题2：网络传输 层的协议，概述UDP与TCP。"></a>问题2：网络传输 层的协议，概述UDP与TCP。</h2><p>答：举了电话通话与邮件发送的例子，由于紧张有些语无伦次。</p>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>1.TCP面向连接（如打电话前需拨号确认连接）；UDP是无连接的（发送数据前不需要建立连接）<br>2.TCP提供可靠服务（数据无差错，不流失，不重复，有重传机制，且按序到达）；UDP尽力最大交付（不保证可靠，无重传机制，无序）<br>3.TCP面向字节流（把数据看成一连串无结构的字符流，每次取多少由主机决定）；UDP面向报文（发送多少接收多少）<br>4.TCP无界（通过字节流传输，字节流太长会拆分，太短会等待，接收方确认才会删除缓冲区；如服务器缓冲区足够大，则多次传输一次接收，被认为无界）；<br>   UDP有界（不拆分不合并，几次传输几次接收，被认为有界）<br>5.TCP有流量控制和拥塞控制（接收方让发送方的速度调节）；UDP没有流量控制（不会改变）</p>
<p>6.TCP的头部（20bytes）比UDP大</p>
<h2 id="问题3：UDP与TCP协议应用举例"><a href="#问题3：UDP与TCP协议应用举例" class="headerlink" title="问题3：UDP与TCP协议应用举例"></a>问题3：UDP与TCP协议应用举例</h2><p>答：举了IP电话与在线传输文件的例子，感觉答得不是很好。</p>
<h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><p>什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… </p>
<p>什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……有些应用场景对可靠性要求不高会用到UPD，比如长视频，要求速率</p>
<h2 id="项目相关："><a href="#项目相关：" class="headerlink" title="项目相关："></a>项目相关：</h2><p>问到是否做过web项目，谈到了项目，其实之前跟着网课做过一些小项目，但自我感觉不是什么大项目，就没敢说。后来说了一些爬虫时的经历，以及自己搭建的博客。</p>
<h2 id="问题4：git相关命令"><a href="#问题4：git相关命令" class="headerlink" title="问题4：git相关命令"></a>问题4：git相关命令</h2><p>答：好久没用过git，许多命令其实忘得差不多了。</p>
<h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h3><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/git.png" alt></p>
<h2 id="ACM比赛相关："><a href="#ACM比赛相关：" class="headerlink" title="ACM比赛相关："></a>ACM比赛相关：</h2><p>一些比赛经历以及有什么帮助。</p>
<h2 id="问题5：快排与堆排"><a href="#问题5：快排与堆排" class="headerlink" title="问题5：快排与堆排"></a>问题5：快排与堆排</h2><p>答：数据结构部分还是比较擅长的，虽然优化部分由于紧张有点记不太清楚了。</p>
<h3 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h3><p>快速排序使用了分治法的策略。它的基本思想是，选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。可以看出，快速排序很重要的一点就是对基准数的选择。影响快速排序性能的因素除了本身数组的有序程度，还和这个基准数有关。在下面的代码中，我们使用最经典的，选择数组的第一个数作为基准数。</p>
<p>快速排序流程如下：</p>
<p>(1)从数列中挑出一个基准值。</p>
<p>(2)将所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面(相同的数可以到任一边)；在这个分区退出之后，该基准就处于数列的中间位置。</p>
<p>(3)递归地把”基准值前面的子数列”和”基准值后面的子数列”进行排序。</p>
<p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</p>
<h2 id="学习情况："><a href="#学习情况：" class="headerlink" title="学习情况："></a>学习情况：</h2><p>浏览CSDN博客，看网课，看书。</p>
<h1 id="3-18作业帮笔试"><a href="#3-18作业帮笔试" class="headerlink" title="3.18作业帮笔试"></a>3.18作业帮笔试</h1><h2 id="作业帮笔试"><a href="#作业帮笔试" class="headerlink" title="作业帮笔试"></a>作业帮笔试</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>1~2048有多少个1。</p>
<h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><p>千位上为1共有1000个（1000~1999）</p>
<p>百位上为1共有2 * 100 = 200个（100~199， 1100~1199）</p>
<p>十位上为1共有21 * 10 = 210个（XX10~XX19，XX∈[0，20]）</p>
<p>个位上为1共有205个（不多说了，自行脑补）</p>
<p>一共有1000+200+210+205 = 1615个</p>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>给出树的前序与中序遍历，求后序。</p>
<h4 id="解法：-1"><a href="#解法：-1" class="headerlink" title="解法："></a>解法：</h4><p>不多说了，不会的话自行面壁。</p>
<h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><p>死锁产生的条件。</p>
<h4 id="解法：-2"><a href="#解法：-2" class="headerlink" title="解法："></a>解法：</h4><p>互斥条件，请求与保持条件，不可抢夺条件，循环等待条件。</p>
<h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><p>0，2，3，5，9，17，31，57，___</p>
<h4 id="解法：-3"><a href="#解法：-3" class="headerlink" title="解法："></a>解法：</h4><p>105（17+31+57）</p>
<h3 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h3><p>2019！末尾有多少个0</p>
<h4 id="解法：-4"><a href="#解法：-4" class="headerlink" title="解法："></a>解法：</h4><p>重点在于质因数的运用，要点如下 </p>
<p>1、基本的一点，2<em>5=10，得到1个0 可以写成2^1</em>5^1=10^1 </p>
<p>2、进一步，4<em>25=100，得到2个0 可以写成2^2</em>5^2=10^2 </p>
<p>3、进一步，8<em>125=1000，得到3个0 可以写成2^3</em>5^3=10^3 </p>
<p>4、进一步，16<em>625=10000，得到4个0 可以写成2^4</em>5^4=10^4 </p>
<p>5、5^5=3125超过2015了，所以5次方以上不考虑 </p>
<p>6、不要担心双数的个数不够用，它会多出很多 </p>
<p>7、有了上面的1到4条，就可以计算了 (运算符<em>表示乘法，^表示乘方) </em></p>
<p>第一步，计算1到2015里多少个5,25,125,625 </p>
<p>1、2015÷5=403 记作A1；</p>
<p>2、2015÷25=80.6取整得80 记作A2； </p>
<p>3、2015÷125=16.12取整得16 记作A3； </p>
<p>4、2015÷625=3.224取整得3 记作A4； </p>
<p>第二步，计算上述A1到A4中重复的部分 </p>
<p>1、能被5整除的数里包含的能被25整除的数，记作B1 B1=A1-A2=403-80=323； </p>
<p>2、能被25整除的数里包含的能被125整除的数，记作B2 B2=A2-A3=80-16=64； </p>
<p>3、能被125整除的数里包含的能被625整除的数，记作B3 B3=A3-A4=16-3=13； </p>
<p>4、能被625整除的数里没有重复其它情况，直接计入结果，记作B4 B4=A4； </p>
<p>第三步，最终结果是 B1<em>1+B2</em>2+B3<em>3+B4</em>4=323+128+39+12=502………(1) </p>
<p>【答案】502个 最终结果也可以这样算： A1+A2+A3+A4=403+80+16+3=502 ………(2） 也就是 2015÷5+2015÷25+2015÷125+2015÷625 =403+80+16+3=502</p>
<h3 id="问题6"><a href="#问题6" class="headerlink" title="问题6"></a>问题6</h3><p>给出一列数，将其中所有的0放置末尾</p>
<p>例如1，2，0，3，0，4，则为1，2，3，4，0，0</p>
<h4 id="解法：-5"><a href="#解法：-5" class="headerlink" title="解法："></a>解法：</h4><p>两个指针，一个快指针，一个慢指针，如果快指针指向的数不为0，则快指针的值赋给慢指针，快指针慢指针均前进一步，否则快指针前进一步，慢指针不动。最后快指针指向尾了，如果慢指针没指向尾，之后的值全部为0。</p>
<h3 id="问题7"><a href="#问题7" class="headerlink" title="问题7"></a>问题7</h3><p>判断字符串是否为合法密码（长度大于8，含三类不同字符，且长度大于2的子串不能出现相同情况，例如A1abcdabc不合法，abc出现两次）</p>
<h4 id="解法：-6"><a href="#解法：-6" class="headerlink" title="解法："></a>解法：</h4><p>前两点太简单就不说了，第3点可以使用set每一次储存3个连续的字符，如果重复就不是合法的字符。</p>
<h3 id="问题8"><a href="#问题8" class="headerlink" title="问题8"></a>问题8</h3><p>5张牌斗牛，其中三张牌之和取余为0即为牛，剩余两张牌之和取余为几结果即为牛几。</p>
<h4 id="解法：-7"><a href="#解法：-7" class="headerlink" title="解法："></a>解法：</h4><p>5张牌只取个位数，然map记录下来，5张牌相加取余，然后依次减去其中一张牌，看得到的数字在map里存不存在，如果存在就说明有牛，牛就是5张牌相加的结果。也就是5张只和减两张看是不是0。相当于一层循环 ，On时间复杂度 </p>
<h1 id="3-19腾讯提前批二面（10分钟）"><a href="#3-19腾讯提前批二面（10分钟）" class="headerlink" title="3.19腾讯提前批二面（10分钟）"></a>3.19腾讯提前批二面（10分钟）</h1><h2 id="腾讯二面"><a href="#腾讯二面" class="headerlink" title="腾讯二面"></a>腾讯二面</h2><p>面试官好像是个技术总监，声音特别小，听的不是很清楚。总之10分钟结束，什么问题也没问，只留下一句之后等结果。然后就挂了，挂的莫名其妙。总结一下教训：</p>
<h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>尽量2分钟左右。要提到很高兴参加贵公司的面试。结尾尽量要客气。</p>
<h3 id="项目情况"><a href="#项目情况" class="headerlink" title="项目情况"></a>项目情况</h3><p>千万不要说项目少，小项目也可以提及，不然对方真以为自己没项目了。（惨痛的教训）</p>
<h3 id="比赛情况"><a href="#比赛情况" class="headerlink" title="比赛情况"></a>比赛情况</h3><p>其实敲代码没什么不好的，我们实习生本来就是应该干底层的（qyq）</p>
<h3 id="岗位期望"><a href="#岗位期望" class="headerlink" title="岗位期望"></a>岗位期望</h3><p>后台研发，我期望做……当然具体还是听从部门的安排，如果部门安排我做哪一块那我会听从部门的安排，然后尽快学习相关技能，尽快融入其中。</p>
<h3 id="实习计划"><a href="#实习计划" class="headerlink" title="实习计划"></a>实习计划</h3><p>1.首先尽快了解企业文化，了解部门规章制度，以便争取未来尽快融入。</p>
<p>2.了解所在团队的成员情况，分工，自己的角色和职责，以便更好的配合。</p>
<p>3.了解岗前应会的内容，及团队当前的主要工作及进展。</p>
<p>4.拟定工作计划，经组长审阅后按照计划推进。</p>
<p>5.自己会不断学习，积极寻求同事和领导的帮助。以达成更好的业绩。</p>
<h3 id="兴趣爱好"><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h3><p>切忌书生气，不能高谈阔论，一副兴趣广泛的样子。尽量要和职业贴近，否则就不要说的太多。</p>
<p>然后面试结束，没问任何专业相关问题，GG。</p>
<h1 id="3-20阿里一面（50分钟）"><a href="#3-20阿里一面（50分钟）" class="headerlink" title="3.20阿里一面（50分钟）"></a>3.20阿里一面（50分钟）</h1><h2 id="阿里首面"><a href="#阿里首面" class="headerlink" title="阿里首面"></a>阿里首面</h2><h3 id="问题1-1"><a href="#问题1-1" class="headerlink" title="问题1"></a>问题1</h3><p>C++指针与引用的区别及内存情况</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题2-1"><a href="#问题2-1" class="headerlink" title="问题2"></a>问题2</h3><p>智能指针问题</p>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题3-1"><a href="#问题3-1" class="headerlink" title="问题3"></a>问题3</h3><p>hash_map与map的区别，底层构造，时间复杂度，选择</p>
<h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题4-1"><a href="#问题4-1" class="headerlink" title="问题4"></a>问题4</h3><p>手写代码树的中序遍历</p>
<h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题5-1"><a href="#问题5-1" class="headerlink" title="问题5"></a>问题5</h3><p>vector的机制</p>
<h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题6-1"><a href="#问题6-1" class="headerlink" title="问题6"></a>问题6</h3><p>堆排序原理</p>
<h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题7-1"><a href="#问题7-1" class="headerlink" title="问题7"></a>问题7</h3><p>集合中，输出所有子集。</p>
<h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题8-1"><a href="#问题8-1" class="headerlink" title="问题8"></a>问题8</h3><p>红墨水蓝墨水问题</p>
<h4 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h4><p>一样多。</p>
<h3 id="现状及项目"><a href="#现状及项目" class="headerlink" title="现状及项目"></a>现状及项目</h3><h3 id="问题9"><a href="#问题9" class="headerlink" title="问题9"></a>问题9</h3><p>预处理以及#ifdef</p>
<h4 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h4><p>选择性编译</p>
<h3 id="问题10"><a href="#问题10" class="headerlink" title="问题10"></a>问题10</h3><p>awk命令</p>
<h4 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h4><h1 id="3-22西科"><a href="#3-22西科" class="headerlink" title="3.22西科"></a>3.22西科</h1><p>具体不多说了，培训班。</p>
<h1 id="3-27西山居笔试"><a href="#3-27西山居笔试" class="headerlink" title="3.27西山居笔试"></a>3.27西山居笔试</h1><p>空间换时间</p>
<p>改错</p>
<p>两个数组问题</p>
<p>三子棋</p>
<h1 id="3-28西山居一面（45分钟）"><a href="#3-28西山居一面（45分钟）" class="headerlink" title="3.28西山居一面（45分钟）"></a>3.28西山居一面（45分钟）</h1><ol>
<li><p>类内const如何初始化</p>
</li>
<li><p>代码规范化问题，以及析构函数与构造函数调用问题</p>
<p>1、C++中, 构造函数和析构函数可以被显示调用. 显示调用默认构造函数的语法: a.A::A();(不能写成a.A();) , 显示调用非默认构造函数的语法: a.A::A(7);(不能写成a.A(7);); 显示调用析构函数的语法: a.A::~A();(可以写成a.~A();) .</p>
<p>2、显示调用构造函数和析构函数就像调用一般的函数一样, 并不意味着创建或销毁对象;</p>
<p>3、如果构造函数中动态分配了空间, 则显示调用构造函数会造成内存泄露. 创建对象时的隐式构造函数调用已经为对象分配了动态内存，当用创建好的对象显示调用构造函数时, 对象指向的动态内存更新为显示调用时所分配的, 对象生命周期结束时析构函数所释放掉的是后一次分配的动态内存, 也就是说创建对象时隐式构造函数调用所分配的那块内存泄漏了.</p>
<p>4、如果析构函数中释放动态分配的空间, 则会造成多次释放同一内存, 会出现严重错误. </p>
</li>
<li><p>三子棋问题</p>
</li>
<li><p>C++虚函数及底层实现</p>
<p>虚函数表</p>
</li>
<li><p>容器及各自底层实现</p>
</li>
<li><p>结构体对齐</p>
</li>
<li><p>C++11特性</p>
</li>
<li><p>内联函数与宏定义</p>
</li>
<li><p>连连看寻路问题</p>
</li>
<li><p>双属性排序问题</p>
</li>
<li><p>字符串最大值问题</p>
</li>
<li><p>找bug，野指针问题</p>
</li>
<li><p>研发岗难度在哪方面（哪些方向）</p>
</li>
</ol>
<h1 id="3-29西山居二三四面"><a href="#3-29西山居二三四面" class="headerlink" title="3.29西山居二三四面"></a>3.29西山居二三四面</h1><h2 id="二面（30分钟）"><a href="#二面（30分钟）" class="headerlink" title="二面（30分钟）"></a>二面（30分钟）</h2><p>深挖项目</p>
<h2 id="三面（10分钟）"><a href="#三面（10分钟）" class="headerlink" title="三面（10分钟）"></a>三面（10分钟）</h2><p>笔试题</p>
<p>三子棋判断输赢</p>
<p>智能指针</p>
<h2 id="四面（45分钟）"><a href="#四面（45分钟）" class="headerlink" title="四面（45分钟）"></a>四面（45分钟）</h2><p>项目</p>
<p>比赛担当角色</p>
<p>虚函数表</p>
<p>模板</p>
<p>Dijkstra算法分析</p>
<p>Linux下两个pthread如何实现同步</p>
<p>socket编程IO多路复用及epoll</p>
<p>如何看待自己的组织能力</p>
<p>为何选择游戏开发</p>
<p>上岗时间及时间安排</p>
<h1 id="4-1东方财富一面（15分钟）"><a href="#4-1东方财富一面（15分钟）" class="headerlink" title="4.1东方财富一面（15分钟）"></a>4.1东方财富一面（15分钟）</h1><p>使用过哪些API</p>
<p>知道哪些设计模式</p>
<p>单例设计模式讲解</p>
<p>101个数(0, 100]，只有一个数出现两次，找出这个数。</p>
<h1 id="4-4声网一面（30分钟）"><a href="#4-4声网一面（30分钟）" class="headerlink" title="4.4声网一面（30分钟）"></a>4.4声网一面（30分钟）</h1><p>比赛相关</p>
<p>智能指针</p>
<p>shared于unique的区别</p>
<p>unique如何保证唯一性</p>
<p>unordered_map</p>
<p>map增删改查时间复杂度</p>
<p>splay伸展树</p>
<p>vector和list的区别</p>
<p>vector底层实现</p>
<p>项链染色问题</p>
<p>区间第k大查询（主席树）</p>
<p>dijkstra算法优化部分优化在哪里</p>
<p>优先队列的底层原理</p>
<p>斐波那契堆</p>
<p>虚函数表</p>
<p>何时必须用初始化列表(const类型，没有默认构造函数，引用)</p>
<p>编译时多态（模板，重载，宏函数）</p>
<p>运行时多态（虚函数）</p>
<h1 id="4-5腾讯笔试"><a href="#4-5腾讯笔试" class="headerlink" title="4.5腾讯笔试"></a>4.5腾讯笔试</h1><h1 id="4-9声网二面（30分钟）"><a href="#4-9声网二面（30分钟）" class="headerlink" title="4.9声网二面（30分钟）"></a>4.9声网二面（30分钟）</h1><p>项目</p>
<p>聊天室项目</p>
<p>找中位数</p>
<p>第k大数</p>
<p>矩阵n次方</p>
<h1 id="4-12阿里二面（25分钟）"><a href="#4-12阿里二面（25分钟）" class="headerlink" title="4.12阿里二面（25分钟）"></a>4.12阿里二面（25分钟）</h1><p>多态</p>
<p>调试</p>
<p>服务器正在运行程序如何调试</p>
<p>vector的reserve与resize区别</p>
<p>链表交叉结点</p>
<p>找中位数</p>
<p>n个硬盘每个损坏概率p，且m个硬盘坏掉概率——(p^m)*((1-p)^(n-m))</p>
<h1 id="4-14腾讯正式批一面（40分钟）"><a href="#4-14腾讯正式批一面（40分钟）" class="headerlink" title="4.14腾讯正式批一面（40分钟）"></a>4.14腾讯正式批一面（40分钟）</h1><p>爬虫项目介绍</p>
<p>如何反爬（不知道）</p>
<p>智能指针概述</p>
<p>遇到异常处理如何解决内存释放问题</p>
<p>如何处理未知异常（不知道）</p>
<p>仿函数（不知道）</p>
<p>用过stl哪些算法</p>
<p>A*搜索</p>
<p>Linux相关命令</p>
<p>如何判断某目录下某文件是否存在（find –name）</p>
<p>如何计算某目录下文件个数（C语言实现readdir）</p>
<p>多进程多线程相关</p>
<p>进程间通信方式</p>
<p>详细概述epoll</p>
<p>read返回值（返回值为长度。为0断开连接，-1为异常）</p>
<p>边沿触发（阻塞，非阻塞）</p>
<p>数据库了解多少</p>
<h1 id="4-21腾讯正式批二面（35分钟）"><a href="#4-21腾讯正式批二面（35分钟）" class="headerlink" title="4.21腾讯正式批二面（35分钟）"></a>4.21腾讯正式批二面（35分钟）</h1><p>答到最后都以为必挂了（虽然最后挺到HR了结果还是人满挂了）。真心感谢面试官手下留情(^人^)</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>TCP与UDP概述</p>
<p>可靠的UDP协议（不知道）</p>
<p>四次挥手过程</p>
<p>timewait在第几次挥手</p>
<p>timewait作用</p>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>智能指针相关</p>
<p>STL容器用过哪些</p>
<p>vector机制</p>
<p>deque机制</p>
<p>delete数组（好久没怎么复习了）</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>集合求子集</p>
<p>输出数组中唯一只有一个不重复元素</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>分页与分段的区别。</p>
<p>概述进程。</p>
<p>进程调度算法。</p>
<p>TCP拥塞算法。</p>
<h1 id="5-09字节跳动（45分钟）"><a href="#5-09字节跳动（45分钟）" class="headerlink" title="5.09字节跳动（45分钟）"></a>5.09字节跳动（45分钟）</h1><p>STL中各种set的底层实现</p>
<p>hashMap如何处理冲突</p>
<p>如何避免hashMap冲突</p>
<p>vector的push_back过程</p>
<p>vector的push_back插入平均时间复杂度及计算过程</p>
<p>python修饰器</p>
<p>tcp四次挥手过程</p>
<p>time_wait相关</p>
<p>http协议</p>
<p>tcp拥塞控制</p>
<p>编程题，数组中，每个数字为向后走的最大步数，至少需要几个数字到达最后一个位置。</p>
<p>进程间通信方式。</p>
<p>常用的信号。</p>
<p>socket的底层实现。</p>
<p>epoll与poll的区别。</p>
<h1 id="5-14百度（35分钟）"><a href="#5-14百度（35分钟）" class="headerlink" title="5.14百度（35分钟）"></a>5.14百度（35分钟）</h1><p>static相关</p>
<p>重载与重写</p>
<p>vector机制</p>
<p>string写时复制</p>
<p>虚拟内存</p>
<h1 id="5-22盛大"><a href="#5-22盛大" class="headerlink" title="5.22盛大"></a>5.22盛大</h1><p>虽然已经确定好方向了，但是offer还是没稳定下来。</p>
]]></content>
      <categories>
        <category>心路历程</category>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>温习C++继承与多态之打造简易回合制5V5小游戏</title>
    <url>/2019/03/11/2019-03-11/</url>
    <content><![CDATA[<p>曾几何时，网页游戏风靡整个网络世界，然而手机游戏的出现，如今的网页游戏已经渐渐销声匿迹了。</p>
<p>还记得我玩的第一款时间较长的网页游戏——龙将，如今服务器已关闭了，包括代理商“风行”如今也鲜为人知。其实那款游戏很简单，两个玩家对弈，双方每人出场5个英雄，按回合制以英雄的速度为先后顺序，每个英雄普通攻击或使用技能，直到一方的所有英雄全部死亡为止。所有攻击操作都是自动的，不需要我们操作，我们只需选择英雄上阵即可。</p>
<p>曾经想着什么时候能自己编一款类似的游戏，以便属性按照自己的想法设定。如今就简简单单实现一下吧。（超级粗略哦）</p>
<p>首先，我们来分析一下，每个英雄都有攻击属性，防御属性，速度，生命值，还有一些特殊的效果（暴击，吸血什么的啦），英雄可以装备武器，可以对敌方英雄造成伤害。那么我们先创建一个Hero类，它包含上述所有属性及方法。然后，每个英雄不同之处在于技能与被动技能，那我们利用多态来实现不同的技能。</p>
<p>再来分析一下武器，武器有基础属性和特殊属性，不同的武器属性不同，那么我们先创建一个基类Weapon类，该类函数声明为纯虚类，不可被继承，由派生来来实现具体功能即可。</p>
<p>英雄和武器写完之后，再创建一个国家类。由于英雄以国家而划分，所以每个国家由许多英雄类指针组成。</p>
<p>每个玩家有5个英雄，具体实现同国家类。</p>
<p>图示如下</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-3-11.png" alt></p>
<p>由于本人比较懒，写着写着又犯懒了，所以技能方面还没实现，每次都是普通攻击触发各种效果。不过目前可以正常运行。等哪天有时间了再继续改进吧。以下是代码：</p>
<p><strong>Weapon.h</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//抽象类</span><br><span class="line">class Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">	//获取基础伤害</span><br><span class="line">	virtual int getBaceDamage() = 0;</span><br><span class="line"></span><br><span class="line">	//获取防御</span><br><span class="line">	virtual int getBaceDef() = 0;</span><br><span class="line"></span><br><span class="line">	//获取吸血</span><br><span class="line">	virtual bool getSuckBlood() = 0;</span><br><span class="line"></span><br><span class="line">	//获取流血</span><br><span class="line">	virtual bool getHold() = 0;</span><br><span class="line"></span><br><span class="line">	static bool isTrigger(int rate);</span><br><span class="line"></span><br><span class="line">	string m_WeaponName;	//武器名</span><br><span class="line">	int m_BaceDamage;	//基础伤害</span><br><span class="line">	int BaceDef;	//基础防御</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Knife :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">	Knife();</span><br><span class="line">	//获取基础伤害</span><br><span class="line">	virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">	//获取防御</span><br><span class="line">	virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">	//获取吸血</span><br><span class="line">	virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">	//获取流血</span><br><span class="line">	virtual bool getHold();</span><br><span class="line"></span><br><span class="line">	int holdRate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DragonSword :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">	DragonSword();</span><br><span class="line">	//获取基础伤害</span><br><span class="line">	virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">	//获取防御</span><br><span class="line">	virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">	//获取吸血</span><br><span class="line">	virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">	//获取流血</span><br><span class="line">	virtual bool getHold();</span><br><span class="line"></span><br><span class="line">	int holdRate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Sword :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">	Sword();</span><br><span class="line">	//获取基础伤害</span><br><span class="line">	virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">	//获取防御</span><br><span class="line">	virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">	//获取吸血</span><br><span class="line">	virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">	//获取流血</span><br><span class="line">	virtual bool getHold();</span><br><span class="line"></span><br><span class="line">	int suckRate;</span><br><span class="line">	int holdRate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Shield :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">	Shield();</span><br><span class="line">	//获取基础伤害</span><br><span class="line">	virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">	//获取防御</span><br><span class="line">	virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">	//获取吸血</span><br><span class="line">	virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">	//获取流血</span><br><span class="line">	virtual bool getHold();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Spear :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">	Spear();</span><br><span class="line">	//获取基础伤害</span><br><span class="line">	virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">	//获取防御</span><br><span class="line">	virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">	//获取吸血</span><br><span class="line">	virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">	//获取流血</span><br><span class="line">	virtual bool getHold();</span><br><span class="line">	int suckRate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Bow :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">	Bow();</span><br><span class="line">	//获取基础伤害</span><br><span class="line">	virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">	//获取防御</span><br><span class="line">	virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">	//获取吸血</span><br><span class="line">	virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">	//获取流血</span><br><span class="line">	virtual bool getHold();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Book :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">	Book();</span><br><span class="line">	//获取基础伤害</span><br><span class="line">	virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">	//获取防御</span><br><span class="line">	virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">	//获取吸血</span><br><span class="line">	virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">	//获取流血</span><br><span class="line">	virtual bool getHold();</span><br><span class="line"></span><br><span class="line">	int suckRate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Fan :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">	Fan();</span><br><span class="line">	//获取基础伤害</span><br><span class="line">	virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">	//获取防御</span><br><span class="line">	virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">	//获取吸血</span><br><span class="line">	virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">	//获取流血</span><br><span class="line">	virtual bool getHold();</span><br><span class="line"></span><br><span class="line">	int holdRate;</span><br><span class="line">	int suckRate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Weapon.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;Weapon.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Knife::Knife()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;m_BaceDamage = 10;</span><br><span class="line">	this-&gt;BaceDef = 0;</span><br><span class="line">	this-&gt;holdRate = 30;</span><br><span class="line">	this-&gt;m_WeaponName = &quot;锋利匕首&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Knife::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Knife::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Knife::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Knife::getHold()</span><br><span class="line">&#123;</span><br><span class="line">	return isTrigger(this-&gt;holdRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DragonSword::DragonSword()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;m_BaceDamage = 20;</span><br><span class="line">	this-&gt;m_WeaponName = &quot;屠龙宝刀&quot;;</span><br><span class="line">	this-&gt;BaceDef = 10;</span><br><span class="line">	this-&gt;holdRate = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int DragonSword::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int DragonSword::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool DragonSword::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool DragonSword::getHold()</span><br><span class="line">&#123;</span><br><span class="line">	return isTrigger(this-&gt;holdRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Weapon::isTrigger(int rate)</span><br><span class="line">&#123;</span><br><span class="line">	if (rate &gt;= rand() % 100 + 1) &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sword::Sword()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;m_BaceDamage = 20;</span><br><span class="line">	this-&gt;m_WeaponName = &quot;倚天神剑&quot;;</span><br><span class="line">	this-&gt;BaceDef = 10;</span><br><span class="line">	this-&gt;suckRate = 10;</span><br><span class="line">	this-&gt;holdRate = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Sword::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Sword::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Sword::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">	return isTrigger(this-&gt;suckRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Sword::getHold()</span><br><span class="line">&#123;</span><br><span class="line">	return isTrigger(this-&gt;holdRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Shield::Shield()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;m_BaceDamage = 0;</span><br><span class="line">	this-&gt;m_WeaponName = &quot;刑天巨盾&quot;;</span><br><span class="line">	this-&gt;BaceDef = 70;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Shield::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Shield::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Shield::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Shield::getHold()</span><br><span class="line">&#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Spear::Spear()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;m_BaceDamage = 10;</span><br><span class="line">	this-&gt;m_WeaponName = &quot;亮银长枪&quot;;</span><br><span class="line">	this-&gt;BaceDef =20;</span><br><span class="line">	this-&gt;suckRate = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Spear::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Spear::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Spear::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">	return isTrigger(this-&gt;suckRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Spear::getHold()</span><br><span class="line">&#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Bow::Bow()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;m_BaceDamage = 70;</span><br><span class="line">	this-&gt;m_WeaponName = &quot;射日神弓&quot;;</span><br><span class="line">	this-&gt;BaceDef = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Bow::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Bow::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Bow::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Bow::getHold()</span><br><span class="line">&#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Book::Book()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;m_BaceDamage = 0;</span><br><span class="line">	this-&gt;m_WeaponName = &quot;遁甲天书&quot;;</span><br><span class="line">	this-&gt;BaceDef = 10;</span><br><span class="line">	this-&gt;suckRate = 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Book::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Book::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Book::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">	return isTrigger(this-&gt;suckRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Book::getHold()</span><br><span class="line">&#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Fan::Fan()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;m_BaceDamage = 30;</span><br><span class="line">	this-&gt;m_WeaponName = &quot;朱雀羽扇&quot;;</span><br><span class="line">	this-&gt;BaceDef = 0;</span><br><span class="line">	this-&gt;suckRate = 10;</span><br><span class="line">	this-&gt;holdRate = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Fan::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Fan::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Fan::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">	return isTrigger(this-&gt;suckRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Fan::getHold()</span><br><span class="line">&#123;</span><br><span class="line">	return isTrigger(this-&gt;holdRate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Hero.h</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&quot;Weapon.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">class Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	Hero();</span><br><span class="line">	int getHP();</span><br><span class="line">	int getMP();</span><br><span class="line">	int getAtk();</span><br><span class="line">	int getDef();</span><br><span class="line">	string getName();</span><br><span class="line">	bool action();</span><br><span class="line">	void getInf();</span><br><span class="line">	void attack(Hero*hero);</span><br><span class="line">	bool isRate(int rate);</span><br><span class="line">	void init_property();</span><br><span class="line">	virtual void skill(Hero * hero) = 0;</span><br><span class="line">	virtual void passive_skill() = 0;</span><br><span class="line"></span><br><span class="line">	bool isDeath;	//是否死亡</span><br><span class="line"></span><br><span class="line">	Weapon*weapon;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">	int max_HP;</span><br><span class="line">	int HP;	//血量</span><br><span class="line">	int MP;	//蓝量</span><br><span class="line">	int atk;	//攻击力</span><br><span class="line">	int def;	//防御力</span><br><span class="line">	int vel;	//速度</span><br><span class="line"></span><br><span class="line">	string name;	//姓名</span><br><span class="line">	string ctry;	//国家</span><br><span class="line">	int id;			//编号</span><br><span class="line">	string sex;		//性别</span><br><span class="line">	string skill_show;</span><br><span class="line">	string skill_name;</span><br><span class="line"></span><br><span class="line">	int wisdom;		//智慧</span><br><span class="line">	int strategy;	//谋略</span><br><span class="line">	int force;		//力量</span><br><span class="line">	int agility;	//敏捷</span><br><span class="line"></span><br><span class="line">	int crit;		//暴击</span><br><span class="line">	int stun;		//重击</span><br><span class="line">	int suckBlood;	//回血</span><br><span class="line">	int miss;		//闪避</span><br><span class="line"></span><br><span class="line">	bool isDiz;		//眩晕</span><br><span class="line">	bool isBleed;	//流血</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Hero.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&quot;hero.h&quot;</span><br><span class="line">#include &quot;Monster.h&quot;</span><br><span class="line">Hero::Hero()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;m_HP = 500;</span><br><span class="line">	this-&gt;m_Atk = 50;</span><br><span class="line">	this-&gt;m_Def = 50;</span><br><span class="line">	this-&gt;m_Name = &quot;靓仔&quot;;</span><br><span class="line">	this-&gt;weapon = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Hero::EquipWeapon(Weapon * weapon)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;weapon = weapon;</span><br><span class="line">	cout &lt;&lt; &quot;英雄&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;装备了&quot; &lt;&lt; this-&gt;weapon-&gt;m_WeaponName &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Hero::Attack(Monster * monster)</span><br><span class="line">&#123;</span><br><span class="line">	int damage = 0;</span><br><span class="line">	int addHP = 0;</span><br><span class="line">	bool isHold = false;</span><br><span class="line">	bool isCrit = false;</span><br><span class="line">	if (this-&gt;weapon == NULL) &#123;</span><br><span class="line">		damage = this-&gt;m_Atk;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		damage = this-&gt;m_Atk + this-&gt;weapon-&gt;getBaceDamage();</span><br><span class="line">		addHP = this-&gt;weapon-&gt;getSuckBlood();</span><br><span class="line">		isHold = this-&gt;weapon-&gt;getHold();</span><br><span class="line">		isCrit = this-&gt;weapon-&gt;getCrit();</span><br><span class="line">		if (addHP) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;英雄触发吸血效果，回血&quot; &lt;&lt; addHP &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		if (isCrit) &#123;</span><br><span class="line">			damage *= 2;</span><br><span class="line">			cout &lt;&lt; &quot;英雄触发暴击效果，怪兽受到双倍伤害&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		if (isHold) &#123;</span><br><span class="line">			monster-&gt;m_Hold = isHold;</span><br><span class="line">			cout &lt;&lt; &quot;英雄触发定身效果，怪兽停止行动一回合&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	damage = damage &gt; monster-&gt;m_Def ? damage - monster-&gt;m_Def : 1;</span><br><span class="line">	monster-&gt;m_HP -= damage;</span><br><span class="line">	this-&gt;m_HP += addHP;</span><br><span class="line">	cout &lt;&lt; &quot;英雄&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;对怪兽&quot; &lt;&lt; monster-&gt;m_Name &lt;&lt; &quot;造成了&quot; &lt;&lt; damage &lt;&lt; &quot;点伤害。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Country.h</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&quot;Hero.h&quot;</span><br><span class="line">#include&quot;Wei.h&quot;</span><br><span class="line">#include&quot;Shu.h&quot;</span><br><span class="line">#include&quot;Wu.h&quot;</span><br><span class="line">#include&quot;Qun.h&quot;</span><br><span class="line">#define NUM_HERO 12</span><br><span class="line">class Wei&#123;</span><br><span class="line">public:</span><br><span class="line">	Wei() &#123;</span><br><span class="line">		for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">			if (!vis[i]) &#123;</span><br><span class="line">				wei[i]-&gt;getInf();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	~Wei() &#123;</span><br><span class="line">		for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">			if (!vis[i]) &#123;</span><br><span class="line">				delete wei[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Hero*wei[NUM_HERO] = &#123;</span><br><span class="line">		new(CaoCao),</span><br><span class="line">		new(DianWei),</span><br><span class="line">		new(XuChu),</span><br><span class="line">		new(GuoJia),</span><br><span class="line">		new(XiaHouDun),</span><br><span class="line">		new(XiaHouYuan),</span><br><span class="line">		new(CaoRen),</span><br><span class="line">		new(ZhangLiao),</span><br><span class="line">		new(SiMaYi),</span><br><span class="line">		new(XuHuang),</span><br><span class="line">		new(ZhenJi),</span><br><span class="line">		new(CaiWenJi)</span><br><span class="line">	&#125;;</span><br><span class="line">	int vis[NUM_HERO] = &#123; false &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Shu&#123;</span><br><span class="line">public:</span><br><span class="line">	Shu() &#123;</span><br><span class="line">		for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">			if (!vis[i]) &#123;</span><br><span class="line">				shu[i]-&gt;getInf();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	~Shu() &#123;</span><br><span class="line">		for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">			if (!vis[i]) &#123;</span><br><span class="line">				delete shu[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Hero*shu[NUM_HERO] = &#123;</span><br><span class="line">		new(LiuBei),</span><br><span class="line">		new(GuanYu),</span><br><span class="line">		new(ZhangFei),</span><br><span class="line">		new(ZhuGeLiang),</span><br><span class="line">		new(ZhaoYun),</span><br><span class="line">		new(MaChao),</span><br><span class="line">		new(HuangZhong),</span><br><span class="line">		new(WeiYan),</span><br><span class="line">		new(HuangYueYing),</span><br><span class="line">		new(JiangWei),</span><br><span class="line">		new(PangTong),</span><br><span class="line">		new(SunShangXiang)</span><br><span class="line">	&#125;;</span><br><span class="line">	int vis[NUM_HERO] = &#123;false&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Wu&#123;</span><br><span class="line">public:</span><br><span class="line">	Wu() &#123;</span><br><span class="line">		for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">			if (!vis[i]) &#123;</span><br><span class="line">				wu[i]-&gt;getInf();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	~Wu() &#123;</span><br><span class="line">		for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">			if (!vis[i]) &#123;</span><br><span class="line">				delete wu[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Hero*wu[NUM_HERO] = &#123;</span><br><span class="line">		new(SunCe),</span><br><span class="line">		new(ZhouYu),</span><br><span class="line">		new(SunQuan),</span><br><span class="line">		new(DaQiao),</span><br><span class="line">		new(XiaoQiao),</span><br><span class="line">		new(HuangGai),</span><br><span class="line">		new(TaiShiCi),</span><br><span class="line">		new(GanNing),</span><br><span class="line">		new(LuSu),</span><br><span class="line">		new(LvMeng),</span><br><span class="line">		new(ZhangZhao),</span><br><span class="line">		new(ZhouTai)</span><br><span class="line">	&#125;;</span><br><span class="line">	int vis[NUM_HERO] = &#123; false &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Qun &#123;</span><br><span class="line">public:</span><br><span class="line">	Qun() &#123;</span><br><span class="line">		for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">			if (!vis[i]) &#123;</span><br><span class="line">				qun[i]-&gt;getInf();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	~Qun() &#123;</span><br><span class="line">		for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">			if (!vis[i]) &#123;</span><br><span class="line">				delete qun[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Hero*qun[NUM_HERO] = &#123;</span><br><span class="line">		new(LvBu),</span><br><span class="line">		new(DiaoChan),</span><br><span class="line">		new(HuaTuo),</span><br><span class="line">		new(YuanShao),</span><br><span class="line">		new(YanLiang),</span><br><span class="line">		new(WenChou),</span><br><span class="line">		new(ZuoCi),</span><br><span class="line">		new(HuaXiong),</span><br><span class="line">		new(GongSunZan),</span><br><span class="line">		new(ZhangJiao),</span><br><span class="line">		new(YuJi),</span><br><span class="line">		new(LingJu)</span><br><span class="line">	&#125;;</span><br><span class="line">	int vis[NUM_HERO] = &#123; false &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>User.h</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&quot;Country.h&quot;</span><br><span class="line">class User &#123;</span><br><span class="line">public:</span><br><span class="line">	Hero * hero[5];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>main.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&quot;Play.h&quot;</span><br><span class="line">int main() &#123;</span><br><span class="line">	play();</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Play.h</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&quot;Country.h&quot;</span><br><span class="line">#include&quot;User.h&quot;</span><br><span class="line">void test();</span><br><span class="line">void play();</span><br><span class="line">void show(User &amp;user);</span><br><span class="line">bool isDeath(User &amp; user);</span><br></pre></td></tr></table></figure>
<p><strong>Play.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&quot;Play.h&quot;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">void test() &#123;</span><br><span class="line">	Hero * hero_1 = new(ZhangFei);</span><br><span class="line">	Hero *hero_2 = new(GuanYu);</span><br><span class="line"></span><br><span class="line">	int round = 0;</span><br><span class="line">	while (true) &#123;</span><br><span class="line">		getchar();</span><br><span class="line">		system(&quot;cls&quot;);</span><br><span class="line">		cout &lt;&lt; &quot;当前第&quot; &lt;&lt; ++round &lt;&lt; &quot;回合开始&quot; &lt;&lt; endl;</span><br><span class="line">		hero_1-&gt;attack(hero_2);</span><br><span class="line">		if (hero_2-&gt;getHP() &lt;= 0) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;怪兽&quot; &lt;&lt; hero_2-&gt;getName() &lt;&lt; &quot;已死，游戏结束，你赢了&quot; &lt;&lt; endl;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		hero_2-&gt;attack(hero_1);</span><br><span class="line">		if (hero_1-&gt;getHP() &lt;= 0) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;英雄&quot; &lt;&lt; hero_1-&gt;getName() &lt;&lt; &quot;已死，游戏结束，你输了&quot; &lt;&lt; endl;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;英雄&quot; &lt;&lt; hero_1-&gt;getName() &lt;&lt; &quot;剩余血量：&quot; &lt;&lt; hero_1-&gt;getHP() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;怪兽&quot; &lt;&lt; hero_2-&gt;getName() &lt;&lt; &quot;剩余血量：&quot; &lt;&lt; hero_2-&gt;getHP() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	delete(hero_1);</span><br><span class="line">	delete(hero_2);</span><br><span class="line">&#125;</span><br><span class="line">void play() &#123;</span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	User user_1;</span><br><span class="line">	cout &lt;&lt; &quot;玩家一选择&quot; &lt;&lt; endl;</span><br><span class="line">	show(user_1);</span><br><span class="line">	User user_2;</span><br><span class="line">	cout &lt;&lt; &quot;玩家二选择&quot; &lt;&lt; endl;</span><br><span class="line">	show(user_2);</span><br><span class="line">	int round = 0;</span><br><span class="line">	while (true) &#123;</span><br><span class="line">		getchar();</span><br><span class="line">		system(&quot;cls&quot;);</span><br><span class="line">		cout &lt;&lt; &quot;当前第&quot; &lt;&lt; ++round &lt;&lt; &quot;回合开始&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			if (!user_1.hero[i]-&gt;isDeath) &#123;</span><br><span class="line">				int Tmp = rand() % 5;</span><br><span class="line">				while (user_2.hero[Tmp]-&gt;isDeath) &#123;</span><br><span class="line">					if (isDeath(user_2)) &#123;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					Tmp = rand() % 5;</span><br><span class="line">				&#125;</span><br><span class="line">				user_1.hero[i]-&gt;attack(user_2.hero[Tmp]);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				cout &lt;&lt; &quot;英雄&quot; &lt;&lt; user_1.hero[i]-&gt;getName() &lt;&lt; &quot;已阵亡。&quot; &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; &quot;**********&quot; &lt;&lt; endl;</span><br><span class="line">			if (!user_2.hero[i]-&gt;isDeath) &#123;</span><br><span class="line">				int Tmp = rand() % 5;</span><br><span class="line">				while (user_1.hero[Tmp]-&gt;isDeath) &#123;</span><br><span class="line">					if (isDeath(user_1)) &#123;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					Tmp = rand() % 5;</span><br><span class="line">				&#125;</span><br><span class="line">				user_2.hero[i]-&gt;attack(user_1.hero[Tmp]);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				cout &lt;&lt; &quot;英雄&quot; &lt;&lt; user_2.hero[i]-&gt;getName() &lt;&lt; &quot;已阵亡。&quot; &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; &quot;**********&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		if (isDeath(user_2)) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;Victory！&quot; &lt;&lt; endl;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (isDeath(user_1)) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;Defeat！&quot; &lt;&lt; endl;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;-------------------&quot; &lt;&lt; endl;</span><br><span class="line">		for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			if (!user_1.hero[i]-&gt;isDeath) &#123;</span><br><span class="line">				cout &lt;&lt; &quot;玩家1英雄&quot; &lt;&lt; user_1.hero[i]-&gt;getName() &lt;&lt; &quot;剩余血量&quot; &lt;&lt; user_1.hero[i]-&gt;getHP() &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				cout &lt;&lt; &quot;玩家1英雄&quot; &lt;&lt; user_1.hero[i]-&gt;getName() &lt;&lt; &quot;已阵亡。&quot; &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;-------------------&quot; &lt;&lt; endl;</span><br><span class="line">		for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			if (!user_2.hero[i]-&gt;isDeath) &#123;</span><br><span class="line">				cout &lt;&lt; &quot;玩家2英雄&quot; &lt;&lt; user_2.hero[i]-&gt;getName() &lt;&lt; &quot;剩余血量&quot; &lt;&lt; user_2.hero[i]-&gt;getHP() &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				cout &lt;&lt; &quot;玩家2英雄&quot; &lt;&lt; user_2.hero[i]-&gt;getName() &lt;&lt; &quot;已阵亡。&quot; &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool isDeath(User &amp; user) &#123;</span><br><span class="line">	int cnt;</span><br><span class="line">	for (cnt = 0; cnt &lt; 5; cnt++) &#123;</span><br><span class="line">		if (!user.hero[cnt]-&gt;isDeath) &#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (cnt &gt;= 5) &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">void show(User &amp;user)</span><br><span class="line">&#123;</span><br><span class="line">	int flag;</span><br><span class="line">	cout &lt;&lt; &quot;----------&quot; &lt;&lt; &quot;请选择您的阵营&quot; &lt;&lt; &quot;----------&quot; &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;---&quot; &lt;&lt; &quot;1.魏----2.蜀----3.吴----4.群&quot; &lt;&lt; &quot;---&quot; &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;----------&quot; &lt;&lt; &quot;--------------&quot; &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; flag;</span><br><span class="line">	int tmp[5];</span><br><span class="line">	Wei *wei;</span><br><span class="line">	Shu *shu;</span><br><span class="line">	Wu *wu;</span><br><span class="line">	Qun *qun;</span><br><span class="line">	switch (flag) &#123;</span><br><span class="line">	case 1:</span><br><span class="line">		cout &lt;&lt; &quot;您已加入魏国阵营，请选择5位武将&quot; &lt;&lt; endl;</span><br><span class="line">		wei = new Wei;</span><br><span class="line">		for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			cin &gt;&gt; tmp[i];</span><br><span class="line">			user.hero[i] = wei-&gt;wei[tmp[i]-1];</span><br><span class="line">			wei-&gt;vis[tmp[i]-1] = true;</span><br><span class="line">		&#125;</span><br><span class="line">		delete wei;</span><br><span class="line">		break;</span><br><span class="line">	case 2:</span><br><span class="line">		cout &lt;&lt; &quot;您已加入蜀国阵营，请选择5位武将&quot; &lt;&lt; endl;</span><br><span class="line">		shu = new Shu;</span><br><span class="line">		for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			cin &gt;&gt; tmp[i];</span><br><span class="line">			user.hero[i] = shu-&gt;shu[tmp[i]-1];</span><br><span class="line">			shu-&gt;vis[tmp[i]-1] = true;</span><br><span class="line">		&#125;</span><br><span class="line">		delete shu;</span><br><span class="line">		break;</span><br><span class="line">	case 3:</span><br><span class="line">		cout &lt;&lt; &quot;您已加入吴国阵营，请选择5位武将&quot; &lt;&lt; endl;</span><br><span class="line">		wu = new Wu;</span><br><span class="line">		for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			cin &gt;&gt; tmp[i];</span><br><span class="line">			user.hero[i] = wu-&gt;wu[tmp[i]-1];</span><br><span class="line">			wu-&gt;vis[tmp[i]-1] = true;</span><br><span class="line">		&#125;</span><br><span class="line">		delete wu;</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		cout &lt;&lt; &quot;您已加入群雄阵营，请选择5位武将&quot; &lt;&lt; endl;</span><br><span class="line">		qun = new Qun;</span><br><span class="line">		for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			cin &gt;&gt; tmp[i];</span><br><span class="line">			user.hero[i] = qun-&gt;qun[tmp[i]-1];</span><br><span class="line">			qun-&gt;vis[tmp[i]-1] = true;</span><br><span class="line">		&#125;</span><br><span class="line">		delete qun;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Wei.h</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&quot;Hero.h&quot;</span><br><span class="line"></span><br><span class="line">class CaoCao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	CaoCao();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DianWei :public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	DianWei();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class XuChu : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	XuChu();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class GuoJia : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	GuoJia();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class XiaHouDun : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	XiaHouDun();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class XiaHouYuan : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	XiaHouYuan();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CaoRen : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	CaoRen();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhangLiao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	ZhangLiao();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SiMaYi : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	SiMaYi();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class XuHuang : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	XuHuang();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhenJi : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	ZhenJi();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CaiWenJi : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	CaiWenJi();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Wei.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;Wei.h&quot;</span><br><span class="line"></span><br><span class="line">CaoCao::CaoCao()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;曹操&quot;;  //姓名</span><br><span class="line">	ctry = &quot;魏&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 1;			//编号</span><br><span class="line">	wisdom = 90;	//智慧</span><br><span class="line">	strategy = 92;	//谋略</span><br><span class="line">	force = 55;		//力量</span><br><span class="line">	agility = 28;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;天下归心&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Sword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CaoCao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CaoCao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">	this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">	this-&gt;atk += this-&gt;force;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DianWei::DianWei()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;典韦&quot;;  //姓名</span><br><span class="line">	ctry = &quot;魏&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 2;			//编号</span><br><span class="line">	wisdom = 54;	//智慧</span><br><span class="line">	strategy = 32;	//谋略</span><br><span class="line">	force = 100;	//力量</span><br><span class="line">	agility = 80;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;古之恶来&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DianWei::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DianWei::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;HP = ceil(this-&gt;HP*1.4);</span><br><span class="line">	this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">	this-&gt;def += floor(this-&gt;force*0.7);</span><br><span class="line">	this-&gt;atk = ceil(this-&gt;atk * 0.9);</span><br><span class="line">	this-&gt;suckBlood += 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XuChu::XuChu()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;许褚&quot;;  //姓名</span><br><span class="line">	ctry = &quot;魏&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 3;			//编号</span><br><span class="line">	wisdom = 50;	//智慧</span><br><span class="line">	strategy = 20;	//谋略</span><br><span class="line">	force = 98;		//力量</span><br><span class="line">	agility = 72;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;虎痴卸甲&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new DragonSword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XuChu::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XuChu::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;atk = floor(this-&gt;atk*1.3);</span><br><span class="line">	this-&gt;crit += 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GuoJia::GuoJia()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;郭嘉&quot;;  //姓名</span><br><span class="line">	ctry = &quot;魏&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 4;			//编号</span><br><span class="line">	wisdom = 100;	//智慧</span><br><span class="line">	strategy = 98;	//谋略</span><br><span class="line">	force = 5;		//力量</span><br><span class="line">	agility = 10;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;鬼才&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GuoJia::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GuoJia::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;vel += this-&gt;wisdom;</span><br><span class="line">	this-&gt;stun += 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XiaHouDun::XiaHouDun()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;夏侯惇&quot;;  //姓名</span><br><span class="line">	ctry = &quot;魏&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 5;			//编号</span><br><span class="line">	wisdom = 78;	//智慧</span><br><span class="line">	strategy = 56;	//谋略</span><br><span class="line">	force = 85;		//力量</span><br><span class="line">	agility = 72;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new DragonSword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XiaHouDun::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XiaHouDun::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;atk += 20;</span><br><span class="line">	this-&gt;stun += 50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XiaHouYuan::XiaHouYuan()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;夏侯渊&quot;;  //姓名</span><br><span class="line">	ctry = &quot;魏&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 6;			//编号</span><br><span class="line">	wisdom = 72;	//智慧</span><br><span class="line">	strategy = 65;	//谋略</span><br><span class="line">	force = 80;		//力量</span><br><span class="line">	agility = 95;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Bow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XiaHouYuan::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XiaHouYuan::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;vel = ceil(this-&gt;vel*1.3);</span><br><span class="line">	this-&gt;atk += this-&gt;strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CaoRen::CaoRen()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;曹仁&quot;;  //姓名</span><br><span class="line">	ctry = &quot;魏&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 7;			//编号</span><br><span class="line">	wisdom = 77;	//智慧</span><br><span class="line">	strategy = 80;	//谋略</span><br><span class="line">	force = 72;		//力量</span><br><span class="line">	agility = 70;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;无懈可击&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Shield;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CaoRen::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CaoRen::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;HP += 2000;</span><br><span class="line">	this-&gt;max_HP = HP;</span><br><span class="line">	this-&gt;def = ceil(this-&gt;def*1.2);</span><br><span class="line">	this-&gt;atk = floor(this-&gt;atk*0.4);</span><br><span class="line">	this-&gt;suckBlood += 80;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhangLiao::ZhangLiao()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;张辽&quot;;  //姓名</span><br><span class="line">	ctry = &quot;魏&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 8;			//编号</span><br><span class="line">	wisdom = 82;	//智慧</span><br><span class="line">	strategy = 80;	//谋略</span><br><span class="line">	force = 78;		//力量</span><br><span class="line">	agility = 80;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangLiao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangLiao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">	this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">	this-&gt;miss += 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SiMaYi::SiMaYi()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;司马懿&quot;;  //姓名</span><br><span class="line">	ctry = &quot;魏&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 9;			//编号</span><br><span class="line">	wisdom = 99;	//智慧</span><br><span class="line">	strategy = 100;	//谋略</span><br><span class="line">	force = 34;		//力量</span><br><span class="line">	agility = 45;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;狼顾之相&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Fan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SiMaYi::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SiMaYi::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">	this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">	this-&gt;atk += this-&gt;agility;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XuHuang::XuHuang()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;徐晃&quot;;  //姓名</span><br><span class="line">	ctry = &quot;魏&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 10;		//编号</span><br><span class="line">	wisdom = 75;	//智慧</span><br><span class="line">	strategy = 82;	//谋略</span><br><span class="line">	force = 82;		//力量</span><br><span class="line">	agility = 75;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;兵粮寸断&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new DragonSword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XuHuang::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XuHuang::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;atk += this-&gt;force;</span><br><span class="line">	this-&gt;stun += 15;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhenJi::ZhenJi()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;甄姬&quot;;  //姓名</span><br><span class="line">	ctry = &quot;魏&quot;;	//国家</span><br><span class="line">	sex = &quot;女&quot;;		//性别</span><br><span class="line">	id = 11;		//编号</span><br><span class="line">	wisdom = 80;	//智慧</span><br><span class="line">	strategy = 25;	//谋略</span><br><span class="line">	force = 20;		//力量</span><br><span class="line">	agility = 100;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;洛神降临&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhenJi::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhenJi::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;def += this-&gt;strategy * 0.5 + this-&gt;wisdom * 0.2;</span><br><span class="line">	this-&gt;miss += 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CaiWenJi::CaiWenJi()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;蔡文姬&quot;;//姓名</span><br><span class="line">	ctry = &quot;魏&quot;;	//国家</span><br><span class="line">	sex = &quot;女&quot;;		//性别</span><br><span class="line">	id = 12;		//编号</span><br><span class="line">	wisdom = 95;	//智慧</span><br><span class="line">	strategy = 35;	//谋略</span><br><span class="line">	force = 25;		//力量</span><br><span class="line">	agility = 55;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;胡笳之音&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CaiWenJi::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CaiWenJi::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">	this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">	this-&gt;stun += 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Shu.h</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&quot;Hero.h&quot;</span><br><span class="line"></span><br><span class="line">class LiuBei : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	LiuBei();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class GuanYu :public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	GuanYu();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhangFei : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	ZhangFei();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhuGeLiang : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	ZhuGeLiang();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhaoYun : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	ZhaoYun();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MaChao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	MaChao();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HuangZhong : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	HuangZhong();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class WeiYan : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	WeiYan();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HuangYueYing : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	HuangYueYing();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class JiangWei : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	JiangWei();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class PangTong : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	PangTong();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SunShangXiang : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	SunShangXiang();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Shu.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;Shu.h&quot;</span><br><span class="line"></span><br><span class="line">LiuBei::LiuBei()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;刘备&quot;;  //姓名</span><br><span class="line">	ctry = &quot;蜀&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 1;			//编号</span><br><span class="line">	wisdom = 72;	//智慧</span><br><span class="line">	strategy = 62;	//谋略</span><br><span class="line">	force = 60;		//力量</span><br><span class="line">	agility = 25;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;唯贤唯德&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Sword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LiuBei::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;MP = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LiuBei::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">	this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">	this-&gt;atk += this-&gt;strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GuanYu::GuanYu()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;关羽&quot;;  //姓名</span><br><span class="line">	ctry = &quot;蜀&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 2;			//编号</span><br><span class="line">	wisdom = 60;	//智慧</span><br><span class="line">	strategy = 60;	//谋略</span><br><span class="line">	force = 98;		//力量</span><br><span class="line">	agility = 90;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;春秋偃月&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new DragonSword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GuanYu::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;MP = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GuanYu::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;stun += 50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhangFei::ZhangFei()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;张飞&quot;;  //姓名</span><br><span class="line">	ctry = &quot;蜀&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 3;			//编号</span><br><span class="line">	wisdom = 70;	//智慧</span><br><span class="line">	strategy = 77;	//谋略</span><br><span class="line">	force = 100;		//力量</span><br><span class="line">	agility = 72;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;雷霆咆哮&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangFei::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;MP = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangFei::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;atk = floor(this-&gt;atk*0.9);</span><br><span class="line">	this-&gt;crit += 50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ZhuGeLiang::ZhuGeLiang()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;诸葛亮&quot;;  //姓名</span><br><span class="line">	ctry = &quot;蜀&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 4;			//编号</span><br><span class="line">	wisdom = 100;	//智慧</span><br><span class="line">	strategy = 100;	//谋略</span><br><span class="line">	force = 10;		//力量</span><br><span class="line">	agility = 32;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;卧龙啸天&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Fan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhuGeLiang::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;MP = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhuGeLiang::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;vel += 50;</span><br><span class="line">	this-&gt;atk += 50;</span><br><span class="line">	this-&gt;miss += 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhaoYun::ZhaoYun()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;赵云&quot;;  //姓名</span><br><span class="line">	ctry = &quot;蜀&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 5;			//编号</span><br><span class="line">	wisdom = 75;	//智慧</span><br><span class="line">	strategy = 80;	//谋略</span><br><span class="line">	force = 98;		//力量</span><br><span class="line">	agility = 100;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;七探蛇盘&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhaoYun::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;MP = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhaoYun::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;miss += 50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MaChao::MaChao()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;马超&quot;;  //姓名</span><br><span class="line">	ctry = &quot;蜀&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 6;			//编号</span><br><span class="line">	wisdom = 42;	//智慧</span><br><span class="line">	strategy = 20;	//谋略</span><br><span class="line">	force = 95;		//力量</span><br><span class="line">	agility = 94;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;西凉铁骑&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MaChao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MaChao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;vel *= 2;</span><br><span class="line">	this-&gt;crit += 30;</span><br><span class="line">	this-&gt;stun += 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuangZhong::HuangZhong()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;黄忠&quot;;  //姓名</span><br><span class="line">	ctry = &quot;蜀&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 7;			//编号</span><br><span class="line">	wisdom = 50;	//智慧</span><br><span class="line">	strategy = 45;	//谋略</span><br><span class="line">	force = 98;	//力量</span><br><span class="line">	agility = 72;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;百步穿杨&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Bow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuangZhong::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuangZhong::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;atk += 20;</span><br><span class="line">	this-&gt;stun += 50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WeiYan::WeiYan()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;魏延&quot;;  //姓名</span><br><span class="line">	ctry = &quot;蜀&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 8;			//编号</span><br><span class="line">	wisdom = 25;	//智慧</span><br><span class="line">	strategy = 75;	//谋略</span><br><span class="line">	force = 80;	//力量</span><br><span class="line">	agility = 75;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;傲骨风凉&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Shield;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WeiYan::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WeiYan::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;atk *= 1.5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuangYueYing::HuangYueYing()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;黄月英&quot;;//姓名</span><br><span class="line">	ctry = &quot;蜀&quot;;	//国家</span><br><span class="line">	sex = &quot;女&quot;;		//性别</span><br><span class="line">	id = 9;			//编号</span><br><span class="line">	wisdom = 99;	//智慧</span><br><span class="line">	strategy = 90;	//谋略</span><br><span class="line">	force = 5;		//力量</span><br><span class="line">	agility = 65;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;奇门遁甲&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuangYueYing::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuangYueYing::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;def += 50;</span><br><span class="line">	this-&gt;miss += 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JiangWei::JiangWei()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;姜维&quot;;  //姓名</span><br><span class="line">	ctry = &quot;蜀&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 10;		//编号</span><br><span class="line">	wisdom = 80;	//智慧</span><br><span class="line">	strategy = 92;	//谋略</span><br><span class="line">	force = 80;		//力量</span><br><span class="line">	agility = 90;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;幼麟之风&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void JiangWei::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void JiangWei::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PangTong::PangTong()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;庞统&quot;;  //姓名</span><br><span class="line">	ctry = &quot;蜀&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 11;		//编号</span><br><span class="line">	wisdom = 90;	//智慧</span><br><span class="line">	strategy = 94;	//谋略</span><br><span class="line">	force = 5;		//力量</span><br><span class="line">	agility = 18;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;火凤燎原&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Fan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PangTong::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PangTong::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;atk *= 1.2;</span><br><span class="line">	this-&gt;vel *= 1.2;</span><br><span class="line">	this-&gt;def *= 1.2;</span><br><span class="line">	this-&gt;miss += 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SunShangXiang::SunShangXiang()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;孙尚香&quot;;  //姓名</span><br><span class="line">	ctry = &quot;蜀&quot;;	//国家</span><br><span class="line">	sex = &quot;女&quot;;		//性别</span><br><span class="line">	id = 12;		//编号</span><br><span class="line">	wisdom = 56;	//智慧</span><br><span class="line">	strategy = 42;	//谋略</span><br><span class="line">	force = 65;		//力量</span><br><span class="line">	agility = 80;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;枭姬联姻&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Bow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SunShangXiang::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SunShangXiang::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;miss += 20;</span><br><span class="line">	this-&gt;stun += 20;</span><br><span class="line">	this-&gt;atk += 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Wu.h</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&quot;Hero.h&quot;</span><br><span class="line"></span><br><span class="line">class SunCe : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	SunCe();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhouYu :public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	ZhouYu();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SunQuan : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	SunQuan();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DaQiao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	DaQiao();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class XiaoQiao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	XiaoQiao();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HuangGai : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	HuangGai();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TaiShiCi : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	TaiShiCi();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class GanNing : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	GanNing();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LuSu : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	LuSu();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LvMeng : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	LvMeng();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhangZhao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	ZhangZhao();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhouTai : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	ZhouTai();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Wu.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;Wu.h&quot;</span><br><span class="line"></span><br><span class="line">SunCe::SunCe()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;孙策&quot;;  //姓名</span><br><span class="line">	ctry = &quot;吴&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 1;			//编号</span><br><span class="line">	wisdom = 78;	//智慧</span><br><span class="line">	strategy = 65;	//谋略</span><br><span class="line">	force = 100;	//力量</span><br><span class="line">	agility = 85;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;力拔山河&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SunCe::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SunCe::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">	this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">	this-&gt;atk += this-&gt;wisdom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhouYu::ZhouYu()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;周瑜&quot;;  //姓名</span><br><span class="line">	ctry = &quot;吴&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 2;			//编号</span><br><span class="line">	wisdom = 90;	//智慧</span><br><span class="line">	strategy = 98;	//谋略</span><br><span class="line">	force = 70;		//力量</span><br><span class="line">	agility = 80;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;业火焚天&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Sword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhouYu::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhouYu::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SunQuan::SunQuan()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;孙权&quot;;  //姓名</span><br><span class="line">	ctry = &quot;吴&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 3;			//编号</span><br><span class="line">	wisdom = 80;	//智慧</span><br><span class="line">	strategy = 80;	//谋略</span><br><span class="line">	force = 50;		//力量</span><br><span class="line">	agility = 60;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;气势汹汹&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Sword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SunQuan::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SunQuan::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DaQiao::DaQiao()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;大乔&quot;;  //姓名</span><br><span class="line">	ctry = &quot;吴&quot;;	//国家</span><br><span class="line">	sex = &quot;女&quot;;		//性别</span><br><span class="line">	id = 4;			//编号</span><br><span class="line">	wisdom = 85;	//智慧</span><br><span class="line">	strategy = 45;	//谋略</span><br><span class="line">	force = 30;		//力量</span><br><span class="line">	agility = 75;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;国色天香&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DaQiao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DaQiao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XiaoQiao::XiaoQiao()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;小乔&quot;;  //姓名</span><br><span class="line">	ctry = &quot;吴&quot;;	//国家</span><br><span class="line">	sex = &quot;女&quot;;		//性别</span><br><span class="line">	id = 5;			//编号</span><br><span class="line">	wisdom = 80;	//智慧</span><br><span class="line">	strategy = 40;	//谋略</span><br><span class="line">	force = 25;		//力量</span><br><span class="line">	agility = 85;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;玲珑之花&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XiaoQiao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XiaoQiao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuangGai::HuangGai()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;黄盖&quot;;  //姓名</span><br><span class="line">	ctry = &quot;吴&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 6;			//编号</span><br><span class="line">	wisdom = 65;	//智慧</span><br><span class="line">	strategy = 65;	//谋略</span><br><span class="line">	force = 85;		//力量</span><br><span class="line">	agility = 35;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;苦肉之计&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line">	this-&gt;weapon = new Shield;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuangGai::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuangGai::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaiShiCi::TaiShiCi()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;太史慈&quot;;  //姓名</span><br><span class="line">	ctry = &quot;吴&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 7;			//编号</span><br><span class="line">	wisdom = 70;	//智慧</span><br><span class="line">	strategy = 50;	//谋略</span><br><span class="line">	force = 90;		//力量</span><br><span class="line">	agility = 90;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;受宠打击&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Bow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TaiShiCi::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TaiShiCi::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GanNing::GanNing()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;甘宁&quot;;  //姓名</span><br><span class="line">	ctry = &quot;吴&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 8;			//编号</span><br><span class="line">	wisdom = 65;	//智慧</span><br><span class="line">	strategy = 75;	//谋略</span><br><span class="line">	force = 76;		//力量</span><br><span class="line">	agility = 80;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;百骑袭营&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Bow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GanNing::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GanNing::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LuSu::LuSu()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;鲁肃&quot;;  //姓名</span><br><span class="line">	ctry = &quot;吴&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 9;			//编号</span><br><span class="line">	wisdom = 80;	//智慧</span><br><span class="line">	strategy = 90;	//谋略</span><br><span class="line">	force = 40;		//力量</span><br><span class="line">	agility = 60;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;大智若愚&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Fan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LuSu::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LuSu::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LvMeng::LvMeng()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;吕蒙&quot;;  //姓名</span><br><span class="line">	ctry = &quot;吴&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 10;		//编号</span><br><span class="line">	wisdom = 80;	//智慧</span><br><span class="line">	strategy = 80;	//谋略</span><br><span class="line">	force = 80;		//力量</span><br><span class="line">	agility = 80;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;白衣渡江&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new DragonSword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LvMeng::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LvMeng::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhangZhao::ZhangZhao()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;张昭&quot;;  //姓名</span><br><span class="line">	ctry = &quot;吴&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 11;		//编号</span><br><span class="line">	wisdom = 80;	//智慧</span><br><span class="line">	strategy = 95;	//谋略</span><br><span class="line">	force = 25;		//力量</span><br><span class="line">	agility = 55;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;制衡之道&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangZhao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangZhao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhouTai::ZhouTai()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;周泰&quot;;  //姓名</span><br><span class="line">	ctry = &quot;吴&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 12;		//编号</span><br><span class="line">	wisdom = 60;	//智慧</span><br><span class="line">	strategy = 45;	//谋略</span><br><span class="line">	force = 90;		//力量</span><br><span class="line">	agility = 80;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Shield;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhouTai::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhouTai::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Qun.h</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&quot;Hero.h&quot;</span><br><span class="line"></span><br><span class="line">class LvBu : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	LvBu();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DiaoChan :public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	DiaoChan();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HuaTuo : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	HuaTuo();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class YuanShao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	YuanShao();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class YanLiang : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	YanLiang();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class WenChou : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	WenChou();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZuoCi : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	ZuoCi();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HuaXiong : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	HuaXiong();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class GongSunZan : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	GongSunZan();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhangJiao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	ZhangJiao();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class YuJi : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	YuJi();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LingJu : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">	LingJu();</span><br><span class="line">	void skill(Hero * hero);</span><br><span class="line">	void passive_skill();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Qun.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;Qun.h&quot;</span><br><span class="line"></span><br><span class="line">LvBu::LvBu()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;吕布&quot;;  //姓名</span><br><span class="line">	ctry = &quot;群&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 1;			//编号</span><br><span class="line">	wisdom = 35;	//智慧</span><br><span class="line">	strategy = 10;	//谋略</span><br><span class="line">	force = 100;	//力量</span><br><span class="line">	agility = 100;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;方天画斩&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LvBu::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LvBu::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">	this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">	this-&gt;atk += this-&gt;agility;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DiaoChan::DiaoChan()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;貂蝉&quot;;  //姓名</span><br><span class="line">	ctry = &quot;群&quot;;	//国家</span><br><span class="line">	sex = &quot;女&quot;;		//性别</span><br><span class="line">	id = 2;			//编号</span><br><span class="line">	wisdom = 96;	//智慧</span><br><span class="line">	strategy = 60;	//谋略</span><br><span class="line">	force = 10;		//力量</span><br><span class="line">	agility = 100;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;闭月羞花&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DiaoChan::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DiaoChan::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuaTuo::HuaTuo()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;华佗&quot;;  //姓名</span><br><span class="line">	ctry = &quot;群&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 3;			//编号</span><br><span class="line">	wisdom = 80;	//智慧</span><br><span class="line">	strategy = 37;	//谋略</span><br><span class="line">	force = 60;		//力量</span><br><span class="line">	agility = 60;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;妙手回天&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuaTuo::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuaTuo::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YuanShao::YuanShao()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;袁绍&quot;;  //姓名</span><br><span class="line">	ctry = &quot;群&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 4;			//编号</span><br><span class="line">	wisdom = 27;	//智慧</span><br><span class="line">	strategy = 20;	//谋略</span><br><span class="line">	force = 44;		//力量</span><br><span class="line">	agility = 55;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;万箭齐发&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Sword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void YuanShao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void YuanShao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YanLiang::YanLiang()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;颜良&quot;;  //姓名</span><br><span class="line">	ctry = &quot;群&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 5;			//编号</span><br><span class="line">	wisdom = 60;	//智慧</span><br><span class="line">	strategy = 60;	//谋略</span><br><span class="line">	force = 90;		//力量</span><br><span class="line">	agility = 90;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;致命一击&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void YanLiang::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void YanLiang::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WenChou::WenChou()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;文丑&quot;;  //姓名</span><br><span class="line">	ctry = &quot;群&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 6;			//编号</span><br><span class="line">	wisdom = 66;	//智慧</span><br><span class="line">	strategy = 66;	//谋略</span><br><span class="line">	force = 88;		//力量</span><br><span class="line">	agility = 88;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;暗箭难防&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Bow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WenChou::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WenChou::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZuoCi::ZuoCi()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;左慈&quot;;  //姓名</span><br><span class="line">	ctry = &quot;群&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 7;			//编号</span><br><span class="line">	wisdom = 100;	//智慧</span><br><span class="line">	strategy = 90;	//谋略</span><br><span class="line">	force = 55;		//力量</span><br><span class="line">	agility = 20;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;道法自然&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZuoCi::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZuoCi::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuaXiong::HuaXiong()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;华雄&quot;;  //姓名</span><br><span class="line">	ctry = &quot;群&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 8;			//编号</span><br><span class="line">	wisdom = 60;	//智慧</span><br><span class="line">	strategy = 67;	//谋略</span><br><span class="line">	force = 90;		//力量</span><br><span class="line">	agility = 70;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;豪情万丈&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new DragonSword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuaXiong::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuaXiong::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GongSunZan::GongSunZan()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;公孙瓒&quot;;//姓名</span><br><span class="line">	ctry = &quot;群&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 9;			//编号</span><br><span class="line">	wisdom = 60;	//智慧</span><br><span class="line">	strategy = 65;	//谋略</span><br><span class="line">	force = 80;		//力量</span><br><span class="line">	agility = 90;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;白马义从&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GongSunZan::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GongSunZan::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhangJiao::ZhangJiao()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;张角&quot;;  //姓名</span><br><span class="line">	ctry = &quot;群&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 10;		//编号</span><br><span class="line">	wisdom = 45;	//智慧</span><br><span class="line">	strategy = 65;	//谋略</span><br><span class="line">	force = 55;		//力量</span><br><span class="line">	agility = 70;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;天公降雷&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Fan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangJiao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangJiao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YuJi::YuJi()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;于吉&quot;;  //姓名</span><br><span class="line">	ctry = &quot;群&quot;;	//国家</span><br><span class="line">	sex = &quot;男&quot;;		//性别</span><br><span class="line">	id = 11;		//编号</span><br><span class="line">	wisdom = 90;	//智慧</span><br><span class="line">	strategy = 80;	//谋略</span><br><span class="line">	force = 40;		//力量</span><br><span class="line">	agility = 10;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;太平要术&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void YuJi::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void YuJi::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LingJu::LingJu()</span><br><span class="line">&#123;</span><br><span class="line">	name = &quot;灵雎&quot;;  //姓名</span><br><span class="line">	ctry = &quot;群&quot;;	//国家</span><br><span class="line">	sex = &quot;女&quot;;		//性别</span><br><span class="line">	id = 12;		//编号</span><br><span class="line">	wisdom = 90;	//智慧</span><br><span class="line">	strategy = 40;	//谋略</span><br><span class="line">	force = 60;		//力量</span><br><span class="line">	agility = 70;	//敏捷</span><br><span class="line"></span><br><span class="line">	skill_name = &quot;涅槃&quot;;</span><br><span class="line">	skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	this-&gt;init_property();</span><br><span class="line">	this-&gt;passive_skill();</span><br><span class="line">	this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LingJu::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LingJu::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>继承</tag>
        <tag>项目</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>C++运算符重载之智能指针</title>
    <url>/2019/03/04/2019-03-04/</url>
    <content><![CDATA[<p>C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。 </p>
<p>既然有了需求，对此，我们可以自行打造智能指针。</p>
<p>Person类有show_age()成员函数。</p>
<p>如果new出来的Person对象，那么必须由我们自行delete。</p>
<p>有了智能指针，就可以让智能指针托管这个对象，这个对象的释放就不用担心了，由智能指针自动进行管理。</p>
<p>为了让智能指针像普通指针一样方便实用，就要重载 -&gt; 与解引用 * 运算符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	Person():age(0)&#123;&#125;</span><br><span class="line">	Person(int age):age(age)&#123;&#125;</span><br><span class="line">	~Person() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;析构调用&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void show_age() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;我的年龄是&quot; &lt;&lt; this-&gt;age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br><span class="line">class SmartPointer &#123;</span><br><span class="line">public:</span><br><span class="line">	SmartPointer():person(NULL)&#123;&#125;</span><br><span class="line">	SmartPointer(Person*person) &#123;</span><br><span class="line">		this-&gt;person = person;</span><br><span class="line">	&#125;</span><br><span class="line">	~SmartPointer() &#123;</span><br><span class="line">		if (person != NULL) &#123;</span><br><span class="line">			delete person;</span><br><span class="line">			person = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;智能指针析构调用&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Person* operator -&gt;() &#123;</span><br><span class="line">		return this-&gt;person;</span><br><span class="line">	&#125;</span><br><span class="line">	Person&amp; operator *() &#123;</span><br><span class="line">		return *this-&gt;person;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	Person *person;</span><br><span class="line">&#125;;</span><br><span class="line">void test() &#123;</span><br><span class="line">	//Person p1(10);</span><br><span class="line">	//p1.show_age();</span><br><span class="line">	//Person *p1 = new Person(10);</span><br><span class="line">	//p1-&gt;show_age();</span><br><span class="line">	//delete p1;</span><br><span class="line">	SmartPointer sp(new Person(10));</span><br><span class="line">	sp-&gt;show_age();</span><br><span class="line">	(*sp).show_age();</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	test();</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>指针</tag>
        <tag>智能指针</tag>
        <tag>重载</tag>
      </tags>
  </entry>
  <entry>
    <title>个人简历</title>
    <url>/2019/02/28/2019-02-28/</url>
    <content><![CDATA[<h3 id="王-骏"><a href="#王-骏" class="headerlink" title="王    骏  "></a><center>王    骏</center><div style="float:right"> <img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/%E8%AF%81%E4%BB%B6%E7%85%A7.jpg" width="120"> </div></h3><center>邮箱：<a href="mailto:15249144478@163.com" target="_blank" rel="noopener">15249144478@163.com</a>        电话：152-0292-4489</center>

<h4 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h4><hr>
<div style="float:right">专  业：陕西科技大学/计算机科学与技术    </div>学  历：本科/2016.9<em>~</em>2020.6<br><br><div style="float:right">GitHub：<a href="http://github.com/qian-youyou" target="_blank" rel="noopener">http://github.com/qian-youyou</a></div>技术博客：<a href="http://qianyouyou.cn">http://qianyouyou.cn</a><br><br>#### 获奖经历<br><br>——<br><br>- 2018.11.25    <strong>亚洲区域赛铜奖</strong>    第43届ACM-ICPC国际大学生程序设计竞赛亚洲区域赛<br><br>     2018.06.10    全国邀请赛铜奖    第43届ACM-ICPC国际大学生程序设计竞赛全国邀请赛<br><br>     2018.04.01    省级二等奖        2018第九届蓝桥杯大赛<br><br>     2018.03.31    省级三等奖        团体程序设计天梯赛<br><br>     2018.03        校级二等奖        第4届陕西科技大学C语言大赛<br><br>     2018.11        校级三等奖         第5届陕西科技大学C语言大赛<br><br>#### 项目经验<br><br>——<br><br>##### 网络爬虫<div style="float:right">2017.11 ~ 2017.12</div>

<p>　　该项目主要建立中小型的文件分享站点，由学校外包项目小组负责。本人在项目小组内主要负责网络爬虫工作，利用Python的BeautifulSoup库抓取静态URL，爬取工标网上的信息到MySQL数据库。之后方便小组搭网站。</p>
<h4 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h4><hr>
<ul>
<li>语言：熟练使用C/C++进行项目开发，了解Python编程语言。<ul>
<li>熟悉C++封装，继承，多态等基础知识及应用，熟练使用STL库，掌握C++异常捕捉和处理。</li>
</ul>
</li>
<li>算法：擅长数据结构与算法优化，尤其擅长图论与数论算法分析。<ul>
<li>例如网络流(最大流，费用流等)，最短路SPFA+SLF与LLL优化，Dijkstra+heap优化，Tarjan算法，A*搜索，KM+slack优化，匈牙利算法+时间戳优化，KMP+Trie树，线段树，加权并查集，矩阵快速幂等。</li>
</ul>
</li>
<li>系统：熟悉Linux操作系统， 了解Linux环境下编程及进程间通信，多线程编程。 </li>
<li>网络：具有网络基础知识， 熟悉TCP/IP协议，了解Socket网络编程。 </li>
<li>前端：熟悉HTML5、CSS等前端语言，能够独立制作静态网页。</li>
<li>其他：了解MySQL基本操作。熟悉Git使用。</li>
</ul>
<h5 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h5><p>一个爱学习，知上进，善总结，重思考，懂感恩的人。</p>
]]></content>
  </entry>
  <entry>
    <title>[设计模式]单例模式案例之打印机案例</title>
    <url>/2019/02/27/2019-02-27/</url>
    <content><![CDATA[<p>当我们启动某一个进程时，就会显示在任务管理器进程管理处；当我们关闭他后再次打开它时，发现启动进程和上次一模一样。也就是说我们启动时它只是在任务管理器上显示了出来，当我们关闭它后它实质上并没有终止，还在继续运行，只不过隐藏了起来。其实这就是单例设计模式。生活中有很多单例设计模式的案例，比如一个国家只有一个主席，即使主席替换，依然只有一个主席。比如某个教室只有一台打印机，那么无论多少人需要使用打印机，都将只能使用这一台打印机。也就是说该对象有且只能创建一个。</p>
<p>接下来我们总结一下单例模式的流程：</p>
<p>1.目的让类中只有一个对象，对象不需要自己释放。</p>
<p>2.将默认构造函数与拷贝构造函数私有化。</p>
<p>3.内部维护一个对象指针。</p>
<p>4.私有化唯一指针。</p>
<p>5.对外提供方法访问该指针。</p>
<p>6.保证了类中只能实例化唯一对象。</p>
<p>我们以打印机为例，某教室只有一台打印机，该打印机一次只能供一个人使用。</p>
<p>我们先来分析打印机，打印机具有打印功能，具有启动功能，具有关闭功能。而且具有一次只能供一人使用的特性，因此创建类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class PrintingPress &#123;</span><br><span class="line">public:</span><br><span class="line">	static PrintingPress*getInstance() &#123;</span><br><span class="line">		return unique;</span><br><span class="line">	&#125;</span><br><span class="line">	bool check() &#123;</span><br><span class="line">		return flag;</span><br><span class="line">	&#125;</span><br><span class="line">	void openPrinting() &#123;</span><br><span class="line">		if (flag == false) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;打印机已启动&quot; &lt;&lt; endl;</span><br><span class="line">			flag = true;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void closePrinting() &#123;</span><br><span class="line">		if (flag == true) &#123;</span><br><span class="line">			flag = false;</span><br><span class="line">			cout &lt;&lt; &quot;打印机已关闭&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; &quot;打印机已关闭，无需执行该操作&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void usingPrinting(string str) &#123;</span><br><span class="line">		if (flag == false) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;很抱歉，打印机被占用。&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	PrintingPress() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;打印机可正常使用&quot; &lt;&lt; endl;</span><br><span class="line">		flag = false;</span><br><span class="line">	&#125;</span><br><span class="line">	PrintingPress(const PrintingPress&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;打印机违规使用&quot; &lt;&lt; endl;</span><br><span class="line">		flag = false;</span><br><span class="line">	&#125;</span><br><span class="line">	static PrintingPress* unique;</span><br><span class="line">	bool flag = false;</span><br><span class="line">&#125;;</span><br><span class="line">PrintingPress* PrintingPress::unique = new PrintingPress;</span><br></pre></td></tr></table></figure>
<p>用户具有使用打印机打印内容的功能，具有关闭打印机的功能，具有打开打印机的功能。因此创建用户类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class user &#123;</span><br><span class="line">public:</span><br><span class="line">	void us() &#123;</span><br><span class="line">		if (flag == true) &#123;</span><br><span class="line">			string str;</span><br><span class="line">			cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl;</span><br><span class="line">			cin &gt;&gt; str;</span><br><span class="line">			p-&gt;usingPrinting(str);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void us(string str) &#123;</span><br><span class="line">		if (flag == true) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl;</span><br><span class="line">			p-&gt;usingPrinting(str);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void op() &#123;</span><br><span class="line">		if (p-&gt;check() == false) &#123;</span><br><span class="line">			p-&gt;openPrinting();</span><br><span class="line">			flag = true;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void cl() &#123;</span><br><span class="line">		if (flag = true) &#123;</span><br><span class="line">			p-&gt;closePrinting();</span><br><span class="line">			flag = false;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	PrintingPress* p = PrintingPress::getInstance();</span><br><span class="line">	bool flag = false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以下代码是用C++写的一个简单的打印机案例测试代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class PrintingPress &#123;</span><br><span class="line">public:</span><br><span class="line">	static PrintingPress*getInstance() &#123;</span><br><span class="line">		return unique;</span><br><span class="line">	&#125;</span><br><span class="line">	bool check() &#123;</span><br><span class="line">		return flag;</span><br><span class="line">	&#125;</span><br><span class="line">	void openPrinting() &#123;</span><br><span class="line">		if (flag == false) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;打印机已启动&quot; &lt;&lt; endl;</span><br><span class="line">			flag = true;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void closePrinting() &#123;</span><br><span class="line">		if (flag == true) &#123;</span><br><span class="line">			flag = false;</span><br><span class="line">			cout &lt;&lt; &quot;打印机已关闭&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; &quot;打印机已关闭，无需执行该操作&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void usingPrinting(string str) &#123;</span><br><span class="line">		if (flag == false) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;很抱歉，打印机被占用。&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	PrintingPress() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;打印机可正常使用&quot; &lt;&lt; endl;</span><br><span class="line">		flag = false;</span><br><span class="line">	&#125;</span><br><span class="line">	PrintingPress(const PrintingPress&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;打印机违规使用&quot; &lt;&lt; endl;</span><br><span class="line">		flag = false;</span><br><span class="line">	&#125;</span><br><span class="line">	static PrintingPress* unique;</span><br><span class="line">	bool flag = false;</span><br><span class="line">&#125;;</span><br><span class="line">PrintingPress* PrintingPress::unique = new PrintingPress;</span><br><span class="line">class user &#123;</span><br><span class="line">public:</span><br><span class="line">	void us() &#123;</span><br><span class="line">		if (flag == true) &#123;</span><br><span class="line">			string str;</span><br><span class="line">			cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl;</span><br><span class="line">			cin &gt;&gt; str;</span><br><span class="line">			p-&gt;usingPrinting(str);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void us(string str) &#123;</span><br><span class="line">		if (flag == true) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl;</span><br><span class="line">			p-&gt;usingPrinting(str);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void op() &#123;</span><br><span class="line">		if (p-&gt;check() == false) &#123;</span><br><span class="line">			p-&gt;openPrinting();</span><br><span class="line">			flag = true;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void cl() &#123;</span><br><span class="line">		if (flag = true) &#123;</span><br><span class="line">			p-&gt;closePrinting();</span><br><span class="line">			flag = false;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	PrintingPress* p = PrintingPress::getInstance();</span><br><span class="line">	bool flag = false;</span><br><span class="line">&#125;;</span><br><span class="line">void test() &#123;</span><br><span class="line">	user tmp[3];</span><br><span class="line">	tmp[1].op();</span><br><span class="line">	tmp[2].op();</span><br><span class="line">	tmp[1].us(&quot;lalalalala&quot;);</span><br><span class="line">	tmp[2].op();</span><br><span class="line">	tmp[1].cl();</span><br><span class="line">	tmp[2].op();</span><br><span class="line">	tmp[2].us(&quot;22222222&quot;);</span><br><span class="line">	tmp[2].cl();</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	test();</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]const指针与指向const的指针</title>
    <url>/2019/02/23/2019-02-23/</url>
    <content><![CDATA[<p>　　最近在复习Ｃ＋＋，指针这块真的是重难点，很久了也没有去理会，今晚好好总结一下const指针，好久没有写过博客了，记录一下~</p>
<p><strong>const指针的定义：</strong></p>
<p>　　const指针是指针变量的值一经初始化，就不可以改变指向，初始化是必要的。其定义形式如下：</p>
<p>type *const 指针名称;</p>
<p>　　声明指针时，可以在类型前或后使用关键字const，也可在两个位置都使用。例如，下面都是合法的声明，但是含义大不同：</p>
<p>const int * pOne;    //指向<strong>整形常量</strong> 的指针，它指向的值不能修改</p>
<p>int * const pTwo;    //指向整形的<strong>常量指针</strong> ，它不能在指向别的变量，但指向（变量）的值可以修改。 </p>
<p>const int *const pThree;  //指向<strong>整形常量</strong> 的<strong>常量指针</strong> 。它既不能再指向别的常量，指向的值也不能修改。</p>
<p>理解这些声明的技巧在于，查看关键字const右边来确定什么被声明为常量 ，如果该关键字的右边是类型，则值是常量；如果关键字的右边是指针变量，则指针本身是常量。下面的代码有助于说明这一点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int *p1;  //the int pointed to is constant</span><br><span class="line"></span><br><span class="line">int * const p2; // p2 is constant, it can&apos;t point to anything else</span><br></pre></td></tr></table></figure>
<p><strong>const指针和const成员函数</strong></p>
<p>可以将关键字用于成员函数。例如：</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Rectangle</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     pubilc:</span><br><span class="line"></span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">        void SetLength(int length)&#123;itslength = length;&#125;</span><br><span class="line"></span><br><span class="line">        int GetLength() const &#123;return itslength;&#125;  //成员函数声明为常量</span><br><span class="line"></span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">     private:</span><br><span class="line"></span><br><span class="line">        int itslength;</span><br><span class="line"></span><br><span class="line">        int itswidth;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>当成员函数被声明为const时，如果试图修改对象的数据，编译器将视为错误。</p>
<p>如果声明了一个指向const对象的指针，则通过该指针只能调用const方法（成员函数）。</p>
<p>示例声明三个不同的Rectangle对象：</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rectangle* pRect = new Rectangle;</span><br><span class="line"></span><br><span class="line">const Rectangle * pConstRect = new Rectangle;     //指向const对象</span><br><span class="line"></span><br><span class="line">Rectangle* const pConstPtr = new Rectangle;</span><br><span class="line"></span><br><span class="line">// pConstRect是指向const对象的指针，它只能使用声明为const的成员函数，如GetLength（）。</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<h1 id><a href="#" class="headerlink" title=" "></a> </h1><h1 id="const指针和指向const的指针"><a href="#const指针和指向const的指针" class="headerlink" title="const指针和指向const的指针"></a>const指针和指向const的指针</h1><p>当使用带有const的指针时其实有两种意思。一种指的是你不能修改指针本身的内容，另一种指的是你不能修改指针指向的内容。听起来有点混淆一会放个例子上来就明白了。<br>      先说指向const的指针，它的意思是指针指向的内容是不能被修改的。它有两种写法。<br>      const int<em> p; （推荐）<br>      int const</em> p;<br>      第一种可以理解为，p是一个指针，它指向的内容是const int 类型。p本身不用初始化它可以指向任何标示符，但它指向的内容是不能被改变的。<br>      第二种很容易被理解成是p是一个指向int的const指针（指针本身不能被修改），但这样理解是错误的，它也是表示的是指向const的指针（指针指向的内容是不能被修改的），它跟第一种表达的是一个意思。为了避免混淆推荐大家用第一种。<br>      再说const指针，它的意思是指针本身的值是不能被修改的。它只有一种写法<br>      int<em> const p=一个地址; (因为指针本身的值是不能被修改的所以它必须被初始化）<br>      这种形式可以被理解为，p是一个指针，这个指针是指向int 的const指针。它指向的值是可以被改变的如</em>p=3;<br>      还有一种情况是这个指针本身和它指向的内容都是不能被改变的，请往下看。<br>      const int<em> const p=一个地址;<br>      int const</em> const p=一个地址;<br>      看了上面的内容是不是有点晕，没关系，你不用去背它，用的多了就知道了，还有个技巧，通过上面的观察我们不难总结出一点规律，是什么呢？这个规律就是： 指向const的指针（指针指向的内容不能被修改）const关健字总是出现在<em>的左边而const指针（指针本身不能被修改）const关健字总是出现在</em>的右边，那不用说两个const中间加个*肯定是指针本身和它指向的内容都是不能被改变的。有了这个规则是不是就好记多了。</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Code highlighting produced by Actipro CodeHighlighter (freeware)http://www.CodeHighlighter.com/--&gt; 1 #include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int a=3;</span><br><span class="line">    int b;</span><br><span class="line">    </span><br><span class="line">    /*定义指向const的指针（指针指向的内容不能被修改）*/ </span><br><span class="line">    const int* p1; </span><br><span class="line">    int const* p2; </span><br><span class="line">    </span><br><span class="line">    /*定义const指针(由于指针本身的值不能改变所以必须得初始化）*/ </span><br><span class="line">    int* const p3=&amp;a; </span><br><span class="line">    </span><br><span class="line">    /*指针本身和它指向的内容都是不能被改变的所以也得初始化*/</span><br><span class="line">    const int* const p4=&amp;a;</span><br><span class="line">    int const* const p5=&amp;b; </span><br><span class="line">    </span><br><span class="line">     p1=p2=&amp;a; //正确</span><br><span class="line">     *p1=*p2=8; //不正确（指针指向的内容不能被修改）</span><br><span class="line">    </span><br><span class="line">     *p3=5; //正确</span><br><span class="line">     p3=p1; //不正确（指针本身的值不能改变） </span><br><span class="line">    </span><br><span class="line">     p4=p5;//不正确 （指针本身和它指向的内容都是不能被改变） </span><br><span class="line">     *p4=*p5=4; //不正确（指针本身和它指向的内容都是不能被改变） </span><br><span class="line">     </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p><strong>const用法小结：</strong><br>const最常用的就是定义常量，除此之外，它还可以修饰函数的参数、返回值和函数的定义体。<br>\1. const修饰函数的参数<br>如果参数作输出用，不论它是什么数据类型，也不论它采用“指针传递”还是“引用传递”，都不能加const 修饰，否则该参数将失去输出功能。<br>const 只能修饰输入参数：<br>如果输入参数采用“指针传递”，那么加const 修饰可以防止意外地改动该指针，起到保护作用。<br>将“const &amp;”修饰输入参数的用法总结如下：<br>(1)对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void Func(A a) 改为void Func(const A &amp;a)。<br>(2)对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void Func(int x) 不应该改为void Func(const int &amp;x)。</p>
<p>\2. const 修饰函数的返回值<br>如果给以“指针传递”方式的函数返回值加const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。例如函数<br>const char <em> GetString(void);<br>如下语句将出现编译错误：<br>char </em>str = GetString();<br>正确的用法是<br>const char *str = GetString();<br>如果返回值不是内部数据类型，将函数A GetA(void) 改写为const A &amp; GetA(void)的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。<br>函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。<br>例如：</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">A &amp; operate = (const A &amp;other); // 赋值函数</span><br><span class="line">&#125;;</span><br><span class="line">A a, b, c; // a, b, c 为A 的对象</span><br><span class="line">a = b = c; // 正常的链式赋值</span><br><span class="line">(a = b) = c; // 不正常的链式赋值，但合法</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>如果将赋值函数的返回值加const 修饰，那么该返回值的内容不允许被改动。上例中，语句 a = b = c 仍然正确，但是语句 (a = b) = c 则是非法的。</p>
<p>\3. const修饰成员函数<br>关于Const函数的几点规则：<br>a. const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数.<br>b. const对象的成员是不可修改的,然而const对象通过指针维护的对象却是可以修改的.<br>c. const成员函数不可以修改对象的数据,不管对象是否具有const性质.它在编译时,以是否修改成员数据为依据,进行检查.<br>d. 然而加上mutable修饰符的数据成员,对于任何情况下通过任何手段都可修改,自然此时的const成员函数是可以修改它的</p>
<p>　　版权所有，转载请注明转载地址：<a href="http://www.cnblogs.com/lihuidashen/p/4378884.html" target="_blank" rel="noopener">http://www.cnblogs.com/lihuidashen/p/4378884.html</a></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>指针</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]#pragma命令详解</title>
    <url>/2019/02/22/2019-02-22/</url>
    <content><![CDATA[<p>每种C和C++的实现支持对其宿主机或操作系统唯一的功能。例如，一些程序需要精确控制超出数据所在的储存空间，或着控制特定函数接受参数的方式。#pragma指示使每个编译程序在保留C和C++语言的整体兼容性时提供不同机器和操作系统特定的功能。编译指示被定义为机器或操作系统特定的，并且通常每种编译程序是不同的。</p>
<p>语法：</p>
<p>#pragma token_string</p>
<p>“token_string”是一系列字符用来给出所需的特定编译程序指令和参数。数字符号“#”必须是包含编译指令的行中第一个非空白字符；而空白字符可以隔开数字符号“#”和关键字“pragma”。在#pragma后面，写任何翻译程序能够作为预处理符号分析的文本。#pragma的参数类似于宏扩展。</p>
<p>如果编译程序发现它不认得一个编译指示，它将给出一个警告，可是编译会继续下去。</p>
<p>为了提供新的预处理功能，或者为编译程序提供由实现定义的信息，编译指示可以用在一个条件语句内。C和C++编译程序可以识别下列编译程序指令。</p>
<table>
<thead>
<tr>
<th>alloc_text</th>
<th>comment</th>
<th>init_seg*</th>
<th>optimize</th>
</tr>
</thead>
<tbody>
<tr>
<td>auto_inline</td>
<td>component</td>
<td>inline_depth</td>
<td>pack</td>
</tr>
<tr>
<td>bss_seg</td>
<td>data_seg</td>
<td>inline_recursion</td>
<td>pointers_to_members*</td>
</tr>
<tr>
<td>check_stack</td>
<td>function</td>
<td>intrinsic</td>
<td>setlocale</td>
</tr>
<tr>
<td>code_seg</td>
<td>hdrstop</td>
<td>message</td>
<td>vtordisp*</td>
</tr>
<tr>
<td>const_seg</td>
<td>include_alias</td>
<td>once</td>
<td>warning</td>
</tr>
</tbody>
</table>
<p>*仅用于C++编译程序。</p>
<p><strong>1 alloc_text</strong></p>
<p>#pragma alloc_text( “textsection”, function1, … )</p>
<p>命名特别定义的函数驻留的代码段。该编译指示必须出现在函数说明符和函数定义之间。</p>
<p>alloc_text编译指示不处理C++成员函数或重载函数。它仅能应用在以C连接方式说明的函数——就是说，函数是用extern “C”连接指示符说明的。如果你试图将这个编译指示应用于一个具有C++连接方式的函数时，将出现一个编译程序错误。</p>
<p>由于不支持使用__based的函数地址，需要使用alloc_text编译指示来指定段位置。由textsection指定的名字应该由双引号括起来。</p>
<p>alloc_text编译指示必须出现在任何需要指定的函数说明之后，以及这些函数的定义之前。</p>
<p>在alloc_text编译指示中引用的函数必须和该编译指示处于同一个模块中。如果不这样做，使以后一个未定义的函数被编译到一个不同的代码段时，错误会也可能不会被捕获。即使程序一般会正常运行，但是函数不会分派到应该在的段。</p>
<p>alloc_text的其它限制如下：</p>
<p>它不能用在一个函数内部。</p>
<p>它必须用于函数说明以后，函数定义以前。</p>
<p><strong>2 auto_inline</strong></p>
<p>#pragma auto_inline( [{on | off}] )</p>
<p>当指定off时将任何一个可以被考虑为作为自动嵌入扩展候选的函数排除出该范围。为了使用auto_inline编译指示，将其紧接着写在一个函数定义之前或之后（不是在其内部）。该编译指示将在其出现以后的第一个函数定义开始起作用。auto_inline编译指示对显式的inline函数不起作用。</p>
<p><strong>3 bss_seg</strong></p>
<p>#pragma data_seg( [“section-name”[, “section-class”] ] )</p>
<p>为未初始化数据指定缺省段。data_seg编译指示除了工作于已初始化数据而不是未初始化的以外具有一样的效果。在一些情况下，你能使用bss_seg将所有未初始化数据安排在一个段中来加速你的装载时间。</p>
<p>#pragma bss_seg( “MY_DATA” )</p>
<p>将导致把#pragma语句之后的未初始化的数据安排在一个叫做MY_DATA的段中。</p>
<p>用bss_seg编译指示分配的数据不包含任何关于其位置的信息。</p>
<p>第二个参数section-class是用于兼容2.0版本以前的Visual C++的，现在将忽略它。</p>
<p><strong>4 check_stack</strong></p>
<p>#pragma check_stack([ {on | off}] )</p>
<p>#pragma check_stack{+ | –}</p>
<p>如果指定off（或者“-”）指示编译程序关闭堆栈探测，或者指定on（或“+”）打开堆栈探测。如果没有给出参数，堆栈探测将根据默认设置决定。该编译指示将在出现该指示之后的第一个函数开始生效。堆栈探测既不是宏和能够生成嵌入代码函数的一部分。</p>
<p>如果你没有给出check­_stack编译指示的参数，堆栈检查将恢复到在命令行指定的行为。详细情况见编译程序参考。#pragma check_stack和/Gs选项的互相作用情况在表2.1中说明。</p>
<p>表 2.1 使用check_stack编译指示</p>
<table>
<thead>
<tr>
<th>编译指示</th>
<th>用/Gs选项编译？</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>#pragma check_stack()或#pragma check_stack</td>
<td>是</td>
<td>后续的函数关闭堆栈检查</td>
</tr>
<tr>
<td>#pragma check_stack()或#pragma check_stack</td>
<td>否</td>
<td>后续的函数打开堆栈检查</td>
</tr>
<tr>
<td>#pragma check_stack(on)或#pragma check_stack(+)</td>
<td>是或者否</td>
<td>后续的函数打开堆栈检查</td>
</tr>
<tr>
<td>#pragma check_stack(off)或#pragma check_stack(-)</td>
<td>是或者否</td>
<td>后续的函数关闭堆栈检查</td>
</tr>
</tbody>
</table>
<p><strong>5 code_seg</strong></p>
<p>#pragma code_seg( [“section-name”[,”section-class”] ] )</p>
<p>指定分配函数的代码段。code_seg编译指示为函数指定默认的段。你也能够像段名一样指定一个可选的类名。使用没有段名字符串的#pragma code_seg将恢复分配到编译开始时候的状态。</p>
<p><strong>6 const_seg</strong></p>
<p>#pragma const_seg( [“section-name”[, “section-class”] ] )</p>
<p>指定用于常量数据的默认段。data_seg编译指示除了可以工作于所有数据以外具有一样的效果。你能够使用该编译指示将你的常量数据保存在一个只读的段中。</p>
<p>#pragma const_seg( “MY_DATA” )</p>
<p>导致在#pragma语句后面的常量数据分配在一个叫做MY_DATA的段中。</p>
<p>用const_seg编译指示分配的数据不包含任何关于其位置的信息。</p>
<p>第二个参数section-class是用于兼容2.0版本以前的Visual C++的，现在将忽略它。</p>
<p><strong>7 comment</strong></p>
<p>#pragma comment( comment-type [, commentstring] )</p>
<p>将描述记录安排到目标文件或可执行文件中去。comment-type是下面说明的五个预定义标识符中的一个，用来指定描述记录的类型。可选的commentstring是一个字符串文字值用于为一些描述类型提供附加的信息。因为commentstring是一个字符串文字值，所以它遵从字符串文字值的所有规则，例如换码字符、嵌入的引号（”）和联接。</p>
<p><strong>7-1 compiler</strong></p>
<p>在目标文件中放置编译程序名和版本号。该描述记录被连接程序忽略。如果你为这个记录类型提供一个commentstring参数，编译程序将生成一个警告。</p>
<p><strong>7-2 exestr</strong></p>
<p>将commentstring放置到目标文件中去。在连结时，这个字符串再被放到可执行文件去中。当可执行文件被装载时这个字符串不会被装入内存，然而，它可以被一个能够在文件中搜索可打印字符串的程序找到。该描述记录的一个用处是在可执行文件中嵌入版本号或者类似的信息。</p>
<p><strong>7-3 lib</strong></p>
<p>将一个库搜索记录放置到目标文件中去。该描述类型必须有包含你要连接程序搜索的库名（和可能的路径）的commentstring参数。因为在目标文件中该库名先于默认的库搜索记录，所以连接程序将如同你在命令行输入这些库一样来搜索它们。你可以在一个源文件中放置多个库搜索记录，每个记录将按照它们出现在源文件中的顺序出现在目标文件中。</p>
<p><strong>7-4 linker</strong></p>
<p>在目标文件中放置连接程序选项。你可以用这个描述类型指定连接程序选项来代替在Project Setting对话框中Link页内的选项。例如，你可以指定/include选项以强迫包含一个符号：</p>
<p>#pragma comment(linker, “/include:__mySymbol”)</p>
<p><strong>7-5 user</strong></p>
<p>在目标文件中包含一个普通描述记录。commentstring参数包含描述的文本。该描述记录将被连接程序忽略。</p>
<p>下面的编译指示导致连接程序在连接时搜索EMAPI.LIB库。连接程序首先在当前工作目录然后在LIB环境变量指定的路径中搜索。</p>
<p>#pragma comment( lib, “emapi” )</p>
<p>下面的编译指示导致编译程序将其名字和版本号放置到目标文件中去。</p>
<p>The following pragma causes the compiler to place the name and version number of the compiler in the object file:</p>
<p>#pragma comment( compiler )</p>
<p>注意，对于具有commentstring参数的描述记录，你可以使用其它用作字符串文字量的宏来提供宏扩展为字符串文字量。你也能够联结任何字符串文字量和宏的组合来扩展成为一个字符串文字量。例如，下面的语句是可以接受的：</p>
<p>#pragma comment( user, “Compiled on “ <strong>DATE</strong> “ at “ <strong>TIME</strong> )</p>
<p><strong>8 component</strong></p>
<p>#pragma component( browser, { on | off }[, references [, name ]] )</p>
<p>#pragma component( minrebuild, on | off )</p>
<p>从源文件内控制浏览信息和依赖信息的收集。</p>
<p><strong>8-1 浏览信息（Browser）</strong></p>
<p>你可以将收集打开或关闭，你也可以指定收集时忽略特别的名字。</p>
<p>使用on或off在编译指示以后控制浏览信息的收集。例如：</p>
<p>#pragma component(browser, off)</p>
<p>终止编译程序收集浏览信息。</p>
<p>注意，为了用这个编译指示打开浏览信息的收集，必须先从Project Setting对话框或者命令行允许浏览信息。</p>
<p>references选项可以有也可以没有name参数。使用没有name参数的references选项将打开或者关闭引用信息的收集（然而继续收集其它浏览信息）。例如：</p>
<p>#pragma component(browser, off, references)</p>
<p>终止编译程序收集引用信息。</p>
<p>使用有name和off参数的references选项将阻止从浏览信息窗口中出现引用到的名字。用这个语法将忽略你不感兴趣的名字和类型从而减少浏览信息文件的大小。例如：</p>
<p>#pragma component(browser, off, references, DWORD)</p>
<p>从这一点以后忽略DWORD的引用。你能够用on恢复DWORD的引用收集：</p>
<p>#pragma component(browser, on, references, DWORD)</p>
<p>这是唯一的方法可以恢复收集指定名字的引用，你必须显式地打开任何你关闭的名字。</p>
<p>为了防止预处理程序扩展名字（就像扩展NULL到0），用引号括起来：</p>
<p>#pragma component(browser, off, references, “NULL”)</p>
<p><strong>8-2 最小化重建（Minimal Rebuild）</strong></p>
<p>Visual C++的最小化重建功能要求编译程序创建并保存需要大量磁盘空间的C++类依赖信息。为了节省磁盘空间，你能够在你不需要收集依赖信息时使用#pragma component(minrebuild,off)，例如，没有改变过头文件。在未修改过的类之后插入#pragma component(minrebuild,on)重新打开依赖信息。</p>
<p>详见Enable Minimal Rebuild(/Gm)编译程序选项。</p>
<p><strong>9 data_seg</strong></p>
<p>#pragma data_seg( [“section-name”[, “section-class”] ] )</p>
<p>指定数据的默认段。例如：</p>
<p>#pragma data_seg( “MY_DATA” )</p>
<p>导致在#pragma语句后分配的数据保存在一个叫做MY_DATA的段中。</p>
<p>用data_seg编译指示分配的数据不包含任何关于其位置的信息。</p>
<p>第二个参数section-class是用于兼容2.0版本以前的Visual C++的，现在将忽略它。</p>
<p><strong>10 function</strong></p>
<p>#pragma function( function1 [, function2, …] )</p>
<p>指定必须生成对编译指示中参数列表内函数的调用。如果你使用intrinsic编译指示（或者/Oi）来告诉编译程序生成内含函数（内含函数如同嵌入代码一样生成，不作为一个函数调用），你能够用function编译指示显式地强迫函数调用。当遇到一个function编译指示，它将在其后面遇到的第一个包含有内含函数的函数定义处生效。其持续作用到源文件的尾部或者出现对同一个内含函数指定intrinsic编译指示。function编译指示只能用于函数外——在全局层次。</p>
<p>为了列出具有内含形式的函数表，参见#pragma intrinsic。</p>
<p><strong>11 hdrstop</strong></p>
<p>#pragma hdrstop [( “filename” )]</p>
<p>控制预编译头文件的工作方式。filename是要使用或者创建（依赖于是否指定了/Yu或/Yc）预编译头文件的名字。如果 filename不包括一个指定路径，将假定预编译头文件和源文件处于同一个目录中。当指定自动预编译头文件选项/YX时，所有指定的文件名将被忽略。</p>
<p>如果有/YX或者/Yc选项，而且C或C++文件包含了一个hdrstop编译指示时，编译程序保存编译指示之前的编译状态。编译指示之后的编译状态不被保存。</p>
<p>hdrstop编译选项不能出现在一个头文件内。它只能出现在源文件的文件级，它也不能出现在任何数据或者函数的说明或定义之中。</p>
<p>注意，除非指定没有文件名的/YX选项或者/Yu或/Yc选项，否则hdrstop编译指示将被忽略。</p>
<p>用一个文件名命名要保存编译状态的预编译头文件。在hdrstop和filename之间的空格是可选的。在hdrstop编译指示中的文件名是一个字符串，这样它服从于C或C++的字符串规则。特别的，你必须像下面例子里面显示的用引号括起来。</p>
<p>#pragma hdrstop( “c:\projects\include\myinc.pch” )</p>
<p>预编译头文件的文件名按照如下规则决定，按照优先次序：</p>
<p>/Fp编译程序选项的参数；</p>
<p>由#pragma hdrstop的filename参数；</p>
<p>原文件名的基本文件名加上.PCH扩展名。</p>
<p><strong>12 include_alias</strong></p>
<p>#pragma include_alias( “long_filename”, “short_filename” )</p>
<p>#pragma include_alias( &lt;long_filename&gt;, &lt;short_filename&gt; )</p>
<p>指定作为long_filename别名的short_filename。一些文件系统允许超出8.3FAT文件系统限制的长头文件名。编译程序不能简单地将长文件名截断为8.3名字，因为长头文件名的前8个字符可能不是唯一的。无论何时编译程序遇到long_filename串，它代替short_filename，并且用short_filename搜索头文件。这个编译指示必须出现在相应的#include指示之前。例如：</p>
<p>// First eight characters of these two files not unique.</p>
<p>#pragma include_alias( “AppleSystemHeaderQuickdraw.h”, “quickdra.h” )</p>
<p>#pragma include_alias( “AppleSystemHeaderFruit.h”, “fruit.h” )</p>
<p>#pragma include_alias( “GraphicsMenu.h”, “gramenu.h” )</p>
<p>#include “AppleSystemHeaderQuickdraw.h”</p>
<p>#include “AppleSystemHeaderFruit.h”</p>
<p>#include “GraphicsMenu.h”</p>
<p>这个别名在搜索时精确匹配，包括拼写和双引号、尖括号。include_alias编译指示在文件名上执行简单的字符串匹配，不进行其它的文件名验证。例如，给出下列指示：</p>
<p>#pragma include_alias(“mymath.h”, “math.h”)</p>
<p>#include “./mymath.h”</p>
<p>#include “sys/mymath.h”</p>
<p>并不执行别名替代，因为头文件名字符串没有精确匹配。另外，在/Yu，/Yc和/YX编译程序选项，或hdrstop编译指示中作为参数的头文件名不被替换。例如，如果你的源文件包含下列指示：</p>
<p>#include &lt;AppleSystemHeaderStop.h&gt;</p>
<p>相应的编译程序选项必须是：</p>
<p>/YcAppleSystemHeaderStop.h</p>
<p>你能够用include­_alias编译指示将任何头文件映射到其它文件。例如：</p>
<p>#pragma include_alias( “api.h”, “c:\version1.0\api.h” )</p>
<p>#pragma include_alias( &lt;stdio.h&gt;, &lt;newstdio.h&gt; )</p>
<p>#include “api.h”</p>
<p>#include &lt;stdio.h&gt;</p>
<p>不要混淆用双引号和尖括号括起来的文件名。例如，给出上面的#pragma include_alias指示时，在下面的#include指示中编译程序不执行替换。</p>
<p>#include &lt;api.h&gt;</p>
<p>#include “stdio.h”</p>
<p>还有，下面的指示将产生一个错误：</p>
<p>#pragma include_alias(&lt;header.h&gt;, “header.h”) // Error</p>
<p>注意，在错误信息中报告的文件名，或者预定义宏<strong>FILE</strong>的值，是执行替换以后的文件名。例如，在下列指示之后：</p>
<p>#pragma include_alias( “VeryLongFileName.H”, “myfile.h” )</p>
<p>#include “VeryLongFileName.H”</p>
<p>文件VeryLongFileName.H产生下列错误信息：</p>
<p>myfile.h(15) : error C2059 : syntax error</p>
<p>还要注意的是不支持传递性。给出下面的指示：</p>
<p>#pragma include_alias( “one.h”, “two.h” )</p>
<p>#pragma include_alias( “two.h”, “three.h” )</p>
<p>#include “one.h”</p>
<p>编译程序将搜索two.h而不是three.h。</p>
<p><strong>13 init_seg</strong></p>
<p>C++特有</p>
<p>#pragma init_seg({ compiler | lib | user | “section-name” [, “func-name”]} )</p>
<p>指定影响启动代码执行的关键字或代码段。因为全局静态对象的初始化可以包含执行代码，所以你必须指定一个关键字来定义什么时候构造对象。在使用需要初始化的动态连接库（DLL）或程序库时使用init_seg编译指示是尤其重要的。</p>
<p>init_seg编译指示的选项有：</p>
<p>13-1 compiler</p>
<p>由Microsoft C运行时间库保留。在这个组中的对象将第一个构造。</p>
<p>13-2 lib</p>
<p>用于第三方类库开发者的初始化。在这个组中的对象将在标记为构造compiler的对象之后，其它对象之前构造。</p>
<p>13-3 user</p>
<p>用于任何其它用户。在这个组中的对象将最后构造。</p>
<p>13-4 section-name</p>
<p>允许显式地指定初始化段。在用户指定的section-name中的对象将不会隐式地构造，而它们的地址将会被放置在由section-name命名的段中。</p>
<p>13-5 func-name</p>
<p>指定当程序退出时，作为atexit函数调用的函数。这个函数必须具有和atexit函数相同的形式：</p>
<p>int funcname(void (__cdecl *)(void));</p>
<p>如果你需要延迟初始化，你能够选择指定显式的段名。随后你必须调用每个静态对象的构造函数。</p>
<p><strong>14 inline_depth</strong></p>
<p>#pragma inline_depth( [0… 255] )</p>
<p>通过控制能够被扩展的一系列函数调用（从0到255次）来控制嵌入函数扩展的发生次数，这个编译指示控制用inline，__inline标记的或在/Ob2选项下能自动嵌入的嵌入函数。</p>
<p>inline_depth编译指示控制能够被扩展的一系列函数调用。例如，如果嵌入深度是4，并且如果A调用B然后调用C，所有的3次调用都将做嵌入扩展。然而，如果设置的最近一次嵌入深度是2，则只有A和B被扩展，而C仍然作为函数调用。</p>
<p>为了使用这个编译指示，你必须设置编译程序选项/Ob为1或者2。用这个编译指示指定的深度设定在该指示后面的第一个函数开始生效。如果你在括号内不指定一个值，inline_depth设置嵌入深度到默认值8。</p>
<p>在扩展时，嵌入深度可以被减少而不能被增加。如果嵌入深度是6，同时在扩展过程中预处理程序遇到一个inline_depth编译指示设置为8，则深度保持为6。</p>
<p>嵌入深度0将拒绝嵌入扩展，深度255将设置在嵌入扩展时没有限制。如果用一个没有指定值的编译指示，则使用为默认值。</p>
<p><strong>15 inline_recursion</strong></p>
<p>#pragma inline_recursion( [{on | off}] )</p>
<p>控制直接或者相互间的递归函数调用式的嵌入扩展。用这个编译指示控制用inline，__inline标记的或在/Ob2选项下能自动嵌入的嵌入函数。使用这个编译指示需要设置编译程序选项/Ob为1或者2。默认的inline_recursion状态是off。这个编译指示在出现该编译指示之后第一个函数调用起作用，并不影响函数的定义。</p>
<p>inline_recursion编译指示控制如何扩展递归函数。如果inline_recursion是off，并且如果一个嵌入函数调用了它自己（直接的或者间接的），函数将仅仅扩展一次。如果inline_recursion是on,函数将扩展多次直到达到inline_depth的值或者容量限制。</p>
<p><strong>16 intrinsic</strong></p>
<p>#pragma intrinsic( function1 [, function2, …] )</p>
<p>指定对在编译指示参数表中函数调用是内含的。编译程序像嵌入代码一样生成内含函数，而不是函数调用。下面列出了具有内含形式的库函数。一旦遇到intrinsic编译指示，它从第一个包含指定内含函数的函数定义开始起作用。作用持续到源文件尾部或者出现包含相同内含函数的function编译指示。intrinsic编译指示只能用在函数定义外——在全局层次。</p>
<p>下列函数具有内含形式：</p>
<table>
<thead>
<tr>
<th>_disable</th>
<th>_enable</th>
<th>_inp</th>
<th>_inpw</th>
<th>_lrotl</th>
<th>_lrotr</th>
</tr>
</thead>
<tbody>
<tr>
<td>_outp</td>
<td>_outpw</td>
<td>_rotl</td>
<td>_rotr</td>
<td>_strset</td>
<td>abs</td>
</tr>
<tr>
<td>fabs</td>
<td>labs</td>
<td>memcmp</td>
<td>memcpy</td>
<td>memset</td>
<td>strcat</td>
</tr>
<tr>
<td>strcmp</td>
<td>strcpy</td>
<td>strlen</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>使用内含函数的程序更快，因为它们没有函数调用的额外代价，然而因为有附加的代码生成，可能比较大。</p>
<p>注意，_alloca和setjmp函数总是内含的，这个行为不受intrinsic编译指示影响。</p>
<p>下列浮点函数没有内含形式。然而它们具有直接将参数通过浮点芯片传送而不是推入程序堆栈的版本。</p>
<table>
<thead>
<tr>
<th>acos</th>
<th>asin</th>
<th>cosh</th>
<th>fmod</th>
<th>pow</th>
<th>sinh</th>
</tr>
</thead>
<tbody>
<tr>
<td>tanh</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>当你同时指定/Oi和/Og编译程序选项（或者任何包含/Og，/Ox，/O1和/O2的选项）时下列浮点函数具有真正的内含形式。</p>
<table>
<thead>
<tr>
<th>atan</th>
<th>exp</th>
<th>log10</th>
<th>sqrt</th>
<th>atan2</th>
<th>log</th>
</tr>
</thead>
<tbody>
<tr>
<td>sin</td>
<td>tan</td>
<td>cos</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>你可以用编译程序选项/Op或/Za来覆盖真内含浮点选项的生成。在这种情况下，函数会像一般库函数一样被生成，同时直接将参数通过浮点芯片传送而不是推入程序堆栈。</p>
<p><strong>17 message</strong></p>
<p>#pragma message( messagestring )</p>
<p>不中断编译，发送一个字符串文字量到标准输出。message编译指示的典型运用是在编译时显示信息。</p>
<p>下面的代码段用message编译指示在编译过程中显示一条信息：</p>
<p>#if _M_IX86 == 500</p>
<p>#pragma message( “Pentium processor build” )</p>
<p>#endif</p>
<p>messagestring参数可以是一个能够扩展成字符串文字量的宏，并且你能够用字符串文字量和宏的任何组合来构造。例如，下面的语句显示被编译文件的文件名和文件最后一次修改的日期和时间。</p>
<p>#pragma message( “Compiling “ <strong>FILE</strong> )</p>
<p>#pragma message( “Last modified on “ <strong>TIMESTAMP</strong> )</p>
<p><strong>18 once</strong></p>
<p>#pragma once</p>
<p>指定在创建过程中该编译指示所在的文件仅仅被编译程序包含（打开）一次。该编译指示的一种常见用法如下：</p>
<p>//header.h</p>
<p>#pragma once</p>
<p>// Your C or C++ code would follow:</p>
<p><strong>19 optimize</strong></p>
<p>仅在专业版和企业版中存在</p>
<p>#pragma optimize( “[optimization-list]”, {on | off} )</p>
<p>代码优化仅有Visual C++专业版和企业版支持。详见Visual C++ Edition。</p>
<p>指定在函数层次执行的优化。optimize编译选项必须在函数外出现，并且在该编译指示出现以后的第一个函数定义开始起作用。on和off参数打开或关闭在optimization-list指定的选项。</p>
<p>optimization-list能够是0或更多个在表2.2中给出的参数：</p>
<p>表 2.2   optimize编译指示的参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>优化类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>假定没有别名。</td>
</tr>
<tr>
<td>g</td>
<td>允许全局优化。</td>
</tr>
<tr>
<td>p</td>
<td>增强浮点一致性。</td>
</tr>
<tr>
<td>s 或 t</td>
<td>指定更短或者更快的机器代码序列。</td>
</tr>
<tr>
<td>w</td>
<td>假定在函数调用中没有别名。</td>
</tr>
<tr>
<td>y</td>
<td>在程序堆栈中生成框架指针。</td>
</tr>
</tbody>
</table>
<p>这些和在/O编译程序选项中使用的是相同的字母。例如：</p>
<p>#pragma optimize( “atp”, on )</p>
<p>用空字符串（””）的optimize编译指示是一种特别形式。它要么关闭所有的优化选项，要么恢复它们到原始（或默认）的设定。</p>
<p>#pragma optimize( “”, off )</p>
<p>#pragma optimize( “”, on )</p>
<p><strong>20 pack</strong></p>
<p>#pragma pack( [ n] )</p>
<p>指定结构和联合成员的紧缩对齐。尽管用/Zp选项设定整个翻译单元的结构和联合成员的紧缩对齐，可以用pack编译指示在<a href="https://www.baidu.com/s?wd=%E6%95%B0%E6%8D%AE%E8%AF%B4%E6%98%8E&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">数据说明</a>层次设定紧缩对齐。从出现该编译指示后的第一个结构或者联合说明开始生效。这个编译指示不影响定义。</p>
<p>当你使用#pragma pack(n)，其中n是1，2，4，8或者16，第一个以后的每个结构成员保存在较小的成员类型或者n字节边界上。如果你使用没有参数的#pragma pack，结构成员将被紧缩到由/Zp指定的值。默认的/Zp紧缩的大小是/Zp8。</p>
<p>编译程序还支持下面的增强语法：</p>
<p>#pragma pack( [ [ { push | pop}, ] [ identifier, ] ] [ n ] )</p>
<p>该语法允许你将使用不同紧缩编译指示的组件合并到同一个翻译单元内。</p>
<p>每次出现有push参数的pack编译指示将保存当前的紧缩对齐值到一个内部的编译程序堆栈。编译指示的参数列表从左向右读取。如果你使用了push，当前紧缩值被保存。如果你提供了一个n值，这个值将成为新的紧缩值。如果你指定了一个你选定的标示符，这个标示符将和新的紧缩值关联。</p>
<p>每次出现有pop参数的pack编译指示从内部编译程序堆栈顶部取出一个值并将那个值作为新的紧缩对齐。如果你用了pop，而内部编译程序堆栈是空的，对齐值将从命令行得到，同时给出一个警告。如果你用了pop并指定了n的值，那个值将成为新的紧缩值。如果你用了pop并指定了一个标示符，将移去所有保存在堆栈中的的值直到匹配的找到匹配的标示符，和该标示符关联的紧缩值也被从堆栈中移出来成为新的紧缩值。如果没有找到匹配的标示符，将从命令行获取紧缩值并产生一个1级警告。默认的紧缩对齐是8。</p>
<p>pack编译指示的新的增强功能允许你编写头文件保证在使用头文件之前和其后的紧缩值是一样的：</p>
<p>/* File name: include1.h</p>
<p>*/</p>
<p>#pragma pack( push, enter_include1 )</p>
<p>/<em> Your include-file code … </em>/</p>
<p>#pragma pack( pop, enter_include1 )</p>
<p>/<em> End of include1.h </em>/</p>
<p>在前面的例子中，进入头文件时将当前紧缩值和标示符enter_include1关联并推入，被记住。在头文件尾部的pack编译选项移去所有在头文件中可能遇到的紧缩值并移去和enter_include1关联的紧缩值。这样头文件保证了在使用头文件之前和其后的紧缩值是一样的。</p>
<p>新功能也允许你在你的代码内用pack编译指示为不同的代码，例如头文件设定不同的紧缩对齐。</p>
<p>#pragma pack( push, before_include1 )</p>
<p>#include “include1.h”</p>
<p>#pragma pack( pop, before_include1 )</p>
<p>在上一个例子中，你的代码受到保护，防止了在include.h中的任何紧缩值的改变。</p>
<p><strong>21 pointers_to_members</strong></p>
<p>C++特有</p>
<p>#pragma pointers_to_members(pointer-declaration, [most-general-representation] )</p>
<p>指定是否能够在相关类定义之前说明一个指向类成员的指针，并且用于控制指针的大小和解释指针的代码。你能够在你的源代码中使用pointers_to_members编译知识来代替/vmx编译程序选项。</p>
<p>pointer-declaration参数指出是否在相关函数定义之前或其后你已经说明了一个指向成员的指针。pointer-declaration参数是下面两个符号之一：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>full_generality</td>
<td>生成安全的，但是有时不能优化的代码。如果有一些指向成员的指针在相关类定义之前说明，你要用full_generality。这个参数总是使用由most-general-representation指定的指针表示方式。</td>
</tr>
<tr>
<td>best_case</td>
<td>对于所有指向成员的指针用最佳的表示方式生成安全的，优化的代码。需要在说明一个指向类成员指针之前定义类。默认是best_case。</td>
</tr>
</tbody>
</table>
<p>most-general-representaion参数指出在一个翻译单元中编译程序能够安全引用任何指向类成员指针的最小指针表示方式。这个参数可以是下列之一：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>single_inheritance</td>
<td>最普通的表示方式是单继承，指向成员函数。如果用于指向具有多重或者虚拟继承方式类成员的指针，将产生一个错误。</td>
</tr>
<tr>
<td>multi_inheritance</td>
<td>最普通的表示方式是多重继承，指向成员函数。如果用于指向具有虚拟继承方式类成员的指针，将产生一个错误。</td>
</tr>
<tr>
<td>virtual_inheritance</td>
<td>最普通的表示方式是虚拟继承，指向成员函数。不会产生错误。当使用#pragma pointers_to_members (full_generality)时这是默认的参数。</td>
</tr>
</tbody>
</table>
<p><strong>22 setlocale</strong></p>
<p>#pragma setlocale( “locale-string” )</p>
<p>定义用于翻译宽字符常数和字符串文字量时用的地区（国家和语言）。由于用于从多字节字符转换到宽字符的算法根据地区或者由于在运行可执行程序不同的地方进行编译而不同，这个编译指示提供一种在编译时指定目标地区的方式。这保证宽字符字符串将以正确的格式保存。默认的locale-string是“C”。“C”地区将字符串中的每个字符作为wchar_t（即unsigned int）映射其值。</p>
<p><strong>23 vtordisp</strong></p>
<p>C++特有</p>
<p>#pragma vtordisp({on | off} )</p>
<p>允许隐藏的附加vtordisp构造函数/析构函数替换成员。vtordisp编译指示仅能够用于具有虚拟基类的代码。如果派生类从一个虚拟基类重载了一个虚拟函数，并且如果派生类的构造函数或析构函数用指向虚拟基类的指针调用了这个函数，编译程序将根据虚拟基类在类中引入一个附加的隐藏“vtordisp”域。</p>
<p>vtodisp编译选项影响它后面的类布局。/vd0和/vd1选项为整个模块指定了相同的行为。指定off将禁止隐藏的vtordisp成员，指定on（默认）将在它们需要的时候允许vtordisp。仅在不可能出现类的构造函数和析构函数通过this指针调用其指向对象中的虚拟函数时才关闭vtordisp。</p>
<p>#pragma vtordisp( off )</p>
<p>class GetReal : virtual public { … };</p>
<p>#pragma vtordisp( on )</p>
<p><strong>24 warning</strong></p>
<p>#pragma warning( warning-specifier : warning-number-list [,warning-specifier : warning-number-list…] )</p>
<p>#pragma warning( push[ , n ] )</p>
<p>#pragma warning( pop )</p>
<p>允许有选择地修改编译程序警告信息的行为。</p>
<p>warning-specifier能够是下列值之一：</p>
<table>
<thead>
<tr>
<th>warning-specifier</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>once</td>
<td>只显示指定信息一次。</td>
</tr>
<tr>
<td>default</td>
<td>对指定信息应用默认的编译程序选项。</td>
</tr>
<tr>
<td>1,2,3,4</td>
<td>对指定信息引用给定的警告等级。</td>
</tr>
<tr>
<td>disable</td>
<td>不显示指定信息。</td>
</tr>
<tr>
<td>error</td>
<td>对指定信息作为错误显示。</td>
</tr>
</tbody>
</table>
<p>warning-number_list能够包含任何警告编号。如下，在一个编译指示中可以指定多个选项：</p>
<p>#pragma warning( disable : 4507 34; once : 4385; error : 164 )</p>
<p>这等价于：</p>
<p>#pragma warning( disable : 4507 34 ) // Disable warning messages</p>
<p>​                                             // 4507 and 34.</p>
<p>#pragma warning( once : 4385 )        // Issue warning 4385</p>
<p>​                                             // only once.</p>
<p>#pragma warning( error : 164 )        // Report warning 164</p>
<p>​                                             // as an error.</p>
<p>对于那些关于代码生成的，大于4699的警告标号，warning编译指示仅在函数定义外时有效。如果指定的警告编号大于4699并且用于函数内时被忽略。下面例子说明了用warning编译指示禁止、然后恢复有关代码生成警告信息的正确位置：</p>
<p>int a;</p>
<p>#pragma warning( disable : 4705 )</p>
<p>void func()</p>
<p>{</p>
<p>​    a;</p>
<p>}</p>
<p>#pragma warning( default : 4705 )</p>
<p>warning编译指示也支持下面语法：</p>
<p>#pragma warning( push [ ,n ] )</p>
<p>#pragma warning( pop )</p>
<p>这里n表示警告等级（1到4）。</p>
<p>warning(push)编译指示保存所有警告的当前警告状态。warning(push,n)保存所有警告的当前状态并将全局警告等级设置为n。</p>
<p>warning(pop)弹出最后一次推入堆栈中的警告状态。任何在push和pop之间改变的警告状态将被取消。考虑下面的例子：</p>
<p>#pragma warning( push )</p>
<p>#pragma warning( disable : 4705 )</p>
<p>#pragma warning( disable : 4706 )</p>
<p>#pragma warning( disable : 4707 )</p>
<p>// Some code</p>
<p>#pragma warning( pop )</p>
<p>在这些代码的结束，pop恢复了所有警告的状态（包括4705，4706和4707）到代码开始时候的样子。</p>
<p>当你编写头文件时，你能用push和pop来保证任何用户修改的警告状态不会影响正常编译你的头文件。在头文件开始的地方使用push，在结束地方使用pop。例如，假定你有一个不能顺利在4级警告下编译的头文件，下面的代码改变警告等级到3，然后在头文件的结束时恢复到原来的警告等级。</p>
<p>#pragma warning( push, 3 )</p>
<p>// Declarations/ definitions</p>
<p>#pragma warning( pop )</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb调试常用命令总结</title>
    <url>/2019/02/17/2019-02-17/</url>
    <content><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a><strong>1 简介</strong></h2><p>​     GDB（GNU Debugger）是GCC的调试工具。其功能强大，现描述如下：     GDB主要帮忙你完成下面四个方面的功能：     1.启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。     2.可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）     3.当程序被停住时，可以检查此时你的程序中所发生的事。     4.动态的改变你程序的执行环境。</p>
<h2 id="2-生成调试信息"><a href="#2-生成调试信息" class="headerlink" title="2 生成调试信息"></a><strong>2 生成调试信息</strong></h2><p>​     一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。如：</p>
<p>​     gcc -g hello.c -o hello</p>
<p>​     g++ -g hello.cpp -o hello</p>
<p>​     如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。</p>
<h2 id="3-启动GDB的方法"><a href="#3-启动GDB的方法" class="headerlink" title="3 启动GDB的方法"></a><strong>3 启动GDB的方法</strong></h2><p>​     gdb program</p>
<p>​     program 也就是你的执行文件，一般在当前目录下。</p>
<h2 id="4-程序运行上下文"><a href="#4-程序运行上下文" class="headerlink" title="4 程序运行上下文"></a><strong>4 程序运行上下文</strong></h2><h3 id="4-1-程序运行参数"><a href="#4-1-程序运行参数" class="headerlink" title="4.1 程序运行参数"></a><strong>4.1 程序运行参数</strong></h3><p>​     set args 可指定运行时参数。（如：set args 10 20 30 40 50 ）</p>
<p>​     show args 命令可以查看设置好的运行参数。</p>
<p>​     run  启动程序</p>
<h3 id="4-2-工作目录"><a href="#4-2-工作目录" class="headerlink" title="4.2 工作目录"></a><strong>4.2 工作目录</strong></h3><p>​     cd 相当于shell的cd命令。</p>
<p>​     pwd 显示当前的所在目录。</p>
<h2 id="5-设置断点"><a href="#5-设置断点" class="headerlink" title="5 设置断点"></a><strong>5 设置断点</strong></h2><h3 id="5-1-简单断点"><a href="#5-1-简单断点" class="headerlink" title="5.1 简单断点"></a><strong>5.1 简单断点</strong></h3><p>​     break 设置断点，可以简写为b</p>
<p>​     b 10 设置断点，在源程序第10行</p>
<p>​     b func 设置断点，在func函数入口处</p>
<h3 id="5-2-多文件设置断点"><a href="#5-2-多文件设置断点" class="headerlink" title="5.2 多文件设置断点"></a><strong>5.2 多文件设置断点</strong></h3><p>​     在进入指定函数时停住:</p>
<p>​     C++中可以使用class::function或function(type,type)格式来指定函数名。如果有名称空间，可以使用namespace::class::function或者function(type,type)格式来指定函数名。</p>
<p>​     break filename:linenum – 在源文件filename的linenum行处停住</p>
<p>​     break filename:function – 在源文件filename的function函数的入口处停住</p>
<p>​     break class::function或function(type,type) – 在类class的function函数的入口处停住</p>
<p>​     break namespace::class::function – 在名称空间为namespace的类class的function函数的入口处停住</p>
<h3 id="5-3-查询所有断点"><a href="#5-3-查询所有断点" class="headerlink" title="5.3 查询所有断点"></a><strong>5.3 查询所有断点</strong></h3><p>​     info b</p>
<h2 id="6条件断点"><a href="#6条件断点" class="headerlink" title="6条件断点"></a><strong>6条件断点</strong></h2><p>​     一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。</p>
<p>​     设置一个条件断点</p>
<p>​     b test.c:8 if intValue == 5</p>
<h2 id="7-维护停止点"><a href="#7-维护停止点" class="headerlink" title="7 维护停止点"></a><strong>7 维护停止点</strong></h2><p>​     delete [range…] 删除指定的断点，如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为d。</p>
<p>​          比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可，就好像回收站一样。</p>
<p>​     disable  [range…]</p>
<p>​          disable所指定的停止点，如果什么都不指定，表示disable所有的停止点。简写命令是dis.</p>
<p>​     enable [range…]</p>
<p>​          enable所指定的停止点，如果什么都不指定，表示enable所有的停止点。简写命令是ena.</p>
<h2 id="8-调试代码"><a href="#8-调试代码" class="headerlink" title="8 调试代码"></a><strong>8 调试代码</strong></h2><p>​     run 运行程序，可简写为r</p>
<p>​     next 单步跟踪，函数调用当作一条简单语句执行，可简写为n</p>
<p>​     step 单步跟踪，函数调进入被调用函数体内，可简写为s</p>
<p>​     finish 退出进入的函数</p>
<p>​     until 在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体,可简写为u。</p>
<p>​     continue 继续运行程序，可简写为c</p>
<h2 id="9-查看运行时数据"><a href="#9-查看运行时数据" class="headerlink" title="9 查看运行时数据"></a><strong>9 查看运行时数据</strong></h2><p>​     print 打印变量、字符串、表达式等的值，可简写为p</p>
<p>​     p count 打印count的值</p>
<h2 id="10-自动显示"><a href="#10-自动显示" class="headerlink" title="10 自动显示"></a><strong>10 自动显示</strong></h2><p>​     你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。</p>
<p>​     display 变量名</p>
<p>​     info display – 查看display设置的自动显示的信息。</p>
<p>​     undisplay num（info display时显示的编号）</p>
<p>​     delete display dnums… – 删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）</p>
<p>​     disable display dnums…</p>
<p>​     enable display dnums…</p>
<p>​     disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。</p>
<h2 id="11-查看修改变量的值"><a href="#11-查看修改变量的值" class="headerlink" title="11. 查看修改变量的值"></a>11. 查看修改变量的值</h2><p>​     (gdb) ptype width – 查看变量width的类型</p>
<p>​          type = double</p>
<p>​     (gdb) p width  – 打印变量width 的值</p>
<p>​          $4 = 13</p>
<p>​     你可以使用set var命令来告诉GDB，width不是你GDB的参数，而是程序的变量名，如：</p>
<p>​          (gdb) set var width=47</p>
<p>​     在你改变程序变量取值时，最好都使用set var格式的GDB命令。</p>
<h2 id="12-显示源代码"><a href="#12-显示源代码" class="headerlink" title="12 显示源代码"></a><strong>12 显示源代码</strong></h2><p>​     GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上 –g 的参数，把源程序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后，</p>
<p>​     GDB会报告程序停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。默认打印10行，还是来看一看查看源代码的GDB命令吧。</p>
<p>​     list linenum</p>
<p>​          Print lines centered around line number linenum in the current source file.</p>
<p>​     list function</p>
<p>​          显示函数名为function的函数的源程序。</p>
<p>​     list</p>
<p>​          显示当前行后面的源程序。</p>
<p>​     list -</p>
<p>​          显示当前行前面的源程序。</p>
<p>​     一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行，当然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数。</p>
<p>​          set listsize count</p>
<p>​     设置一次显示源代码的行数。(unless the list argument explicitly specifies some other number)</p>
<p>​          show listsize</p>
<p>​     查看当前listsize的设置。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>gdb调试</tag>
      </tags>
  </entry>
  <entry>
    <title>七牛云测试域名到期图片转移腾讯云COS过程</title>
    <url>/2019/02/16/2019-02-16-1/</url>
    <content><![CDATA[<p>今天终于把七牛云到期的测试域名所属空间的博客照片迁移到腾讯云。腾讯云有一定量免费空间供用户使用，希望腾讯云短期内不要出对没钱用户的制裁条款。当然，出了我们也不用慌，再迁移便是，正所谓不折腾不舒服斯基。果然免费的都是要付出其它代价的～ </p>
<h1 id="备份七牛云图片到本地"><a href="#备份七牛云图片到本地" class="headerlink" title="备份七牛云图片到本地"></a>备份七牛云图片到本地</h1><h3 id="批量下载七牛云图片到本地的步骤"><a href="#批量下载七牛云图片到本地的步骤" class="headerlink" title="批量下载七牛云图片到本地的步骤"></a><strong>批量下载七牛云图片到本地的步骤</strong></h3><p>1、下载以下工具包解压到当地硬盘，比如 D 盘，那么解压之后就获得一个 qiniu 文件夹，里面包含有两个文件，分别是 qshell.conf 和 qshell.exe 文件。</p>
<p> 批量下载七牛云图片到本地工具包（密码: xp1p）</p>
<p>2、用记事本或者 Notepad++ 软件打开 qshell.conf 文件，然后根据里面的要求填写相应的内容并保存。完成之后大概如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. &#123;</span><br><span class="line">2.     &quot;dest_dir&quot;  :   &quot;//images&quot;,</span><br><span class="line">3.     &quot;bucket&quot;    :   &quot;blog&quot;,</span><br><span class="line">4.     &quot;domain&quot;    :   &quot;http://********.com&quot;,</span><br><span class="line">5.     &quot;access_key&quot;    :&quot;******************&quot;,</span><br><span class="line">6.     &quot;secret_key&quot;    :&quot;******************&quot;,</span><br><span class="line">7.     &quot;is_private&quot;    :false,</span><br><span class="line">8.     &quot;prefix&quot;    :   &quot;&quot;,</span><br><span class="line">9.     &quot;suffix&quot;    :   &quot;&quot;</span><br><span class="line">10. &#125;</span><br></pre></td></tr></table></figure>
<p>其中 access_key 和 secret_key 的值可以在七牛云后台中的个人中心的密钥管理中获得。</p>
<p>3、运行电脑的 CMD，比如刚才我们是解压在 D 盘，那么就在CMD 中分别输入 d:、cd qiniu 和 qshell qdownload 10 qshell.conf  命令后即可自动下载七牛云的图片到本地指定的文件夹中，其中最后一条命令的 10 就是 10 线程的意思，一般是越大越快。</p>
<p>一般情况下等待一段时间就会自动下载完毕，我这次下载了带有前缀 boke112 的图片，图片不多，所以很快就下载完了。</p>
<h3 id="申请腾讯云"><a href="#申请腾讯云" class="headerlink" title="申请腾讯云"></a>申请腾讯云</h3><p>自行申请。</p>
<h2 id="批量替换文章里的图片链接"><a href="#批量替换文章里的图片链接" class="headerlink" title="批量替换文章里的图片链接"></a>批量替换文章里的图片链接</h2><p>本人参考网上一篇<a href="https://blog.csdn.net/HuYingJie_1995/article/details/82355033" target="_blank" rel="noopener">批量修改文件内容的Python代码</a>，魔改后。成功实现了批量修改本地Markdown文章图片链接。下面把Python代码贴出来供大家参考，轻拍～（Python版本2.7）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding=utf-8#可加入中文注释</span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">#函数功能：将指定文件夹下所有文件和子文件夹下的文件遍历，并修改文件内容</span><br><span class="line">import os</span><br><span class="line">fpath =&quot;/Users/fsf/PycharmProjects/Python2_tencentcloud/test&quot;#这里是你的第一级文件夹的路径</span><br><span class="line">def filechanger(path):</span><br><span class="line">        filenames = os.listdir(path)#将path路径下的所有文件名存入列表filenames</span><br><span class="line">        for filename in filenames:#循环遍历每个文件</span><br><span class="line">                domain = os.path.abspath(path)#获取规范的路径</span><br><span class="line">                filename = os.path.join(domain,filename)#带路径的文件名</span><br><span class="line">                if os.path.isdir(filename):  # 如果是文件夹进入递归</span><br><span class="line">                        filechanger(filename)</span><br><span class="line">                        continue</span><br><span class="line">                fread = open(filename,&apos;r&apos;)</span><br><span class="line">                fwrite = open(&quot;%s.backup&quot;%filename,&apos;w&apos;)</span><br><span class="line"></span><br><span class="line">                for line in fread.readlines():</span><br><span class="line">                        src_str = line</span><br><span class="line"></span><br><span class="line">                        if src_str.find(&apos;![&apos;) != -1:</span><br><span class="line">                                start = src_str.index(&apos;![&apos;) + 2</span><br><span class="line">                                end = src_str.index(&apos;](&apos;)</span><br><span class="line">                                sub = src_str[start:end]</span><br><span class="line"></span><br><span class="line">                                start1 = end + 2</span><br><span class="line">                                end1 = src_str.index(&apos;)&apos;)</span><br><span class="line">                                sub1 = src_str[start1:end1]</span><br><span class="line"></span><br><span class="line">                                sub2 = src_str[(end1 - 4):end1]</span><br><span class="line"></span><br><span class="line">                                s1 = &apos;https://xxxxxxxxx-3334.cos.ap-hongkong.myqcloud.com/&apos;</span><br><span class="line">                                s11 = &apos;https://xxxxxxxxx-3334.cos.ap-hongkong.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7&apos;</span><br><span class="line"></span><br><span class="line">                                # sub3 = src_str[:start1] + &apos;../images/&apos; + sub + sub2 + src_str[end1] + src_str[(end1+1):]</span><br><span class="line">                                s2 = sub + sub2 + src_str[end1] + src_str[(end1+1):]</span><br><span class="line"></span><br><span class="line">                                if src_str[start:(start + 12)] == &apos;屏幕快照&apos;:</span><br><span class="line">                                    s22 = s11 + src_str[(start + 12):end] + sub2 + src_str[end1] + src_str[(end1+1):]</span><br><span class="line">                                    sub3 = src_str[:start1] + s22.replace(&apos; &apos;, &apos;%20&apos;)</span><br><span class="line">                                else:</span><br><span class="line">                                    sub3 = src_str[:start1] + s1 + s2.replace(&apos; &apos;,&apos;%20&apos;)</span><br><span class="line">                                fwrite.write(sub3)  # 修改后写入新文件</span><br><span class="line">                                print(sub3)</span><br><span class="line">                        else:</span><br><span class="line">                                fwrite.write(src_str)</span><br><span class="line">                                print(src_str)</span><br><span class="line">                                continue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                fread.close()</span><br><span class="line">                fwrite.close()</span><br><span class="line">                os.remove(filename)#如果想更改数据后想保留原文件以及修改文件名可屏蔽这一句和下一句</span><br><span class="line">                os.rename(&quot;%s.backup&quot; % filename, filename)#</span><br><span class="line">filechanger(fpath)</span><br></pre></td></tr></table></figure>
<p>自18年9月，终于把七牛云到期的测试域名所属空间的博客照片迁移到腾讯云。腾讯云有一定量免费空间供用户使用（发博文时免费额度：50 GB 标准存储容量，10 GB CDN 回源流量，100 万次读请求，100 万次写请求。费用实例），希望腾讯云短期内不要出对没钱用户的制裁条款。当然，出了我们也不用慌，再迁移便是，正所谓不折腾不舒服斯基。果然免费的都是要付出其它代价的～ </p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>不蒜子统计失效问题解决</title>
    <url>/2019/02/16/2019-02-16/</url>
    <content><![CDATA[<h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><p>hexo想要开启站点统计，只需找到_config.yml配置文件，把busuanzi_count的enable设置为true即可。但近期，这个不蒜子的统计功能就失效了。查阅了<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子官方</a>的说法，</p>
<blockquote>
<p>“因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！”</p>
</blockquote>
<p>由于七牛云9月底强行关闭测试域名，导致本博客在七牛云存的所有图片也无法正常加载了。</p>
<h4 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h4><p>找到原来不蒜子的域名文件，并替换掉旧的域名。<br> 文件路径：\themes\next\layout_third-party\analytics\busuanzi-counter.swig，只需要替换src对应的域名即可，如下是替换后的域名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>默剧</title>
    <url>/2018/12/11/2018-12-11/</url>
    <content><![CDATA[<p>默剧 </p>
<p>浅悠悠(摘星集)12.11 </p>
<p>1 </p>
<p>霏霏思雨， </p>
<p>雨里等你， </p>
<p>不念凄寂， </p>
<p>只念你。 </p>
<p>2 </p>
<p>借一方清水涟漪， </p>
<p>泛起眷恋的气息。 </p>
<p>你无声色的思绪， </p>
<p>是我解不开的迷。 </p>
<p>3 </p>
<p>你我此刻的局， </p>
<p>像演一出默剧。 </p>
<p>静静观戏的你， </p>
<p>从不发表建议。 </p>
<p>留下我， </p>
<p>也沉默在这孤单角色里。 </p>
<p>4 </p>
<p>一纸夙愿， </p>
<p>写进风里。 </p>
<p>青骢双骑， </p>
<p>想和你。 </p>
<p>5 </p>
<p>借一曲寂寥旋律， </p>
<p>点缀这孤独的戏。 </p>
<p>没有言语的默剧， </p>
<p>我用风雨吸引你。 </p>
<p>6 </p>
<p>说不出的千言万语， </p>
<p>丢在风里， </p>
<p>把这独角戏的结局， </p>
<p>寄在雨里。 </p>
<p>淋着雨， </p>
<p>盼着你储存温度的消息。 </p>
<p>7 </p>
<p>寒风十里， </p>
<p>我在等雨。 </p>
<p>风里雨里， </p>
<p>不见你。 </p>
<p>8 </p>
<p>借一道惊雷霹雳， </p>
<p>撕裂无言的默剧。 </p>
<p>期待下一场大雨， </p>
<p>洗刷过往的回忆。 </p>
<p>9 </p>
<p>将那洗不掉的泪痕， </p>
<p>淹没心底， </p>
<p>你我没有句点的剧， </p>
<p>绝口不提。 </p>
<p>留下你， </p>
<p>是我心口掩不住的秘密。 </p>
<p>10 </p>
<p>相逢似雨， </p>
<p>遥遥无期。 </p>
<p>从此， </p>
<p>只爱清酒， </p>
<p>不爱你。 </p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>摘星集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>备战焦作日常小练之PrimeGame</title>
    <url>/2018/11/21/2018-11-21/</url>
    <content><![CDATA[<p>Given a suqence of nn integers a_iai.</p>
<p>Let \text{mul}(l, r) = \prod_{i = l}^{r} a_imul(l,r)=∏i=lrai and \text{fac}(l, r)fac(l,r) be the number of distinct prime factors of \text{mul}(l, r)mul(l,r).</p>
<p>Please calculate \sum_{i = 1}^{n}\sum_{j = i}^{n}\text{fac}(i, j)∑i=1n∑j=infac(i,j)</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The first line contains one integer nn (1 \le n \le 10^61≤n≤106) \text{—}— the length of the sequence.</p>
<p>The second line contains nn integers a_iai (1 \le i \le n, 1 \le a_i \le 10^61≤i≤n,1≤ai≤106) \text{—}— the sequence.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>Print the answer to the equation.</p>
<h4 id="样例输入1复制"><a href="#样例输入1复制" class="headerlink" title="样例输入1复制"></a>样例输入1复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">99 62 10 47 53 9 83 33 15 24</span><br></pre></td></tr></table></figure>
<h4 id="样例输出1复制"><a href="#样例输出1复制" class="headerlink" title="样例输出1复制"></a>样例输出1复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">248</span><br></pre></td></tr></table></figure>
<h4 id="样例输入2复制"><a href="#样例输入2复制" class="headerlink" title="样例输入2复制"></a>样例输入2复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">6 7 5 5 4 9 9 1 8 12</span><br></pre></td></tr></table></figure>
<h4 id="样例输出2复制"><a href="#样例输出2复制" class="headerlink" title="样例输出2复制"></a>样例输出2复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">134</span><br></pre></td></tr></table></figure>
<h4 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h4><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%20Nanjing%20Onsite%202018" target="_blank" rel="noopener">ACM-ICPC Nanjing Onsite 2018</a></p>
<p>题意</p>
<p>n个数，求所有[i,j]区间内每个数不重复的素数因素之和。</p>
<p>题解</p>
<p>将每个数分解成不同素数之积。例如例1，99分解成3和11，62分解成2和31，10分解成2和5，47分解成47，53为53，9为3，83为83，33为3和11，15为3和5，24为2和3。</p>
<p>第1个数出现次数为n次，第2个为(n-1) <em> 2次，第3个为(n-3) </em> 3次……则素数因数不重复的前提下和母数出现次数相同。但由于某些区间存在相同素数，所以我们规定假设某一位数的素数因数p所在位置为c,上一个这个素数p位置为b，则这次这个素数p出现次数为(n + 1 - c) * (c - b)。当然所以素数的初始位置为0，没出现一次就将该位置更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn = 1e6+7;</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int size;</span><br><span class="line">    ll prime[20];</span><br><span class="line">&#125;node[maxn];</span><br><span class="line">int n;</span><br><span class="line">int pos[maxn];</span><br><span class="line">bool isPrime[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    for(ll i = 2; i &lt; maxn; i++)&#123;</span><br><span class="line">        if(!isPrime[i])&#123;</span><br><span class="line">            node[i].prime[node[i].size++] = i;</span><br><span class="line">            for(ll j = i+i; j &lt; maxn; j+=i)&#123;</span><br><span class="line">                isPrime[j] = true;</span><br><span class="line">            	node[j].prime[node[j].size++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">        ll tmp;</span><br><span class="line">        scanf(&quot;%lld&quot;, &amp;tmp);</span><br><span class="line">        for(int j = 0; j &lt; node[tmp].size; j++)&#123;</span><br><span class="line">            ans += (ll)(n + 1 - i)*(i - pos[node[tmp].prime[j]]);</span><br><span class="line">            pos[node[tmp].prime[j]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>求最小的有2^(500500)个因子的数</title>
    <url>/2018/11/18/2018-11-18/</url>
    <content><![CDATA[<p>我们知道，120有16个因子(不信自己数一数)。事实上120也是最小的有16个因子的数。</p>
<p>请你找出最小的有2的500500次方个因子的数。</p>
<p>因为数据过大，可以结果对500500507取模。</p>
<p>思路：</p>
<p>以120为例，120的质因数分解为<code>2*2*2*3*5</code>。那么和16有什么关系呢？很明显，从这5个数中随机选[0-5]个数共有多少种方法呢。刚好16种。及<code>4*2*2</code>种。2有4种选法，3有2种（选或不选），5也2种。所以组合方式为16种。</p>
<p>现在看这道题，2^500500个因子，与2相关，1个素数p有2^1种，3个p有2^2种，7个有1^3种……</p>
<p>现在我们有500500个位置，那么1个p占1位，若p有多个，则剩下的2个占1位，然后剩下的4个1位，8个1位……而2^32已经超int范围了，所以次方最大为16。然后我们打表求出前500500个素数，对着500500个素数中分别插入2^2,2^4,2^8,2^16,3^2,3^4,3^8,5^2……插入的前提是p^n要小于500500个数中的最大数。最后求出这500500个数之后，只需相乘就是该数了。有了思路就可以写代码了。</p>
<p>答案取模500500507后为35407281</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll mod = 500500507;</span><br><span class="line">const ll mi = 500500+1;</span><br><span class="line">const ll maxn = 2e7;</span><br><span class="line">ll a[4] = &#123;2, 4, 8, 16&#125;;</span><br><span class="line">ll prime[mi+100];</span><br><span class="line">ll check[maxn], tot;</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(check, 0, sizeof(check));</span><br><span class="line">    prime[tot++] = 1;</span><br><span class="line">    for (ll i = 2; i &lt; maxn; ++i)&#123;</span><br><span class="line">        if(!check[i])&#123;</span><br><span class="line">            prime[tot++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tot == mi)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        for (ll j = 1; j &lt; tot; ++j)&#123;</span><br><span class="line">            if (i * prime[j] &gt; maxn)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            check[i*prime[j]] = 1;</span><br><span class="line">            if (i % prime[j] == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll Pow(ll a, ll b)&#123;</span><br><span class="line">    ll ans = 1;</span><br><span class="line">    for(ll i = 1; i &lt;= b; i++)&#123;</span><br><span class="line">        ans *= a;</span><br><span class="line">        if(ans &gt; prime[tot-1])&#123;</span><br><span class="line">            ans = prime[tot-1]+1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    priority_queue&lt;ll&gt;que;</span><br><span class="line">    que.push(1);</span><br><span class="line">    ll Size = 1;</span><br><span class="line">    ll Top = 4;</span><br><span class="line">    for(ll i = 1; i &lt; mi; i++)&#123;</span><br><span class="line">        if(Size &gt;= mi)&#123;</span><br><span class="line">            if(prime[i] &gt;= que.top())&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                que.pop();</span><br><span class="line">                que.push(prime[i]);</span><br><span class="line">                for(ll j = 0; j &lt; Top; j++)&#123;</span><br><span class="line">                    if(Pow(prime[i], a[j]) &gt;= prime[tot-1])&#123;</span><br><span class="line">                        Top = j;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(Pow(prime[i], a[j]) &gt;= que.top())&#123;</span><br><span class="line">                        Top = j;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        que.pop();</span><br><span class="line">                        que.push(Pow(prime[i], a[j]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            que.push(prime[i]);</span><br><span class="line">            Size++;</span><br><span class="line">            for(ll j = 0; j &lt; Top; j++)&#123;</span><br><span class="line">                if(Pow(prime[i], a[j]) &gt;= prime[tot-1])&#123;</span><br><span class="line">                    Top = j;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(Size &gt;= mi)&#123;</span><br><span class="line">                    if(Pow(prime[i], a[j]) &gt;= que.top())&#123;</span><br><span class="line">                        Top = j;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        que.pop();</span><br><span class="line">                        que.push(Pow(prime[i], a[j]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    if(Pow(prime[i], a[j]) &gt;= prime[tot-1])&#123;</span><br><span class="line">                        Top = j;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    que.push(Pow(prime[i], a[j]));</span><br><span class="line">                    Size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = 1;</span><br><span class="line">    int SI = 0;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        ans *= que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        ans%=mod;</span><br><span class="line">        SI++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>昨世今生</title>
    <url>/2018/11/09/2018-11-09/</url>
    <content><![CDATA[<p>author：浅悠悠</p>
<p>致亲人，致自己</p>
<p>5岁，</p>
<p>你的梦想是什么呢？</p>
<p>emm，环游世界！</p>
<p>为什么呢？</p>
<p>爷爷之前说的。</p>
<p>9岁，告别了童言无忌</p>
<p>然而玩耍依然是最大的乐趣。</p>
<p>那些年，是记忆里的伊甸园。</p>
<p>12岁，你开始了奋发学习</p>
<p>你并不理解知识改变命运，</p>
<p>但你却依旧坚持，</p>
<p>为了心中的荣誉。</p>
<p>那些年，你的理想是北大清华。</p>
<p>15岁，你读了高中</p>
<p>开始憧憬大人们的生活，</p>
<p>也开始尝试各种偶像剧。</p>
<p>你喜欢看好莱坞，听飞轮海。</p>
<p>你学明星留起了长发，</p>
<p>也在心里默默藏起了一个她。</p>
<p>17岁，快要高考了</p>
<p>你却接受了各式文化的洗礼，</p>
<p>渐渐喜欢弹琴写词，</p>
<p>喜欢吟诗作画，</p>
<p>喜欢古典音乐与欧美文学，</p>
<p>喜欢听《为你写诗》，看她笑靥如花 。</p>
<p>那些年，你眼里只有她。</p>
<p>18岁，你踏上了大学生活</p>
<p>昔日的她也断了联系。</p>
<p>你开始学李清照多愁善感，</p>
<p>也学苏轼一笑释然。</p>
<p>时而感时花溅泪，</p>
<p>时而欲与天公试比高。</p>
<p>那一年，你的理想是文学与艺术。</p>
<p>20岁，大二刚刚结束</p>
<p>你开始后悔两年的蹉跎，</p>
<p>也明白了人生几何。</p>
<p>身边有几个一直陪伴你的红颜，</p>
<p>但你每次都觉得和那个她比，</p>
<p>差了一点。</p>
<p>你封闭起自己奋发图强，</p>
<p>渐渐厌倦了与别人的交流，</p>
<p>却渴望着别人的理解。</p>
<p>那些年，你的理想是出人头地。</p>
<p>22岁，即将毕业</p>
<p>却发现很难找到一份令自己满意的工作，</p>
<p>你渐渐明白很多事情不是由自己决定。</p>
<p>你收起了曾经的轻狂，</p>
<p>也渐渐学着别人假装。</p>
<p>你开始喜欢看周星驰，听毛不易。</p>
<p>那一年，你的理想是找到一份稳定的工作。</p>
<p>24岁，忙碌的工作压得你喘不过气</p>
<p>看尽了天外有天有无常，</p>
<p>山外有山有他乡，</p>
<p>你已忘却了喜怒无常，</p>
<p>凡事都一笑而过。</p>
<p>你穿梭于各个城市之间，</p>
<p>有时也常常想起曾经环游世界的梦想，</p>
<p>但也只能感慨马路的纵横交错。</p>
<p>那些年，你只想轻松一点。</p>
<p>26岁，你依旧孑然一身</p>
<p>随着年纪增长的，</p>
<p>除了脱单的朋友们，</p>
<p>还有送去各种礼金。</p>
<p>过节回家，父母从带你串亲戚，</p>
<p>变成了催你找对象。</p>
<p>而你每次都是推辞说忙，</p>
<p>或者配不上别人家的姑娘。</p>
<p>28岁，你遇见了一个和你境遇类似的姑娘</p>
<p>初次见面，简单地交涉，</p>
<p>彼此没有脸红，也没有心跳，只剩下尴尬。</p>
<p>终于她喝了一口浓咖啡说，你还不错。</p>
<p>你愣了一下，说，你也不错。</p>
<p>29岁，你们结婚了</p>
<p>你并不确定她是否真的喜欢你，</p>
<p>就像你不确定是否真的喜欢她，</p>
<p>只是双方父母一直在催促。</p>
<p>攒了几年去实现理想的钱，</p>
<p>全部用在了这场婚宴上。</p>
<p>婚前的酒宴，朋友来的不多也不少。</p>
<p>你醉后对朋友说，不想结婚，</p>
<p>朋友说，你只是喝多了，想多了。</p>
<p>30岁，渐渐升职</p>
<p>独自负责几个项目，</p>
<p>管理几个刚毕业的入职者。</p>
<p>然而她怀孕了，辞掉了工作，</p>
<p>于是你又每日加班。</p>
<p>电话那边总是抱怨，</p>
<p>但你却不能争辩什么。</p>
<p>那些年，你的理想是简单安稳的生活。</p>
<p>31岁，有了孩子</p>
<p>大大小小的费用又花去了一笔钱，</p>
<p>不过都无所谓，</p>
<p>你看着你的孩子，</p>
<p>心中满是欣慰。</p>
<p>那一年，你的全部只为孩子。</p>
<p>32岁，人生最忙碌的一年，</p>
<p>孩子24小时的折腾，</p>
<p>第二天拖着疲惫的身体上班，</p>
<p>老板说你上班不干活，</p>
<p>回家媳妇说你不干活，</p>
<p>你想了半天也没明白，那谁干的活呢。</p>
<p>那些年，你不再提起理想。</p>
<p>35岁，你的身体越来越差，</p>
<p>加班越来越少，</p>
<p>晋升也越来越慢，</p>
<p>而孩子也要开始上幼儿园了，</p>
<p>各种培训机构与学费又花去了不少积蓄，</p>
<p>那一年，你本打算给自己过个生日，换个新电脑</p>
<p>40岁，曾经宣告世界的理想已不知去何方。</p>
<p>你常常希望将曾经未完成的心愿寄托给孩子，</p>
<p>但望着尚未还完的房贷，你笑笑摇摇头。</p>
<p>一天，他对你说，爸，我想学钢琴。</p>
<p>你没什么犹豫的，这些年你已经习惯了，</p>
<p>但那句“爸爸现在买不起”你始终说不出口。</p>
<p>孩子很懂事，说：爸爸没事，我学吉他也可以。</p>
<p>你看着这么懂事的孩子，却开心不起来。</p>
<p>那些年，你不再提起那些年。</p>
<p>50岁，孩子上了大学</p>
<p>他学的专业你有点不懂，</p>
<p>你知道工作不好找，</p>
<p>你和他深夜聊聊，</p>
<p>准备了四两白酒，</p>
<p>你说着那些曾经你最讨厌的话，</p>
<p>你们从交流变成了争吵，</p>
<p>你发现，你老了，老到可能都打不过这个18岁的孩子。</p>
<p>你说不过他，只能说一句：我是你爸！ </p>
<p>孩子看着你，知道再怎么争辩都没用，</p>
<p>这场确立你最后威严的酒局不欢而散，</p>
<p>在孩子回自己屋的路上叨叨了一句 “我不想活成你那样” 。</p>
<p>50岁的人了，怎么就哭了呢？</p>
<p>一定是酒太烈了，</p>
<p>对，一定是酒太烈了</p>
<p>54岁，孩子也工作了</p>
<p>似乎有一点理解你了，</p>
<p>但你却反了过来，</p>
<p>告诉他说不要妥协 。</p>
<p>55岁，孩子结婚了</p>
<p>你问他，你喜欢他吗。</p>
<p>他愣了愣，喜欢吧。</p>
<p>60岁，有时间旅行了</p>
<p>你和老伴准备好了，</p>
<p>孩子却说：爸妈，我工作忙了。</p>
<p>帮我照顾一下孩子。</p>
<p>你们退了机票，</p>
<p>又回到了30年前</p>
<p>65岁，孩子的孩子也上学了</p>
<p>你下定决心说：一定要环游世界，</p>
<p>可是手边的拐杖，</p>
<p>只能支撑你走到楼下花园。</p>
<p>68岁，你已走到了人生的尽头。</p>
<p>你躺在医院的病床上，</p>
<p>望着窗外泛黄的枯叶不知何时落下来。</p>
<p>你迷迷糊糊的看见医生摇了摇头，</p>
<p>你明白了，你要死了。</p>
<p>你并没有感到害怕。</p>
<p>你这一生，无怨无悔。</p>
<p>只是，有好多遗憾啊。</p>
<p>听说，人死时是最清醒的。</p>
<p>因为那时你的大脑里会倒叙你的一生。</p>
<p>生命的倒叙走向了最后一秒，</p>
<p>忽然间，身边的人哭了，你却笑了。</p>
<p>原来画面又回到了18岁的离别季，</p>
<p>那一天离别前，你们端坐在操场的石凳上，</p>
<p>各自心中思绪万千，嘴上却沉默无言。</p>
<p>终于，你放下了腼腆，</p>
<p>攥紧了她的手，</p>
<p>笑着对她说，</p>
<p>往后余生，</p>
<p>愿你拥有全部的权力，</p>
<p>而我愿拥有全部的义务。</p>
]]></content>
      <categories>
        <category>心路历程</category>
        <category>散文</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title>最小割求解最大权闭合子图</title>
    <url>/2018/10/10/2018-10-10/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>有一个有向图，每一个点都有一个权值（可以为正或负或0），选择一个权值和最大的子图，使得每个点的后继都在子图里面，这个子图就叫最大权闭合子图。<br> 如下图：<br> <img src="https://img-blog.csdn.net/20170826170245647?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FuOTE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="有向图"><br> 能选的子图有Ø,{4},{3,4},{2,4},{1,2,3,4},它们的权值分别为0,-1,5,-6,4.<br> 所以最大权闭合子图为{3,4}，权值为5.</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>这个问题可以转化为最小割问题，用网络流解决。<br> 从源点s向每个正权点连一条容量为权值的边，每个负权点向汇点t连一条容量为权值的绝对值的边，有向图原来的边容量全部为无限大。<br> <img src="https://img-blog.csdn.net/20170826171031814?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FuOTE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="最小割建模"><br> 求它的最小割，割掉后，与源点s连通的点构成最大权闭合子图，权值为（正权值之和-最小割）。</p>
<h3 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h3><h4 id="割掉一条边的含义"><a href="#割掉一条边的含义" class="headerlink" title="割掉一条边的含义"></a>割掉一条边的含义</h4><p>由于原图的边都是无穷大，那么割边一定是与源点s或汇点t相连的。</p>
<p>割掉s与i的边，表示不选择i点作为子图的点；<br> 割掉i与t的边，表示选择i点为子图的点。</p>
<p>如果s与i有边，表示i存在子图中；<br> 如果i与t有边，表示i不存在于子图中。</p>
<h4 id="合法性"><a href="#合法性" class="headerlink" title="合法性"></a>合法性</h4><p>只有s与t不连通时，才能得到闭合子图。</p>
<p>如果s与t连通，则存在点i,j，使得s到i有边，i到j连通，j到t有边，所以j一定是i的后继，但选择了i，没有选择j，不是闭合子图。</p>
<p>如果s与t不连通，选择了正权点i，一定选择了i后继中的所有负权点。设j是i的后继中的正权点，则割掉s到j的边是没有意义的，最小割不会割掉它，则j一点被选中，所以i的所有后继都被选中，符合闭合图的定义。</p>
<h4 id="最优性"><a href="#最优性" class="headerlink" title="最优性"></a>最优性</h4><p>最小割=(不选的正权之和+要选的负权绝对值之和）<br> 最大权闭合子图=（正权之和-不选的正权之和-要选的负权绝对值之和）=正权值和-最小割<br> 因为正权值和，是定值，而最小割保证值最小，所以最大权闭合子图一定最优。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>POJ2987_Firing</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>最小割</tag>
        <tag>最大权闭合子图</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统三大经典同步问题</title>
    <url>/2018/10/09/2018-10-09/</url>
    <content><![CDATA[<p>用专业术语来说, 进程是程序的一次动态执行.说简单点, 就是进程是系统中的某个任务.操作系统中有多个任务需要执行, 那么怎样执行才能使它们同步呢? 即如何让任务并发执行互不影响呢? 这就引出了进程同步中的经典问题: 生产者消费者问题, 哲学家进餐问题, 读写问题</p>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>有一群生产者进程在生产产品, 并将这些产品提供给消费者进程取消费. 为使生产者进程与消费者进程能并发进行, 在两者间设置了一个具有n个缓冲区的缓冲池, 生产者进程将其所生产的产品翻入缓冲区中, 消费者进程可从一个缓冲区中取走产品取消费.生产者消费者进程都以异步方式进行, 但它们之间必须保持同步, 不允许消费者进程到空缓冲区去取产品, 也不允许生产者进程向已满的缓冲区投放产品.</p>
<p>一个缓冲池中有n个缓冲区, 只要缓冲池未满, 生产者便可以投放产品; 缓冲池为空, 消费者便可以消费产品</p>
<h3 id="法一-记录型信号量"><a href="#法一-记录型信号量" class="headerlink" title="法一:记录型信号量"></a>法一:记录型信号量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//生产者消费者问题</span><br><span class="line">//记录型信号量</span><br><span class="line">//缓冲池中有n个缓冲区, 互斥信号量mutex, </span><br><span class="line">//信号量empty表示空缓冲区数量, full表示满缓冲区的数量</span><br><span class="line">int in = out = 0;</span><br><span class="line">item buffer[n];</span><br><span class="line">semaphore mutex = 1, empty = n, full = 0;</span><br><span class="line">void producer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        producer an item nextp;</span><br><span class="line">        wait(empty);</span><br><span class="line">        wait(mutex);</span><br><span class="line">        buffer[in] = nextp;</span><br><span class="line">        in = (in + 1) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(full);</span><br><span class="line">    &#125; while(true);</span><br><span class="line">&#125;</span><br><span class="line">void consumer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        wait(full);</span><br><span class="line">        wait(mutex);</span><br><span class="line">        nextc = buffer[out];</span><br><span class="line">        out = (out + 1) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(empty);</span><br><span class="line">        consumer the item in nextc;</span><br><span class="line">    &#125; while(true);</span><br><span class="line">&#125;</span><br><span class="line">void main() &#123;</span><br><span class="line">    cobegin</span><br><span class="line">        producer();</span><br><span class="line">        consumer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意: 对信号量的wait()和signal()操作必定是成对出现的.</p>
<h3 id="法二-AND型信号量"><a href="#法二-AND型信号量" class="headerlink" title="法二:AND型信号量"></a>法二:AND型信号量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//AND型信号量</span><br><span class="line">//Swait(empty, mutex)代替wait(empty)和wait(mutex)</span><br><span class="line">//Ssignal(mutex,full)代替signal(mutext)和signal(full)</span><br><span class="line">//Swait(full, mutex)代替wait(full)和wait(mutex)</span><br><span class="line">//Ssignal(mutex, empty)代替signal(mutex)和signal(empty)</span><br><span class="line">int in = out = 0;</span><br><span class="line">item buffer[n];</span><br><span class="line">semaphore mutex = 1, empty = n, full = 0;</span><br><span class="line">void producer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        producer an item nextp;</span><br><span class="line">        Swait(empty, mutex);</span><br><span class="line">        buffer[in] = nextp;</span><br><span class="line">        in = (in + 1) % n;</span><br><span class="line">        Ssignal(mutex, full);</span><br><span class="line">    &#125; while(true);</span><br><span class="line">&#125;</span><br><span class="line">void consumer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        Swait(full, mutex);</span><br><span class="line">        nextc = buffer[out];</span><br><span class="line">        out = (out + 1) % n;</span><br><span class="line">        Ssignal(mutex, empty);</span><br><span class="line">        consumer the item in nextc;</span><br><span class="line">    &#125; while(true);</span><br><span class="line">&#125;</span><br><span class="line">void main() &#123;</span><br><span class="line">    cobegin</span><br><span class="line">        producer();</span><br><span class="line">        consumer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="法三-管程"><a href="#法三-管程" class="headerlink" title="法三: 管程"></a>法三: 管程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//管程</span><br><span class="line">//建立管程producerconsumer,PC</span><br><span class="line">/*</span><br><span class="line">put(x), 生产者利用该过程将自己生产的产品投放到缓冲池中, 并用整型变量count表示缓冲池中已有的产品数目,当</span><br><span class="line">count&gt;=N时, 表示缓冲池已满,生产者需等待.</span><br><span class="line">get(x), 消费者利用该过程从缓冲池中取出一个产品, 当count&lt;=0时, 表示缓冲池已无可用的产品, 消费者需等待</span><br><span class="line">condition 为notfull和notempty</span><br><span class="line">cwait(condition), 当管程被一个进程占用时, 其他进程调用该进程时阻塞, 并挂在条件condition的队列上</span><br><span class="line">csignal(condition), 唤醒在cwait执行后阻塞在条件condition队列上的进程, 如果这样的进程不止一个, 则选择其中一个</span><br><span class="line">实施唤醒操作, 如果队列为空, 则无操作而返回.</span><br><span class="line">*/</span><br><span class="line">Monitor producerconsumer &#123;</span><br><span class="line">    item buffer[N];</span><br><span class="line">    int in, out;</span><br><span class="line">    condition notfull, notempty;</span><br><span class="line">    int count;</span><br><span class="line">    public:</span><br><span class="line">        void put(item x) &#123;</span><br><span class="line">            if (count &gt;= N) cwait(notfull);</span><br><span class="line">            buffer[in] = x;</span><br><span class="line">            in = (in + 1) % N;</span><br><span class="line">            count++;</span><br><span class="line">            ssignal(notempty);</span><br><span class="line">        &#125;</span><br><span class="line">        void get(item x) &#123;</span><br><span class="line">            if (count &lt;= 0) cwait(notempty);</span><br><span class="line">            x = buffer[out];</span><br><span class="line">            out = (out + 1) % N;</span><br><span class="line">            count--;</span><br><span class="line">            csignal(notfull);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            in = 0;</span><br><span class="line">            out = 0;</span><br><span class="line">            count = 0;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;PC;</span><br><span class="line"></span><br><span class="line">void producer() &#123;</span><br><span class="line">    item x;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        producer an item in nextp;</span><br><span class="line">        PC.put(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void consumer() &#123;</span><br><span class="line">    item x;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        PC.get(x);</span><br><span class="line">        consumer the item in nextc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void main() &#123;</span><br><span class="line">    cobegin</span><br><span class="line">        producer();</span><br><span class="line">        consumer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h2><p>五个哲学家公用一张圆桌, 分别坐在周围的五张桌子上, 在圆桌上有五个碗和五只筷子交叉排列, 它们的生活方式是交替的进行思考和进餐. 哲学家进行思考时不用筷子, 饥饿时取一只他两边的任意一只筷子(默认取左边的筷子, 没有时取右边的, 都没有时就取不了), 当他有两只筷子时就能进餐. 进餐后, 放下筷子继续思考.若只有一只筷子, 不放弃该筷子并等待拥有另一只筷子时再进餐.</p>
<p>用一个信号量表示一只筷子, 共五个信号量 semaphore chopsitck[5] = {1, 1, 1, 1, 1}; , 为 1 表示筷子未拿起, 为0表示筷子被拿起.那么第i为科学家的进餐活动就可以描述为</p>
<h3 id="法一-记录型信号量-1"><a href="#法一-记录型信号量-1" class="headerlink" title="法一:记录型信号量"></a>法一:记录型信号量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    wait(chopstick[i]);</span><br><span class="line">    wait(chopstick[(i + 1) % 5]);</span><br><span class="line">    //eat</span><br><span class="line">    signal(chopstick[i]);</span><br><span class="line">    signal(chopstick[(i + 1) % 5]);</span><br><span class="line">    //think</span><br><span class="line">&#125; while (true);</span><br></pre></td></tr></table></figure>
<p>假设五位哲学家都要拿筷子(都拿左手边), 那么将没有人可以 用餐, 就会陷入死锁状态.则哲学家进餐的解决方法:</p>
<p>1.至多允许四位哲学家拿同一边的筷子, 则可让至少一位哲学家先用餐, 用餐完后释放筷子进而让其他哲学家有机会用餐.</p>
<p>2.五位哲学家先竞争奇数(偶数)好筷子, 在竞争偶数(奇数)号筷子, 总会有一位哲学家能进餐.</p>
<h3 id="法二-AND型信号量-1"><a href="#法二-AND型信号量-1" class="headerlink" title="法二: AND型信号量"></a>法二: AND型信号量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//AND型信号量</span><br><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line">do &#123;</span><br><span class="line">    //think</span><br><span class="line">    Swait(chopsitck[(i + 1) % 5], chopsitck[i]);</span><br><span class="line">    //eat</span><br><span class="line">    Ssignal(chopsitck[(i + 1) % 5], chopsitck[i]);</span><br><span class="line">&#125; while (true);</span><br></pre></td></tr></table></figure>
<h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>一个数据文件或记录可被多个进程所共享, 则我们称这个文件或记录为共享对象.读文件的进程称为Reader进程, 写文件的进程称为Writer进程.共享对象可以被多个Reader进程, 因为读进程并不会破坏数据, 但是Writer进程在任何时刻只能有一个, 且须与其他对象互斥的访问共享对象, 否则多个写进程会造成冲突. 读写者问题即一个Writer进程必须与其他进程互斥的访问共享对象.</p>
<p>设置写互斥信号量wmutex</p>
<p>设置读互斥信号量rmutex</p>
<p>整型变量readcount表示正在读的进程数目(Reader)</p>
<p>当readcount!=0时, 表示有Reader进程,此时不能进行Writer进程.</p>
<p>法一:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//记录型信号量</span><br><span class="line">semaphore rmutext = 1, wmutext = 1;</span><br><span class="line">int readcount = 0;</span><br><span class="line">void Reader() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        wait(rmutex);</span><br><span class="line">        if (readcount == 0) &#123;</span><br><span class="line">            wait(wmutex);</span><br><span class="line">        &#125;</span><br><span class="line">        readcount++;</span><br><span class="line">        signal(rmutex);</span><br><span class="line">        </span><br><span class="line">        perform read operation;</span><br><span class="line">        </span><br><span class="line">        wait(rmutex);</span><br><span class="line">        readcount--;</span><br><span class="line">        if (readcount == 0) &#123;</span><br><span class="line">            signal(wmutext);</span><br><span class="line">        &#125;</span><br><span class="line">        signal(rmutex);</span><br><span class="line">    &#125; while (true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Writer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        wait(wmutex);</span><br><span class="line">        perform write operation;</span><br><span class="line">        signal(wmutex);</span><br><span class="line">    &#125; while (true);</span><br><span class="line">&#125;</span><br><span class="line">void main() &#123;</span><br><span class="line">    cobegin</span><br><span class="line">        Reader();</span><br><span class="line">        Writer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>法二:</p>
<p>引入RN, 表示最多允许RN个Reader进程同时读</p>
<p>信号量L初始为RN</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//信号量集</span><br><span class="line">int RN;</span><br><span class="line">semaphore L = RN, mx = 1;</span><br><span class="line">void Reader() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        Swait(L, 1, 1);</span><br><span class="line">        Swait(mx, 1, 0);</span><br><span class="line">        </span><br><span class="line">        perform read operation;</span><br><span class="line">        </span><br><span class="line">        Ssignal(L, 1);</span><br><span class="line">    &#125; while (true);</span><br><span class="line">&#125;</span><br><span class="line">void Writer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        Swait(mx, 1, 1; L, RN, 0);</span><br><span class="line">        perform write operation;</span><br><span class="line">        Ssignal(mx, 1);</span><br><span class="line">    &#125; while (true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    cobegin</span><br><span class="line">        Reader();</span><br><span class="line">        Writer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程序人生</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>多线程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>强连通图经典算法——Tarjan算法</title>
    <url>/2018/10/08/2018-10-08/</url>
    <content><![CDATA[<p><strong>Tarjan 算法</strong></p>
<p><strong>一.算法简介</strong></p>
<p>Tarjan 算法一种由Robert Tarjan提出的求解有向图强连通分量的算法，它能做到线性时间的复杂度。</p>
<p>我们定义：</p>
<p>如果两个顶点可以相互通达，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。</p>
<p><img src="https://images2015.cnblogs.com/blog/1009519/201609/1009519-20160914143526445-1192876799.png" alt="img"></p>
<p>例如：在上图中，{1 , 2 , 3 , 4 } , { 5 }　,  { 6 } 三个区域可以相互连通，称为这个图的强连通分量。</p>
<p>Tarjan算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。</p>
<p>再Tarjan算法中，有如下定义。</p>
<p>DFN[ i ] : 在DFS中该节点被搜索的次序(时间戳)</p>
<p>LOW[ i ] : 为i或i的子树能够追溯到的最早的栈中节点的次序号</p>
<p>当DFN[ i ]==LOW[ i ]时，为i或i的子树可以构成一个强连通分量。</p>
<p><strong>二.算法图示</strong></p>
<p>以1为Tarjan 算法的起始点，如图</p>
<p><img src="https://images2015.cnblogs.com/blog/1009519/201609/1009519-20160914144921414-2016099517.png" alt="img"></p>
<p>顺次DFS搜到节点6</p>
<p><img src="https://images2015.cnblogs.com/blog/1009519/201609/1009519-20160914145231586-1855011628.png" alt="img"></p>
<p> 回溯时发现LOW[ 5 ]==DFN[ 5 ] ,  LOW[ 6 ]==DFN[ 6 ] ,则{ 5 } , { 6 } 为两个强连通分量。回溯至3节点，拓展节点4.</p>
<p><img src="https://images2015.cnblogs.com/blog/1009519/201609/1009519-20160914145758727-370899436.png" alt="img"></p>
<p>拓展节点1 ， 发现1再栈中更新LOW[ 4 ]，LOW[ 3 ] 的值为1</p>
<p><img src="https://images2015.cnblogs.com/blog/1009519/201609/1009519-20160914150752023-616745966.png" alt="img"></p>
<p> 回溯节点1，拓展节点2</p>
<p><img src="https://images2015.cnblogs.com/blog/1009519/201609/1009519-20160914150954258-732799852.png" alt="img"></p>
<p>自此，Tarjan Algorithm 结束，{1 , 2 , 3 , 4 } , { 5 }　,  { 6 } 为图中的三个强连通分量。</p>
<p><img src="https://images2015.cnblogs.com/blog/1009519/201609/1009519-20160916105304086-271091564.png" alt="img"></p>
<p>不难发现，Tarjan Algorithm 的时间复杂度为O(E+V).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Tarjan ( int x ) &#123;</span><br><span class="line">         dfn[ x ] = ++dfs_num ;</span><br><span class="line">         low[ x ] = dfs_num ;</span><br><span class="line">         vis [ x ] = true ;//是否在栈中</span><br><span class="line">         stack [ ++top ] = x ;</span><br><span class="line">         for ( int i=head[ x ] ; i!=0 ; i=e[i].next )&#123;</span><br><span class="line">                  int temp = e[ i ].to ;</span><br><span class="line">                  if ( !dfn[ temp ] )&#123;</span><br><span class="line">                           Tarjan ( temp ) ;</span><br><span class="line">                           low[ x ] = gmin ( low[ x ] , low[ temp ] ) ;</span><br><span class="line">                 &#125;</span><br><span class="line">                 else if ( vis[ temp ])low[ x ] = gmin ( low[ x ] , dfn[ temp ] ) ;</span><br><span class="line">         &#125;</span><br><span class="line">         if ( dfn[ x ]==low[ x ] ) &#123;//构成强连通分量</span><br><span class="line">                  vis[ x ] = false ;</span><br><span class="line">                  color[ x ] = ++col_num ;//染色</span><br><span class="line">                  while ( stack[ top ] != x ) &#123;//清空</span><br><span class="line">                           color [stack[ top ]] = col_num ;</span><br><span class="line">                           vis [ stack[ top-- ] ] = false ;</span><br><span class="line">                 &#125;</span><br><span class="line">                 top -- ;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>Tarjan算法</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title>NAIPC2016-F.Mountain Scenes</title>
    <url>/2018/10/02/2018-10-02/</url>
    <content><![CDATA[<ul>
<li>1000ms</li>
<li>262144K</li>
</ul>
<p>An artist begins with a roll of ribbon, one inch wide. She clips it into pieces of various integral lengths, then aligns them with the bottom of a frame, rising vertically in columns, to form a mountain scene. A mountain scene must be uneven; if all columns are the same height, it’s a plain scene, not a mountain scene! It is possible that she may not use all of the ribbon.</p>
<p><a href="https://res.jisuanke.com/img/upload/20180914/0d311ad59ca6302ae44e05c553c59b205ecf2913.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/0d311ad59ca6302ae44e05c553c59b205ecf2913.png" alt="img"></a></p>
<p>If our artist has 44 inches of ribbon and a 2 \times 22×2 inch frame, she could form these scenes:</p>
<p><a href="https://res.jisuanke.com/img/upload/20180914/2e4d94cb5e3526193ec13f4402c8d7fbe533df16.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/2e4d94cb5e3526193ec13f4402c8d7fbe533df16.png" alt="img"></a><a href="https://res.jisuanke.com/img/upload/20180914/90ef24006d11e28c94eed98262a7ae555963c28d.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/90ef24006d11e28c94eed98262a7ae555963c28d.png" alt="img"></a><a href="https://res.jisuanke.com/img/upload/20180914/c43ed5f0716e4d776714586c04369d1299cccb7a.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/c43ed5f0716e4d776714586c04369d1299cccb7a.png" alt="img"></a> <a href="https://res.jisuanke.com/img/upload/20180914/474d838a889f76324ffecb940bd7bf5731cfca2d.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/474d838a889f76324ffecb940bd7bf5731cfca2d.png" alt="img"></a><a href="https://res.jisuanke.com/img/upload/20180914/116665c4b2c23c019afe8991e93f28786fc9c7dd.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/116665c4b2c23c019afe8991e93f28786fc9c7dd.png" alt="img"></a><a href="https://res.jisuanke.com/img/upload/20180914/5cc932933eb1b0c94e695090999f5b5cf88e7966.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/5cc932933eb1b0c94e695090999f5b5cf88e7966.png" alt="img"></a></p>
<p>She would not form these scenes, because they’re plains, not mountains!</p>
<p><a href="https://res.jisuanke.com/img/upload/20180914/61f02e20e1290a24e6e2bd70df3626df8d4b20de.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/61f02e20e1290a24e6e2bd70df3626df8d4b20de.png" alt="img"></a><a href="https://res.jisuanke.com/img/upload/20180914/8d83ffddd160ffd19a4a5522b9e73ef09bb02b39.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/8d83ffddd160ffd19a4a5522b9e73ef09bb02b39.png" alt="img"></a><a href="https://res.jisuanke.com/img/upload/20180914/100a7f671569edb6ba5decbc74cadcc130a56da4.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/100a7f671569edb6ba5decbc74cadcc130a56da4.png" alt="img"></a></p>
<p>Given the length of the ribbon and the width and height of the frame, all in inches, how many different mountain scenes can she create? Two scenes are different if the regions covered by ribbon are different. There’s no point in putting more than one piece of ribbon in any column.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>Each input will consist of a single test case. Note that your program may be run multiple times on different inputs. The input will consist of a single line with three space-separated integers nn, ww and hh, where nn (0 \le n \le 10,000)(0≤n≤10,000) is the length of the ribbon in inches, w (1 \le w \le 100)w(1≤w≤100) is the width and hh (1 \le h \le 100)(1≤h≤100)is the height of the frame, both in inches.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>Output a single integer, indicating the total number of mountain scenes our artist could possibly make, modulo 10^9 + 7109+7.</p>
<h4 id="样例输入1复制"><a href="#样例输入1复制" class="headerlink" title="样例输入1复制"></a>样例输入1复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">25 5 5</span><br></pre></td></tr></table></figure>
<h4 id="样例输出1复制"><a href="#样例输出1复制" class="headerlink" title="样例输出1复制"></a>样例输出1复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7770</span><br></pre></td></tr></table></figure>
<h4 id="样例输入2复制"><a href="#样例输入2复制" class="headerlink" title="样例输入2复制"></a>样例输入2复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 5 5</span><br></pre></td></tr></table></figure>
<h4 id="样例输出2复制"><a href="#样例输出2复制" class="headerlink" title="样例输出2复制"></a>样例输出2复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6050</span><br></pre></td></tr></table></figure>
<h4 id="样例输入3复制"><a href="#样例输入3复制" class="headerlink" title="样例输入3复制"></a>样例输入3复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 10 1</span><br></pre></td></tr></table></figure>
<h4 id="样例输出3复制"><a href="#样例输出3复制" class="headerlink" title="样例输出3复制"></a>样例输出3复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1022</span><br></pre></td></tr></table></figure>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>问题可以转化为有n个物品，现有w个盘子，每个盘子的容量为[0,h]，所有盘子放的物品不能全部相同，n个物品选[0,n]个物品放进盘中，共有多少种方法。</p>
<p>首先，利用dp，第一层i为第i个盘子，第2层j为前i个盘子共放置j个物品共有多少种方法。这样<code>dp[i][j]+=dp[i-1][j-k]</code>，其中k[0,h]</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll maxn = 1e4+7;</span><br><span class="line">const ll mod = 1e9+7;</span><br><span class="line">ll dp[107][maxn];</span><br><span class="line">ll n,w,h;</span><br><span class="line">ll solve()&#123;</span><br><span class="line">    memset(dp,0,sizeof(dp));</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    if(n &gt; w * h)&#123;</span><br><span class="line">        n = w*h;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[0][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i&lt;=w; i++)&#123;</span><br><span class="line">        for(int j = 0;j&lt;=n; j++)&#123;</span><br><span class="line">            for(int k = 0; k&lt;=h&amp;&amp;k&lt;=j; k++)&#123;</span><br><span class="line">                dp[i][j]+=dp[i-1][j-k];</span><br><span class="line">                dp[i][j]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = (dp[w][n] - 1 - n/w + mod)%mod;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;w,&amp;h))&#123;</span><br><span class="line">        printf(&quot;%lld\n&quot;,solve());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>分时最短路+次小生成树+最小费用最大流题解</title>
    <url>/2018/09/29/2018-09-29/</url>
    <content><![CDATA[<h1 id="问题-A-高速"><a href="#问题-A-高速" class="headerlink" title="问题 A: 高速"></a>问题 A: 高速</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 15  解决: 4<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1027&amp;pid=0&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1915" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1915&amp;cid=1027" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>]</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>教练开车去东北，因为比赛地点在东北。共有 n 座城，已知教练在 s 城，比赛地点在 t 城，n 座城之间共有 m 条高速，每条高速连接两座城市，每两座城市之间最多两条高速。每条高速都有权值 v，表示两个城市之间最快可以 v 小时到达。</p>
<p>然而高速不是永久开放的，每条高速都会有一段开放时间 [ a，b ]，表示该高速在 a ~ b 小时范围之间开放，其余时间处于关闭状态，不能通过任何车辆。例如 [ 24，27 ]表示该路在第 24 小时到 27 小时之间开放。</p>
<p>已知教练在 0 时刻出发，他最快多少小时可以到达 t 城。</p>
<p>（PS：由于刹车坏掉了，因此车一旦启动就不能停下来，也就是说车不能停于某点或某边，不过车可以来回无限次在两地之间穿梭）</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>多组测试样例，首行输入 t，表示 t 组样例。</p>
<p>图为无向图，s 城固定为 1 点，t 城固定为 n 点。</p>
<p>每组样例第 1 行，输入n，m（1 &lt; n ≤ 100，0 &lt; m ≤ 1000）。</p>
<p>接下来 m 行，每行 5 个数值x，y，v，l，f。表示 x 与 y 有一条高速，耗时为 v。该路开放时间为[ l，f ]。</p>
<p>数据保证教练可以到达终点，只不过是时间问题。</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出一个数值，即最少耗时。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5 4</span><br><span class="line">2 3 1 5 11</span><br><span class="line">2 5 1 3 18</span><br><span class="line">4 3 1 7 14</span><br><span class="line">1 4 1 0 15</span><br></pre></td></tr></table></figure>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tag：图论、分时最短路</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//最短路</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx = 0x3f3f3f3f;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">int t,n,m,cnt;</span><br><span class="line">int dis[maxn];  //当前该点到原点最短距离</span><br><span class="line">bool vis[maxn]; //是否访问过</span><br><span class="line">int head[maxn]; //点集</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next,to,w,l,r;  //上一条边，下一个点，权值，左值，右值</span><br><span class="line">&#125;edge[2*maxn];  //边集</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int u,dis;</span><br><span class="line">    NODE()&#123;&#125;</span><br><span class="line">	NODE(int u,ll w):u(u),dis(w)&#123;&#125;</span><br><span class="line">	bool operator &lt;(const NODE &amp;a)const&#123;</span><br><span class="line">		return dis&gt;a.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;node[2*maxn];  //点集加最短距离</span><br><span class="line">void add(int u, int v, int w, int l,int r)&#123; //构建边集</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].l = l;</span><br><span class="line">    edge[cnt].r = r;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;    //初始化</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head,-1,sizeof(head));</span><br><span class="line">    memset(dis,maxx,sizeof(dis));</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;    //读入数据</span><br><span class="line">    int u,v,w,l,r;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i = 0;i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d%d&quot;,&amp;u,&amp;v,&amp;w,&amp;l,&amp;r);</span><br><span class="line">        add(u,v,w,l,r);</span><br><span class="line">        add(v,u,w,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void init_data(int kk)&#123; //初始化数据</span><br><span class="line">    vis[kk] = false;</span><br><span class="line">    dis[kk] = maxx;</span><br><span class="line">&#125;</span><br><span class="line">int solve(int s)&#123;</span><br><span class="line">    priority_queue&lt;NODE&gt;q;  //储存最短距离</span><br><span class="line">    q.push(NODE(s,0));  //读入原点</span><br><span class="line">    while(!q.empty())&#123;  //队列为空则无法到达</span><br><span class="line">        int kk = q.top().u; //储存当前最短距离下标</span><br><span class="line">        int minD = q.top().dis; //储存当前最短距离</span><br><span class="line">        q.pop();</span><br><span class="line">        if(kk==n)   //若下标为目标值，return</span><br><span class="line">            return minD;</span><br><span class="line">        vis[kk] = true; //该点是否访问</span><br><span class="line">        for(int l = head[kk]; l!=-1; l=edge[l].next)&#123;   //松弛边</span><br><span class="line">            if(!vis[edge[l].to]&amp;&amp;minD&lt;=edge[l].r&amp;&amp;minD&gt;=edge[l].l&amp;&amp;minD + edge[l].w &lt; dis[edge[l].to])&#123;</span><br><span class="line">                dis[edge[l].to] = minD + edge[l].w;</span><br><span class="line">                q.push(NODE(edge[l].to,dis[edge[l].to]));   //将松弛后的边压入队列</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        init_data(kk);  //初始化数据</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        init(); //初始化</span><br><span class="line">        read(); //读入</span><br><span class="line">        printf(&quot;%d\n&quot;,solve(1));    //解决方案</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-C-千年老二"><a href="#问题-C-千年老二" class="headerlink" title="问题 C: 千年老二"></a>问题 C: 千年老二</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 24  解决: 12<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1028&amp;pid=2&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1913" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1913&amp;cid=1028" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>]</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>雷婷与万钧是青梅竹马，无论是考试还是玩游戏，雷婷总是第一，而万钧总是第二，尽管万钧有做第一的实力，但他每次都会把第一让给雷婷，仅因为每次读榜单时雷霆万钧听起来是那么顺耳。这天，雷婷参加了 acm 选拔，万钧也跟着雷婷参加。题目是这样的：</p>
<p>有 n 个节点，编号为 1~n，有 m 条边，每条边都有一个距离。两点之间最多只有 1 条边。现在你需要选取 n-1 条边，使得所有点都连接起来都有通路。n-1 条边距离之和越小分数越高。</p>
<p>万钧立马意识到这道题是求最小生成树的，并且每个人的答案不能相同，万钧根据瞪眼法立马瞪出了答案，然而他还是等待雷婷先做完。现在雷婷已经找到了距离最短的1种方案，不过他俩太心有灵犀了，答案一模一样，万钧想获得第 2 名，请你帮万钧想一种方案，距离之和越短越好，但不能和雷婷的结果相同。一条边不同即可认为不同。如果找不到输出 -1。当然存在一种情况，如果雷婷的方案是没有方案求出最短距离，即表示该图没有最小生成树，即输出 -1。总之雷婷的方案是最优解的一种。</p>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>存在多组数据，第一行一个正整数 t，表示有 t 组数据。</p>
<p>每组数据第一行有两个整数 n 和 m（2 ≤ n ≤ 100，1 ≤ m ≤ 1000)，之后 m 行，每行三个正整数 s，e，w，表示 s 到 e 的双向路的权值为 w。</p>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>输出次小生成树的值（如果存在多个最小生成树或仅有一个树，则次小生成树就是最小生成树，输出-1），如果不存在输出 -1。</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3 3</span><br><span class="line">3 1 3</span><br><span class="line">1 2 1</span><br><span class="line">2 3 2</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tag：图论、次小生成树</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//次小生成树</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int L=1e5+7;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">const int maxn=1000+7;</span><br><span class="line">int father[maxn],n,m,num[maxn],nPos;    //父节点（并查集），点数，边数，最小生成树点集，当前访问方位</span><br><span class="line">struct node&#123;</span><br><span class="line">    int s,y,w;</span><br><span class="line">&#125;edge[L];   //边集，左端点，右端点，权值</span><br><span class="line">void init()&#123;    //初始化并查集</span><br><span class="line">    for(int i=0;i&lt;=n;i++)</span><br><span class="line">        father[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">int root(int x)&#123;    //并查集，构造父节点</span><br><span class="line">    return father[x]==x?x:father[x]=root(father[x]);</span><br><span class="line">&#125;</span><br><span class="line">void unite(int x,int y)&#123;    //并查集，合并两个联通图</span><br><span class="line">    x=root(x);</span><br><span class="line">    y=root(y);</span><br><span class="line">    if(x!=y)</span><br><span class="line">        father[y]=x;</span><br><span class="line">&#125;</span><br><span class="line">int alike(int x,int y)&#123; //并查集，判断是否为同一连通图</span><br><span class="line">    return root(x)==root(y);</span><br><span class="line">&#125;</span><br><span class="line">int cmp(node a,node b)&#123; //sort结构体排序</span><br><span class="line">    return a.w&lt;b.w;</span><br><span class="line">&#125;</span><br><span class="line">int secondTree(int pos) //次小生成树</span><br><span class="line">&#123;</span><br><span class="line">    init(); //初始化</span><br><span class="line">    int sum=0,cnt=0;</span><br><span class="line">    for(int i=0;i&lt;m;i++)    //对于删去边后的图进行最小生成树运算</span><br><span class="line">    &#123;</span><br><span class="line">        if(cnt==n-1)</span><br><span class="line">            break;</span><br><span class="line">        if(i==pos)</span><br><span class="line">            continue;</span><br><span class="line">        if(!alike(edge[i].s,edge[i].y))&#123;</span><br><span class="line">            unite(edge[i].s,edge[i].y);</span><br><span class="line">            sum+=edge[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt!=n-1?-1:sum; //判断删除边后是否能构成最小生成树</span><br><span class="line">&#125;</span><br><span class="line">int kruskal()&#123;  //最小生成树</span><br><span class="line">    init();</span><br><span class="line">    sort(edge,edge+m,cmp);  //对边进行权值排序</span><br><span class="line">    int sum=0,cnt=0;</span><br><span class="line">    for(int i=0;i&lt;m;i++)    //每次选择最小且未访问过的一条边</span><br><span class="line">    &#123;</span><br><span class="line">        if(cnt==n-1)</span><br><span class="line">            break;</span><br><span class="line">        if(!alike(edge[i].s,edge[i].y))&#123;</span><br><span class="line">            unite(edge[i].s,edge[i].y);</span><br><span class="line">            sum+=edge[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">            num[++nPos]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt!=n-1?-1:sum; //判断边是否大于等于n-1，否则输出-1</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;    //读入数据</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;edge[i].s,&amp;edge[i].y,&amp;edge[i].w);</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;   //解决方案</span><br><span class="line">    int Min=inf;</span><br><span class="line">    nPos=0;</span><br><span class="line">    int mst=kruskal();  //最小生成树值</span><br><span class="line">    if(mst==-1) &#123;   //没有最小生成树即输出-1</span><br><span class="line">        printf(&quot;-1\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=nPos;i++)&#123;   //对最小生成树的每条边进行遍历，选择删边后的最小值</span><br><span class="line">        int secmst=secondTree(num[i]);</span><br><span class="line">        if(secmst!=-1)  //若没有次小生成树输出-1</span><br><span class="line">            Min=min(Min,secmst);</span><br><span class="line">        &#125;</span><br><span class="line">    if(Min!=inf&amp;&amp;Min!=mst)</span><br><span class="line">        printf(&quot;%d\n&quot;,Min); //输出结果</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;-1\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        read(); //读入数据</span><br><span class="line">        solve();    //解决方案</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-F-给力台球厅"><a href="#问题-F-给力台球厅" class="headerlink" title="问题 F: 给力台球厅"></a>问题 F: 给力台球厅</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 10  解决: 3<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1028&amp;pid=5&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1912" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1912&amp;cid=1028" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>]</p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>教练爱打台球。这天偶遇一家台球厅，便进去看看。然而这家台球厅貌似和平常的台球厅不太一样，它的每张桌面上的洞都是随机分布在桌面上的，球也是随机摆放的。</p>
<p>教练立即意识到，此台球厅的桌面不符合正态分布之概率密度函数，而是呈离散分布，顿时患有强迫症的教练心里就不舒服了。为了平缓一下翻腾的内心，教练随机选取了一张球和洞数量一样的球桌，望着奇怪的桌面与奇怪的球，教练脑袋上不禁长出了大把大把的草：如果能求出所有球入洞的最短距离之和该有多好啊。</p>
<p>现有一个桌面面积为 n×m 的台球桌，将台球桌分成 n×m 个小格，台球桌上有许多的洞和许多的球，均匀分布在小格里，且每个小格只有三种状态，有球，有洞，空白。球用 @ 表示，洞用 # 表示，空白的地方用 * 表示。每个洞只能容纳一个球，球每次只能按照上下左右的方向移动，且每移动一格视为移动 1 个单位长度。当一个球被另一个球挡住时，它可以跳球，所以每一个球都可以完全无视其他球或洞的存在而继续前行，直到进自己心仪的洞。现求所有球进洞的距离之和最小是多少。如果你能帮教练解决这道题，恭喜你就是 ACM 队员了（每个球只能进一个洞，每个洞内有球的话就变成空白状态）</p>
<h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>多组测试样例，首行输入 m，n，即矩形台球桌面的边长。(2 ≤ m，n ≤ 20，球最多100个，洞最多100个，保证洞和球数量相等)</p>
<h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>输出一个整数，即所有球入洞的距离最短是多少。</p>
<h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 2</span><br><span class="line">*#</span><br><span class="line">@*</span><br><span class="line">7 8</span><br><span class="line">****#***</span><br><span class="line">****#***</span><br><span class="line">****#***</span><br><span class="line">@@@@#@@@</span><br><span class="line">****#***</span><br><span class="line">****#***</span><br><span class="line">****#***</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">28</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tag：图论、最小费用最大流</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//网络流</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int INF = 0x3f3f3f3f; //无穷大</span><br><span class="line">const int maxn = 60007;</span><br><span class="line">const int maxm = 1000007;</span><br><span class="line">int vis[maxn],d[maxn],pre[maxn],a[maxn],m,n;    //是否访问，最短路，前置节点，流量，边集，点集</span><br><span class="line">char mp[107][107];  //台球地图</span><br><span class="line">struct Edge&#123;</span><br><span class="line">    int u, v, c, cost, next;</span><br><span class="line">&#125;edge[maxm];    //网络流边集</span><br><span class="line"></span><br><span class="line">int s[maxn], cnt;   //每个点流量</span><br><span class="line"></span><br><span class="line">void init()&#123;    //初始化</span><br><span class="line">	cnt = 0;</span><br><span class="line">	memset(s, -1, sizeof(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int u, int v, int c, int cost)&#123;    //对两点之间进行单向边建立</span><br><span class="line">	edge[cnt].u = u;</span><br><span class="line">	edge[cnt].v = v;</span><br><span class="line">	edge[cnt].cost = cost;</span><br><span class="line">	edge[cnt].c = c;</span><br><span class="line">	edge[cnt].next = s[u];</span><br><span class="line">	s[u] = cnt++;   //建立单向边</span><br><span class="line">	edge[cnt].u = v;</span><br><span class="line">	edge[cnt].v = u;</span><br><span class="line">	edge[cnt].cost = -cost;</span><br><span class="line">	edge[cnt].c = 0;</span><br><span class="line">	edge[cnt].next = s[v];</span><br><span class="line">	s[v] = cnt++;   //建立双向边</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool spfa(int ss, int ee,int &amp;flow,int &amp;cost)&#123;  //以距离为费用寻找最短路，以最短路为当前增广路</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	memset(d, INF, sizeof d);</span><br><span class="line">	memset(vis, 0, sizeof vis); //初始化</span><br><span class="line">	d[ss] = 0, vis[ss] = 1, pre[ss] = 0, a[ss] = INF;</span><br><span class="line">	q.push(ss);</span><br><span class="line">	while (!q.empty())&#123; //spfa以费用为距离寻找最短路</span><br><span class="line">		int u = q.front();q.pop();</span><br><span class="line">		vis[u] = 0;</span><br><span class="line">		for (int i = s[u]; ~i; i = edge[i].next)&#123;   //和当前点相连所有边松弛过程</span><br><span class="line">			int v = edge[i].v;</span><br><span class="line">			if (edge[i].c&gt;0&amp;&amp; d[v]&gt;d[u] + edge[i].cost)&#123;    //松弛过程</span><br><span class="line">				d[v] = d[u] + edge[i].cost;</span><br><span class="line">				pre[v] = i;</span><br><span class="line">				a[v] = min(a[u], edge[i].c);    //取最小值</span><br><span class="line">				if (!vis[v])&#123;</span><br><span class="line">					vis[v] = 1;</span><br><span class="line">					q.push(v);     //压入待松弛队列</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (d[ee] == INF) return 0; //判断是否有最短路，无说明最大流完成</span><br><span class="line">	flow += a[ee];</span><br><span class="line">	cost += d[ee]*a[ee];</span><br><span class="line">	int u = ee;</span><br><span class="line">	while (u != ss)&#123;    //求当前最短路下的流量和</span><br><span class="line">		edge[pre[u]].c -= a[ee];</span><br><span class="line">		edge[pre[u] ^ 1].c += a[ee];</span><br><span class="line">		u = edge[pre[u]].u;</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int MCMF(int ss, int ee)&#123;   //最小费用最大流</span><br><span class="line">	int cost = 0, flow=0;   //初始化</span><br><span class="line">	while (spfa(ss, ee, flow, cost));   //寻找增广路径，直到没有增广路径为止</span><br><span class="line">	return cost;    //返回最大流费用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct point&#123;</span><br><span class="line">    int x,y;    //球坐标，洞坐标</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    point H[107],P[107];    //建立球集与洞集</span><br><span class="line">    int h=0,p=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;   //输入地图</span><br><span class="line">        scanf(&quot;%s&quot;,&amp;mp[i]);</span><br><span class="line">        for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">            if(mp[i][j]==&apos;#&apos;)&#123;  //若为洞则坐标加入洞集</span><br><span class="line">                H[h].x=i;</span><br><span class="line">                H[h].y=j;</span><br><span class="line">                h++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(mp[i][j]==&apos;@&apos;)&#123; //若为球则坐标加入球集</span><br><span class="line">                P[p].x=i;</span><br><span class="line">                P[p].y=j;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    init(); //初始化</span><br><span class="line">    for(int i=0;i&lt;h;i++)</span><br><span class="line">        for(int j=0;j&lt;p;j++)&#123;</span><br><span class="line">        int c=fabs(H[i].x-P[j].x)+fabs(H[i].y-P[j].y);</span><br><span class="line">             add(i+1,h+j+1,1,c);</span><br><span class="line">        &#125;   //建立球与洞之间的路径</span><br><span class="line">    for(int i=0;i&lt;h;i++)    //建立超级源点</span><br><span class="line">        add(0,i+1,1,0);</span><br><span class="line">    for(int i=0;i&lt;p;i++)    //建立超级汇点</span><br><span class="line">        add(h+1+i,h+p+1,1,0);</span><br><span class="line">    printf(&quot;%d\n&quot;,MCMF(0,h+p+1));   //最小费用最大流</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">        if(!(m||n))</span><br><span class="line">            break;</span><br><span class="line">        solve();    //解决方案</span><br><span class="line">    &#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>训练之路</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>最小费用最大流</tag>
        <tag>次小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>利用容斥原理求解范围内互素数对数例题</title>
    <url>/2018/09/26/2018-09-26/</url>
    <content><![CDATA[<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>Given 5 integers: a, b, c, d, k, you’re to find x in a…b, y in c…d that GCD(x, y) = k. GCD(x, y) means the greatest common divisor of x and y. Since the number of choices may be very large, you’re only required to output the total number of different number pairs.<br>Please notice that, (x=5, y=7) and (x=7, y=5) are considered to be the same.<br><strong>Yoiu can assume that a = c = 1 in all test cases.</strong> </p>
<p>Input</p>
<p>The input consists of several test cases. The first line of the input is the number of the cases. There are no more than 3,000 cases.<br>Each case contains five integers: a, b, c, d, k, 0 &lt; a &lt;= b &lt;= 100,000, 0 &lt; c &lt;= d &lt;= 100,000, 0 &lt;= k &lt;= 100,000, as described above. </p>
<p>Output</p>
<p>For each test case, print the number of choices. Use the format in the example. </p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 3 1 5 1</span><br><span class="line">1 11014 1 14409 9</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case 1: 9</span><br><span class="line">Case 2: 736427</span><br></pre></td></tr></table></figure>
<p>Hint</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">For the first sample input, all the 9 pairs of numbers are (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 5), (3, 4), (3, 5).</span><br></pre></td></tr></table></figure>
<p>题意：</p>
<p>求解[1,b]范围内和[1,d]范围内最大公约数为k的二元组的对数</p>
<p>题解：</p>
<p>gcd(a,b)=k，我们可以写成gcd(a/k,b/k)=1。因此我们只需求[1,b/k]和[1,d/k]范围内互素数的对数。首先利用欧拉函数很容易求解[1,min(a,b)]范围内互素数的对数，将φ(1~min(a,b))全部加起来，就求出1~min(a,b)所有互素对数，假设d永远＞=b,那么接下来我们只需求[1,b]范围内和[b+1,d]范围内互素的数，此时需用容斥原理。对于[1,b]范围内和x互素的数，最多为b个，而在这b个数中我们只需减去不互素的对数即可。我们需先求出x的所有质因数，然后这些质因数的倍数在[1,b]范围内的个数为b/g，因此只需减去这些对数即可，然而由于会有重复的情况出现，因此需用容斥原理处理一下。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll oula[maxn];</span><br><span class="line">int a,b,c,d,k;</span><br><span class="line">struct Number</span><br><span class="line">&#123;</span><br><span class="line">    int cnt;</span><br><span class="line">    int prime[20];</span><br><span class="line">&#125; fac[maxn];</span><br><span class="line">void getLa( int n)</span><br><span class="line">&#123;</span><br><span class="line">    memset(fac,0,sizeof(fac));</span><br><span class="line">    for(int i = 0; i &lt; n; ++i)</span><br><span class="line">        oula[i] = i;</span><br><span class="line">    for(int i = 2; i &lt; n; ++i)</span><br><span class="line">        if( oula[i] == i )</span><br><span class="line">            for(int j = 1; j*i &lt; n; ++j)&#123;</span><br><span class="line">                oula[j*i] -= oula[j*i]/i;</span><br><span class="line">                fac[j*i].prime[fac[j*i].cnt++]=i;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll inc(int index,int b,int m)</span><br><span class="line">&#123;</span><br><span class="line">    ll r=0,t;</span><br><span class="line">    for(int i=index; i&lt;fac[m].cnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t=b/fac[m].prime[i];//b范围内有多少个数和m的因数为prime[i]</span><br><span class="line">        r+=t-inc(i+1,t,m);//减去这些数就是b范围内和m互质的数的个数。</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line">ll solve()</span><br><span class="line">&#123;</span><br><span class="line">    b/=k;</span><br><span class="line">    d/=k;</span><br><span class="line">    if(b&gt;d)</span><br><span class="line">        swap(b,d);</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= b; ++i)</span><br><span class="line">        ans+=oula[i];</span><br><span class="line">    for(int i=b+1; i&lt;=d; ++i)</span><br><span class="line">        ans+=b-inc(0,b,i);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    getLa(maxn);</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    for(int cas = 1; cas&lt;=t; ++cas)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);</span><br><span class="line">        if(k==0)&#123;</span><br><span class="line">            printf(&quot;Case %d: 0\n&quot;,cas);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case %d: %lld\n&quot;,cas,solve());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面那道和上面这道类似，稍微改一下就好。</p>
<h2 id="Visible-Trees"><a href="#Visible-Trees" class="headerlink" title="Visible Trees"></a>Visible Trees</h2><p>There are many trees forming a m * n grid, the grid starts from (1,1). Farmer Sherlock is standing at (0,0) point. He wonders how many trees he can see.<br>If two trees and Sherlock are in one line, Farmer Sherlock can only see the tree nearest to him.</p>
<p>Input</p>
<p>The first line contains one integer t, represents the number of test cases. Then there are multiple test cases. For each test case there is one line containing two integers m and n(1 ≤ m, n ≤ 100000)</p>
<p>Output</p>
<p>For each test case output one line represents the number of trees Farmer Sherlock can see.</p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>题意</p>
<p>求解[1,b]范围内和[1,d]范围内最大公约数为k的二元组的对数。当然和上面不同之处在于对数左右数不同也认为不同。(2,3)和(3,2)为不同的对数。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll oula[maxn];</span><br><span class="line">int m,n;</span><br><span class="line">struct Number</span><br><span class="line">&#123;</span><br><span class="line">    int cnt;</span><br><span class="line">    int prime[20];</span><br><span class="line">&#125; fac[maxn];</span><br><span class="line">void getLa( int n)</span><br><span class="line">&#123;</span><br><span class="line">    memset(fac,0,sizeof(fac));</span><br><span class="line">    for(int i = 0; i &lt; n; ++i)</span><br><span class="line">        oula[i] = i;</span><br><span class="line">    for(int i = 2; i &lt; n; ++i)</span><br><span class="line">        if( oula[i] == i )</span><br><span class="line">            for(int j = 1; j*i &lt; n; ++j)&#123;</span><br><span class="line">                oula[j*i] -= oula[j*i]/i;</span><br><span class="line">                fac[j*i].prime[fac[j*i].cnt++]=i;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll inc(int index,int b,int m)</span><br><span class="line">&#123;</span><br><span class="line">    ll r=0,t;</span><br><span class="line">    for(int i=index; i&lt;fac[m].cnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t=b/fac[m].prime[i];</span><br><span class="line">        r+=t-inc(i+1,t,m);</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line">ll solve()</span><br><span class="line">&#123;</span><br><span class="line">    if(m&gt;n)</span><br><span class="line">        swap(m,n);</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= m; ++i)</span><br><span class="line">        ans+=oula[i];</span><br><span class="line">    ans=ans*2-1;</span><br><span class="line">    for(int i=m+1; i&lt;=n; ++i)</span><br><span class="line">        ans+=m-inc(0,m,i);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    getLa(maxn);</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line">        printf(&quot;%lld\n&quot;,solve());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跳蚤"><a href="#跳蚤" class="headerlink" title="跳蚤"></a>跳蚤</h2><p>Z城市居住着很多只跳蚤。在Z城市周六生活频道有一个娱乐节目。一只跳蚤将被请上一个高空钢丝的正中央。钢丝很长，可以看作是无限长。节目主持人会给该跳蚤发一张卡片。卡片上写有N+1个自然数。其中最后一个是M，而前N个数都不超过M，卡片上允许有相同的数字。跳蚤每次可以从卡片上任意选择一个自然数S，然后向左，或向右跳S个单位长度。而他最终的任务是跳到距离他左边一个单位长度的地方，并捡起位于那里的礼物。<br>比如当N=2，M=18时，持有卡片(10, 15, 18)的跳蚤，就可以完成任务：他可以先向左跳10个单位长度，然后再连向左跳3次，每次15个单位长度，最后再向右连跳3次，每次18个单位长度。而持有卡片(12, 15, 18)的跳蚤，则怎么也不可能跳到距他左边一个单位长度的地方。<br>当确定N和M后，显然一共有M^N张不同的卡片。现在的问题是，在这所有的卡片中，有多少张可以完成任务。 </p>
<p>Input</p>
<p>两个整数N和M(N &lt;= 15 , M &lt;= 100000000)。</p>
<p>Output</p>
<p>可以完成任务的卡片数。</p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 4</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>
<p>Hint</p>
<p>这12张卡片分别是：<br>(1, 1, 4), (1, 2, 4), (1, 3, 4), (1, 4, 4), (2, 1, 4), (2, 3, 4),<br>(3, 1, 4), (3, 2, 4), (3, 3, 4), (3, 4, 4), (4, 1, 4), (4, 3, 4) </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define LL long long int</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1005,maxm = 100005,INF = 1000000000;</span><br><span class="line"></span><br><span class="line">LL N,M;</span><br><span class="line">int fac[maxn],faci = 0;</span><br><span class="line"></span><br><span class="line">void Sp()&#123;</span><br><span class="line">	LL e = M;</span><br><span class="line">	for (LL i = 2; i * i &lt;= e; i++)&#123;</span><br><span class="line">		if (e % i == 0)&#123;</span><br><span class="line">			fac[++faci] = i;</span><br><span class="line">			while (e % i == 0) e /= i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (e - 1) fac[++faci] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">	LL ans = 1;</span><br><span class="line">	for (; b; b &gt;&gt;= 1, a *= a)</span><br><span class="line">		if (b &amp; 1) ans *= a;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL cal(int s)&#123;</span><br><span class="line">	LL mult = 1,pos = 1;</span><br><span class="line">	for (int i = 1; s; i++,s &gt;&gt;= 1)&#123;</span><br><span class="line">		if (s &amp; 1)&#123;</span><br><span class="line">			mult *= fac[i];</span><br><span class="line">			pos *= -1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return qpow(M/mult,N) * pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]容斥原理的三种运用方式</title>
    <url>/2018/09/25/2018-09-25-1/</url>
    <content><![CDATA[<p>在计数时，必须注意无一重复，无一遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。 集合相交通常情况为奇加偶减，即加上重叠为奇次的，减去重叠为偶次的。</p>
<p>容斥原理是属于一种模板题目，一般简单的都是之间打模板，稍难的题目运用到了数学分析和数论的其他知识。</p>
<p>容斥原理分为三种实现：</p>
<p>1.位运算与二进制枚举（容易理解）</p>
<p>2.队列数组（耗时最短）</p>
<p>3.递归（代码最短但不容易理解）</p>
<p><a href="http://blog.csdn.net/deepseazbw/article/details/76187211" target="_blank" rel="noopener">http://blog.csdn.net/deepseazbw/article/details/76187211</a></p>
<p>HDU的一道题目用的三种方法实现，一般都是找出一个数字的素因子，然后用cnt（计算器）记录下来，然后分别三种方法实现.</p>
<p>实现容斥原理的时候</p>
<p>1.先计算出容斥部分，然后再用总数减去 <a href="http://blog.csdn.net/deepseazbw/article/details/76187211" target="_blank" rel="noopener">http://blog.csdn.net/deepseazbw/article/details/76187211</a></p>
<p>2.在容斥部分的时候，就将总数带入进去 <a href="http://blog.csdn.net/deepseazbw/article/details/76660935" target="_blank" rel="noopener">http://blog.csdn.net/deepseazbw/article/details/76660935</a></p>
<p>模板题目： HDU  4135  1695</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]求解逆元的3种方法</title>
    <url>/2018/09/25/2018-09-25/</url>
    <content><![CDATA[<h2 id="简述逆元"><a href="#简述逆元" class="headerlink" title="简述逆元"></a>简述逆元</h2><p>逆元(Inverse element)就是在mod意义下，不能直接除以一个数，而要乘以它的逆元。<br> 比如a∗b≡1(modp)a∗b≡1(modp)，那么a，b互为模n意义下的逆元，比如你要算x/a，就可以改成x*b%p</p>
<p>观察a∗b≡1(modp)a∗b≡1(modp),变形为a∗b+k∗p=1a∗b+k∗p=1，就可以用扩展欧几里得算法求a了，同时这里也说明了a和p只有在互素的情况下才存在逆元。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在下面所有的算法中，最好先把除数取个模再运算。</p>
<h2 id="方法一：扩展欧几里得算法"><a href="#方法一：扩展欧几里得算法" class="headerlink" title="方法一：扩展欧几里得算法"></a>方法一：扩展欧几里得算法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>a∗b≡1(modp)a∗b≡1(modp)<br> a∗b+k∗p=1a∗b+k∗p=1<br> 然后a就是我们要求的逆元，最终得到一个正数a的话就要对a mod p，因为a加上mp的时侯k减少mb可以使得等式依然成立。</p>
<p>如果你不想让逆元为正数，那么直接返回x也是可以正确的逆元</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y)//扩展欧几里得算法 </span><br><span class="line">&#123;</span><br><span class="line">    if(b==0)</span><br><span class="line">    &#123;</span><br><span class="line">        x=1,y=0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">LL getInv(int a,int mod)//求a在mod下的逆元，不存在逆元返回-1 </span><br><span class="line">&#123;</span><br><span class="line">    LL x,y;</span><br><span class="line">    LL d=exgcd(a,mod,x,y);</span><br><span class="line">    return d==1?(x%mod+mod)%mod:-1;</span><br><span class="line">&#125;1234567891011121314151617</span><br></pre></td></tr></table></figure>
<p>注意：返回的时候可以改成(x+mod)%mod，因为扩展欧几里得算法算出来的x应该不会太大.</p>
<p>性能分析:</p>
<ul>
<li>时间复杂度:O(logn)（实际是斐波那契数列）</li>
<li>适用范围：只要存在逆元即可求，适用于个数不多但是mod很大的时候，也是最常见的一种求逆元的方法。</li>
</ul>
<h2 id="方法二-费马小定理-欧拉定理"><a href="#方法二-费马小定理-欧拉定理" class="headerlink" title="方法二:费马小定理/欧拉定理"></a>方法二:费马小定理/欧拉定理</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>费马小定理：若p为素数，则有ap−1≡1(modp)ap−1≡1(modp)<br>   ap−2∗a≡1(modp)ap−2∗a≡1(modp)<br>   ap−2ap−2就是a在mod p意义下的逆元啦。</p>
<p>欧拉定理：若a、p互素，则有aφ(p)≡1(modp)aφ(p)≡1(modp)(费马小定理的一般形式)<br>   aφ(p)∗a≡1(modp)aφ(p)∗a≡1(modp)<br>   aφ(p)−1aφ(p)−1就是a在mod p意义下的逆元啦。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LL qkpow(LL a,LL p,LL mod)</span><br><span class="line">&#123;</span><br><span class="line">    LL t=1,tt=a%mod;</span><br><span class="line">    while(p)</span><br><span class="line">    &#123;</span><br><span class="line">        if(p&amp;1)t=t*tt%mod;</span><br><span class="line">        tt=tt*tt%mod;</span><br><span class="line">        p&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line">LL getInv(LL a,LL mod)</span><br><span class="line">&#123;</span><br><span class="line">    return qkpow(a,mod-2,mod);</span><br><span class="line">&#125;123456789101112131415</span><br></pre></td></tr></table></figure>
<p>性能分析：</p>
<ul>
<li>O(logmod)</li>
<li>适用范围：一般在mod是个素数的时候用，比扩欧快一点而且好写。</li>
<li>但是如果是合数，相信一般没人无聊到去算个欧拉函数。</li>
</ul>
<h2 id="方法三：递推求逆元"><a href="#方法三：递推求逆元" class="headerlink" title="方法三：递推求逆元"></a>方法三：递推求逆元</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>p是模数，i是待求的逆元，我们求的是i−1i−1在mod p意义下的值<br> p=k∗i+rp=k∗i+r令 r &lt; i,则k=p/i,r=p%i<br> k∗i+r≡0(modp)k∗i+r≡0(modp)<br> k∗r−1+i−1≡0(modp)k∗r−1+i−1≡0(modp)<br> i−1≡−k∗r−1(modp)i−1≡−k∗r−1(modp)<br> i−1≡−p/i∗inv[pmodi]i−1≡−p/i∗inv[pmodi]<br> 嗯。。好难看的公式<br> 说白了就是:inv[i]=-(mod/i)*inv[i%mod]<br> 然后边界是inv[1]=1<br> 这不仅为我们提供了一个线性求逆元的方法，也提供了一种O(logmod)求逆元的方法</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><h4 id="线性求逆元"><a href="#线性求逆元" class="headerlink" title="线性求逆元"></a>线性求逆元</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LL inv[mod+5];</span><br><span class="line">void getInv(LL mod)</span><br><span class="line">&#123;</span><br><span class="line">    inv[1]=1;</span><br><span class="line">    for(int i=2;i&lt;mod;i++)</span><br><span class="line">        inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">&#125;1234567</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>调用前要先预处理</li>
<li>调用的时候要先对除数取mod</li>
</ul>
<p>性能分析：</p>
<ul>
<li>时间复杂度O(n)</li>
<li>适用范围：mod数是不大的素数而且多次调用，比如卢卡斯定理。</li>
</ul>
<h4 id="递归求逆元"><a href="#递归求逆元" class="headerlink" title="递归求逆元"></a>递归求逆元</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LL inv(LL i)</span><br><span class="line">&#123;</span><br><span class="line">    if(i==1)return 1;</span><br><span class="line">    return (mod-mod/i)*inv(mod%i)%mod;</span><br><span class="line">&#125;12345</span><br></pre></td></tr></table></figure>
<p>性能分析</p>
<ul>
<li>时间复杂度:O(logmod)</li>
<li>好像找到了最简单的算法了！！</li>
<li>适用范围： mod数是素数，所以并不好用，比如中国剩余定理中就不好使，因为很多时候可能会忘记考虑mod数是不是素数。</li>
</ul>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>逆元</tag>
        <tag>exgcd</tag>
        <tag>费马小定理</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]生成函数小结</title>
    <url>/2018/09/24/2018-09-24/</url>
    <content><![CDATA[<h1 id="母函数"><a href="#母函数" class="headerlink" title="母函数"></a>母函数</h1><p><strong>母函数是用于解决组合问题计数的一种方法。</strong><br> 在了解它之前我们先看看熟悉的杨辉三角。<br>  <img src="https://img-blog.csdn.net/20170611212741764?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ0hOX0pa/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>杨辉三角的第n行(注意是从0开始标号的)的数字就是(1+x)n(1+x)n的展开式从低项到高项的各项系数，也可以表示为组合数的形式CinCni。如果将两者联系起来我们会发现，(1+x)(1+x)可以看成对于一件取舍，1=x01=x0就是不取，x就是取。这样在(1+x)n(1+x)n的展开式中xixi项的系数就是从n件物品选取i件的方案数。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给定数列a0,a1,a2…ana0,a1,a2…an，构造函数G(x)=a0f0(x)+a1f1(x)+a2f2(x)…anfn(x)G(x)=a0f0(x)+a1f1(x)+a2f2(x)…anfn(x),其中G(x)G(x)就是该序列的母函数，f0(x),f1(x),f2(x)…fn(x)f0(x),f1(x),f2(x)…fn(x)为标志函数。<br> <strong>母函数主要有两种形式：普通型母函数和指数型母函数。</strong></p>
<h2 id="普通型母函数"><a href="#普通型母函数" class="headerlink" title="普通型母函数"></a>普通型母函数</h2><p>先看一个例题：<a href="http://blog.csdn.net/chn_jz/article/details/73064925" target="_blank" rel="noopener">HDU 1085</a><br> 普通型母函数的标志函数一般为x0，x1,x2…xnx0，x1,x2…xn<br> 因为每个硬币有个数限制，但是也不难构造出</p>
<p>G(x)=(1+x+x2+x3+…+xnum1)(1+x2+x4+…+x2∗num2)(1+x5+x10+…+x5∗num5)G(x)=(1+x+x2+x3+…+xnum1)(1+x2+x4+…+x2∗num2)(1+x5+x10+…+x5∗num5)</p>
<p>xixi</p>
<h2 id="指数型母函数"><a href="#指数型母函数" class="headerlink" title="指数型母函数"></a>指数型母函数</h2><p>再看一个例题：<a href="http://blog.csdn.net/chn_jz/article/details/73062222" target="_blank" rel="noopener">HDU 1521</a><br> 指数型母函数的标志函数一般为x00!,x11!,x22!…xnn!x00!,x11!,x22!…xnn!，对于xii!xii!表示在一个方案中某个元素出现了ii次，而不同位置的该种元素本质不同，所以在记方案数时只算作一种，所以最后结果应处以i！i！。<br> 对于这道题就不难构造出母函数为</p>
<p>G(x)=(1/ 0!+X / 1!+X2 / 2!+…+Xa1 / a1!)(1 / 0!+X / 1!+X2 / 2!+…+Xa2 / a2!)( / 0!+X / 1!+X2 / 2!+…+Xan / an!)</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-ACM/ICPC北京网络赛D题 80 Days（非暴力0(n)解法）</title>
    <url>/2018/09/22/2018-09-22-1/</url>
    <content><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><em>80 Days is an interesting game based on Jules Verne’s science fiction “Around the World in Eighty Days”.</em> In this game, you have to manage the limited money and time.</p>
<p>Now we simplified the game as below:</p>
<p>There are n cities on a circle around the world which are numbered from 1 to n by their order on the circle. When you reach the city i at the first time, you will get ai dollars (ai can even be negative), and if you want to go to the next city on the circle, you should pay bi dollars. At the beginning you have c dollars.</p>
<p>The goal of this game is to choose a city as start point, then go along the circle and visit all the city once, and finally return to the start point. During the trip, the money you have must be no less than zero.</p>
<p>Here comes a question: to complete the trip, which city will you choose to be the start city?</p>
<p>If there are multiple answers, please output the one with the smallest number.</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>The first line of the input is an integer T (T ≤ 100), the number of test cases.</p>
<p>For each test case, the first line contains two integers n and c (1 ≤ n ≤ 10^6, 0 ≤ c ≤ 10^9).  The second line contains n integers a1, …, an  (-10^9 ≤ ai ≤ 10^9), and the third line contains n integers b1, …, bn (0 ≤ bi ≤ 10^9).</p>
<p>It’s guaranteed that the sum of n of all test cases is less than 106</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>For each test case, output the start city you should choose.</p>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>For test case 1, both city 2 and 3 could be chosen as start point, 2 has smaller number. But if you start at city 1, you can’t go anywhere.</p>
<p>For test case 2, start from which city seems doesn’t matter, you just don’t have enough money to complete a trip.</p>
<p><strong>利用前缀和与后缀和优化dp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define LL long long</span><br><span class="line">const LL maxn = 1e6+7;</span><br><span class="line">LL a[maxn],b[maxn],cha[maxn],qian[maxn],qian2[maxn], hou[maxn], hou2[maxn];</span><br><span class="line">void init(LL n,LL c)&#123;</span><br><span class="line">    hou[n+1] = qian[0] = 0;</span><br><span class="line">    hou2[n] = hou[n] = cha[n];</span><br><span class="line">    qian2[1] = qian[1] = cha[1];</span><br><span class="line">    for(int i = 2;i&lt;=n;i++)&#123;</span><br><span class="line">        qian[i] = cha[i]+qian[i-1];</span><br><span class="line">        qian2[i] = min(qian[i],qian2[i-1]);</span><br><span class="line">    &#125;</span><br><span class="line">    LL sum = 0;</span><br><span class="line">    for(int i = n-1;i&gt;0;i--)&#123;</span><br><span class="line">        hou[i] = cha[i]+hou[i+1];</span><br><span class="line">        hou2[i] = min(hou[i]-sum,cha[i]);</span><br><span class="line">        if(hou2[i]&gt;=0)&#123;</span><br><span class="line">            sum=hou[i];</span><br><span class="line">            hou2[i]=0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int fun(LL n,LL c)&#123;</span><br><span class="line">    if(qian[n]+c&lt;0)</span><br><span class="line">        return -1;</span><br><span class="line">    for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(cha[i]+c&gt;=0&amp;&amp;cha[i]+c+hou2[i+1]&gt;=0)&#123;</span><br><span class="line">            if(hou[i]+c+qian2[i-1]&gt;=0)&#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    LL n,c;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;c);</span><br><span class="line">        for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">            scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">            scanf(&quot;%lld&quot;,&amp;b[i]);</span><br><span class="line">            cha[i] = a[i] - b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        init(n,c);</span><br><span class="line">        int tmp = fun(n,c);</span><br><span class="line">        printf(&quot;%d\n&quot;,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>尺取法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define MAX 1000005</span><br><span class="line"> </span><br><span class="line">int p[MAX&lt;&lt;1],a[MAX],b[MAX];</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	while(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		int n;</span><br><span class="line">		long long c;</span><br><span class="line">		scanf(&quot;%d%lld&quot;,&amp;n,&amp;c);</span><br><span class="line">		for(int i = 1;i &lt;= n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i = 1;i &lt;= n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;b[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i = 1;i &lt;= n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			p[i] = p[i + n] = a[i] - b[i];</span><br><span class="line">		&#125;</span><br><span class="line">		int l = 1,r = 1;</span><br><span class="line">		while(l &lt;= n &amp;&amp; r - l + 1 &lt;= n)</span><br><span class="line">		&#123;</span><br><span class="line">			c = c + p[r];</span><br><span class="line">			r ++;</span><br><span class="line">			while(c &lt; 0)</span><br><span class="line">			&#123;</span><br><span class="line">				c = c - p[l];</span><br><span class="line">				l ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(l &gt; n)</span><br><span class="line">			printf(&quot;-1\n&quot;);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;%d\n&quot;,l);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>动态规划</tag>
        <tag>尺取法</tag>
      </tags>
  </entry>
  <entry>
    <title>[组合数学]动态规划解决整数划分问题</title>
    <url>/2018/09/22/2018-09-22/</url>
    <content><![CDATA[<p>整数划分问题是将一个正整数n拆成一组数连加并等于n的形式，且这组数中的最大加数不大于n。</p>
<p>如6的整数划分为：    </p>
<p>6         6     </p>
<p>5        5 + 1     </p>
<p>4         4 + 2, 4 + 1 + 1     </p>
<p>3         3 + 3, 3 + 2 + 1, 3 + 1 + 1 + 1    </p>
<p>2        2 + 2 + 2, 2 + 2 + 1 + 1, 2 + 1 + 1 + 1 + 1     </p>
<p>1         1 + 1 + 1 + 1 + 1 + 1</p>
<p>设n为要划分的正整数，m是划分中的最大加数(当m &gt; n时，最大加数为n)，     </p>
<p>1 当n = 1或m = 1时，split的值为1，可根据上例看出，只有一个划分1 或 1 + 1 + 1 + 1 + 1 + 1     可用程序表示为if(n == 1 || m == 1) return 1;          </p>
<p>2 下面看一看m 和 n的关系。它们有三种关系     </p>
<p>(1) m &gt; n     在整数划分中实际上最大加数不能大于n，因此在这种情况可以等价为split(n, n);     可用程序表示为if(m &gt; n) return split(n, n); </p>
<p>(2) m = n     这种情况可用递归表示为split(n, m - 1) + 1，从以上例子中可以看出，就是最大加     数为6和小于6的划分之和     用程序表示为if(m == n) return (split(n, m - 1) + 1); </p>
<p>(3) m &lt; n     这是最一般的情况，在划分的大多数时都是这种情况。     从上例可以看出，设m = 4，那split(6, 4)的值是最大加数小于4划分数和整数2的划分数的和。</p>
<p>因此，split(n, m)可表示为split(n, m - 1) + split(n - m, m) </p>
<p><strong>hdu1028</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 121;</span><br><span class="line">int n, dp[maxn][maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(dp,0,sizeof(dp));</span><br><span class="line">    dp[0][0] = dp[1][0] = 1;</span><br><span class="line">    for(int i = 1;i&lt;maxn;i++)</span><br><span class="line">        dp[i][1] = 1;</span><br><span class="line">    for(int i = 2;i&lt;maxn;i++)</span><br><span class="line">        for(int j = 1;j&lt;=i;j++)</span><br><span class="line">            dp[i][j] = dp[i][j-1] + dp[i-j][min(i-j,j)];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,dp[n][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>组合数学</tag>
        <tag>动态规划</tag>
        <tag>划分</tag>
      </tags>
  </entry>
  <entry>
    <title>[容斥原理]Hard to prepare</title>
    <url>/2018/09/20/2018-09-20/</url>
    <content><![CDATA[<p>After Incident, a feast is usually held in Hakurei Shrine. This time Reimu asked Kokoro to deliver a Nogaku show during the feast. To enjoy the show, every audience has to wear a Nogaku mask, and seat around as a circle.</p>
<p>There are N guests Reimu serves. Kokoro has 2^k2k masks numbered from 0,1,\cdots,0,1,⋯, 2^k - 12k−1, and every guest wears one of the masks. The masks have dark power of Dark Nogaku, and to prevent guests from being hurt by the power, two guests seating aside must ensure that if their masks are numbered ii and jj , then ii XNOR jj must be positive. (two guests can wear the same mask). XNOR means ~(ii^jj) and every number has kk bits. (11 XNOR 1 = 11=1, 00XNOR 0 = 10=1, 11 XNOR 0 = 00=0)</p>
<p>You may have seen 《A Summer Day’s dream》, a doujin Animation of Touhou Project. Things go like the anime, Suika activated her ability, and the feast will loop for infinite times. This really troubles Reimu: to not make her customers feel bored, she must prepare enough numbers of different Nogaku scenes. Reimu find that each time the same guest will seat on the same seat, and She just have to prepare a new scene for a specific mask distribution. Two distribution plans are considered different, if any guest wears different masks.</p>
<p>In order to save faiths for Shrine, Reimu have to calculate that to make guests not bored, how many different Nogaku scenes does Reimu and Kokoro have to prepare. Due to the number may be too large, Reimu only want to get the answer modules 1e9+71e9+7 . Reimu did never attend Terakoya, so she doesn’t know how to calculate in module. So Reimu wishes you to help her figure out the answer, and she promises that after you succeed she will give you a balloon as a gift.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>First line one number TT , the number of testcases; (T \le 20)(T≤20) .</p>
<p>Next TT lines each contains two numbers, NNand k(0&lt;N, k \le 1e6)k(0&lt;N,k≤1e6) .</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each testcase output one line with a single number of scenes Reimu and Kokoro have to prepare, the answer modules 1e9+71e9+7 .</p>
<h4 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 1</span><br><span class="line">4 2</span><br></pre></td></tr></table></figure>
<h4 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">84</span><br></pre></td></tr></table></figure>
<h4 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h4><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E5%BE%90%E5%B7%9E%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 徐州赛区网络预赛</a></p>
<p><strong>题目描述</strong></p>
<p>有n个位置围成一个圈，2^k个数，每个位置随便放置一个数，要求范围在1到2^k之间，然而每个数都有一个互斥的数，且互斥的两个数不会和其他的重复，要求相邻位置不能有互斥的数。</p>
<p><strong>题解</strong></p>
<p>首先用快速幂求出2^k然后赋给k，即k = 2^k。然后假设这n个数依次排开，那么每一个数不能是上一个元素的互斥数，那么第1个元素共k种，那么之后每一种为k-1种。即<code>k*(k-1)^(n-1)</code>，然而这样的话最后一个元素可以为第一个元素的互斥数，因此要减去相应的数，根据容斥原理最终列出实在为<code>k*(k-1)^(n-1)-k*(k-1)^(n-2)+k*(k-1)^(n-3)-k*(k-1)^(n-4)……</code>然而这样做会超时，因此我们可以合并，即加一次减一次合并到一起重新得到公式。</p>
<p>当然我们也可以换一种思考方式，很容易想到，第1个数有<img src="https://private.codecogs.com/gif.latex?%5Csmall%202%5Ek" alt="\small 2^k">种选择，第2个数到第n-1个数都有<img src="https://private.codecogs.com/gif.latex?%5Csmall%202%5Ek-1" alt="\small 2^k-1">种选择，第n个数有<img src="https://private.codecogs.com/gif.latex?%5Csmall%202%5Ek-2" alt="\small 2^k-2">种选择。</p>
<p>所以答案就是<img src="https://private.codecogs.com/gif.latex?%5Csmall%202%5Ek%282%5Ek-2%29%282%5Ek-1%29%5E%7Bn-2%7D" alt="\small 2^k(2^k-2)(2^k-1)^{n-2}"></p>
<p>但是这样会出现漏算：在第1个数和第n-1个数相同的情况下，第n个数有<img src="https://private.codecogs.com/gif.latex?%5Csmall%202%5Ek-1" alt="\small 2^k-1">种选择， 而并非<img src="https://private.codecogs.com/gif.latex?%5Csmall%202%5Ek-2" alt="\small 2^k-2">种</p>
<p>然后仔细分析可以发现，漏算的情况你可以把第1个数和第n-1个数当成同一个数，这样序列长度就变成n-2了，问题规模变小</p>
<p>递归或递推即可</p>
<p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">const ll mod = 1e9+7;</span><br><span class="line">ll quick_pow(ll ans, ll res, ll n)&#123;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1)</span><br><span class="line">            ans = ans * res % mod;</span><br><span class="line">        res = res * res % mod;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">ll solve(ll n, ll k)&#123;</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    ll i = (n&amp;1)+2;</span><br><span class="line">    ll res = pow(k-1,i-2);</span><br><span class="line">    for(;i&lt;=n;i+=2)&#123;</span><br><span class="line">        ans = (ans + res) % mod;</span><br><span class="line">        res = res * (k - 1) % mod * (k - 1) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = ans * k % mod * (k - 2) % mod;</span><br><span class="line">    ans = (ans + k) % mod;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll t,n,k;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);</span><br><span class="line">        k = quick_pow(1,2,k);</span><br><span class="line">        printf(&quot;%lld\n&quot;,solve(n,k));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>2015 ACM-ICPC Asia Regional Contest Shanghai Site - Onsite Contest</title>
    <url>/2018/09/18/2018-09-18-2/</url>
    <content><![CDATA[<h2 id="F-Friendship-of-Frog"><a href="#F-Friendship-of-Frog" class="headerlink" title="F - Friendship of Frog"></a>F - Friendship of Frog</h2><p> NN frogs from different countries are standing in a line. Each country is represented by a lowercase letter. The distance between adjacent frogs (e.g. the 1st1stand the 2nd2nd frog, the N−1thN−1th and the NthNth frog, etc) are exactly 11. Two frogs are friends if they come from the same country.<br>The closest friends are a pair of friends with the <strong>minimum</strong> distance. Help us find that distance.</p>
<p>Input</p>
<p>First line contains an integer TT, which indicates the number of test cases.<br>Every test case only contains a string with length NN, and the ithith character of the string indicates the country of ithith frogs.<br>⋅⋅ 1≤T≤501≤T≤50.<br>⋅⋅ for 80% data, 1≤N≤1001≤N≤100.<br>⋅⋅ for 100% data, 1≤N≤10001≤N≤1000.<br>⋅⋅ the string only contains lowercase letters.</p>
<p>Output</p>
<p>For every test case, you should output “ <strong>Case #x: y</strong>“, where xx indicates the case number and counts from 11 and yy is the result. If there are no frogs in same country, output −1−1 instead.</p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">abcecba</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case #1: 2</span><br><span class="line">Case #2: -1</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>超级水题，一次性遍历，顺便设置一个字母表，记录上一个字母位置，初始值为0，每遇到一个字母，对该字母表进行更新。如果上一个该字母表不为0，则先用当前位置减去表中上一个位置，然后记录下最小值，然后再更新。最终如果最小值为初始值，则输出-1，否则输出该最小值。</p>
<p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e9+7;</span><br><span class="line">char str[1007];</span><br><span class="line">int a[26];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    for(int cc = 1;cc&lt;=t;cc++)&#123;</span><br><span class="line">        scanf(&quot;%s&quot;,&amp;str);</span><br><span class="line">        int minD = maxx;</span><br><span class="line">        memset(a,0,sizeof(a));</span><br><span class="line">        int len = strlen(str);</span><br><span class="line">        for(int i = 0;i&lt;len;i++)&#123;</span><br><span class="line">            int num = str[i]-&apos;a&apos;;</span><br><span class="line">            if(a[num])</span><br><span class="line">                minD = min(minD,i - a[num] + 1);</span><br><span class="line">            a[num] = i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(minD == maxx)</span><br><span class="line">            printf(&quot;Case #%d: -1\n&quot;,cc);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;Case #%d: %d\n&quot;,cc,minD);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="K-Kingdom-of-Black-and-White"><a href="#K-Kingdom-of-Black-and-White" class="headerlink" title="K - Kingdom of Black and White"></a>K - Kingdom of Black and White</h2><p>In the Kingdom of Black and White (KBW), there are two kinds of frogs: black frog and white frog.<br>Now NN frogs are standing in a line, some of them are black, the others are white. The total strength of those frogs are calculated by dividing the line into minimum parts, each part should still be continuous, and can only contain one kind of frog. Then the strength is the sum of the squared length for each part.<br>However, an old, evil witch comes, and tells the frogs that she will change the color of <strong>at most one</strong> frog and thus the strength of those frogs might change.<br>The frogs wonder the <strong>maximum</strong> possible strength after the witch finishes her job.</p>
<p>Input</p>
<p>First line contains an integer TT, which indicates the number of test cases.<br>Every test case only contains a string with length NN, including only 00(representing<br>a black frog) and 11 (representing a white frog).<br>⋅⋅ 1≤T≤501≤T≤50.<br>⋅⋅ for 60% data, 1≤N≤10001≤N≤1000.<br>⋅⋅ for 100% data, 1≤N≤1051≤N≤105.<br>⋅⋅ the string only contains 0 and 1.</p>
<p>Output</p>
<p>For every test case, you should output “ <strong>Case #x: y</strong>“,where xx indicates the case number and counts from 11 and yy is the answer.</p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">000011</span><br><span class="line">0101</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case #1: 26</span><br><span class="line">Case #2: 10</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>解法有点偏暴力，首先将01分成m个联通块，一次性遍历，将m个联通块的长度储存起来，算出总值ans。然后对这m个联通块分别判断加1情况下是否变大，当然该值的计算要先用ans减去该联通块以及相邻左边或右边联通块的值，然后再加上更新的值。</p>
<p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string s;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    for(int cas=1;cas&lt;=t;cas++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        int flag = -1;</span><br><span class="line">        vector&lt;long long&gt; Q;</span><br><span class="line">        int len = 0;</span><br><span class="line">        for(int i=0;i&lt;s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[i]-&apos;0&apos;!=flag)</span><br><span class="line">            &#123;</span><br><span class="line">                Q.push_back(len);</span><br><span class="line">                len = 1;</span><br><span class="line">                flag = s[i]-&apos;0&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                len++;</span><br><span class="line">        &#125;</span><br><span class="line">        Q.push_back(len);</span><br><span class="line">        Q.push_back(0);</span><br><span class="line">        long long res = 0;</span><br><span class="line">        for(int i=1;i&lt;Q.size()-1;i++)</span><br><span class="line">            res += Q[i]*Q[i];</span><br><span class="line">        long long ans = res;</span><br><span class="line">        for(int i=1;i&lt;Q.size()-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            long long tmp = 0;</span><br><span class="line">            if(Q[i]==1)</span><br><span class="line">                ans = max(ans,res-Q[i-1]*Q[i-1]-Q[i]*Q[i]-Q[i+1]*Q[i+1]+(Q[i-1]+Q[i+1]+1)*(Q[i-1]+Q[i+1]+1));</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                ans = max(ans,res-Q[i-1]*Q[i-1]-Q[i]*Q[i]+(Q[i-1]+1)*(Q[i-1]+1)+(Q[i]-1)*(Q[i]-1));</span><br><span class="line">                ans = max(ans,res-Q[i+1]*Q[i+1]-Q[i]*Q[i]+(Q[i+1]+1)*(Q[i+1]+1)+(Q[i]-1)*(Q[i]-1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %lld\n&quot;,cas,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="L-LCM-Walk"><a href="#L-LCM-Walk" class="headerlink" title="L - LCM Walk"></a>L - LCM Walk</h2><p> A frog has just learned some number theory, and can’t wait to show his ability to his girlfriend.<br>Now the frog is sitting on a grid map of infinite rows and columns. Rows are numbered 1,2,⋯1,2,⋯ from the bottom, so are the columns. At first the frog is sitting at grid (sx,sy)(sx,sy), and begins his journey.<br>To show his girlfriend his talents in math, he uses a special way of jump. If currently the frog is at the grid (x,y)(x,y), first of all, he will find the minimum zzthat can be divided by both xx and yy, and jump exactly zz steps to the up, or to the right. So the next possible grid will be (x+z,y)(x+z,y), or (x,y+z)(x,y+z).<br>After a finite number of steps (perhaps zero), he finally finishes at grid (ex,ey)(ex,ey). However, he is too tired and he forgets the position of his starting grid!<br>It will be too stupid to check each grid one by one, so please tell the frog the number of possible starting grids that can reach (ex,ey)(ex,ey)!</p>
<p>Input</p>
<p>First line contains an integer TT, which indicates the number of test cases.<br>Every test case contains two integers exex and eyey, which is the destination grid.<br>⋅⋅ 1≤T≤10001≤T≤1000.<br>⋅⋅ 1≤ex,ey≤1091≤ex,ey≤109.</p>
<p>Output</p>
<p>For every test case, you should output “ <strong>Case #x: y</strong>“, where xx indicates the case number and counts from 11 and yy is the number of possible starting grids. </p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">6 10</span><br><span class="line">6 8</span><br><span class="line">2 8</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case #1: 1</span><br><span class="line">Case #2: 2</span><br><span class="line">Case #3: 3</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>设当前位置为(x,y)，gcd(x,y) = g。则可设x = m1g，y=m2g，LCM（x,y） = m1m2g，则目标值为（m1g+m1m2g，m2g）或（m1g，m2g+m1m2g）。已知目标值，求x，y。我们设目标值为x2，y2，则可推出m1 = x2/(g+y2)或m2 = y2/(g+x2)。递归过程，直到m1或m2不为0则返回值，否则次数加1，再继续递归。</p>
<p>最终得到结果。</p>
<p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">ll gcd(ll a,ll b)&#123;</span><br><span class="line">    return a%b==0?b:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">ll dfs(ll g,ll x,ll y)&#123;</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    if(!(x%(g+y)))&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        ll tmp = x*g/(g+y);</span><br><span class="line">        ans+=dfs(gcd(max(tmp,y),min(tmp,y)),tmp,y);</span><br><span class="line">    &#125;</span><br><span class="line">    if(!(y%(g+x)))&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        ll tmp = y*g/(g+x);</span><br><span class="line">        ans+=dfs(gcd(max(tmp,x),min(tmp,x)),x,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll t,x,y;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">    for(ll c = 1;c&lt;=t;c++)&#123;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);</span><br><span class="line">        ll tmp = gcd(max(x,y),min(x,y));</span><br><span class="line">        ll ans = dfs(tmp,x,y);</span><br><span class="line">        printf(&quot;Case #%lld: %lld\n&quot;,c,++ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>数论</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI手拉手问题</title>
    <url>/2018/09/18/2018-09-18-1/</url>
    <content><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>n个人n双手，每一次选择两个空手让这两个空手拉起来，然后这两个手不再是空手。一个人有两只手，问最终所有手都拉起来构成环的个数的期望。PS：一个人的左手和右手也可以拉起来构成一个环。</p>
<p>例如：n为2时，期望为4/3，假设从第一个人的左手开始，他的左手和右手和第2个人的左手和右手拉起来的概率都为1/3，其中自己的左手和右手拉起来构成环数为2，其他为1，则期望为<code>1/3*2+1/3*1+1/3*1</code></p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>1+1/3+1/5+……1/(2n-1)</p>
<p>如果直接看公式很容易理解，每多一个人，就多了两只手，假设除了这个人以外其他人的期望都算出来了，假设期望为F(n)，那么对于这个人来说无非两种情况，要么和自己拉，要么和别人拉，和自己拉的概率为1/(2n-1)，和别人拉的概率为(2n-2)/(2n-1)。和自己拉的话很好理解，在之前的期望上加1就好了，和别人拉的话就可以把这两个人绑定起来当成一个人就好了，期望就是之前的期望。所以用公式的话就是<code>F(n+1)=F(n)*(2n-2)/(2n-1)+(F(n)+1)*1/(2n-1)</code>,化简就得<code>F(n+1)=F(n)+1/(2n-1)</code>，递归得F(n)=1+1/3+1/5+……1/(2n-1)</p>
<p>根据调和级数推到公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ld long double</span><br><span class="line">const int maxn = 1e7+7;</span><br><span class="line">ld a[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    a[0] = 0;</span><br><span class="line">    a[1]=1;</span><br><span class="line">    for(int i = 2;i&lt;maxn;i++)&#123;</span><br><span class="line">        a[i]=a[i-1]+1.0/(2*i-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    //freopen(&quot;head.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    //freopen(&quot;head.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    long long tmp;</span><br><span class="line">    init();</span><br><span class="line">    cin&gt;&gt;tmp;</span><br><span class="line">    if(tmp*1.0&gt;=maxn)</span><br><span class="line">        cout&lt;&lt;log(2*tmp-1) - log(((2*tmp-1)-1)/2)/ 2 + 0.57721566490153286060651209 / 2&lt;&lt;endl;</span><br><span class="line">    else</span><br><span class="line">        cout&lt;&lt;a[tmp]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>概率论</category>
      </categories>
      <tags>
        <tag>期望</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找距离最小点对</title>
    <url>/2018/09/18/2018-09-18/</url>
    <content><![CDATA[<p>在应用中，常用诸如点、圆等简单的几何对象代表现实世界中的实体。在涉及这些几何对象的问题中，常需要了解其邻域中其他几何对象的信息。例如，在空中交通控制问题中，若将飞机作为空间中移动的一个点来看待，则具有最大碰撞危险的2架飞机，就是这个空间中最接近的一对点。这类问题是计算几何学中研究的基本问题之一。下面我们着重考虑平面上的最接近点对问题。</p>
<p>​    最接近点对问题的提法是:给定平面上n个点，找其中的一对点，使得在n个点的所有点对中，该点对的距离最小。</p>
<p>​    严格地说，最接近点对可能多于1对。为了简单起见，这里只限于找其中的一对。</p>
<p><strong>参考解答</strong></p>
<p>​    这个问题很容易理解，似乎也不难解决。我们只要将每一点与其他n-1个点的距离算出，找出达到最小距离的两个点即可。然而，这样做效率太低，需要O(n2)的计算时间。在问题的计算复杂性中我们可以看到，该问题的计算时间下界为Ω(nlogn)。这个下界引导我们去找问题的一个θ(nlogn)<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">算法</a>。</p>
<p>这个问题显然满足分治法的第一个和第二个适用条件，我们考虑将所给的平面上n个点的集合S分成2个子集S1和S2，每个子集中约有n/2个点，·然后在每个子集中递归地求其最接近的点对。在这里，一个关键的问题是如何实现分治法中的合并步骤，即由S1和S2的最接近点对，如何求得原集合S中的最接近点对，因为S1和S2的最接近点对未必就是S的最接近点对。如果组成S的最接近点对的2个点都在S1中或都在S2中，则问题很容易解决。但是，如果这2个点分别在S1和S2中，则对于S1中任一点p，S2中最多只有n/2个点与它构成最接近点对的候选者，仍需做n2/4次计算和比较才能确定S的最接近点对。因此，依此思路，合并步骤耗时为O(n2)。整个算法所需计算时间T(n)应满足:　</p>
<p>T(n)=2T(n/2)+O(n2)</p>
<p>​     它的解为T(n)=O(n2)，即与合并步骤的耗时同阶，显示不出比用穷举的方法好。从解递归方程的套用公式法，我们看到问题出在合并步骤耗时太多。这启发我们把注意力放在合并步骤上。</p>
<p>​    为了使问题易于理解和分析，我们先来考虑一维的情形。此时S中的n个点退化为x轴上的n个实数x1,x2,..,xn。最接近点对即为这n个实数中相差最小的2个实数。我们显然可以先将x1,x2,..,xn排好序，然后，用一次线性扫描就可以找出最接近点对。这种方法主要计算时间花在排序上，因此如在排序算法中所证明的，耗时为O(nlogn)。然而这种方法无法直接推广到二维的情形。因此，对这种一维的简单情形，我们还是尝试用分治法来求解，并希望能推广到二维的情形。</p>
<p>​    假设我们用x轴上某个点m将S划分为2个子集S1和S2，使得S1={x∈S|x≤m}；S2={x∈S|x&gt;m}。这样一来，对于所有p∈S1和q∈S2有p</p>
<p>​    递归地在S1和S2上找出其最接近点对{p1,p2}和{q1,q2}，并设δ=min{|p1-p2|,|q1-q2|}，S中的最接近点对或者是{p1,p2}，或者是{q1,q2}，或者是某个{p3,q3}，其中p3∈S1且q3∈S2。如图1所示。</p>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/junerfsoft/466945/o_092408_1704_1_633579015612968750.gif" alt="img">图1 一维情形的分治法</p>
<p>我们注意到，如果S的最接近点对是{p3,q3}，即|p3-q3|&lt;δ，则p3和q3两者与m的距离不超过δ，即|p3-m|&lt;δ，|q3-m|&lt;δ，也就是说，p3∈(m-δ,m]，q3∈(m,m+δ]。由于在S1中，每个长度为δ的半闭区间至多包含一个点（否则必有两点距离小于δ），并且m是S1和S2的分割点，因此(m-δ,m]中至多包含S中的一个点。同理，(m,m+δ]中也至多包含S中的一个点。由图1可以看出，如果(m-δ,m]中有S中的点，则此点就是S1中最大点。同理，如果(m,m+δ]中有S中的点，则此点就是S2中最小点。因此，我们用线性时间就能找到区间(m-δ,m]和(m,m+δ]中所有点，即p3和q3。从而我们用线性时间就可以将S1的解和S2的解合并成为S的解。也就是说，按这种分治策略，合并步可在O(n)时间内完成。这样是否就可以得到一个有效的算法了呢？还有一个问题需要认真考虑，即分割点m的选取，及S1和S2的划分。选取分割点m的一个基本要求是由此导出集合S的一个线性分割，即S=S1∪S2 ，S1∩S2=Φ，且S1{x|x≤m}；S2{x|x&gt;m}。容易看出，如果选取m=[max(S)+min(S)]/2，可以满足线性分割的要求。选取分割点后，再用O(n)时间即可将S划分成S1={x∈S|x≤m}和S2={x∈S|x&gt;m}。然而，这样选取分割点m，有可能造成划分出的子集S1和S2的不平衡。例如在最坏情况下，|S1|=1，|S2|=n-1，由此产生的分治法在最坏情况下所需的计算时间T(n)应满足递归方程:</p>
<p>T(n)=T(n-1)+O(n)</p>
<p>​    它的解是T(n)=O(n2)。这种效率降低的现象可以通过分治法中”平衡子问题”的方法加以解决。也就是说，我们可以通过适当选择分割点m，使S1和S2中有大致相等个数的点。自然地，我们会想到用S的n个点的坐标的中位数来作分割点。在选择算法中介绍的选取中位数的线性时间算法使我们可以在O(n)时间内确定一个平衡的分割点m。</p>
<p>​     至此，我们可以设计出一个求一维点集S中最接近点对的距离的算法CPAIR1如下。</p>
<p>function CPAIR1(S);</p>
<p>begin</p>
<p>if |S|=2</p>
<p>then δ=|x[2]-x[1]| // x[1..n]存放的是S中n个点的坐标</p>
<p>else if (|S|=1)</p>
<p>then δ:=∞</p>
<p>else</p>
<p>begin</p>
<p>m:=S中各点的坐标值的中位数;</p>
<p>构造S1和S2,使S1={x∈S|x≤m}，S2={x∈S|x&gt;m}; δ1:=CPAIRI(S1); δ2:=CPAIRI(S2);</p>
<p>p:=max(S1); q:=min(S2);</p>
<p>δ:=min(δ1,δ2,q-p);</p>
<p>end;</p>
<p>return(δ);</p>
<p>end;</p>
<p>由以上的分析可知，该算法的分割步骤和合并步骤总共耗时O(n)。因此，算法耗费的计算时间T(n)满足递归方程：</p>
<p>​     解此递归方程可得T(n)=O(nlogn)。</p>
<p>​    这个算法看上去比用排序加扫描的算法复杂，然而这个算法可以向二维推广。</p>
<p>​    下面我们来考虑二维的情形。此时S中的点为平面上的点，它们都有2个坐标值x和y。为了将平面上点集S线性分割为大小大致相等的2个子集S1和S2，我们选取一垂直线l:x=m来作为分割直线。其中m为S中各点x坐标的中位数。由此将S分割为S1={p∈S|px≤m}和S2={p∈S|px&gt;m}。从而使S1和S2分别位于直线l的左侧和右侧，且S=S1∪S2 。由于m是S中各点x坐标值的中位数，因此S1和S2中的点数大致相等。</p>
<p>​    递归地在S1和S2上解最接近点对问题，我们分别得到S1和S2中的最小距离δ1和δ2。现设δ=min(δ1,δ1)。若S的最接近点对(p,q)之间的距离d(p,q)&lt;δ则p和q必分属于S1和S2。不妨设p∈S1，q∈S2。那么p和q距直线l的距离均小于δ。因此，我们若用P1和P2分别表示直线l的左边和右边的宽为δ的2个垂直长条，则p∈P1，q∈P2，如图2所示。</p>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/junerfsoft/466945/o_092408_1704_2.jpg" alt="img"></p>
<p>图2 距直线l的距离小于δ的所有点</p>
<p> 在一维的情形，距分割点距离为δ的2个区间(m-δ,m](m,m+δ]中最多各有S中一个点。因而这2点成为唯一的末检查过的最接近点对候选者。二维的情形则要复杂些，此时，P1中所有点与P2中所有点构成的点对均为最接近点对的候选者。在最坏情况下有n2/4对这样的候选者。但是P1和P2中的点具有以下的稀疏性质，它使我们不必检查所有这n2/4对候选者。考虑P1中任意一点p,它若与P2中的点q构成最接近点对的候选者，则必有d(p,q)&lt;δ。满足这个条件的P2中的点有多少个呢？容易看出这样的点一定落在一个δ×2δ的矩形R中，如图3所示。</p>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/junerfsoft/466945/o_092408_1704_3_633579015617343750.jpg" alt="img">图3 包含点q的δ×2δ的矩形R</p>
<p>​    由δ的意义可知P2中任何2个S中的点的距离都不小于δ。由此可以推出矩形R中最多只有6个S中的点。事实上，我们可以将矩形R的长为2δ的边3等分，将它的长为δ的边2等分，由此导出6个（δ/2）×（2δ/3）的矩形。如图4(a)所示。</p>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/junerfsoft/466945/o_092408_1704_4_633579015619375000.jpg" alt="img">图4 矩形R中点的稀疏性</p>
<p>​    若矩形R中有多于6个S中的点，则由鸽舍原理易知至少有一个δ×2δ的小矩形中有2个以上S中的点。设u,v是这样2个点，它们位于同一小矩形中，则</p>
<p>​     因此d(u,v)≤5δ/6&lt;δ 。这与δ的意义相矛盾。也就是说矩形R中最多只有6个S中的点。图4(b)是矩形R中含有S中的6个点的极端情形。由于这种稀疏性质，对于P1中任一点p，P2中最多只有6个点与它构成最接近点对的候选者。因此，在分治法的合并步骤中，我们最多只需要检查6×n/2=3n对候选者，而不是n2/4对候选者。这是否就意味着我们可以在O(n)时间内完成分治法的合并步骤呢？现在还不能作出这个结论，因为我们只知道对于P1中每个S1中的点p最多只需要检查P2中的6个点，但是我们并不确切地知道要检查哪6个点。为了解决这个问题，我们可以将p和P2中所有S2的点投影到垂直线l上。由于能与p点一起构成最接近点对候选者的S2中点一定在矩形R中，所以它们在直线l上的投影点距p在l上投影点的距离小于δ。由上面的分析可知，这种投影点最多只有6个。因此，若将P1和P2中所有S的点按其y坐标排好序，则对P1中所有点p，对排好序的点列作一次扫描，就可以找出所有最接近点对的候选者，对P1中每一点最多只要检查P2中排好序的相继6个点。</p>
<p>​    至此，我们可以给出用分治法求二维最接近点对的算法CPAIR2如下:</p>
<p>function CPAIR2(S);</p>
<p>begin</p>
<p>if |S|=2</p>
<p>then δ:=S中这2点的距离</p>
<p>else if |S|=0</p>
<p>then δ:=∞</p>
<p>else</p>
<p>begin</p>
<p>\1. m:=S中各点x坐标值的中位数; 构造S1和S2，使S1={p∈S|px≤m}和S2={p∈S|px&gt;m}</p>
<p>\2. δ1:=CPAIR2(S1);δ2:=CPAIR2(S2);</p>
<p>\3. δm:=min(δ1,δ2);</p>
<p>\4. 设P1是S1中距垂直分割线l的距离在δm之内的所有点组成的集合， P2是S2中距分割线l的距离在δm之内所有点组成的集合。将P1和P2中的点依其y坐标值从小到大排序，并设P1<em>和P2</em>是相应的已排好序的点列;</p>
<ol start="5">
<li>通过扫描P1<em>以及对于P1</em>中每个点检查P2<em>中与其距离在δm之内的所有点(最多6个)可以完成合并。当P1</em>中的扫描指针逐次向上移动 时，P2*中的扫描指针可在宽为2δm的一个区间内移动。设δl是按 这种扫描方式找到的点对间的最小距离;</li>
</ol>
<p>\6. δ=min(δm,δl);</p>
<p>end;</p>
<p>return(δ);</p>
<p>end;</p>
<p>下面我们来分析一下算法CPAIR2的计算复杂性。设对于n个点的平面点集S，算法耗时T(n)。算法的第1步和第5步用了O(n)时间，第3步和第6步用了常数时间，第2步用了2T(n/2)时间。若在每次执行第4步时进行排序，则在最坏情况下第4步要用O(nlogn)时间。这不符合我们的要求。因此，在这里我们要作一个技术上的处理。我们采用设计算法时常用的预排序技术，即在使用分治法之前，预先将S中n个点依其y坐标值排好序，设排好序的点列为P<em>。在执行分治法的第4步时，只要对P</em>作一次线性扫描，即可抽取出我们所需要的排好序的点列P1<em>和P2</em>。然后，在第5步中再对P1*作一次线性扫描，即可求得δl。因此，第4步和第5步的两遍扫描合在一起只要用O(n)时间。这样一来，经过预排序处理后的算法CPAIR2所需的计算时间T(n)满足递归方程：</p>
<p>​    显而易见T(n)=O(nlogn)，预排序所需的计算时间为O(n1ogn)。因此，整个算法所需的计算时间为O(nlogn)。在渐近的意义下，此算法已是最优的了。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>计算几何</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>重装系统后，如何快速搭建之前基于github的博客</title>
    <url>/2018/09/17/2018-09-17/</url>
    <content><![CDATA[<h3 id="声明：此文是针对于windows环境"><a href="#声明：此文是针对于windows环境" class="headerlink" title="声明：此文是针对于windows环境"></a>声明：此文是针对于windows环境</h3><p>前提：我需要说几个条件;</p>
<p>1.当初搭建博客时的ssh没有删除，如果删除那就再重新配置一个，配置方法参照我上一篇博客；</p>
<p>2.当初搭建博客的仓库没有删除，如果删除，那就再重新搭一个吧，剩下的教程几乎没有关系了</p>
<p>3.如果，当时搭建博客时，如果按照我的教程，或者说按照网上大多数教程，有建了一个文件夹（例如：git pages或者hexo），这个文件夹在重装系统后还有保留下来，那最好不过。</p>
<h4 id="先说第一种情况：如果那个文件夹在的情况下："><a href="#先说第一种情况：如果那个文件夹在的情况下：" class="headerlink" title="先说第一种情况：如果那个文件夹在的情况下："></a>先说第一种情况：如果那个文件夹在的情况下：</h4><p>不知道你们有没有按照其他的教程去配置静态页面，我按照那个方法有在github上新建了一个branch</p>
<p>那个gh-pages是我新建的branch，如果建了没关系</p>
<p>我们只需用点击master就好，回到原来的地方</p>
<p>然后再你原来的那个文件夹里打开git bash here</p>
<p>输入npm install hexo –save</p>
<p>然后可以试着输入hexo g 和hexo d</p>
<p>提示你需要重新配置邮箱和用户名，那么按照原来的邮箱和原来的用户名输入就好；</p>
<p>再次输入hexo g，如果有提示</p>
<p>就说明已经重新配置好了；</p>
<h4 id="如果没有保留当初在桌面配置的文件夹"><a href="#如果没有保留当初在桌面配置的文件夹" class="headerlink" title="如果没有保留当初在桌面配置的文件夹"></a>如果没有保留当初在桌面配置的文件夹</h4><p>首先先看看自己电脑上有没有ssh</p>
<p>在自己的一个盘里建一个文件夹，里面分别有三个文件夹（git，node，git pages）</p>
<p>分别在git和node里配置好git和node</p>
<p>然后再git pages里打开git bash here检查有没有ssh</p>
<p>cd ~/. ssh</p>
<p>如果有 No such file or directory</p>
<p>说明是第一次使用，那么按照上一篇博客配置，</p>
<p>如果提示有，那么你可以先试试这个ssh能用不，先别急着删；</p>
<p>按照刚刚的步骤再输入 npm install hexo –save</p>
<p>然后按照刚刚的步骤再来一次；</p>
<p>如果最后hexo d后，文章没有推上去，那么就说明没有成功，需要重新配置ssh</p>
<p>先删除原来的ssh<br>ssh-add -D<br>rm -r ~/.ssh</p>
<p>最好查看一下上一篇博客里，Deployment的config.yml文件里面的deploy值有没有改好（参照上一篇）</p>
<p>配置好了之后再按照刚刚的步骤再来一次（记得配置邮箱和用户名）</p>
<p>如果git bash在这儿没有起作用的话，</p>
<p>那么win+r打开cmd，安装一个类似刚刚操作的扩展</p>
<p>输入 npm install hexo-deployer-git –save</p>
<p>然后再输入</p>
<p>hexo g<br>hexo d</p>
<p>然后再进入自己的博客页面查看。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>数论小问题</title>
    <url>/2018/09/16/2018-09-16/</url>
    <content><![CDATA[<p>输入x和y，有一个游戏，两人玩，第一轮赢的人得1分，第二轮2分…以此类推，n轮中至少需要几轮才能使得甲获得x分乙获得y分？</p>
<p>答案：n = min( n*(n+1)/2&gt;=x+y )</p>
<p>当时看到此题时脑海中浮现的并不是分数什么的，而是一个阶梯状的管子，往里面灌水，x代表一定容量的水，y代表一定容量的水，然后管子每升高1个高度就会多1个容量，最终刚好为n<em>(n+1)/2或n</em>(n+1)/2+1，n<em>(n+1)/2即x+y=n</em>(n+1)/2，否则为n*(n+1)/2+1。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>质因数分解原创算法</title>
    <url>/2018/09/13/2018-09-13/</url>
    <content><![CDATA[<p>由于这几天电脑坏掉了，这个算法是之前总结出来的，当时没来的及总结。具体就不介绍了。作用是范围内某数快速分解质因数相乘。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Prime()&#123;</span><br><span class="line">	memset(tag,0,sizeof(tag));</span><br><span class="line">	int cnt=0;</span><br><span class="line">	for(int i = 2; i&lt;N; i++)&#123;</span><br><span class="line">		if(tag[i])</span><br><span class="line">			prime[cnt++]=i;</span><br><span class="line">		for(int j=0;j&lt;cnt &amp;&amp; prime[j]*i&lt;N; j++)&#123;</span><br><span class="line">			tag[i*prime[j]] = i;</span><br><span class="line">			if(i % prime[j]==0)</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打表时表中储存为该数最小质数，这样给一个数只需除以对应表中数，直到除到最后为1为止</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]路径规划总结之A*搜索</title>
    <url>/2018/09/10/2018-09-10/</url>
    <content><![CDATA[<h2 id="路径规划"><a href="#路径规划" class="headerlink" title="路径规划"></a>路径规划</h2><p>路径规划是指的是机器人的最优路径规划问题，即依据某个或某些优化准则（如工作代价最小、行走路径最短、行走时间最短等），在工作空间中找到一个从起始状态到目标状态能避开障碍物的最优路径。机器人的路径规划应用场景极丰富，最常见如游戏中NPC及控制角色的位置移动，百度地图等导航问题，小到家庭扫地机器人、无人机大到各公司正争相开拓的无人驾驶汽车等。</p>
<p>目前路径规划算法分为：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-09-10-%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92.png" alt></p>
<h2 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h2><p>首先，我们来看看<code>A*</code>算法的定义：<code>A*</code>（A-Star)算法是一种静态路网中求解最短路径最有效的<strong>直接</strong>搜索方法，也是解决许多搜索问题的有效算法。 采用广度优先搜索策略，在搜索过程中使用启发函数，即有大致方向的向前进虽然目标有时候不是很明确。 </p>
<p>在计算机科学中，A*算法作为Dijkstra算法的扩展，因其高效性而被广泛应用于寻路及图的遍历，如星际争霸等游戏中就大量使用。在理解算法前，我们需要知道几个概念：</p>
<ul>
<li>搜索区域（The Search Area）：图中的搜索区域被划分为了简单的二维数组，数组每个元素对应一个小方格，当然我们也可以将区域等分成是五角星，矩形等，通常将一个单位的中心点称之为搜索区域节点（Node）。　　</li>
<li>开放列表(Open List)：我们将路径规划过程中待检测的节点存放于Open List中，而已检测过的格子则存放于Close List中。</li>
<li>父节点（parent）：在路径规划中用于回溯的节点，开发时可考虑为双向链表结构中的父结点指针。</li>
<li>路径排序（Path Sorting）：具体往哪个节点移动由以下公式确定：F(n) = G + H 。G代表的是从初始位置A沿着已生成的路径到指定待检测格子的移动开销。H指定待测格子到目标节点B的估计移动开销。</li>
<li>启发函数（Heuristics Function）：H为启发函数，也被认为是一种试探，由于在找到唯一路径前，我们不确定在前面会出现什么障碍物，因此用了一种计算H的算法，具体根据实际场景决定。在我们简化的模型中，H采用的是传统的曼哈顿距离（Manhattan Distance），也就是横纵向走的距离之和。</li>
</ul>
<p>可能看定义不是很好理解，那么我们根据例子具体看看什么是A*算法吧。</p>
<p>详细讲解参考：</p>
<p><a href="https://baike.baidu.com/item/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/938987?fr=aladdin" target="_blank" rel="noopener">启发式算法</a></p>
<p><a href="https://www.cnblogs.com/zhoug2020/p/3468167.html" target="_blank" rel="noopener">A*算法</a></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>A*算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM-ICPC 2018 徐州赛区网络预赛</title>
    <url>/2018/09/09/2018-09-09/</url>
    <content><![CDATA[<h2 id="Characters-with-Hash"><a href="#Characters-with-Hash" class="headerlink" title="Characters with Hash"></a>Characters with Hash</h2><p><a href="https://wenda.jisuanke.com/nanti/31461" target="_blank" rel="noopener">问答</a></p>
<ul>
<li>26.45%</li>
<li>1000ms</li>
<li>262144K</li>
</ul>
<p>Mur loves hash algorithm, and he sometimes encrypt another one’s name, and call him with that encrypted value. For instance, he calls Kimura KMR, and calls Suzuki YJSNPI. One day he read a book about SHA-256256 , which can transit a string into just 256256 bits. Mur thought that is really cool, and he came up with a new algorithm to do the similar work. The algorithm works this way: first we choose a single letter L as the seed, and for the input(you can regard the input as a string ss, s[i]s[i] represents the iith character in the string) we calculates the value(|(int) L - s[i]|∣(int)L−s[i]∣), and write down the number(keeping leading zero. The length of each answer equals to 22because the string only contains letters and numbers). Numbers writes from left to right, finally transfer all digits into a single integer(without leading zero(ss)). For instance, if we choose ‘z’ as the seed, the string “oMl” becomes “1111 4545 1414”.</p>
<p>It’s easy to find out that the algorithm cannot transfer any input string into the same length. Though in despair, Mur still wants to know the length of the answer the algorithm produces. Due to the silliness of Mur, he can even not figure out this, so you are assigned with the work to calculate the answer.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>First line a integer TT , the number of test cases (T \le 10)(T≤10).</p>
<p>For each test case:</p>
<p>First line contains a integer NN and a character zz, (N \le 1000000)(N≤1000000).</p>
<p>Second line contains a string with length NN . Problem makes sure that all characters referred in the problem are only letters.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>A single number which gives the answer.</p>
<h4 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 z</span><br><span class="line">oMl</span><br><span class="line">6 Y</span><br><span class="line">YJSNPI</span><br></pre></td></tr></table></figure>
<h4 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h4 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h4><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E5%BE%90%E5%B7%9E%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 徐州赛区网络预赛</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char str[1000007],ch[2];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d%s%s&quot;,&amp;n,ch,str);</span><br><span class="line">        int ans = 2*n;</span><br><span class="line">        for(int i = 0; i&lt;n; i++)&#123;</span><br><span class="line">            if(str[i]==ch[0])</span><br><span class="line">                ans-=2;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(abs(str[i]-ch[0])&lt;10)</span><br><span class="line">                    ans-=1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ans==0)</span><br><span class="line">            ans++;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-ACM-ICPC沈阳网络预赛K题-Supreme Number</title>
    <url>/2018/09/08/2018-09-08-1/</url>
    <content><![CDATA[<h3 id="Supreme-Number"><a href="#Supreme-Number" class="headerlink" title="Supreme Number"></a>Supreme Number</h3><p><a href="https://wenda.jisuanke.com/nanti/31452" target="_blank" rel="noopener">问答</a></p>
<ul>
<li>26.7%</li>
<li>1000ms</li>
<li>131072K</li>
</ul>
<p>A prime number (or a prime) is a natural number greater than 11 that cannot be formed by multiplying two smaller natural numbers.</p>
<p>Now lets define a number NN as the <strong>supreme number</strong> if and only if each number made up of an non-empty <strong>subsequence</strong> of all the numeric digits of NN must be either a prime number or 11.</p>
<p>For example, 1717 is a supreme number because 11, 77, 1717 are all prime numbers or 11, and 1919 is not, because 99 is not a prime number.</p>
<p>Now you are given an integer N\ (2 \leq N \leq 10^{100})N (2≤N≤10100), could you find the maximal <em>supreme number</em> that does not exceed NN?</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>In the first line, there is an integer T\ (T \leq 100000)T (T≤100000) indicating the numbers of test cases.</p>
<p>In the following TT lines, there is an integer N\ (2 \leq N \leq 10^{100})N (2≤N≤10100).</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case print <code>&quot;Case #x: y&quot;</code>, in which xx is the order number of the test case and yy is the answer.</p>
<h3 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">6</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<h3 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case #1: 5</span><br><span class="line">Case #2: 73</span><br></pre></td></tr></table></figure>
<h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E6%B2%88%E9%98%B3%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 沈阳赛区网络预赛</a></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>非空子序列必须为素数，那么每一位就只能由1,2,3,5,7组成，且除了1以外其他只能出现一次，那么最后算上1就只剩下20个数了，1,2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317，预处理以下就好了。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int pri[19] = &#123;2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317&#125;;</span><br><span class="line">int read()</span><br><span class="line">&#123;</span><br><span class="line">    char ch=&apos; &apos;;</span><br><span class="line">    int ans=0;</span><br><span class="line">    while(ch&lt;&apos;0&apos; || ch&gt;&apos;9&apos;)</span><br><span class="line">        ch=getchar();</span><br><span class="line">    while(ch&lt;=&apos;9&apos; &amp;&amp; ch&gt;=&apos;0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(ans&lt;100000)</span><br><span class="line">        ans=ans*10+ch-&apos;0&apos;;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    for(int aaa=1;aaa&lt;=t;aaa++)&#123;</span><br><span class="line">        int ans = read();</span><br><span class="line">        int i;</span><br><span class="line"></span><br><span class="line">        for(i = 0;i&lt;19;i++)&#123;</span><br><span class="line">            if(pri[i]&gt;ans)&#123;</span><br><span class="line">                cout&lt;&lt;&quot;Case #&quot;&lt;&lt;aaa&lt;&lt;&quot;: &quot;&lt;&lt;pri[i-1]&lt;&lt;endl;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i==19)</span><br><span class="line">            cout&lt;&lt;&quot;Case #&quot;&lt;&lt;aaa&lt;&lt;&quot;: &quot;&lt;&lt;pri[18]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打表代码"><a href="#打表代码" class="headerlink" title="打表代码"></a>打表代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 10000000</span><br><span class="line">int h=0;</span><br><span class="line">bool p[N];</span><br><span class="line">int prime[N];</span><br><span class="line">bool dfs(int x)&#123;</span><br><span class="line">    if(p[x]==false)</span><br><span class="line">        return false;</span><br><span class="line">    int c = 1;</span><br><span class="line">    while(c&lt;x)&#123;</span><br><span class="line">        c*=10;</span><br><span class="line">        if(p[x%c]==false)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        if(c&gt;x)</span><br><span class="line">            break;</span><br><span class="line">        int tmp = x;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            if(p[tmp]==false)</span><br><span class="line">                return false;</span><br><span class="line">            if(p[tmp%c]==false)</span><br><span class="line">                return false;</span><br><span class="line">            tmp/=c;</span><br><span class="line">            if(!tmp)</span><br><span class="line">                break;</span><br><span class="line">            if(dfs(tmp)==false)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void db()</span><br><span class="line">&#123;</span><br><span class="line">	memset(p,true,sizeof(p));</span><br><span class="line">	p[0] = false;</span><br><span class="line">	for(int i=2;i&lt;N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	    if(p[i]==false)</span><br><span class="line">            continue;</span><br><span class="line">		for(int j=2;i*j&lt;N;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			p[i*j]=false;</span><br><span class="line">		&#125;</span><br><span class="line">		if(!dfs(i))</span><br><span class="line">            p[i] = false;</span><br><span class="line">        if(p[i]==true)</span><br><span class="line">		&#123;</span><br><span class="line">			prime[h++]=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	db();</span><br><span class="line">	int n;  //打印前n个质数</span><br><span class="line">	for(int i=0;i&lt;=h;i++)</span><br><span class="line">		cout&lt;&lt;prime[i]&lt;&lt;&quot;,&quot;;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">//2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-ACM-ICPC沈阳网络预赛D题-A*模板题</title>
    <url>/2018/09/08/2018-09-08/</url>
    <content><![CDATA[<h2 id="Made-In-Heaven"><a href="#Made-In-Heaven" class="headerlink" title="Made In Heaven"></a>Made In Heaven</h2><p><a href="https://wenda.jisuanke.com/nanti/31445" target="_blank" rel="noopener">问答</a></p>
<ul>
<li>14.67%</li>
<li>1000ms</li>
<li>131072K</li>
</ul>
<p>One day in the jail, F·F invites Jolyne Kujo (JOJO in brief) to play tennis with her. However, Pucci the father somehow knows it and wants to stop her. There are NN spots in the jail and MM roads connecting some of the spots. JOJO finds that Pucci knows the route of the former (K-1)(K−1)-th shortest path. If Pucci spots JOJO in one of these K-1K−1 routes, Pucci will use his stand Whitesnake and put the disk into JOJO’s body, which means JOJO won’t be able to make it to the destination. So, JOJO needs to take the KK-th quickest path to get to the destination. What’s more, JOJO only has TT units of time, so she needs to hurry.</p>
<p>JOJO starts from spot SS, and the destination is numbered EE. It is possible that JOJO’s path contains any spot more than one time. Please tell JOJO whether she can make arrive at the destination using no more than TT units of time.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>There are at most 5050 test cases.</p>
<p>The first line contains two integers NN and MM (1 \leq N \leq 1000, 0 \leq M \leq 10000)(1≤N≤1000,0≤M≤10000). Stations are numbered from 11 to NN.</p>
<p>The second line contains four numbers S, E, KS,E,K and TT ( 1 \leq S,E \leq N1≤S,E≤N, S \neq ES≠E, 1 \leq K \leq 100001≤K≤10000, 1 \leq T \leq 1000000001≤T≤100000000 ).</p>
<p>Then MM lines follows, each line containing three numbers U, VU,V and WW (1 \leq U,V \leq N, 1 \leq W \leq 1000)(1≤U,V≤N,1≤W≤1000) . It shows that there is a directed road from UU-th spot to VV-th spot with time WW.</p>
<p>It is guaranteed that for any two spots there will be only one directed road from spot AA to spot BB (1 \leq A,B \leq N, A \neq B)(1≤A,B≤N,A≠B), but it is possible that both directed road &lt;A,B&gt;&lt;A,B&gt;and directed road &lt;B,A&gt;&lt;B,A&gt; exist.</p>
<p>All the test cases are generated randomly.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>One line containing a sentence. If it is possible for JOJO to arrive at the destination in time, output <code>&quot;yareyaredawa&quot;</code> (without quote), else output <code>&quot;Whitesnake!&quot;</code> (without quote).</p>
<h3 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 2</span><br><span class="line">1 2 2 14</span><br><span class="line">1 2 5</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure>
<h3 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yareyaredawa</span><br></pre></td></tr></table></figure>
<h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E6%B2%88%E9%98%B3%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 沈阳赛区网络预赛</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>N个点，M条边，起始点为s，结束为n，求s到n的第k短的路的长度，判断长度是否大于T，如果大于，输出“<code>Whitesnake!</code>”，否则输出“<code>yareyaredawa</code>”</p>
<p>类似<a href="http://poj.org/problem?id=2449" target="_blank" rel="noopener">POJ2449</a></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>A*+SPFA</p>
<h4 id="A-算法："><a href="#A-算法：" class="headerlink" title="A*算法："></a>A*算法：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A*，启发式搜索，是一种较为有效的搜索方法。</span><br><span class="line">我们在搜索的时候，很多时候在当前状态，已经不是最优解了，但是我们却继续求解；这个就是暴力搜索浪费时间的原因。</span><br><span class="line">我们在有些时候，往往可以根据一些信息推断出继续搜索是一种劣解。</span><br><span class="line">所以如果能够判断出来的话，就可以不继续了，以达到节省运行时间的目的。</span><br></pre></td></tr></table></figure>
<h4 id="估价函数："><a href="#估价函数：" class="headerlink" title="估价函数："></a>估价函数：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为了提高搜索效率，我们可以对未来可能产生的代价进行预估。我们设计一个估价函数，以任意状态输入，计算出从该状态到目标状态所需代价的估计值。</span><br><span class="line">在搜索时，我们总沿着当前代价+未来估价最小的状态进行搜索。</span><br><span class="line"></span><br><span class="line">估价函数需要满足：</span><br><span class="line">　　设当前状态state到目标函数所需代价的估计值为f(state)</span><br><span class="line">　　设在未来的搜索中，实际求出的从当前状态state到目标状态的最小代价为g(state)</span><br><span class="line">　　对于任意的state，应该有f(state)&lt;=g(state)</span><br><span class="line">也就是说，估价函数的估值不能大于未来实际代价，估价比实际代价更优。</span><br></pre></td></tr></table></figure>
<h4 id="第K短路："><a href="#第K短路：" class="headerlink" title="第K短路："></a>第K短路：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据估价函数的设计准则，在第K短路中从x到T的估计距离f(x)应该不大于第K短路中从x到T的实际距离g(x)，于是，我们可以把估价函数f(x)定为从x到T的最短路径长度，这样不但能保证f(x)&lt;=g(x)，还能顺应g(x)的实际变化趋势。</span><br><span class="line">实现过程：</span><br><span class="line">1.预处理f(x)，在反向图上以T为起点求到每个点的最短路</span><br><span class="line">2.定义堆，维护&#123;p,g,h&#125;，p是某一个点，g是估价，h是实际，那么g+h更小的点p会优先访问</span><br><span class="line">3.取出堆顶元素u扩展，如果节点v被取出的次数尚未达到k，就把新的&#123;v,g,h+length(u,v)&#125;插入堆中</span><br><span class="line">4.重复第2-3步，直到第K次取出终点T，此时走过的路径长度就是第K短路</span><br><span class="line"></span><br><span class="line">因为估价函数的作用，图中很多节点访问次数远小于K</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">const ll maxn=100010;</span><br><span class="line">ll n,m,dis[maxn];</span><br><span class="line">ll tot,head1[maxn],head2[maxn];</span><br><span class="line">bool flag[maxn];</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    ll to;</span><br><span class="line">    ll w;</span><br><span class="line">    ll next;</span><br><span class="line">&#125;e[maxn*2],e2[maxn*2];</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    ll f;</span><br><span class="line">    ll g;</span><br><span class="line">    ll from;</span><br><span class="line">    bool operator &lt; (node a)const</span><br><span class="line">    &#123;</span><br><span class="line">        if(a.f==f)</span><br><span class="line">        return g&gt;a.g;</span><br><span class="line">        return f&gt;a.f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void add_edge(ll u,ll v,ll w)</span><br><span class="line">&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    e[tot].to=v;</span><br><span class="line">    e[tot].w=w;</span><br><span class="line">    e[tot].next=head1[u];</span><br><span class="line">    head1[u]=tot;</span><br><span class="line">    e2[tot].to=u;</span><br><span class="line">    e2[tot].w=w;</span><br><span class="line">    e2[tot].next=head2[v];</span><br><span class="line">    head2[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void prepare()</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;tot=0;</span><br><span class="line">    memset(head1,0,sizeof(head1));</span><br><span class="line">    memset(head2,0,sizeof(head2));</span><br><span class="line">&#125;</span><br><span class="line">void spfa(ll t)</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;</span><br><span class="line">    dis[t]=0;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.push(t);</span><br><span class="line">    flag[t]=1;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ll v=q.front();</span><br><span class="line">        q.pop();flag[v]=0;</span><br><span class="line">        for(ll i=head2[v];i;i=e2[i].next)</span><br><span class="line">        if(dis[e2[i].to]&gt;dis[v]+e2[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[e2[i].to]=dis[v]+e2[i].w;</span><br><span class="line">            if(!flag[e2[i].to])</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(e2[i].to);</span><br><span class="line">                flag[e2[i].to]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a_star(ll s,ll t,ll k)</span><br><span class="line">&#123;</span><br><span class="line">    if(s==t) k++;</span><br><span class="line">    if(dis[s]==maxn) return -1;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    ll cnt=0;</span><br><span class="line">    node tmp,to;</span><br><span class="line">    tmp.from=s;</span><br><span class="line">    tmp.g=0;</span><br><span class="line">    tmp.f=tmp.g+dis[tmp.from];</span><br><span class="line">    q.push(tmp);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(tmp.from==t) cnt++;</span><br><span class="line">        if(cnt==k) return tmp.g;</span><br><span class="line">        for(ll i=head1[tmp.from];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            to.from=e[i].to;</span><br><span class="line">            to.g=tmp.g+e[i].w;</span><br><span class="line">            to.f=to.g+dis[to.from];</span><br><span class="line">            q.push(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll x,y,z,s,t,k;</span><br><span class="line">    ll T;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;t&gt;&gt;k&gt;&gt;T;</span><br><span class="line">        prepare();</span><br><span class="line">        for(ll i=1;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">            add_edge(x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">        spfa(t);</span><br><span class="line">        ll ans=a_star(s,t,k);</span><br><span class="line">        if(ans&lt;=T&amp;&amp;ans!=-1)</span><br><span class="line">            cout&lt;&lt;&quot;yareyaredawa&quot;&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;&quot;Whitesnake!&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="k短路模板"><a href="#k短路模板" class="headerlink" title="k短路模板"></a>k短路模板</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ll maxn=100010;</span><br><span class="line">ll n,m,dis[maxn];</span><br><span class="line">ll tot,head1[maxn],head2[maxn];</span><br><span class="line">bool flag[maxn];</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    ll to;</span><br><span class="line">    ll w;</span><br><span class="line">    ll next;</span><br><span class="line">&#125;e[maxn*2],e2[maxn*2];</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    ll f;</span><br><span class="line">    ll g;</span><br><span class="line">    ll from;</span><br><span class="line">    bool operator &lt; (node a)const</span><br><span class="line">    &#123;</span><br><span class="line">        if(a.f==f)</span><br><span class="line">        return g&gt;a.g;</span><br><span class="line">        return f&gt;a.f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void add_edge(ll u,ll v,ll w)</span><br><span class="line">&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    e[tot].to=v;</span><br><span class="line">    e[tot].w=w;</span><br><span class="line">    e[tot].next=head1[u];</span><br><span class="line">    head1[u]=tot;</span><br><span class="line">    e2[tot].to=u;</span><br><span class="line">    e2[tot].w=w;</span><br><span class="line">    e2[tot].next=head2[v];</span><br><span class="line">    head2[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void prepare()</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;tot=0;</span><br><span class="line">    memset(head1,0,sizeof(head1));</span><br><span class="line">    memset(head2,0,sizeof(head2));</span><br><span class="line">&#125;</span><br><span class="line">void spfa(ll t)</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;</span><br><span class="line">    dis[t]=0;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.push(t);</span><br><span class="line">    flag[t]=1;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ll v=q.front();</span><br><span class="line">        q.pop();flag[v]=0;</span><br><span class="line">        for(ll i=head2[v];i;i=e2[i].next)</span><br><span class="line">        if(dis[e2[i].to]&gt;dis[v]+e2[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[e2[i].to]=dis[v]+e2[i].w;</span><br><span class="line">            if(!flag[e2[i].to])</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(e2[i].to);</span><br><span class="line">                flag[e2[i].to]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a_star(ll s,ll t,ll k)</span><br><span class="line">&#123;</span><br><span class="line">    if(s==t) k++;</span><br><span class="line">    if(dis[s]==maxn) return -1;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    ll cnt=0;</span><br><span class="line">    node tmp,to;</span><br><span class="line">    tmp.from=s;</span><br><span class="line">    tmp.g=0;</span><br><span class="line">    tmp.f=tmp.g+dis[tmp.from];</span><br><span class="line">    q.push(tmp);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(tmp.from==t) cnt++;</span><br><span class="line">        if(cnt==k) return tmp.g;</span><br><span class="line">        for(ll i=head1[tmp.from];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            to.from=e[i].to;</span><br><span class="line">            to.g=tmp.g+e[i].w;</span><br><span class="line">            to.f=to.g+dis[to.from];</span><br><span class="line">            q.push(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>最短路</tag>
        <tag>A*算法</tag>
      </tags>
  </entry>
  <entry>
    <title>[最短路]SPFA的SLF与LLL优化</title>
    <url>/2018/09/05/2018-09-05-2/</url>
    <content><![CDATA[<p>SPFA是按照 FIFO 的原则更新距离的, 没有考虑到距离标号的作用。实现中 SPFA 有两个非常著名的优化: SLF 和 LLL。</p>
<p>SLF：Small Label First 策略，设要加入的节点是j，队首元素为i，若dist(j) &lt; dist(i)，则将j插入队首，否则插入队尾。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">const int inf = 1 &lt;&lt; 30 , maxn = 100000 + 11 , M = 200000 + 11  ; </span><br><span class="line">using namespace std ;//1061109567</span><br><span class="line">int n , m , head[maxn]  , dis[maxn] , cnt , sum , tot ;</span><br><span class="line">bool mark[maxn] ; </span><br><span class="line">struct id</span><br><span class="line">&#123;</span><br><span class="line">    int nxt ,to , val ;</span><br><span class="line">&#125; edge[M] ;</span><br><span class="line">deque &lt; int &gt; Q ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline void Init ( )</span><br><span class="line">&#123;</span><br><span class="line">    freopen( &quot;NSOOJ#10719.in&quot; , &quot;r&quot; , stdin  ) ;</span><br><span class="line">    freopen( &quot;NSOOJ#10719.out&quot; , &quot;w&quot; , stdout ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int read( )</span><br><span class="line">&#123;</span><br><span class="line">    char ch = getchar( ) ; int k = 1 , ret = 0 ;</span><br><span class="line">    while( ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos; ) &#123; if( ch == &apos;-&apos; ) k = -1 ; ch = getchar( ) ; &#125;</span><br><span class="line">    while( ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos; ) ret = ret * 10 + ch - &apos;0&apos; , ch = getchar( ) ;</span><br><span class="line">    return k * ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add( int u , int v , int va )</span><br><span class="line">&#123;</span><br><span class="line">    edge[++cnt].nxt = head[u] , edge[cnt].to = v ;</span><br><span class="line">    edge[cnt].val = va , head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void input(  )</span><br><span class="line">&#123;</span><br><span class="line">    n = read()  , m = read( ) ;</span><br><span class="line">    int u ,v , c ;</span><br><span class="line">    memset( head , -1 , sizeof(head)) ;</span><br><span class="line">    for( int x = 1 ; x &lt;= m ; ++x )</span><br><span class="line">    &#123;</span><br><span class="line">        u = read( ) , v = read( ) , c = read( ) ;</span><br><span class="line">        add( u ,v , c )  ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void spfa( )</span><br><span class="line">&#123;</span><br><span class="line">    memset( dis , 127/2 , sizeof(dis) ) ;</span><br><span class="line">    dis[1] = 0 , mark[1] = true ;</span><br><span class="line">    Q.push_back( 1 ) ;</span><br><span class="line">    while( !Q.empty( ) )</span><br><span class="line">    &#123;</span><br><span class="line">        int u = Q.front( ) ; Q.pop_front( ) ; mark[u] = false ;</span><br><span class="line">    </span><br><span class="line">        for( int i = head[u] ; ~i ; i = edge[i].nxt )</span><br><span class="line">        &#123;</span><br><span class="line">            int v = edge[i].to ; </span><br><span class="line">            if( dis[v] &gt; dis[u] + edge[i].val )</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + edge[i].val ;</span><br><span class="line">                if( !mark[v] )</span><br><span class="line">                &#123;</span><br><span class="line">                    mark[v] = true ; </span><br><span class="line">                    if( Q.empty( ) || dis[v] &gt; dis[Q.front( )]  ) Q.push_back( v ) ;</span><br><span class="line">                    else Q.push_front( v ) ;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if( dis[n] == 1061109567 ) printf( &quot;%d\n&quot; , -1 ) ;</span><br><span class="line">    else printf( &quot;%d\n&quot; , dis[n] ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">//    Init( ) ; </span><br><span class="line">    input( ) ;</span><br><span class="line">    spfa( ) ;</span><br><span class="line">//    fclose( stdin ) ;</span><br><span class="line">//       fclose( stdout ) ;</span><br><span class="line">    return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LLL：Large Label Last 策略，设队首元素为i，每次弹出时进行判断，队列中所有dist值的平均值为x，若dist(i)&gt;x则将i插入到队尾，每次出队时，若 d[i]&gt;平均值，把 i 移到队列末尾，如此反复，直到找到某一i使得dist(i)&lt;=x，则将i出队进行松弛操作。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">const int inf = 1 &lt;&lt; 30 , maxn = 100000 + 11 , M = 200000 + 11  ; </span><br><span class="line">using namespace std ;//1061109567</span><br><span class="line">int n , m , head[maxn]  , dis[maxn] , cnt , sum , tot ;</span><br><span class="line">bool mark[maxn] ; </span><br><span class="line">struct id</span><br><span class="line">&#123;</span><br><span class="line">    int nxt ,to , val ;</span><br><span class="line">&#125; edge[M] ;</span><br><span class="line">deque &lt; int &gt; Q ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline void Init ( )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    freopen( &quot;NSOOJ#10719.in&quot; , &quot;r&quot; , stdin  ) ;</span><br><span class="line">    freopen( &quot;NSOOJ#10719.out&quot; , &quot;w&quot; , stdout ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int read( )</span><br><span class="line">&#123;</span><br><span class="line">    char ch = getchar( ) ; int k = 1 , ret = 0 ;</span><br><span class="line">    while( ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos; ) &#123; if( ch == &apos;-&apos; ) k = -1 ; ch = getchar( ) ; &#125;</span><br><span class="line">    while( ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos; ) ret = ret * 10 + ch - &apos;0&apos; , ch = getchar( ) ;</span><br><span class="line">    return k * ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add( int u , int v , int va )</span><br><span class="line">&#123;</span><br><span class="line">    edge[++cnt].nxt = head[u] , edge[cnt].to = v ;</span><br><span class="line">    edge[cnt].val = va , head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void input(  )</span><br><span class="line">&#123;</span><br><span class="line">    n = read()  , m = read( ) ;</span><br><span class="line">    int u ,v , c ;</span><br><span class="line">    memset( head , -1 , sizeof(head)) ;</span><br><span class="line">    for( int x = 1 ; x &lt;= m ; ++x )</span><br><span class="line">    &#123;</span><br><span class="line">        u = read( ) , v = read( ) , c = read( ) ;</span><br><span class="line">        add( u ,v , c )  ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void spfa( )</span><br><span class="line">&#123;</span><br><span class="line">    memset( dis , 127/2 , sizeof(dis) ) ;</span><br><span class="line">    dis[1] = 0 , mark[1] = true ;</span><br><span class="line">    Q.push_back( 1 ) ; tot = 0 ;</span><br><span class="line">    while( !Q.empty( ) )</span><br><span class="line">    &#123;</span><br><span class="line">        int u = Q.front( ) ;</span><br><span class="line">        Q.pop_front( ) ;</span><br><span class="line">        if( dis[u] * tot &gt; sum )</span><br><span class="line">        &#123;</span><br><span class="line">        	Q.push_back( u ) ;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        mark[u] = false ;</span><br><span class="line">        tot-- ; sum -= dis[u] ;</span><br><span class="line">        for( int i = head[u] ; ~i ; i = edge[i].nxt )</span><br><span class="line">        &#123;</span><br><span class="line">            int v = edge[i].to ; </span><br><span class="line">            if( dis[v] &gt; dis[u] + edge[i].val )</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + edge[i].val ;</span><br><span class="line">                if( !mark[v] )</span><br><span class="line">                &#123;</span><br><span class="line">                    mark[v] = true ; </span><br><span class="line">                    if( Q.empty( ) || dis[v] * tot &gt; sum ) Q.push_back( v ) ;</span><br><span class="line">                    else Q.push_front( v ) ;</span><br><span class="line">                    tot++ ; sum += dis[v] ;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if( dis[n] == 1061109567 ) printf( &quot;%d\n&quot; , -1 ) ;</span><br><span class="line">    else printf( &quot;%d\n&quot; , dis[n] ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">//    Init( ) ; </span><br><span class="line">    input( ) ;</span><br><span class="line">    spfa( ) ;</span><br><span class="line">//    fclose( stdin ) ;</span><br><span class="line">//       fclose( stdout ) ;</span><br><span class="line">    return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>SPFA算法</tag>
      </tags>
  </entry>
  <entry>
    <title>[C++] pair和make_pair</title>
    <url>/2018/09/05/2018-09-05-1/</url>
    <content><![CDATA[<p>偶然间从一篇博客上看到了make_pair，所以顺便记录下来。博客地址：<a href="https://blog.csdn.net/yockie/article/details/6980692" target="_blank" rel="noopener">pair与make_pair</a></p>
<p>std::pair主要的作用是将两个数据组合成一个数据，两个数据可以是同一类型或者不同类型。<br>例如std::pair&lt;int,float&gt; 或者 std::pair&lt;double,double&gt;等。<br>pair实质上是一个结构体，其主要的两个成员变量是first和second，这两个变量可以直接使用。<br>初始化一个pair可以使用构造函数，也可以使用std::make_pair函数，make_pair函数的定义如下：<br>template pair make_pair(T1 a, T2 b) { return pair(a, b); }<br>    一般make_pair都使用在需要pair做参数的位置，可以直接调用make_pair生成pair对象。<br>另一个使用的方面就是pair可以接受隐式的类型转换，这样可以获得更高的灵活度。但是这样会出现如下问题：<br>    例如有如下两个定义：<br>        std::pair&lt;int, float&gt;(1, 1.1);<br>        std::make_pair(1, 1.1);<br>其中第一个的second变量是float类型，而make_pair函数会将second变量都转换成double类型。<br>这个问题在编程是需要引起注意。<br>下面是一段pair与make_pair的例子程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">	pair &lt;string,double&gt; product1 (&quot;tomatoes&quot;,3.25);</span><br><span class="line">	pair &lt;string,double&gt; product2;</span><br><span class="line">	pair &lt;string,double&gt; product3;</span><br><span class="line">	product2.first =&quot;lightbulbs&quot;; // type of first is string</span><br><span class="line">	product2.second =0.99; // type of second is double</span><br><span class="line">	product3 = make_pair (&quot;shoes&quot;,20.0);</span><br><span class="line">	cout &lt;&lt;&quot;The price of &quot;&lt;&lt; product1.first &lt;&lt;&quot; is $&quot;&lt;&lt; product1.second &lt;&lt;&quot;\n&quot;;</span><br><span class="line">	cout &lt;&lt;&quot;The price of &quot;&lt;&lt; product2.first &lt;&lt;&quot; is $&quot;&lt;&lt; product2.second &lt;&lt;&quot;\n&quot;;</span><br><span class="line">	cout &lt;&lt;&quot;The price of &quot;&lt;&lt; product3.first &lt;&lt;&quot; is $&quot;&lt;&lt; product3.second &lt;&lt;&quot;\n&quot;;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>[单源最短路]两大优化算法争锋之SPFA与堆优化版Dijkstra</title>
    <url>/2018/09/05/2018-09-05/</url>
    <content><![CDATA[<p>单源最短路(SSSP)的算法有Dijkstra，Bellman-Ford， 两大算法优化后即为Dijkstra+heap与SPFA。</p>
<p>这两个优化版算法写起来非常相似。接下来就从算法思路、时间复杂度、写法和适用场景上进行对比分析。 </p>
<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>时间复杂度：O(V2+E) </p>
<p>n-1次循环</p>
<p>–&gt;找到未标记的d最小的点</p>
<p>–&gt;标记，松弛它的边</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void dijkstra(int s)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    vis[s] = true;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        dis[i] = road[s][i];</span><br><span class="line">    for(int u = 1; u&lt;n; u++)&#123;</span><br><span class="line">        int minD = inf,k = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[i]&lt;minD)&#123;</span><br><span class="line">                k = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[k] = true;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[k]+road[k][i]&lt;dis[i])&#123;</span><br><span class="line">                dis[i]=dis[k]+road[k][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h2><p>时间复杂度：O(VE) </p>
<p>n-1次循环</p>
<p>–&gt;对所有边松弛</p>
<p>还能再松弛则有负环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dis[10010];</span><br><span class="line">int u[10010],v[10010],w[10010];</span><br><span class="line">int n,m;</span><br><span class="line">void Bellman_ford(int a)&#123;</span><br><span class="line">    memset(dis,inf,sizeof(dis));//赋初始值</span><br><span class="line">    dis[a]=0;</span><br><span class="line">    for(int i=1;i&lt;=n-1;i++)//更新n-1次</span><br><span class="line">        for(int j=1;j&lt;=m;j++)//更新每一条边</span><br><span class="line">            dis[v[j]]=min(dis[v[j]],dis[u[j]]+w[j]);//判断是否更新</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="两大基础算法对比"><a href="#两大基础算法对比" class="headerlink" title="两大基础算法对比"></a>两大基础算法对比</h2><ul>
<li>Dijkstra是每次确定了到一个点的最短距离，再用该点更新到其它点的距离。不能处理有负边的图。</li>
<li>Bellman-Ford是每次对所有边松弛。可以计算出有负边无负环的最短路，可以判断是否存在负环。</li>
</ul>
<h1 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h1><h2 id="Dijkstra-heap优化"><a href="#Dijkstra-heap优化" class="headerlink" title="Dijkstra+heap优化"></a>Dijkstra+heap优化</h2><p>时间复杂度：O((V+E)lgV)</p>
<p>用STL中的优先队列实现堆：</p>
<p>while(优先队列非空)</p>
<p>–&gt;队头出队，松弛它的边</p>
<p>–&gt;松弛了的&lt;新距离,点&gt;入队</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; q;</span><br><span class="line">...</span><br><span class="line">while(!q.empty())&#123;  // O(V) 加上count&lt;n可以优化一点点 </span><br><span class="line">    int w=q.top().first, u=q.top().second;</span><br><span class="line">    q.pop();   // O(lgV)</span><br><span class="line">    if(b[u])continue; b[u]=true;</span><br><span class="line">    //++count;</span><br><span class="line">    for(int i=head[u];i;i=e[i].next)&#123; // Sum -&gt; O(E)</span><br><span class="line">        int v=e[i].to;</span><br><span class="line">        if(d[u]+e[i].w&lt;d[v])&#123;</span><br><span class="line">            d[v]=d[u]+e[i].w;</span><br><span class="line">            q.push(PII(d[v],v));  // O(lgV)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>时间复杂度：O(kE) or O(VE)</p>
<p>while(队非空)</p>
<p>–&gt;队头出队，松弛它的边</p>
<p>–&gt;松弛了且不在队内的点入队</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(!q.empty())&#123;</span><br><span class="line">    int u=q.front(); q.pop();</span><br><span class="line">    b[u]=false;</span><br><span class="line">    for(int i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        int v=e[i].to;</span><br><span class="line">        if(d[u]+e[i].w&lt;d[v])&#123;</span><br><span class="line">            d[v]=d[u]+e[i].w;</span><br><span class="line">            if(!b[v])b[v]=true,q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法思路对比"><a href="#算法思路对比" class="headerlink" title="算法思路对比"></a>算法思路对比</h2><ul>
<li>Dijkstra+heap是用小根堆，每次取出d最小的点，来更新距离，那么这个点来说，最小距离就是当前的d。</li>
<li>SPFA是用双端队列，每次取出队头，来更新距离，它之后可能还会入队。它是一种动态逼近法，因为每次松弛距离都会减小，所以松弛一定会有结束的。如果一个点入队超过n次就是存在负环。</li>
</ul>
<h2 id="复杂度分析对比"><a href="#复杂度分析对比" class="headerlink" title="复杂度分析对比"></a>复杂度分析对比</h2><p>Dijkstra+heap</p>
<ul>
<li>因为是堆，取队头需要O(lgV)。</li>
<li>松弛边时，因为点的d改变了，所以点v需要以新距离重新入堆，O(lgV)，总共O(ElgV)。</li>
<li>因此总的是O((V+E)lgV)</li>
</ul>
<p>SPFA</p>
<ul>
<li>论文证明也不严格。复杂度不太好分析。</li>
<li><del>总的是O(kE)。k大概为2</del>。</li>
<li>复杂度应该是 O(VE)。</li>
</ul>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>如果是稠密图，Dijkstra+heap比SPFA快。稀疏图则SPFA更快。SPFA可以有SLF和LLL两种优化，SLF就是d比队头小就插入队头，否则插入队尾。</p>
<p>另外，Dijkstra和Prim也很相似，它们的区别主要是d的含义，前者是到s的临时最短距离，后者是到树的临时最短距离，相同点是，每次找d最小的更新其它点的距离。</p>
<h1 id="Dijkstra堆优化版代码"><a href="#Dijkstra堆优化版代码" class="headerlink" title="Dijkstra堆优化版代码"></a>Dijkstra堆优化版代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll maxx = 0x3f3f3f3f3f3f3f3f;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">int t,n,m,cnt;</span><br><span class="line">ll dis[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int head[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next;</span><br><span class="line">    int to;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;edge[2*maxn];</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int u;</span><br><span class="line">    ll dis;</span><br><span class="line">    NODE()&#123;&#125;</span><br><span class="line">	NODE(int u,ll w):u(u),dis(w)&#123;&#125;</span><br><span class="line">	bool operator &lt;(const NODE &amp;a)const</span><br><span class="line">	&#123;</span><br><span class="line">		return dis&gt;a.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;node[2*maxn];</span><br><span class="line">void add(int u, int v, ll w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void dijkstra(int s)&#123;</span><br><span class="line">    memset(dis,maxx,sizeof(dis));</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    priority_queue&lt;NODE&gt;q;</span><br><span class="line">    q.push(NODE(s,0));</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int kk = q.top().u;</span><br><span class="line">        ll minD = q.top().dis;</span><br><span class="line">        q.pop();</span><br><span class="line">        if(vis[kk])</span><br><span class="line">            continue;</span><br><span class="line">        vis[kk] = true;</span><br><span class="line">        for(int l = head[kk]; l!=-1; l=edge[l].next)&#123;</span><br><span class="line">            if(!vis[edge[l].to]&amp;&amp;minD + edge[l].w &lt; dis[edge[l].to])&#123;</span><br><span class="line">                dis[edge[l].to] = minD + edge[l].w;</span><br><span class="line">                q.push(NODE(edge[l].to,dis[edge[l].to][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        memset(head,-1,sizeof(head));</span><br><span class="line">        cnt = 0;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        for(int i = 0;i &lt; m; i++)&#123;</span><br><span class="line">            scanf(&quot;%d%d%lld&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add(u,v,w);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(1);</span><br><span class="line">        if(dis[n]!=maxx)</span><br><span class="line">        	printf(&quot;%lld\n&quot;,dis[n]);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;0\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
        <tag>Dijkstra算法</tag>
        <tag>SPFA算法</tag>
        <tag>Bellman-Ford算法</tag>
      </tags>
  </entry>
  <entry>
    <title>[分层最短路]Magical Girl Haze</title>
    <url>/2018/09/04/2018-09-04/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一张图，共有m条路，从1走到n，一共可以使k条路的路程为0，求最短路。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>去掉的k条路肯定全部在从1到n的某一条路径上，这样走这一条路径才有可能最短。我们可以对最短路分层，即分别求k为0，k为1，k为2……k为k的情况下最短路程。定义最短路时使用二维数组<code>dis[n][k]</code>,n为结点数，k为分层数。设i为每次求得的最短路结点，kk为所在层，dis为最短路，原点到原点的距离为0，则：</p>
<p>最短路状态转移方程：<code>dis[j][kk]=min(dis[i][kk]+road[i][j],dis[j][kk])</code></p>
<p>分层状态转移方程：<code>dis[j][kk+1]=min(dis[i][kk],dis[j][kk+1])</code></p>
<h2 id="Magical-Girl-Haze"><a href="#Magical-Girl-Haze" class="headerlink" title="Magical Girl Haze"></a>Magical Girl Haze</h2><p>There are NN cities in the country, and MMdirectional roads from uu to v(1\le u, v\le n)v(1≤u,v≤n). Every road has a distance c_ici. Haze is a Magical Girl that lives in City 11, she can choose no more than KK roads and make their distances become 00. Now she wants to go to City NN, please help her calculate the minimum distance.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line has one integer T(1 \le T\le 5)T(1≤T≤5), then following TT cases.</p>
<p>For each test case, the first line has three integers N, MN,M and KK.</p>
<p>Then the following MM lines each line has three integers, describe a road, U_i, V_i, C_iUi,Vi,Ci. There might be multiple edges between uu and vv.</p>
<p>It is guaranteed that N \le 100000, M \le 200000, K \le 10N≤100000,M≤200000,K≤10,<br>0 \le C_i \le 1e90≤Ci≤1e9. There is at least one path between City 11 and City NN.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, print the minimum distance.</p>
<h4 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5 6 1</span><br><span class="line">1 2 2</span><br><span class="line">1 3 4</span><br><span class="line">2 4 3</span><br><span class="line">3 4 1</span><br><span class="line">3 5 6</span><br><span class="line">4 5 2</span><br></pre></td></tr></table></figure>
<h4 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h4 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h4><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E5%8D%97%E4%BA%AC%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 南京赛区网络预赛</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll maxx = 0x3f3f3f3f3f3f3f3f;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">int t,n,m,k,cnt;</span><br><span class="line">ll dis[maxn][12];</span><br><span class="line">bool vis[maxn][12];</span><br><span class="line">int head[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next;</span><br><span class="line">    int to;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;edge[2*maxn];</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int u, j;</span><br><span class="line">    ll dis;</span><br><span class="line">    NODE()&#123;&#125;</span><br><span class="line">	NODE(int u,int j,ll w):u(u),j(j),dis(w)&#123;&#125;</span><br><span class="line">	bool operator &lt;(const NODE &amp;a)const</span><br><span class="line">	&#123;</span><br><span class="line">		return dis&gt;a.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;node[2*maxn];</span><br><span class="line">void add(int u, int v, ll w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void dijkstra(int s)&#123;</span><br><span class="line">    memset(dis,maxx,sizeof(dis));</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    priority_queue&lt;NODE&gt;q;</span><br><span class="line">    q.push(NODE(s,0,0));</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int kk = q.top().u;</span><br><span class="line">        int j = q.top().j;</span><br><span class="line">        ll minD = q.top().dis;</span><br><span class="line">        q.pop();</span><br><span class="line">        if(vis[kk][j])</span><br><span class="line">            continue;</span><br><span class="line">        vis[kk][j] = true;</span><br><span class="line">        for(int l = head[kk]; l!=-1; l=edge[l].next)&#123;</span><br><span class="line">            if(j&lt;k&amp;&amp;!vis[edge[l].to][j+1]&amp;&amp;dis[edge[l].to][j+1] &gt; minD)&#123;</span><br><span class="line">                dis[edge[l].to][j+1] = minD;</span><br><span class="line">                q.push(NODE(edge[l].to,j+1,dis[edge[l].to][j+1]));</span><br><span class="line">            &#125;</span><br><span class="line">            if(!vis[edge[l].to][j]&amp;&amp;minD + edge[l].w &lt; dis[edge[l].to][j])&#123;</span><br><span class="line">                dis[edge[l].to][j] = minD + edge[l].w;</span><br><span class="line">                q.push(NODE(edge[l].to,j,dis[edge[l].to][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        memset(head,-1,sizeof(head));</span><br><span class="line">        cnt = 0;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        for(int i = 0;i &lt; m; i++)&#123;</span><br><span class="line">            scanf(&quot;%d%d%lld&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add(u,v,w);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(1);</span><br><span class="line">        if(dis[n][k]!=maxx)</span><br><span class="line">        	printf(&quot;%lld\n&quot;,dis[n][k]);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;0\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>分层最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>[数论]辗转相除法求gcd的数学证明</title>
    <url>/2018/09/03/2018-09-03-2/</url>
    <content><![CDATA[<p>在写证明过程之前，我们先回顾一下最大公约数gcd的欧几里得求法。</p>
<p>gcd，即最大公因数。为了书写方便，人们常习惯以gcd(a,b)表示a,b的最大公因数。那最小公倍数呢？我们知道若已知a,b,gcd(a,b),那么最小公倍数就自然等于a * b / gcd(a,b)。这里就不证明了。</p>
<p>我们接着看gcd，如何高效求gcd呢？目前最快的方法算是欧几里得算法了。</p>
<p>欧几里得算法其实很简单，已知a，b，其中a&gt;b，求gcd(a,b)。</p>
<p>解：用b整除a，得到余数c，再用c整除b，得到余数d，再用d整除c，得到余数e……不断这样操作，最后直到没有余数为止。假设e再整除d，余数为0，则e为最大公因数。</p>
<p>列式子即为：</p>
<p>a = x1 * b + r1;</p>
<p>b = x2 * r1 + r2;</p>
<p>r1 = x3 * r2 + r3;</p>
<p>……</p>
<p>rn-1= xn+1 * rn + rn+1;</p>
<p>rn = xn+2 * rn+1 + 0;</p>
<p>若设a为r-1，b为r0，则通项公式即为rn-1 / rn = xn+1 <em> rn + rn+1，最后一项为rn / rn+1 = xn+2 </em> rn+1。</p>
<p>很容易理解，若某一步余数为0，则上一步的余数即为最大公约数。很容易证明该循环一定会终止，因为最坏的情况下a和b的最大公因数是1，那么任何一个数都是1的倍数，所以任何数取余1都为0，所以循环必会结束。</p>
<p>该算法历经千年，直到现在依然为求解gcd最高效的算法，gcd(a,b)最坏的情况下运算次数最多才是b位数的7位，这里就不详细介绍了。</p>
<p>那么为什么最后的结果就是最大公因数呢，接下来我们来证明一下。</p>
<p>假设g为gcd(a,b)，即g为g，b的最大公因数，则带到上式记为rn = xn+2 * g，这个式子g必然为rn的因数。</p>
<p>那再带到上一个式子，rn-1 = xn+1 * rn + g，由于g既是rn的因数，又是g的因数，则g是rn-1的因数。</p>
<p>再带到上一个式子，rn-2 = xn * rn-1 + rn，由于g是rn-1，rn的因数，所以g必然是rn-2的因数。</p>
<p>……</p>
<p>最终带到第一组式子中，即g既是a的因数，也是b的因数。</p>
<p>那如何证明它是最大公因数呢？</p>
<p>我们假设h为a，b的任意因数，则h整除a，且h整除b，带到第一个式子，则h整除r1，再带到第2个式子，h整除r2，再带到第3个式子，h整除r3……直到倒数第二个式子，h整除rn+1，即h整除g由于最后一个式子余数为0，那么既然g为a，b的因数，h为g的因数，则h&lt;=g，故g为gcd(a,b)。</p>
<p>证毕。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>An Olympian Math Problem</title>
    <url>/2018/09/03/2018-09-03-1/</url>
    <content><![CDATA[<p>问题描述：</p>
<p>求解<code>(1 * 1! + 2 * 2! + …… + (n-2) * (n-2)! + (n-1) * (n-1)!) mod n = n - 1</code>。</p>
<p>PS：<code>n! = 1 * 2 * …… * n</code>。</p>
<p>证明过程：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/2018-09-03QQ%E5%9B%BE%E7%89%8720180904190419.jpg" alt></p>
<p>Alice, a student of grade 66, is thinking about an Olympian Math problem, but she feels so despair that she cries. And her classmate, Bob, has no idea about the problem. Thus he wants you to help him. The problem is:</p>
<p>We denote k!k!:</p>
<p>k! = 1 \times 2 \times \cdots \times (k - 1) \times kk!=1×2×⋯×(k−1)×k</p>
<p>We denote SS:</p>
<p>S = 1 \times 1! + 2 \times 2! + \cdots +S=1×1!+2×2!+⋯+<br>(n - 1) \times (n-1)!(n−1)×(n−1)!</p>
<p>Then SS module nn is <strong><strong>____</strong></strong></p>
<p>You are given an integer nn.</p>
<p>You have to calculate SS modulo nn.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains an integer T(T \le 1000)T(T≤1000), denoting the number of test cases.</p>
<p>For each test case, there is a line which has an integer nn.</p>
<p>It is guaranteed that 2 \le n\le 10^{18}2≤n≤1018.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, print an integer SS modulo nn.</p>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>The first test is: S = 1\times 1!= 1S=1×1!=1, and 11modulo 22 is 11.</p>
<p>The second test is: S = 1\times 1!+2 \times 2!= 5S=1×1!+2×2!=5, and 55 modulo 33 is 22.</p>
<h4 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h4 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h4 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h4><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E5%8D%97%E4%BA%AC%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 南京赛区网络预赛</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">ll t,n;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">        printf(&quot;%lld\n&quot;,n-1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>介于邻接矩阵与邻接表之间的存图方式————链式前向星</title>
    <url>/2018/09/03/2018-09-03/</url>
    <content><![CDATA[<p><strong>链式前向星</strong></p>
<p><strong>图的存储一般有三种：邻接矩阵、邻接表、前向星。</strong></p>
<p><strong>若图是稀疏图，边很少，开二维数组很浪费;</strong></p>
<p><strong>若点很多(如10000个点)<code>a[10000][10000]</code>又会爆.只能用前向星做.</strong></p>
<p><strong>前向星的效率不是很高，优化后为链式前向星，直接介绍链式前向星。</strong></p>
<h2 id="（一）链式前向星"><a href="#（一）链式前向星" class="headerlink" title="（一）链式前向星"></a><strong>（一）链式前向星</strong></h2><h2 id="1-结构"><a href="#1-结构" class="headerlink" title="1. 结构"></a>1. <strong>结构</strong></h2><p><strong>这里用两个东西：</strong></p>
<p><strong>1 结构体数组edge存边，edge[i]表示第i条边,</strong></p>
<p><strong>2 head[i]存以i为起点的第一条边(在edge中的下标)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct EDGE&#123;</span><br><span class="line">	int next;   //下一条边的存储下标(默认0) </span><br><span class="line">	int to;     //这条边的终点 </span><br><span class="line">	int w;      //权值 </span><br><span class="line">&#125;; </span><br><span class="line">EDGE edge[500010];</span><br></pre></td></tr></table></figure>
<h2 id="2-增边"><a href="#2-增边" class="headerlink" title="2.增边"></a><strong>2.增边</strong></h2><p><strong>若以点i为起点的边新增了一条，在edge中的下标为j.</strong></p>
<p><strong>那么edge[j].next=head[i];然后head[i]=j.</strong></p>
<p><strong>即每次新加的边作为第一条边，最后倒序遍历</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Add(int u, int v, int w) &#123;  //起点u, 终点v, 权值w </span><br><span class="line">	//cnt为边的计数，从1开始计 </span><br><span class="line">	edge[++cnt].next = head[u];</span><br><span class="line">	edge[cnt].w = w;</span><br><span class="line">	edge[cnt].to = v;</span><br><span class="line">	head[u] = cnt;    //第一条边为当前边 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-遍历"><a href="#3-遍历" class="headerlink" title="3. 遍历"></a>3. <strong>遍历</strong></h2><p><strong>遍历以st为起点的边</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i=head[st]; i!=0; i=edge[i].next)</span><br></pre></td></tr></table></figure>
<p>i开始为第一条边，每次指向下一条(以0为结束标志)  （若下标从0开始，next应初始化-1）</p>
<p><strong>一个简单的输出有向图熟悉链式前向星：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXM 500010</span><br><span class="line">#define MAXN 10010</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">	int next;   //下一条边的存储下标 </span><br><span class="line">	int to;     //这条边的终点 </span><br><span class="line">	int w;      //权值 </span><br><span class="line">&#125;; </span><br><span class="line">EDGE edge[MAXM];</span><br><span class="line">int n, m, cnt;</span><br><span class="line">int head[MAXN];  //head[i]表示以i为起点的第一条边 </span><br><span class="line">void Add(int u, int v, int w) &#123;  //起点u, 终点v, 权值w </span><br><span class="line">	edge[++cnt].next = head[u];</span><br><span class="line">	edge[cnt].w = w;</span><br><span class="line">	edge[cnt].to = v;</span><br><span class="line">	head[u] = cnt;    //第一条边为当前边 </span><br><span class="line">&#125; </span><br><span class="line">void Print() &#123;</span><br><span class="line">	int st;</span><br><span class="line">	cout &lt;&lt; &quot;Begin with[Please Input]: \n&quot;;</span><br><span class="line">	cin &gt;&gt; st;</span><br><span class="line">	for(int i=head[st]; i!=0; i=edge[i].next) &#123;//i开始为第一条边，每次指向下一条(以0为结束标志)若下标从0开始，next应初始化-1 </span><br><span class="line">		cout &lt;&lt; &quot;Start: &quot; &lt;&lt; st &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;End: &quot; &lt;&lt; edge[i].to &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;W: &quot; &lt;&lt; edge[i].w &lt;&lt; endl &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int s, t, w;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for(int i=1; i&lt;=m; i++) &#123;</span><br><span class="line">		cin &gt;&gt; s &gt;&gt; t &gt;&gt; w;</span><br><span class="line">		Add(s, t, w);</span><br><span class="line">	&#125;</span><br><span class="line">	Print(); </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="（二）链式前向星实现SPFA"><a href="#（二）链式前向星实现SPFA" class="headerlink" title="（二）链式前向星实现SPFA"></a><strong>（二）链式前向星实现SPFA</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXM 500010</span><br><span class="line">#define MAXN 10010</span><br><span class="line">#define ANS_MAX 2147483647</span><br><span class="line">struct EDGE &#123;</span><br><span class="line">	int next;</span><br><span class="line">	int to;</span><br><span class="line">	int w;</span><br><span class="line">&#125;;</span><br><span class="line">EDGE edge[MAXM];</span><br><span class="line">int n, m, st, cnt;</span><br><span class="line">int head[MAXN];</span><br><span class="line">int d[MAXN];</span><br><span class="line">bool inq[MAXN];</span><br><span class="line">inline int Read() &#123;</span><br><span class="line">	char c; int ans = 0; bool Sign = false;</span><br><span class="line">	while(!isdigit(c=getchar()) &amp;&amp; c != &apos;-&apos;);</span><br><span class="line">	if(c == &apos;-&apos;) &#123;</span><br><span class="line">		Sign = true;</span><br><span class="line">		c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	do &#123;</span><br><span class="line">		ans = (ans&lt;&lt;3) + (ans&lt;&lt;1) + (c ^ &apos;0&apos;);</span><br><span class="line">	&#125; while(isdigit(c=getchar()));</span><br><span class="line">	return Sign ? -ans : ans;</span><br><span class="line">&#125;</span><br><span class="line">void Add(int u, int v, int w) &#123;</span><br><span class="line">	edge[++cnt].next = head[u];</span><br><span class="line">	edge[cnt].to = v;</span><br><span class="line">	edge[cnt].w = w;</span><br><span class="line">	head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line">void read() &#123;</span><br><span class="line">	int x, y, w;</span><br><span class="line">	n = Read();</span><br><span class="line">	m = Read();</span><br><span class="line">	st = Read();</span><br><span class="line">	for(int i=1; i&lt;=m; i++) &#123;</span><br><span class="line">		x = Read();</span><br><span class="line">		y = Read();</span><br><span class="line">		w = Read();</span><br><span class="line">		Add(x, y, w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void SPFA(int x) &#123;</span><br><span class="line">	d[x] = 0; for(int i=1; i&lt;=n; i++) d[i] = ANS_MAX;</span><br><span class="line">	queue&lt;int&gt; Q; Q.push(x); inq[x] = true;</span><br><span class="line">	while(!Q.empty()) &#123;</span><br><span class="line">		int k = Q.front(); Q.pop(); inq[k] = false;</span><br><span class="line">		for(int i=head[k]; i!=0; i=edge[i].next) &#123;</span><br><span class="line">			int j = edge[i].to;</span><br><span class="line">			if(d[j] &gt; d[k] + edge[i].w) &#123;</span><br><span class="line">				d[j] = d[k] + edge[i].w;</span><br><span class="line">				if(!inq[j]) &#123;</span><br><span class="line">					Q.push(j);</span><br><span class="line">					inq[j] = true;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1; i&lt;=n; i++) printf(&quot;%d &quot;, d[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	read();</span><br><span class="line">	SPFA(st);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图论</tag>
        <tag>链式前向星</tag>
      </tags>
  </entry>
  <entry>
    <title>2018中国大学生程序设计竞赛 - 网络选拔赛 1001 Buy and Resell</title>
    <url>/2018/08/25/2018-08-25-2/</url>
    <content><![CDATA[<h1 id="Buy-and-Resell"><a href="#Buy-and-Resell" class="headerlink" title="Buy and Resell"></a>Buy and Resell</h1><p><strong>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0    Accepted Submission(s): 0</strong></p>
<p>Problem Description</p>
<p>The Power Cube is used as a stash of Exotic Power. There are n cities numbered 1,2,…,n where allowed to trade it. The trading price of the Power Cube in the i-th city is ai dollars per cube. Noswal is a foxy businessman and wants to quietly make a fortune by buying and reselling Power Cubes. To avoid being discovered by the police, Noswal will go to the i-th city and choose exactly one of the following three options on the i-th day:<br>\1. spend ai dollars to buy a Power Cube<br>\2. resell a Power Cube and get ai dollars if he has at least one Power Cube<br>\3. do nothing<br>Obviously, Noswal can own more than one Power Cubes at the same time. After going to the n cities, he will go back home and stay away from the cops. He wants to know the maximum profit he can earn. In the meanwhile, to lower the risks, he wants to minimize the times of trading (include buy and sell) to get the maximum profit. Noswal is a foxy and successful businessman so you can assume that he has infinity money at the beginning.</p>
<p>Input</p>
<p>There are multiple test cases. The first line of input contains a positive integer T (T≤250), indicating the number of test cases. For each test case:<br>The first line has an integer n. (1≤n≤105)<br>The second line has n integers a1,a2,…,an where ai means the trading price (buy or sell) of the Power Cube in the i-th city. (1≤ai≤109)<br>It is guaranteed that the sum of all n is no more than 5×105.</p>
<p>Output</p>
<p>For each case, print one line with two integers —— the maximum profit and the minimum times of trading to get the maximum profit.</p>
<p>Sample Input</p>
<p>3 4 1 2 10 9 5 9 5 9 10 5 2 2 1</p>
<p>Sample Output</p>
<p><em>Hint</em></p>
<p>profit = - 1 - 2 + 10 + 9 = 16</p>
<p>profit = - 5 + 10 = 5</p>
<p>profit = 0</p>
<p>题解：</p>
<p>n天，每天商品有个价格，或买或卖或不买不卖。</p>
<p>贪心策略：分为两个堆（或优先队列），一个堆v为储存买的价格，一个堆s储存卖的价格。第i天的商品和之前买与卖两个堆中的最小值进行比较。共分为四种情况：1.如果第i天的价格比买的堆v里最小值大，且买的堆v里最小值比卖的堆s里最小值小，则买掉买的堆v里最小的，再卖出去，交易次数加2，即v.pop(),s.push(),cnt+2。2.如果第i天的价格比卖的堆s里最小值大，且买的堆v里最小值比卖的堆s里最小值大，则买掉卖的堆s里最小的，再卖出去，意思为现在卖比之前卖的那次更划算，我们把它买回来就等于之前那次没有卖，再卖出去等于现在才卖，即s.pop(),v.push(),s.push()。3.如果当天的价格即小于s中最小又小于v中最小，则把他放到买的堆v里，即v.push()。</p>
<p>这样下来，最后买的堆里剩下的就是没买没卖的。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll t;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        ll n, tmp, cnt = 0,sum = 0;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">        priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt;v,s;</span><br><span class="line">        for(ll i = 0;i&lt;n;i++)&#123;</span><br><span class="line">            scanf(&quot;%lld&quot;,&amp;tmp);</span><br><span class="line">            if(!v.empty())&#123;</span><br><span class="line">                if(!s.empty()&amp;&amp;tmp&gt;s.top()&amp;&amp;s.top()&lt;=v.top())&#123;</span><br><span class="line">                    sum+=tmp-(s.top());</span><br><span class="line">                    v.push(s.top());</span><br><span class="line">                    s.pop();</span><br><span class="line">                    s.push(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                 else if(tmp&gt;v.top()&amp;&amp;(s.empty()||s.top()&gt;v.top()))&#123;</span><br><span class="line">                    s.push(tmp);</span><br><span class="line">                    sum+=tmp-(v.top());</span><br><span class="line">                    v.pop();</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(tmp&lt;=v.top())&#123;</span><br><span class="line">                    v.push(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(!s.empty()&amp;&amp;tmp&gt;s.top())&#123;</span><br><span class="line">                    v.push(s.top());</span><br><span class="line">                    sum+=tmp-s.top();</span><br><span class="line">                    s.pop();</span><br><span class="line">                    s.push(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    v.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%lld %lld\n&quot;,sum,2*cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>贪心</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title>2018中国大学生程序设计竞赛 - 网络选拔赛 1009 Tree and Permutation</title>
    <url>/2018/08/25/2018-08-25-1/</url>
    <content><![CDATA[<h1 id="Tree-and-Permutation"><a href="#Tree-and-Permutation" class="headerlink" title="Tree and Permutation"></a>Tree and Permutation</h1><p><strong>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0    Accepted Submission(s): 0</strong></p>
<p>Problem Description</p>
<p>There are N vertices connected by N?1 edges, each edge has its own length.<br>The set { 1,2,3,…,N } contains a total of N! unique permutations, let’s say the i-th permutation is Pi and Pi,j is its j-th number.<br>For the i-th permutation, it can be a traverse sequence of the tree with N vertices, which means we can go from the Pi,1-th vertex to the Pi,2-th vertex by the shortest path, then go to the Pi,3-th vertex ( also by the shortest path ) , and so on. Finally we’ll reach the Pi,N-th vertex, let’s define the total distance of this route as D(Pi) , so please calculate the sum of D(Pi) for all N! permutations.</p>
<p>Input</p>
<p>There are 10 test cases at most.<br>The first line of each test case contains one integer N ( 1≤N≤105 ) .<br>For the next N?1 lines, each line contains three integer X, Y and L, which means there is an edge between X-th vertex and Y-th of length L ( 1≤X,Y≤N,1≤L≤109 ) .</p>
<p>Output</p>
<p>For each test case, print the answer module 109+7 in one line.</p>
<p>Sample Input</p>
<p>3</p>
<p>1 2 1</p>
<p>2 3 1</p>
<p>3</p>
<p>1 2 1</p>
<p>1 3 2</p>
<p>Sample Output</p>
<p>16</p>
<p>24</p>
<p>题意：</p>
<p>首先给出一个含有n个节点的树，边权为距离。</p>
<p>对于1-n的某一种排列p1,p2,p3……pn，贡献为dis(p1,p2)+dis(p2,p3)+dis(p3,p4)+……+dis(pn-1,pn)</p>
<p>求所有排列的贡献和</p>
<p>题解：</p>
<p>一棵树n个结点n-1条边，所以任意两点之间都有最短距离。由于所有遍历方式可以看做n个结点的排列，而每次有直接关系的只有两点之间的距离，因此只需求出两点之间的距离在所有排列中一共出现多少次即可。</p>
<p>比如n=2时，两个点1,2，共有两种排列方式，即1,2,和2,1</p>
<p>n=3时，三个点1,2,3,其中1,2共有4种方法得到，即1,2,3,和2,1,3,和3,1,2,和3,2,1</p>
<p>n=4时，三个点1,2,3,4,其中1,2共有12种方法得到，即1,2,3,4,和1,2,4,3,和2,1,3,4,和2,1,4,3,和3,1,2,4,和3,2,1,4和4,1,2,3,和4,2,1,3,和3,4,1,2,和4,3,1,2,和3,4,2,1,和4,3,2,1,</p>
<p>n=jie[n-1]*（n-1）。</p>
<p>先用树状dp求出所有两两结点之间的距离之和，再乘以每条边在所有结点排列的n！方式中一共用到的次数。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">const ll mod = 1e9+7;</span><br><span class="line">ll sum[maxn], n;</span><br><span class="line">ll dp[maxn];</span><br><span class="line">ll jie[maxn];</span><br><span class="line">ll jie2[maxn];</span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    ll v, w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; tree[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    jie[2] = 2;</span><br><span class="line">    for(ll i = 3;i&lt;maxn;i++)&#123;</span><br><span class="line">        jie[i] = jie[i-1]*(i-1)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(ll cur, ll father)</span><br><span class="line">&#123;</span><br><span class="line">    sum[cur] = 1;</span><br><span class="line">    for(ll i = 0; i &lt; tree[cur].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll son = tree[cur][i].v;</span><br><span class="line">        ll len = tree[cur][i].w;</span><br><span class="line">        if(father == son)</span><br><span class="line">            continue;</span><br><span class="line">        dfs(son, cur);</span><br><span class="line">        sum[cur] += sum[son]%mod;</span><br><span class="line">        sum[cur]%=mod;</span><br><span class="line">        dp[cur] += (dp[son]%mod + (n-sum[son])%mod*sum[son]%mod * len%mod)%mod;</span><br><span class="line">        dp[cur]%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    ll u, v, w;</span><br><span class="line">    while(scanf(&quot;%lld&quot;, &amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&lt;=2)&#123;</span><br><span class="line">            if(n==1)&#123;</span><br><span class="line">                printf(&quot;0\n&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            printf(&quot;%lld\n&quot;, 2*w%mod);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for(ll i = 0; i &lt; n; i++)</span><br><span class="line">            tree[i].clear();</span><br><span class="line">        memset(sum, 0, sizeof(sum));</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        for(ll i = 0; i &lt; n-1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            u--,v--;</span><br><span class="line">            Edge t1, t2;</span><br><span class="line">            t1.v = v;</span><br><span class="line">            t1.w = w;</span><br><span class="line">            t2.v = u;</span><br><span class="line">            t2.w = w;</span><br><span class="line">            tree[u].push_back(t1);</span><br><span class="line">            tree[v].push_back(t2);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(0, -1);</span><br><span class="line">        printf(&quot;%lld\n&quot;, (dp[0]%mod)*jie[n]%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>组合数学</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title>2018中国大学生程序设计竞赛 - 网络选拔赛 1004 Find Integer</title>
    <url>/2018/08/25/2018-08-25/</url>
    <content><![CDATA[<h1 id="Find-Integer"><a href="#Find-Integer" class="headerlink" title="Find Integer"></a>Find Integer</h1><p><strong>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0    Accepted Submission(s): 0Special Judge</strong></p>
<p>Problem Description</p>
<p>people in USSS love math very much, and there is a famous math problem .<br>give you two integers n,a,you are required to find 2 integers b,c such that an+bn=cn.</p>
<p>Input</p>
<p>one line contains one integer T;(1≤T≤1000000)<br>next T lines contains two integers n,a;(0≤n≤1000,000,000,3≤a≤40000)</p>
<p>Output</p>
<p>print two integers b,c if b,c exits;(1≤b,c≤1000,000,000);<br>else print two integers -1 -1 instead.</p>
<p>Sample Input</p>
<p>1 2 3</p>
<p>Sample Output</p>
<p>4 5</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>本题首先用到了费马大定理，即a^n+b^n≠c^n。(a,b,c∈Z，n&gt;2)</p>
<p>所以当n大于2或者n为0时直接输出-1,-1，当n=1时直接输出1,a+1。</p>
<p>当n=2时，输出勾股数。</p>
<p>首先a²+b²=c²，a²=c²-b²，a²=(c+b)(c-b)。</p>
<p>设x=c+b，y=c-b，则a²=xy。</p>
<p>c=(x+y)/2，b=(x-y)/2。</p>
<p>当然我的方法是通过打表求得勾股数，方法有点偏暴力，即枚举x，y，然后用公式看c，b是否在范围内且为整数，当然在枚举的时候少不了剪枝，不然肯定tle。</p>
<p>不过后来听说根据费马大定理奇偶数列法则可。直接推出式子。</p>
<p>打表代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">struct node&#123;</span><br><span class="line">    ll b,c;</span><br><span class="line">&#125;aa[40007];</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(aa,0,sizeof(aa));</span><br><span class="line">    for(ll i = 3;i&lt;=40000;i++)&#123;</span><br><span class="line">        for(ll j = 1;j&lt;i;j++)&#123;</span><br><span class="line">            if(i*i%j==0)&#123;</span><br><span class="line">                ll x = j;</span><br><span class="line">                ll y = i*i/j;</span><br><span class="line">                if((x+y)%2==0)&#123;</span><br><span class="line">                    aa[i].c=(x+y)/2;</span><br><span class="line">                    aa[i].b=(y-x)/2;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        ll a,b,c,n;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;a);</span><br><span class="line">        if(n&gt;2||n==0)&#123;</span><br><span class="line">            printf(&quot;-1 -1\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(n==1)&#123;</span><br><span class="line">            printf(&quot;1 %lld\n&quot;,a+1);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            if(aa[a].b)&#123;</span><br><span class="line">                printf(&quot;%lld %lld\n&quot;,aa[a].b,aa[a].c);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                printf(&quot;-1 -1\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0(1)代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll a,b,c,n;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;a);</span><br><span class="line">        if(n&gt;2||n==0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;-1 -1\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(n==1)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;1 %lld\n&quot;,a+1);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(a%2==1&amp;&amp;a&gt;1)</span><br><span class="line">            &#123;</span><br><span class="line">                ll cc=(a-1)/2;</span><br><span class="line">                b=2*cc*(cc+1);</span><br><span class="line">                c=2*cc*(cc+1)+1;</span><br><span class="line">                printf(&quot;%lld %lld\n&quot;,b,c);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(a%2==0&amp;&amp;a&gt;2)</span><br><span class="line">            &#123;</span><br><span class="line">                ll cc=a/2;</span><br><span class="line">                b=cc*cc-1;</span><br><span class="line">                c=cc*cc+1;</span><br><span class="line">                printf(&quot;%lld %lld\n&quot;,b,c);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                printf(&quot;-1 -1\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="推导过程："><a href="#推导过程：" class="headerlink" title="推导过程："></a>推导过程：</h2><p>a为任意情况</p>
<p>a² = c² - b²</p>
<p>a² = (c+b)(c-b)</p>
<p>a²  = a² * 1</p>
<p>c + b = a² </p>
<p>c - b = 1</p>
<p>c = (a²  + 1) / 2</p>
<p>b = (a²  - 1) / 2</p>
<p>a为偶数情况：</p>
<p>if(a² % 2 == 0)</p>
<p>a²  = a²/2 * 2</p>
<p>c + b = a²/2 </p>
<p>c - b = 2</p>
<p>c = a²/4 + 1</p>
<p>b =a²/4 - 1</p>
<p>证毕</p>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>数论</tag>
        <tag>CCPC</tag>
        <tag>费马大定理</tag>
      </tags>
  </entry>
  <entry>
    <title>8.23网络流专项训练题解</title>
    <url>/2018/08/23/2018-08-23/</url>
    <content><![CDATA[<h1 id="问题-A-赛马"><a href="#问题-A-赛马" class="headerlink" title="问题 A: 赛马"></a>问题 A: 赛马</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 32  解决: 5<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=0&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1890" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1890&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1890&amp;getkey=A121ED5825" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1890" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>古有田忌赛马戏齐王，今有悠悠赛马虐渣渣。悠悠和他的小老弟渣渣每人有n匹马，每匹马都有一个评分，分数越高速度越快。现在渣渣不甘于当小老弟，随着赛马曲的想起，渣渣决定挑战悠悠，规则同田忌赛马。每胜一局得1分，每负一局减一分，赵神做裁判，悠悠为了捍卫自己的王者地位，决定出老千，问了赵神关于渣渣的赛马顺序，请问悠悠最高能得多少分。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>文件有多组测试样例，遇0为止。</p>
<p>首行一个整数n，n&lt;=1000;</p>
<p>第2行n个整数表示悠悠每匹马的分数。</p>
<p>第3行n个整数表示渣渣每匹马的分数。0&lt;=分数&lt;500;</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出悠悠最高分。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">192 173 71</span><br><span class="line">195 177 74</span><br><span class="line">2</span><br><span class="line">10 10</span><br><span class="line">10 10</span><br><span class="line">2</span><br><span class="line">220 219</span><br><span class="line">222 218</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>水题，可以用网络流或者匹配，也可以用更简单的方法。</p>
<p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=0&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1890" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1890&amp;getkey=A121ED5825" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1890" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题贪心可解。贪心策略即田忌赛马的策略。第1步我们将我们最慢的马和对方最快的马进行比较，如果最慢的马比对方最慢的马快，那么我们就胜一局，然后返回第1步。反之我们进行第2步，继续拿我们最快的马和对方最快的马进行比较，如果获胜就胜一局，然后返回第1步。反之我们进行第3步，继续拿我们最慢的马和对方最快的马进行比较，这种情况下分为两种情况，一种是得分相等，另外一种是我方必败，必败得分减一，否则不变，然后我们再返回第1步。直到所有的马都结束为止，此时我们就得到了最高得分。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1007],b[1007];</span><br><span class="line">int main()&#123;</span><br><span class="line">	freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    int n;</span><br><span class="line">    while(cin&gt;&gt;n)&#123;</span><br><span class="line">    	if(n==0)</span><br><span class="line">    		break;</span><br><span class="line">        for(int i=0; i&lt;n; i++)</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        for(int i=0; i&lt;n; i++)</span><br><span class="line">            cin&gt;&gt;b[i];</span><br><span class="line">        sort(a,a+n);</span><br><span class="line">        sort(b,b+n);</span><br><span class="line">        int s=0;</span><br><span class="line">        for(int i=0,j=0,k=n-1,l=n-1; i&lt;=k;)&#123;</span><br><span class="line">            if(a[i]&gt;b[j])</span><br><span class="line">            	s++,i++,j++;</span><br><span class="line">            else if(a[k]&gt;b[l])</span><br><span class="line">            	s++,k--,l--;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(a[i]&lt;b[l])</span><br><span class="line">                	s--;</span><br><span class="line">                i++,l--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-B-海上钢琴师"><a href="#问题-B-海上钢琴师" class="headerlink" title="问题 B: 海上钢琴师"></a>问题 B: 海上钢琴师</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=1&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1894" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1894&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1894&amp;getkey=93904EDF34" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1894" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>宁愿一生孤独，不愿随波逐流。海上钢琴师毅然留在了船上，与大海为伴，此生再不上岸。</p>
<p>然而，他的音乐却已名扬四海。为了将他的钢琴声可以传播到陆地以便欣赏，人们决定在陆地与钢琴师所在的船之间的n-2座岛屿上建立声音保留设备。每当声音传到该设备处时，以该设备为起点可以将声音信号发送到其他与该设备有信号连接的设备那里。信号传播是单向的，且是有限的。当该设备将一部分信号传给其他设备时，该设备所拥有的总信号要减去相应传出去的信号，所保留的信号可以继续传给其他的设备。船上也有该设备，由于岛屿与船的位置不同，所以钢琴声传到设备的声音有限。设备与设备之间的传播分贝也有限。陆地的总接收设备与某些岛屿上的设备有信号连接，请问陆地最多能收到多少分贝的钢琴声。</p>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>第一行输入两个数m，n。m代表共有m对设备建立了单向连接。n代表包括船和陆地在内共有n个设备。编号1为船，编号n为陆地，其他为岛屿（n&lt;=100，m&lt;=1000）</p>
<p>接下来m行，每行三个数a，b，c，代表a-&gt;b，即a的信号可以传到b信号，最大可以通过该信号传送c分贝。c&lt;=2000</p>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>输出陆地上最大可以收到多少分贝声音。（海上钢琴声不超过10000分贝）</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">1 2 100</span><br><span class="line">1 3 50</span><br><span class="line">2 3 2</span><br><span class="line">3 4 60</span><br><span class="line">2 4 99</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">150</span><br></pre></td></tr></table></figure>
<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>样例解释：（容量，流量）</p>
<p>方案1：</p>
<p><img src="http://sustoj.com/JudgeOnline/upload/image/20180822/20180822133414_80763.png" alt="img"></p>
<p>方案2：</p>
<p><img src="http://sustoj.com/JudgeOnline/upload/image/20180822/20180822133437_68424.png" alt="img"></p>
<p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=1&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1894" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1894&amp;getkey=93904EDF34" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1894" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>网络流最大流模板题。题面转化过来就是一个网络流模型，船为s，陆地为t，设备之间的连接就是弧。用FF算法，EK算法，Dinic算法，SAP算法，预流推进，均可解。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=200+7;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">int r[maxn][maxn]; //残留网络，初始化为原图</span><br><span class="line">bool visit[maxn];</span><br><span class="line">int pre[maxn];</span><br><span class="line">int m,n;</span><br><span class="line">bool bfs(int s,int t)  //寻找一条从s到t的增广路，若找到返回true</span><br><span class="line">&#123;</span><br><span class="line">    int p;</span><br><span class="line">    queue&lt;int &gt; q;</span><br><span class="line">    memset(pre,-1,sizeof(pre));</span><br><span class="line">    memset(visit,false,sizeof(visit));</span><br><span class="line"></span><br><span class="line">    pre[s]=s;</span><br><span class="line">    visit[s]=true;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        p=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(r[p][i]&gt;0&amp;&amp;!visit[i])</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i]=p;</span><br><span class="line">                visit[i]=true;</span><br><span class="line">                if(i==t) return true;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int EdmondsKarp(int s,int t)</span><br><span class="line">&#123;</span><br><span class="line">   int flow=0,d,i;</span><br><span class="line">   while(bfs(s,t))</span><br><span class="line">   &#123;</span><br><span class="line">       d=inf;</span><br><span class="line">       for(i=t;i!=s;i=pre[i])</span><br><span class="line">           d=d&lt;r[pre[i]][i]? d:r[pre[i]][i];</span><br><span class="line">       for(i=t;i!=s;i=pre[i])</span><br><span class="line">       &#123;</span><br><span class="line">           r[pre[i]][i]-=d;</span><br><span class="line">           r[i][pre[i]]+=d;</span><br><span class="line">       &#125;</span><br><span class="line">       flow+=d;</span><br><span class="line">   &#125;</span><br><span class="line">   return flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    while(cin&gt;&gt;m&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v,w;</span><br><span class="line">        memset(r,0,sizeof(r));</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            r[u][v]+=w;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;EdmondsKarp(1,n)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-C-进击的巨人"><a href="#问题-C-进击的巨人" class="headerlink" title="问题 C: 进击的巨人"></a>问题 C: 进击的巨人</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=2&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1895" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1895&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1895&amp;getkey=DF84EFB393" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1895" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>那一年，巨人发起了第一轮进击，s城破，埃尔文团长带领众居民计划逃往较安全的t城。从s城到t城之间共有m坐城市，某些城市之间构成单向通路。由s城到t城恰构成一个有向无环图。然而每条路上都有限定的最大人流量。埃尔文团长想知道每一次最多有多少居民能到达t城。</p>
<h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>首行输入两个数n，m（n，m&lt;=100），n0为s城，nn为t城。s城到t城之间的城用n1——nn表示。m表示单项通道数。</p>
<p>接下来m行，每行三个数a，b，c，代表a到b的最大人流量是c。c&lt;1000。</p>
<h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>输出最多有多少人到t</p>
<h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 14</span><br><span class="line">0 2 5</span><br><span class="line">0 1 10</span><br><span class="line">1 2 6</span><br><span class="line">0 3 5</span><br><span class="line">3 1 2</span><br><span class="line">1 5 3</span><br><span class="line">5 2 3</span><br><span class="line">5 4 3</span><br><span class="line">3 5 3</span><br><span class="line">3 4 4</span><br><span class="line">3 6 5</span><br><span class="line">2 6 6</span><br><span class="line">4 6 10</span><br><span class="line">2 4 4</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure>
<p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=2&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1895" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1895&amp;getkey=DF84EFB393" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1895" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>网络流最大流模板题。用FF算法，EK算法，Dinic算法，SAP算法，预流推进，均可解。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=200+7;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">int r[maxn][maxn]; //残留网络，初始化为原图</span><br><span class="line">bool visit[maxn];</span><br><span class="line">int pre[maxn];</span><br><span class="line">int m,n;</span><br><span class="line">bool bfs(int s,int t)  //寻找一条从s到t的增广路，若找到返回true</span><br><span class="line">&#123;</span><br><span class="line">    int p;</span><br><span class="line">    queue&lt;int &gt; q;</span><br><span class="line">    memset(pre,-1,sizeof(pre));</span><br><span class="line">    memset(visit,false,sizeof(visit));</span><br><span class="line"></span><br><span class="line">    pre[s]=s;</span><br><span class="line">    visit[s]=true;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        p=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(r[p][i]&gt;0&amp;&amp;!visit[i])</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i]=p;</span><br><span class="line">                visit[i]=true;</span><br><span class="line">                if(i==t) return true;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int EdmondsKarp(int s,int t)</span><br><span class="line">&#123;</span><br><span class="line">   int flow=0,d,i;</span><br><span class="line">   while(bfs(s,t))</span><br><span class="line">   &#123;</span><br><span class="line">       d=inf;</span><br><span class="line">       for(i=t;i!=s;i=pre[i])</span><br><span class="line">           d=d&lt;r[pre[i]][i]? d:r[pre[i]][i];</span><br><span class="line">       for(i=t;i!=s;i=pre[i])</span><br><span class="line">       &#123;</span><br><span class="line">           r[pre[i]][i]-=d;</span><br><span class="line">           r[i][pre[i]]+=d;</span><br><span class="line">       &#125;</span><br><span class="line">       flow+=d;</span><br><span class="line">   &#125;</span><br><span class="line">   return flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v,w;</span><br><span class="line">        memset(r,0,sizeof(r));</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            r[u][v]+=w;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;EdmondsKarp(0,n)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-D-X档案"><a href="#问题-D-X档案" class="headerlink" title="问题 D: X档案"></a>问题 D: X档案</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 5  解决: 3<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=3&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1883" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1883&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1883&amp;getkey=B46583A0E8" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1883" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>据X档案记载，倘若外星文明即将攻击地球，会在战争之前发动病毒袭击，最合理的对象是鸟或狗，因为鸟在空中传播病毒的范围2较广，而狗相较于其他动物来说和人类接触最频繁。X城作为全球反外星文明的重要基地，对外星文明来说威胁最大而作为外星文明首先攻击的目标。因此，X长官下令捕杀了全城的鸟，而狗由于受到爱狗人士们的保护免于此劫。然而灾难还是降临了，外星文明悄无声息地将病毒注入到一些狗体内。据全球卫星显示，X城的地形是一个n<em>m的矩阵，划分成了n</em>m个1<em>1的小矩阵。矩阵的四周被城墙所围。而在某些单位1</em>1的小矩阵中有居民，或者有被感染的狗。我们已经知道了狗的全部坐标，为了安全起见，X长官启动了X计划，将这些狗在未发作之前用围栏隔离起来以防止狗攻击人类，每个1*1的小矩阵四周均可建立围栏。该计划收录到了X档案中。围栏使得狗和人类均无法通过。由于计划的机密性，长官不想动用太多的财力，现求最少需要多长围栏才能将所有狗隔离。</p>
<h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>输入包含多组样例，读到文件结束。</p>
<p>第一行为n，m，代表n*m的矩阵。（0&lt;n，m&lt;=150）</p>
<p>接下来n行，每行m个由0，1，2组成的数。</p>
<p>0代表此处没有任何东西，1代表此处有人，2代表此处有被感染的狗。</p>
<h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>输出格式为：Case i: k</p>
<p>i为第i组样例，k为所需最短的围栏长度。</p>
<h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 6</span><br><span class="line">0 0 0 1 0 0</span><br><span class="line">2 0 0 0 0 1</span><br><span class="line">0 0 1 0 0 0</span><br><span class="line">0 0 2 0 0 1</span><br><span class="line">0 0 0 1 0 0</span><br><span class="line">4 6</span><br><span class="line">0 0 1 0 0 1</span><br><span class="line">0 0 0 1 1 0</span><br><span class="line">0 0 0 0 2 2</span><br><span class="line">0 1 1 0 2 0</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case 1: 6</span><br><span class="line">Case 2: 4</span><br></pre></td></tr></table></figure>
<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>第1组样例解释：</p>
<p><img src="http://sustoj.com/JudgeOnline/upload/image/20180821/20180821210755_92707.png" alt="img"> </p>
<p>第2组样例解释：</p>
<p><img src="http://sustoj.com/JudgeOnline/upload/image/20180821/20180821211137_35539.png" alt="img"> </p>
<p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=3&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1883" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1883&amp;getkey=B46583A0E8" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1883" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>题目描述那么多，其实就是最小割问题。只不过我们要建立一个超级源点指向所有狼（羊），再建立一个超级汇点指向所有羊（狼）。羊和狼为结点，两个节点直接一条边，权值为1。最终求解最大流即可。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define maxn 100100</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int to[maxn],c[maxn],first[maxn],Next[maxn],N;</span><br><span class="line">int d[maxn];</span><br><span class="line">int Q[maxn],bot,top,tag[maxn],can[maxn];</span><br><span class="line">int s,t,n,m,tmp,ans,cas=0;</span><br><span class="line">int TAG=5201314;</span><br><span class="line">void _init()</span><br><span class="line">&#123;</span><br><span class="line">    ans=s=0,t=n*m+1,N=-1;</span><br><span class="line">    for (int i=s; i&lt;=t; i++) first[i]=-1;</span><br><span class="line">&#125;</span><br><span class="line">void edge(int U,int V,int W)</span><br><span class="line">&#123;</span><br><span class="line">    N++;</span><br><span class="line">    to[N]=V,c[N]=W;</span><br><span class="line">    Next[N]=first[U],first[U]=N;</span><br><span class="line">&#125;</span><br><span class="line">void _input()</span><br><span class="line">&#123;</span><br><span class="line">    int cur=0;</span><br><span class="line">    for (int i=1; i&lt;=n; i++)</span><br><span class="line">        for (int j=1; j&lt;=m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;tmp);</span><br><span class="line">            cur++;</span><br><span class="line">            if (i&lt;n) edge(cur,cur+m,1),edge(cur+m,cur,1);</span><br><span class="line">            if (j&lt;m) edge(cur,cur+1,1),edge(cur+1,cur,1);</span><br><span class="line">            if (tmp==2) edge(s,cur,inf),edge(cur,s,inf);</span><br><span class="line">                else if (tmp==1) edge(cur,t,inf),edge(t,cur,inf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">    TAG++;</span><br><span class="line">    Q[bot=top=1]=t,d[t]=0,tag[t]=TAG;</span><br><span class="line">    while (bot&lt;=top)</span><br><span class="line">    &#123;</span><br><span class="line">        int cur=Q[bot++];</span><br><span class="line">        for (int i=first[cur]; i!=-1; i=Next[i])</span><br><span class="line">        &#123;</span><br><span class="line">            if (c[i^1]&lt;=0 || tag[to[i]]==TAG) continue;</span><br><span class="line">            tag[to[i]]=TAG,d[to[i]]=d[cur]+1,Q[++top]=to[i];</span><br><span class="line">            if (to[i]==s) return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dfs(int cur,int num)</span><br><span class="line">&#123;</span><br><span class="line">    if (cur==t) return num;</span><br><span class="line">    int tmp=num,k;</span><br><span class="line">    for (int i=first[cur]; i!=-1; i=Next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        if (d[cur]!=d[to[i]]+1 || c[i]&lt;=0 || tag[to[i]]!=TAG || can[to[i]]==TAG) continue;</span><br><span class="line">        k=dfs(to[i],min(num,c[i]));</span><br><span class="line">        if (k) c[i]-=k,c[i^1]+=k,num-=k;</span><br><span class="line">        if (num==0) break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (num) can[cur]=TAG;</span><br><span class="line">    return tmp-num;</span><br><span class="line">&#125;</span><br><span class="line">void dinic()&#123;</span><br><span class="line">    while (bfs())</span><br><span class="line">    	ans+=dfs(s,inf);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    while (scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        _init();</span><br><span class="line">        _input();</span><br><span class="line">        dinic();</span><br><span class="line">        printf(&quot;Case %d: %d\n&quot;,++cas,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-E-同桌的你"><a href="#问题-E-同桌的你" class="headerlink" title="问题 E: 同桌的你"></a>问题 E: 同桌的你</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=4&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1892" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1892&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1892&amp;getkey=FA65543DBF" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1892" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>据yoyo统计，青春期的情侣80%都是曾经的同桌。因此，选择好的同桌对你日后的感情发展有很大的帮助。高一7班共有n个男生，m个女生，男生们听过分析后纷纷要求重新排座位，以期待和心仪的女生做同桌。每个男生都有自己的暗恋对象，0&lt;=暗恋对象的个数&lt;=m，也就是说某个男生最多暗恋全班女生，最少一个都不暗恋。汪老师知道这件事后很是重视，于是开始调座位，优先考虑男生和他的暗恋女生坐在一起。男生用a表示，女生用n表示。请问最多有多少男生能和自己心仪的对象坐在一起。</p>
<h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>首行输入n，m，e（0&lt;n，m&lt;=1000，0&lt;=e&lt;=10000）n男m女e为所有男生暗恋女生的个数之和。</p>
<p>接下来e行，每行两个数i，j，代表ai男生暗恋bj女生。</p>
<h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>一个整数，最优分配下最多有多少男生能和自己心仪的对象坐在一起。</p>
<h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1 2</span><br><span class="line">2 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>样例解释：</p>
<p>全班两个男生暗恋班里唯一一个女生，无论怎么分配只能凑成一对。</p>
<p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=4&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1892" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1892&amp;getkey=FA65543DBF" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1892" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>二分图最大匹配问题。男生和女生构成二分图，每个男生和暗恋的女生之间建立一条边。由于不涉及到权值，因此可用匈牙利算法求解，当然也可用网络流求解。网络流的话就是在二分图的两部分分别建立超级源点s和超级汇点t，每条边的容量固定是1，然后此题就转化成了网络流问题。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line">int cnt=2;</span><br><span class="line">int alist[6000001];</span><br><span class="line">struct data&#123;</span><br><span class="line">    int v;int next;int value;</span><br><span class="line">&#125;edge[6000001];</span><br><span class="line">void add(int u,int v,int value)</span><br><span class="line">&#123;</span><br><span class="line">    edge[cnt].v=v;</span><br><span class="line">    edge[cnt].value=value;</span><br><span class="line">    edge[cnt].next=alist[u];</span><br><span class="line">    alist[u]=cnt++;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">int h[1000001];</span><br><span class="line">int q[1000001];</span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">    int x,next;</span><br><span class="line">    memset(h,-1,sizeof(h));</span><br><span class="line">    int head=0,tail=1;</span><br><span class="line">    q[head]=1;</span><br><span class="line">    h[1]=0;</span><br><span class="line">    while(head&lt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        x=q[head++];</span><br><span class="line">        next=alist[x];</span><br><span class="line">        while(next)</span><br><span class="line">        &#123;</span><br><span class="line">            int v=edge[next].v;</span><br><span class="line">            int value=edge[next].value;</span><br><span class="line">            if(value&amp;&amp;h[v]&lt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                q[tail++]=v;</span><br><span class="line">                h[v]=h[x]+1;</span><br><span class="line">            &#125;</span><br><span class="line">            next=edge[next].next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(h[n]==-1) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int ans;</span><br><span class="line">int dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    if(x==n) return y;</span><br><span class="line">    int next=alist[x];</span><br><span class="line">    int w,used=0;</span><br><span class="line">    while(next)</span><br><span class="line">    &#123;</span><br><span class="line">        int v=edge[next].v;</span><br><span class="line">        int value=edge[next].value;</span><br><span class="line">        if(value&amp;&amp;h[v]==h[x]+1)</span><br><span class="line">        &#123;</span><br><span class="line">                w=y-used;</span><br><span class="line">                w=dfs(v,min(w,value));</span><br><span class="line">                edge[next].value-=w;</span><br><span class="line">                edge[next^1].value+=w;</span><br><span class="line">                used+=w;</span><br><span class="line">                if(used==y) return y;</span><br><span class="line">        &#125;</span><br><span class="line">        next=edge[next].next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!used) h[x]=-1;</span><br><span class="line">    return used;</span><br><span class="line">&#125;</span><br><span class="line">void dinic()</span><br><span class="line">&#123;</span><br><span class="line">    while(bfs()) ans+=dfs(1,0x7fffffff);</span><br><span class="line">&#125;</span><br><span class="line">int n1,m1,e1;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;n1,&amp;m1,&amp;e1);</span><br><span class="line">    n=n1+m1+2;</span><br><span class="line">    for(int i=1;i&lt;=n1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        add(1,i+1,1);</span><br><span class="line">        add(i+1,1,1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=e1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">        if(u&lt;=n1&amp;&amp;v&lt;=m1)</span><br><span class="line">        add(u+1,v+n1+1,1),</span><br><span class="line">        add(v+n1+1,u+1,1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        add(i+n1+1,n,1);</span><br><span class="line">        add(n,i+n1+1,1);</span><br><span class="line">    &#125;</span><br><span class="line">    dinic();//暴力跑最大流</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-F-奇迹暖暖"><a href="#问题-F-奇迹暖暖" class="headerlink" title="问题 F: 奇迹暖暖"></a>问题 F: 奇迹暖暖</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=5&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1893" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1893&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1893&amp;getkey=5F0E1E84F3" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1893" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>梅拉抢走了绫罗的设计图，暖暖决定帮绫罗抢过来。于是梅拉和暖暖开始了搭配比赛。梅拉和暖暖各有n套衣服。由于暖暖是天才服装搭配师，且自带主角光环，又怎会输呢，（废话，输了你怎么通关啊）只不过暖暖为了让梅拉输的心服口服，决定狠狠虐梅拉一把。针对梅拉的n套衣服，暖暖的每套衣服i得分都比梅拉的任意一套衣服j得分高出score(ij)，0&lt;=score(ij)&lt;100000。然而每比完一场，他们之后的比赛都不能再用这套的衣服了。所以对于n场比赛，求出暖暖最高能比梅拉高多少分？（至少为0）</p>
<h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p>首行输入n(n&lt;=300)</p>
<p>接下来n行，第i行表示暖暖的第i套衣服，每行n个数，第j个数表示暖暖第i套衣服比梅拉第j套衣服的分高多少分。</p>
<p>0&lt;=score(ij)&lt;100000</p>
<h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p>输出一个整数，即最高高出多少分</p>
<h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">100 5</span><br><span class="line">20 23</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>
<p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=5&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1893" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1893&amp;getkey=5F0E1E84F3" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1893" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p>最大权二分图匹配。暖暖和梅拉构成二分图。每条边均有权值，最终求解二分匹配下的最大权值。二分图匹配除了网络流以外还有两道专门解二分图的算法，即匈牙利算法和KM算法。匈牙利算法一般解决二分图最大匹配问题，即边没有权值。而km算法一般解决有权值的二分图。本题为KM算法模板题。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=300+7;</span><br><span class="line">const int INF=0x3f3f3f3f;</span><br><span class="line">int n,nx,ny;</span><br><span class="line">int linker[N],lx[N],ly[N],slack[N];</span><br><span class="line">int visx[N],visy[N],w[N][N];</span><br><span class="line"></span><br><span class="line">int DFS(int x)&#123;</span><br><span class="line">    visx[x]=1;</span><br><span class="line">    for(int y=1;y&lt;=ny;y++)&#123;</span><br><span class="line">        if(visy[y])</span><br><span class="line">            continue;</span><br><span class="line">        int tmp=lx[x]+ly[y]-w[x][y];</span><br><span class="line">        if(tmp==0)&#123;</span><br><span class="line">            visy[y]=1;</span><br><span class="line">            if(linker[y]==-1 || DFS(linker[y]))&#123;</span><br><span class="line">                linker[y]=x;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(slack[y]&gt;tmp)&#123;</span><br><span class="line">            slack[y]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int KM()&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    memset(linker,-1,sizeof(linker));</span><br><span class="line">    memset(ly,0,sizeof(ly));</span><br><span class="line">    for(i=1;i&lt;=nx;i++)      //lx初始化为与它关联边中最大的</span><br><span class="line">        for(j=1,lx[i]=-INF;j&lt;=ny;j++)</span><br><span class="line">            if(w[i][j]&gt;lx[i])</span><br><span class="line">                lx[i]=w[i][j];</span><br><span class="line">    for(int x=1;x&lt;=nx;x++)&#123;</span><br><span class="line">        for(i=1;i&lt;=ny;i++)</span><br><span class="line">            slack[i]=INF;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            memset(visx,0,sizeof(visx));</span><br><span class="line">            memset(visy,0,sizeof(visy));</span><br><span class="line">            if(DFS(x))  //若成功（找到了增广轨），则该点增广完成，进入下一个点的增广</span><br><span class="line">                break;  //若失败（没有找到增广轨），则需要改变一些点的标号，使得图中可行边的数量增加。</span><br><span class="line">                        //方法为：将所有在增广轨中（就是在增广过程中遍历到）的X方点的标号全部减去一个常数d，</span><br><span class="line">                        //所有在增广轨中的Y方点的标号全部加上一个常数d</span><br><span class="line">            int d=INF;</span><br><span class="line">            for(i=1;i&lt;=ny;i++)</span><br><span class="line">                if(!visy[i] &amp;&amp; d&gt;slack[i])</span><br><span class="line">                    d=slack[i];</span><br><span class="line">            for(i=1;i&lt;=nx;i++)</span><br><span class="line">                if(visx[i])</span><br><span class="line">                    lx[i]-=d;</span><br><span class="line">            for(i=1;i&lt;=ny;i++)  //修改顶标后，要把所有不在交错树中的Y顶点的slack值都减去d</span><br><span class="line">                if(visy[i])</span><br><span class="line">                    ly[i]+=d;</span><br><span class="line">                else</span><br><span class="line">                    slack[i]-=d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(i=1;i&lt;=ny;i++)</span><br><span class="line">        if(linker[i]!=-1)</span><br><span class="line">            res+=w[linker[i]][i];</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">        nx=ny=n;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            for(int j=1;j&lt;=n;j++)</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;w[i][j]);</span><br><span class="line">        int ans=KM();</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-G-巨人也疯狂"><a href="#问题-G-巨人也疯狂" class="headerlink" title="问题 G: 巨人也疯狂"></a>问题 G: 巨人也疯狂</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 2  解决: 2<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=6&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1896" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1896&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1896&amp;getkey=53D9617A4C" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1896" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>人类发现巨人控制吃人的神经是由一些神经元和一些神经通道组成的，每个神经通道两端各有一个神经元，且这个通道是单向的。吃人信号从脑部神经元S发出到控制吃人的神经元T，S、T之间是一个有向无环图。人类想把某些神经通道切断达到S的信号无法传到T（由于神经元太小不容易砍掉，所以考虑神经元），每个神经通道由于位置不同也有砍断所需的力量。人类想知道如何花最小的力气而使S的信号传不到T。</p>
<h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>首行输入两个数，n，m，（n，m&lt;1000）。n代表包括s，t在内共有n个节点，1为s，n为t。</p>
<p>接下来m行，每行3个数，a，b，c，表示a到b的神经通路需要花费c力气。</p>
<h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>输出最小的力气。</p>
<h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 8</span><br><span class="line">1 2 2</span><br><span class="line">1 3 2</span><br><span class="line">2 4 2</span><br><span class="line">2 5 2</span><br><span class="line">3 5 2</span><br><span class="line">4 6 2</span><br><span class="line">6 7 2</span><br><span class="line">5 7 2</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=6&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1896" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1896&amp;getkey=53D9617A4C" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1896" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p>网络流最小割模板题。根据最小割最大流定理，求最小割问题即求最大流问题。用FF算法，EK算法，Dinic算法，SAP算法，预流推进，均可解。</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=200+7;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">int r[maxn][maxn]; //残留网络，初始化为原图</span><br><span class="line">bool visit[maxn];</span><br><span class="line">int pre[maxn];</span><br><span class="line">int m,n;</span><br><span class="line">bool bfs(int s,int t)  //寻找一条从s到t的增广路，若找到返回true</span><br><span class="line">&#123;</span><br><span class="line">    int p;</span><br><span class="line">    queue&lt;int &gt; q;</span><br><span class="line">    memset(pre,-1,sizeof(pre));</span><br><span class="line">    memset(visit,false,sizeof(visit));</span><br><span class="line"></span><br><span class="line">    pre[s]=s;</span><br><span class="line">    visit[s]=true;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        p=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(r[p][i]&gt;0&amp;&amp;!visit[i])</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i]=p;</span><br><span class="line">                visit[i]=true;</span><br><span class="line">                if(i==t) return true;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int EdmondsKarp(int s,int t)</span><br><span class="line">&#123;</span><br><span class="line">   int flow=0,d,i;</span><br><span class="line">   while(bfs(s,t))</span><br><span class="line">   &#123;</span><br><span class="line">       d=inf;</span><br><span class="line">       for(i=t;i!=s;i=pre[i])</span><br><span class="line">           d=d&lt;r[pre[i]][i]? d:r[pre[i]][i];</span><br><span class="line">       for(i=t;i!=s;i=pre[i])</span><br><span class="line">       &#123;</span><br><span class="line">           r[pre[i]][i]-=d;</span><br><span class="line">           r[i][pre[i]]+=d;</span><br><span class="line">       &#125;</span><br><span class="line">       flow+=d;</span><br><span class="line">   &#125;</span><br><span class="line">   return flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v,w;</span><br><span class="line">        memset(r,0,sizeof(r));</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            r[u][v]+=w;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;EdmondsKarp(0,n)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-H-过河拆桥"><a href="#问题-H-过河拆桥" class="headerlink" title="问题 H: 过河拆桥"></a>问题 H: 过河拆桥</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=7&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1891" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1891&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1891&amp;getkey=EC9961F440" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1891" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>猴子是一种自私的动物。动物世界由河流分成了n个岛屿。这天，猴子在a1岛屿上望见an岛屿上有一片桃林。a1到an之间有n-2个岛屿，分别是a2——an-1。岛屿之间共有m坐桥，每座桥都有一定的距离。现在猴子通过这些桥从a1走到了an，然而由于猴子怕其他动物也过去享受那片桃林，于是每走一座桥都会拆一座桥。终于到了an，吃完桃子后，正直涨潮，于是他必须马上回到a1，由于之前走过的桥被拆了，所以只能寻找一条新的路回到a1。请问猴子从a1到an，再从an回到a1的最短路径是多少。</p>
<h2 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h2><p>首行输入nm（n&lt;=1000m&lt;=10000）</p>
<p>接下来m行，每行三个数x，y，z，代表ax岛与ay岛之间有桥，距离是z。（z&lt;=35000）</p>
<h2 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h2><p>输出一个整数，为最短距离。</p>
<h2 id="样例输入-7"><a href="#样例输入-7" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">2 3 1</span><br><span class="line">2 4 2</span><br><span class="line">1 2 1</span><br><span class="line">3 4 1</span><br><span class="line">1 3 2</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-7"><a href="#样例输出-7" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=7&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1891" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1891&amp;getkey=EC9961F440" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1891" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h2><p>最小费用最大流问题。本题可以转化为从1到n找两条不重边的路，使得这两条路的距离之和加起来相对于其他方案来说最小。转化成功之后就是建模过程。首先以1为源点，n为汇点。边的长度就是每条边的费用，每条边的容量为1。由于我们要找两条路到达t，那么我们s点的流量就必须是2，这样流到t点的最大流最大为2，为1证明无解，为2即有解。然而由于源点流量一般无限大，那么我们只需再建立一个超级源点sss，和源点s相连，且容量为2，当然sss到s的费用为0。建完模之后我们就可以用最小费用最大流模板代码求解了。</p>
<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+7;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    int to,cap,cost ,rev;</span><br><span class="line">&#125;;</span><br><span class="line">int V;</span><br><span class="line">vector&lt;edge&gt;G[maxn];</span><br><span class="line">int dist[maxn];</span><br><span class="line">int prevv[maxn],preve[maxn];</span><br><span class="line">void add(int from,int to,int cap,int cost)</span><br><span class="line">&#123;</span><br><span class="line">    edge e,w;</span><br><span class="line">    e.to=to;</span><br><span class="line">    e.cap=cap;</span><br><span class="line">    e.cost=cost;</span><br><span class="line">    e.rev=G[to].size();</span><br><span class="line">    G[from].push_back(e);</span><br><span class="line">    w.to=from;</span><br><span class="line">    w.cap=0;</span><br><span class="line">    w.cost=-cost;</span><br><span class="line">    w.rev=G[from].size()-1;</span><br><span class="line">    G[to].push_back(w);</span><br><span class="line">&#125;</span><br><span class="line">int min_ans(int s,int t,int f)</span><br><span class="line">&#123;</span><br><span class="line">    int res=0;</span><br><span class="line"></span><br><span class="line">    while(f&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0; i&lt;V; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[i]=inf;</span><br><span class="line">        &#125;</span><br><span class="line">        dist[s]=0;</span><br><span class="line">        bool update=true;</span><br><span class="line">        while(update)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            update=false;</span><br><span class="line">            for(int v=0; v&lt;V; v++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(dist[v]==inf)</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                for(int i=0; i&lt;G[v].size(); i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    edge &amp;e=G[v][i];</span><br><span class="line">                    if(e.cap&gt;0&amp;&amp;dist[e.to]&gt;dist[v]+e.cost)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dist[e.to]=dist[v]+e.cost;</span><br><span class="line">                        prevv[e.to]=v;</span><br><span class="line">                        preve[e.to]=i;</span><br><span class="line">                        update=true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(dist[t]==inf)</span><br><span class="line">            return -1;</span><br><span class="line">        int d=f;</span><br><span class="line">        for(int v=t; v!=s; v=prevv[v])</span><br><span class="line">        &#123;</span><br><span class="line">            d=min(d,G[prevv[v]][preve[v]].cap);</span><br><span class="line">        &#125;</span><br><span class="line">        f-=d;</span><br><span class="line">        res+=d*dist[t];</span><br><span class="line">        for(int v=t; v!=s; v=prevv[v])</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e =G[prevv[v]][preve[v]];</span><br><span class="line">            e.cap-=d;</span><br><span class="line">            G[v][e.rev].cap+=d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int N,M;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    int a,b,c;</span><br><span class="line">    while(cin&gt;&gt;N&gt;&gt;M)</span><br><span class="line">    &#123;</span><br><span class="line">        V=N;</span><br><span class="line">        for(int i=0; i&lt;=N; i++)</span><br><span class="line">            G[i].clear();</span><br><span class="line">        for(int i=0; i&lt;M; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            a--;</span><br><span class="line">            b--;</span><br><span class="line">            add(a,b,1,c);</span><br><span class="line">            add(b,a,1,c);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,min_ans(0,N-1,2));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-I-植物大战僵尸"><a href="#问题-I-植物大战僵尸" class="headerlink" title="问题 I: 植物大战僵尸"></a>问题 I: 植物大战僵尸</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=8&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1889" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1889&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1889&amp;getkey=31996BAC1B" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1889" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和Zombies（僵尸）是游戏的主角，其中Plants防守，而Zombies进攻。该款游戏包含多种不同的挑战系列，比如Protect Your Brain、Bowling等等。其中最为经典的，莫过于玩家通过控制Plants来防守Zombies的进攻，或者相反地由玩家通过控制Zombies对Plants发起进攻。</p>
<p>现在，我们将要考虑的问题是游戏中Zombies对Plants的进攻，请注意，本题中规则与实际游戏有所不同。游戏中有两种角色，Plants和Zombies，每个Plant有一个攻击位置集合，它可以对这些位置进行保护；而Zombie进攻植物的方式是走到植物所在的位置上并将其吃掉。</p>
<p>游戏的地图可以抽象为一个N行M列的矩阵，行从上到下用0到N–1编号，列从左到右用0到M–1编号；在地图的每个位置上都放有一个Plant，为简单起见，我们把位于第r行第c列的植物记为Pr c。</p>
<p>Plants分很多种，有攻击类、防守类和经济类等等。为了简单的描述每个Plant，定义Score和Attack如下：</p>
<p>Score[Pr c]</p>
<p>Zombie击溃植物Pr c可获得的能源。若Score[Pr c]为非负整数，则表示击溃植物Pr c可获得能源Score[Pr c]，若为负数表示击溃Pr c需要付出能源 -Score[Pr c]。</p>
<p>Attack[Pr c]</p>
<p>植物Pr c能够对Zombie进行攻击的位置集合。</p>
<p>Zombies必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此Zombies的进攻总是从地图的右侧开始。也就是说，对于第r行的进攻，Zombies必须首先攻击Pr M-1；若需要对Pr c（0≤c&lt;M-1）攻击，必须将PrM-1 Pr M-2 … Pr c+1先击溃，并移动到位置(r c)才可进行攻击。</p>
<p>在本题的设定中，Plants的攻击力是无穷大的，一旦Zombie进入某个Plant的攻击位置，该Zombie会被瞬间消灭，而该Zombie没有时间进行任何攻击操作。因此，即便Zombie进入了一个Plant所在的位置，但该位置属于其他植物的攻击位置集合，则Zombie会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。</p>
<p>Zombies的目标是对Plants的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套Zombies的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。</p>
<h2 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h2><p>输入的第一行包含两个整数N M，分别表示地图的行数和列数。</p>
<p>接下来N×M行描述每个位置上植物的信息。第r×M + c + 1行按照如下格式给出植物Pr c的信息：第一个整数为Score[Pr c] 第二个整数为集合Attack[Pr c]中的位置个数w，接下来w个位置信息（r’ c’），表示Pr c可以攻击位置第r’ 行第c’ 列。</p>
<h2 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h2><p>输出仅包含一个整数，表示可以获得的最大能源收入。注意，你也可以选择不进行任何攻击，这样能源收入为0。</p>
<h2 id="样例输入-8"><a href="#样例输入-8" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">10 0</span><br><span class="line">20 0</span><br><span class="line">-10 0</span><br><span class="line">-5 1 0 0</span><br><span class="line">100 1 2 1</span><br><span class="line">100 0</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-8"><a href="#样例输出-8" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure>
<p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=8&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1889" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1889&amp;getkey=31996BAC1B" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1889" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h2><p>最大权闭合图问题。最大权闭合图转化为最小割问题，再由最小割转化成最大流问题。课件上有详解。</p>
<p>（本题作为NOI的考试题，同时也是今天十道题中最难的一道题，是不是顿时感觉到了自己与高中生们的差距(ó﹏ò｡)ε=(´ο｀*)))唉）</p>
<h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">#define M 1000</span><br><span class="line">using namespace std;</span><br><span class="line">int now,tot,s,t,va[M],du[M],H[M],h[M],ok[M],d[M],v[M],cur[M];</span><br><span class="line">int n,m;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">struct edge1</span><br><span class="line">&#123;</span><br><span class="line">	int x,y,ne;</span><br><span class="line">&#125;e[500000];</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">	int from,to,cap,flow,ne;</span><br><span class="line">&#125;E[500000];</span><br><span class="line">int C(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">	return (x-1)*m+y;</span><br><span class="line">&#125;</span><br><span class="line">void Add(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">	e[++tot].y=y;</span><br><span class="line">	e[tot].x=x;</span><br><span class="line">	e[tot].ne=H[x];</span><br><span class="line">	H[x]=tot;</span><br><span class="line">	du[y]++;</span><br><span class="line">&#125;</span><br><span class="line">void Addedge(int from,int to,int cap)</span><br><span class="line">&#123;</span><br><span class="line">	E[++tot]=(edge)&#123;from,to,cap,0,h[from]&#125;;</span><br><span class="line">	h[from]=tot;</span><br><span class="line">	E[++tot]=(edge)&#123;to,from,0,0,h[to]&#125;;</span><br><span class="line">	h[to]=tot;</span><br><span class="line">&#125;</span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">	for (int i=s;i&lt;=t;i++)</span><br><span class="line">		v[i]=0;</span><br><span class="line">	v[s]=1;</span><br><span class="line">	d[s]=0;</span><br><span class="line">	q.push(s);</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		int x=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		for (int i=h[x];i;i=E[i].ne)</span><br><span class="line">		&#123;</span><br><span class="line">			edge e=E[i];</span><br><span class="line">			if (!v[e.to]&amp;&amp;e.cap&gt;e.flow)</span><br><span class="line">			&#123;</span><br><span class="line">				v[e.to]=1;</span><br><span class="line">				d[e.to]=d[x]+1;</span><br><span class="line">				q.push(e.to);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return v[t];</span><br><span class="line">&#125;</span><br><span class="line">int dfs(int x,int a)</span><br><span class="line">&#123;</span><br><span class="line">	if (x==t||!a) return a;</span><br><span class="line">	int flow=0;</span><br><span class="line">	for (int &amp;i=cur[x];i;i=E[i].ne)</span><br><span class="line">	&#123;</span><br><span class="line">		edge &amp;e=E[i];</span><br><span class="line">		if (d[e.to]!=d[x]+1) continue;</span><br><span class="line">		int f=dfs(e.to,min(a,e.cap-e.flow));</span><br><span class="line">		if (f)</span><br><span class="line">		&#123;</span><br><span class="line">			flow+=f;</span><br><span class="line">			a-=f;</span><br><span class="line">			e.flow+=f;</span><br><span class="line">			E[i^1].flow-=f;</span><br><span class="line">			if (!a) break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return flow;</span><br><span class="line">&#125;</span><br><span class="line">int dinic()</span><br><span class="line">&#123;</span><br><span class="line">	int flow=0;</span><br><span class="line">	while (bfs())</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i=s;i&lt;=t;i++)</span><br><span class="line">			cur[i]=h[i];</span><br><span class="line">		flow+=dfs(s,inf);</span><br><span class="line">	&#125;</span><br><span class="line">	return flow;</span><br><span class="line">&#125;</span><br><span class="line">void Topsort()</span><br><span class="line">&#123;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	for (int i=1;i&lt;=now;i++)</span><br><span class="line">		if (!du[i]) ok[i]=1,q.push(i);</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		int x=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		for (int i=H[x];i;i=e[i].ne)</span><br><span class="line">		&#123;</span><br><span class="line">			int y=e[i].y;</span><br><span class="line">			du[y]--;</span><br><span class="line">			if (!du[y])</span><br><span class="line">			&#123;</span><br><span class="line">				ok[y]=1;</span><br><span class="line">				q.push(y);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">	for (int i=1;i&lt;=n;i++)</span><br><span class="line">		for (int j=1;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			now++;</span><br><span class="line">			int w;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;va[now],&amp;w);</span><br><span class="line">			for (int k=1;k&lt;=w;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				int x,y;</span><br><span class="line">				scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">				x++,y++;</span><br><span class="line">				Add(now,C(x,y));</span><br><span class="line">			&#125;</span><br><span class="line">			if (j!=m) Add(now+1,now);</span><br><span class="line">		&#125;</span><br><span class="line">	Topsort();</span><br><span class="line">	s=0,t=now+1;</span><br><span class="line">	int ans=0;</span><br><span class="line">	tot=1;</span><br><span class="line">	for (int x=1;x&lt;=now;x++)</span><br><span class="line">		if (ok[x])</span><br><span class="line">		&#123;</span><br><span class="line">			if (va[x]&gt;0) ans+=va[x],Addedge(s,x,va[x]);</span><br><span class="line">			else Addedge(x,t,-va[x]);</span><br><span class="line">			for (int i=H[x];i;i=e[i].ne)</span><br><span class="line">			&#123;</span><br><span class="line">				int y=e[i].y;</span><br><span class="line">				if (ok[y])</span><br><span class="line">					Addedge(y,x,inf);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	cout&lt;&lt;ans-dinic()&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-J-Pigs"><a href="#问题-J-Pigs" class="headerlink" title="问题 J: Pigs"></a>问题 J: Pigs</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 2  解决: 2<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=9&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1887" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1887&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1887&amp;getkey=874A405F35" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1887" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>Mirko works on a pig farm that consists of M locked pig-houses and Mirko can’t unlock any pighouse because he doesn’t have the keys. Customers come to the farm one after another. Each of them has keys to some pig-houses and wants to buy a certain number of pigs.<br>All data concerning customers planning to visit the farm on that particular day are available to Mirko early in the morning so that he can make a sales-plan in order to maximize the number of pigs sold.<br>More precisely the procedure is as following: the customer arrives opens all pig-houses to which he has the key Mirko sells a certain number of pigs from all the unlocked pig-houses to him and if Mirko wants he can redistribute the remaining pigs across the unlocked pig-houses.<br>An unlimited number of pigs can be placed in every pig-house.<br>Write a program that will find the maximum number of pigs that he can sell on that day.</p>
<h2 id="输入-9"><a href="#输入-9" class="headerlink" title="输入"></a>输入</h2><p>The first line of input contains two integers M and N 1 &lt;= M &lt;= 1000 1 &lt;= N &lt;= 100 number of pighouses and number of customers. Pig houses are numbered from 1 to M and customers are numbered from 1 to N.<br>The next line contains M integeres for each pig-house initial number of pigs. The number of pigs in each pig-house is greater or equal to 0 and less or equal to 1000.<br>The next N lines contains records about the customers in the following form ( record about the i-th customer is written in the (i+2)-th line):<br>A K1 K2 … KA B It means that this customer has key to the pig-houses marked with the numbers K1 K2 … KA (sorted nondecreasingly ) and that he wants to buy B pigs. Numbers A and B can be equal to 0.</p>
<h2 id="输出-9"><a href="#输出-9" class="headerlink" title="输出"></a>输出</h2><p>The first and only line of the output should contain the number of sold pigs.</p>
<h2 id="样例输入-9"><a href="#样例输入-9" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">3 1 10</span><br><span class="line">2 1 2 2</span><br><span class="line">2 1 3 3</span><br><span class="line">1 2 6</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-9"><a href="#样例输出-9" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=9&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1887" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1887&amp;getkey=874A405F35" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1887" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h2><p>课件上有建模讲解。</p>
<h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=107,M=1007,INF=0x3f3f3f3f;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    char c=getchar();int x=0,f=1;</span><br><span class="line">    while(c&lt;&apos;0&apos;||c&gt;&apos;9&apos;)&#123;if(c==&apos;-&apos;)f=-1; c=getchar();&#125;</span><br><span class="line">    while(c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;)&#123;x=x*10+c-&apos;0&apos;; c=getchar();&#125;</span><br><span class="line">    return x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int m,n,s,t;</span><br><span class="line">int pig[M],now[M];</span><br><span class="line">struct edge&#123;</span><br><span class="line">    int v,c,f,ne;</span><br><span class="line">&#125;e[N*M&lt;&lt;1];</span><br><span class="line">int cnt,h[N];</span><br><span class="line">inline void ins(int u,int v,int c)&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    e[cnt].v=v;e[cnt].c=c;e[cnt].f=0;e[cnt].ne=h[u];h[u]=cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">    e[cnt].v=u;e[cnt].c=0;e[cnt].f=0;e[cnt].ne=h[v];h[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">int q[N],head,tail,vis[N],d[N];</span><br><span class="line">bool bfs()&#123;</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    memset(d,0,sizeof(d));</span><br><span class="line">    head=tail=1;</span><br><span class="line">    d[s]=0;vis[s]=1;</span><br><span class="line">    q[tail++]=s;</span><br><span class="line">    while(head!=tail)&#123;</span><br><span class="line">        int u=q[head++];</span><br><span class="line">        for(int i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">            int v=e[i].v;</span><br><span class="line">            if(!vis[v]&amp;&amp;e[i].c&gt;e[i].f)&#123;</span><br><span class="line">                vis[v]=1;</span><br><span class="line">                d[v]=d[u]+1;</span><br><span class="line">                q[tail++]=v;</span><br><span class="line">                if(v==t) return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int cur[N];</span><br><span class="line">int dfs(int u,int a)&#123;</span><br><span class="line">    if(u==t||a==0) return a;</span><br><span class="line">    int flow=0,f;</span><br><span class="line">    for(int &amp;i=cur[u];i;i=e[i].ne)&#123;</span><br><span class="line">        int v=e[i].v;</span><br><span class="line">        if(d[v]==d[u]+1&amp;&amp;(f=dfs(v,min(a,e[i].c-e[i].f)))&gt;0)&#123;</span><br><span class="line">            flow+=f;</span><br><span class="line">            e[i].f+=f;</span><br><span class="line">            e[((i-1)^1)+1].f-=f;</span><br><span class="line">            a-=f;</span><br><span class="line">            if(a==0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int dinic()&#123;</span><br><span class="line">    int flow=0;</span><br><span class="line">    while(bfs())&#123;</span><br><span class="line">        for(int i=s;i&lt;=t;i++) cur[i]=h[i];</span><br><span class="line">        flow+=dfs(s,INF);</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    m=read();</span><br><span class="line">    n=read();</span><br><span class="line">    s=0;</span><br><span class="line">    t=n+1;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">    	pig[i]=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int A=read(),B,x;</span><br><span class="line">        while(A--)&#123;</span><br><span class="line">            x=read();</span><br><span class="line">            if(!now[x]) ins(s,i,pig[x]),now[x]=i;</span><br><span class="line">            else ins(now[x],i,INF),now[x]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        B=read();</span><br><span class="line">        ins(i,t,B);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,dinic());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>匹配</tag>
        <tag>二分图</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>最小费用最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>进击的网络流</title>
    <url>/2018/08/22/2018-08-22/</url>
    <content><![CDATA[<p>内容：网络流</p>
<p>网络流：2018-8-23</p>
<p>课件：by.浅悠悠</p>
<p>主讲人：王骏</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%871.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%872.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%873.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%874.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%875.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%876.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%877.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%878.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%879.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8710.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8711.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8712.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8713.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8714.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8715.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8716.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8717.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8718.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8719.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8720.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8721.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8722.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8723.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8724.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8725.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8726.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8727.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8728.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8729.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8730.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8731.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8732.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8733.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8734.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8735.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8736.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8737.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8738.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8739.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8740.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8741.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8742.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8743.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8744.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8745.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8746.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8747.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8748.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8749.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8750.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8751.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8752.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8753.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8754.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8755.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8756.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8757.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8758.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8759.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8760.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8761.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8762.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8763.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8764.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8765.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8766.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8767.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8768.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8769.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8770.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8771.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8772.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8773.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8774.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8775.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8776.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8777.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8778.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8779.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8780.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8781.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8782.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8783.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8784.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8785.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8786.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8787.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8788.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8789.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8790.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8791.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8792.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8793.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8794.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8795.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8796.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8797.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8798.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%8799.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87100.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87101.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87102.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87103.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87104.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87105.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87106.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87107.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87108.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87109.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87110.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87111.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87112.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87113.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87114.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87115.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87116.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87117.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87118.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87119.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87120.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87121.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87122.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87123.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87124.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87125.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87126.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87127.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87128.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87129.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87130.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87131.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87132.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87133.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87134.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87135.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87136.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87137.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87138.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87139.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87140.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87141.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87142.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87143.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87144.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87145.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87146.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87147.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87148.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87149.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87150.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87151.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87152.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87153.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87154.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87155.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87156.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87157.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87158.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87159.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-8-21/%E5%B9%BB%E7%81%AF%E7%89%87160.jpg" alt></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>预流推进</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title>图论3(网络流 + 二分图 + 匹配)</title>
    <url>/2018/08/19/2018-08-19/</url>
    <content><![CDATA[<h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>最大流问题的解决一般基于两种方法，即<strong>增广路算法</strong>与<strong>预流推进算法</strong>。</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>一个连通的赋权有向图D=（V、E、C），其中V是该图的顶点集，E是有向边(即弧)集，C是弧上的容量。此外顶点集中包括一个起点和一个终点。</p>
<h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>网络上的流就是由起点流向终点的可行流</p>
<h3 id="正方向"><a href="#正方向" class="headerlink" title="正方向"></a>正方向</h3><p>设P为容量网络中源点到汇点的一条链，由源点s到汇点t的方向就为正方向。</p>
<h3 id="残量网络"><a href="#残量网络" class="headerlink" title="残量网络"></a>残量网络</h3><p>在一个图中，<strong>残留网络</strong>指在既有的容量和已具备的流量条件下，网络中仍然可以继续增大流量的边所组成的网络。</p>
<h3 id="增广路经"><a href="#增广路经" class="headerlink" title="增广路经"></a>增广路经</h3><p>在残留网络中的一条从源点s流向汇点t的路径叫做一条<strong>增广路。</strong></p>
<h3 id="割"><a href="#割" class="headerlink" title="割"></a>割</h3><p>图的<strong>割</strong>可以用来表示对图的一个划分，将原图 G=(V,E)的顶点集 V 分为 S、T 两部分，让源点 s 在 S 中，汇点 t 在 T 中，能够通过 S、T 间的最大净流量为割(S,T)的容量，<strong>最小割</strong>为图中具有最小容量的割。</p>
<h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><h3 id="增广路算法"><a href="#增广路算法" class="headerlink" title="增广路算法"></a>增广路算法</h3><p>利用不断寻找增广路并在其上对流量进行更新的方法寻找网络的最大流。</p>
<p>每次用BFS找一条最短的增广路径，然后沿着这条路径修改流量值（实际修改的是残量网络的边权）。当没有增广路时，算法停止，此时的流就是最大流。</p>
<h3 id="最大流最小割定理："><a href="#最大流最小割定理：" class="headerlink" title="最大流最小割定理："></a>最大流最小割定理：</h3><p>在网络的一个流量状态下，通过图的任意一个割的流量都与该流量相同，所以具有最小容量的割的的容量就是该图的流量的最大值即最大流。</p>
<h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><h2 id="有上下界的最大流"><a href="#有上下界的最大流" class="headerlink" title="有上下界的最大流"></a>有上下界的最大流</h2><h2 id="二分图网络流匹配"><a href="#二分图网络流匹配" class="headerlink" title="二分图网络流匹配"></a>二分图网络流匹配</h2>]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>匹配</tag>
        <tag>二分图</tag>
        <tag>匈牙利算法</tag>
        <tag>KM算法</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年我们一起学过的线性代数</title>
    <url>/2018/08/17/2018-08-17/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>矩阵论</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数学1（排列组合 + 鸽巢原理 + 容斥原理）</title>
    <url>/2018/08/16/2018-08-16/</url>
    <content><![CDATA[<h1 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h1><h2 id="加法-乘法法则"><a href="#加法-乘法法则" class="headerlink" title="加法/乘法法则"></a>加法/乘法法则</h2><h3 id="加法法则"><a href="#加法法则" class="headerlink" title="加法法则"></a>加法法则</h3><p>相互独立的事件 A、B 分别有 k 和 l 种方法产生，则产生 A 或 B 的方法数为 k+l 种。</p>
<h4 id="集合论定义"><a href="#集合论定义" class="headerlink" title="集合论定义"></a>集合论定义</h4><p>若|A|=k，|B|=l ，且A∩B=Φ ，则|A∪B| = k+l 。</p>
<p>S = S1 ∪ S2 ∪ · · · ∪ Sm,    Si ∩ Sj = ∅ (i ≠ j)</p>
<p>⇒</p>
<p>|S| = |S1| + |S2| + · · · + |Sm|。</p>
<h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p>a食堂有3种汉堡，b食堂有4种小吃，c食堂有2种包子，你的早餐只想吃一种，共有多少种选择方法？</p>
<p>解：</p>
<p>设S是所有食物的集合，Si是第i类食物的集合(i=1,2,3)，显然，Si∩Sj=Φ (i≠j) ，根据加法法则有：</p>
<p>|S| = |S1| + |S2| + |S3| = 3 + 4 + 2 = 9。</p>
<h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p>大于0小于10的奇偶数有多少个？</p>
<p>解：</p>
<p>设S是符合条件数的集合，S1、S2分别是符合条件的奇数、偶数集合，显然，S1∩S2=Φ ，根据加法法则有：</p>
<p>|S| = |S1| + |S2| = 5 + 4 = 9。</p>
<h3 id="乘法法则"><a href="#乘法法则" class="headerlink" title="乘法法则"></a>乘法法则</h3><p>相互独立的事件 A、B 分别有 k 和 l 种方法产生，则选取A以后再选取B 的方法数为 k×l 种。</p>
<h4 id="集合论定义-1"><a href="#集合论定义-1" class="headerlink" title="集合论定义"></a>集合论定义</h4><p>若|A|=k，|B|=l ，A×B={(a,b)|a∈A，b∈B}，则|A×B| = k×l 。</p>
<p>S = P × Q </p>
<p>⇒</p>
<p>|S| = |P | × |Q|。</p>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>从A 地到B地有二条不同的道路，从B地到C地有四条不同的道路，而从C地到D地有三条不同的道路。求从A地经B、C两地到达D地的道路数。</p>
<p>解：</p>
<p>设S是所求的道路数集合，S1、S2、S3分别是从A到B、从B到C、从C到D的道路集合，根据乘法法则有</p>
<p>|S| = |S1 | × |S2| × |S3| = 2 × 4 × 3 = 24。</p>
<h3 id="计数问题的分类"><a href="#计数问题的分类" class="headerlink" title="计数问题的分类"></a>计数问题的分类</h3><p>有序安排或有序选择</p>
<p>​      ——允许重复/不允许重复</p>
<p>无序安排或无序选择</p>
<p>​      ——允许重复/不允许重复</p>
<h4 id="重集的概念"><a href="#重集的概念" class="headerlink" title="重集的概念"></a>重集的概念</h4><p>标准集的特性：确定、无序、相异等。</p>
<p>重集：B={k1 <em> b1, k2 </em> b2, …, kn * bn}，其中：bi为n个互不相同的元素，称 ki为bi的重数， i = 1, 2, …, n，n=1,2,…, ∞，ki = 1, 2, …, ∞。</p>
<h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><h3 id="线排列"><a href="#线排列" class="headerlink" title="线排列"></a>线排列</h3><p>从n个不同元素中，取r个(0≤r≤n)按一定顺序排列起来，其排列数P(n,r)。</p>
<h4 id="集合论定义-2"><a href="#集合论定义-2" class="headerlink" title="集合论定义"></a>集合论定义</h4><p>设A={an} ，从A中选择r个(0≤r≤n)元素排列起来，A的r−有序子集，A的r−排列。</p>
<h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p>若n, r∈Z且n≥r≥0, P(n,r)=n!/(n-r)!。</p>
<p>若n=r，称全排列P(n,n)= n!；</p>
<p>若n＜r, P(n,r)=0；</p>
<p>若r=0, P(n,r)=1。</p>
<h5 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h5><p>构造集合A的r−排列时，可以从A的n各元素中任选一个作为排列的第一项，有n种选法；第一项选定后从剩下的n-1个元素中选排列的第二项有n-1种选法；…由此类推，第r项有n-r+1种选法。根据乘法原理有：</p>
<p>P(n,r) = n(n-1)……(n-r+1) = n!/(n-r)! 。</p>
<h4 id="推论1"><a href="#推论1" class="headerlink" title="推论1"></a>推论1</h4><p>若n, r∈N且n≥r≥2，则P(n,r)=n×P(n-1,r-1) 。</p>
<h5 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h5><p>在集合A的n个元素中，任一个元素都可以排在它的r−排列首位，故首位有n种取法；首位取定后，其他位置的元素正好是从A的另n-1个元素中取r-1个的排列，因此有P(n-1,r-1)种取法。由乘法法则有：</p>
<p>P(n,r)=n×P(n-1,r-1)</p>
<h4 id="推论2"><a href="#推论2" class="headerlink" title="推论2"></a>推论2</h4><p>若n, r∈N且n≥r≥2，则P(n,r)= r×P(n-1,r-1)+P(n-1,r) 。</p>
<h5 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h5><p>当r≥2时，把集合A的r−排列分为两大类：一类包含A中的某个固定元素，不妨设为a1，另一类不包含a1 。第一类排列相当于先从A-{a1}中取r-1个元素进行排列，有P(n-1,r-1)种取法，再将a1放入每一个上述排列中，对任一排列，a1都有r种放法。由乘法法则，第一类排列共有r×P(n-1,r-1)个。第二类排列实质上是A-{a1}的r−排列，共有P(n-1,r)个。再由加法法则有：</p>
<p>P(n,r)= r×P(n-1,r-1)+P(n-1,r)</p>
<h4 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h4><p>由数字1,2,3,4,5可以构成多少个所有数字互不相同的四位数？</p>
<p>解：</p>
<p>由于所有的四位数字互不相同，故每一个四位数就是集合{1,2,3,4,5}的一个4−排列，因而所求的四位数个数为</p>
<p>P(5,4)=5!/(5-4)!=120。</p>
<h4 id="例2-1"><a href="#例2-1" class="headerlink" title="例2"></a>例2</h4><p>将具有9个字母的单词FRAGMENTS进行排列，要求字母A总是紧跟在字母R的右边，问有多少种这样的排法？如果再要求字母M和N必须相邻呢？</p>
<p>解：</p>
<p>由于A总是R的右边，故这样的排列相当于是8个元素的集合{F,RA,G,M,E,N,T,S}的一个全排列，个数为</p>
<p>P(8,8) = 8! = 40320。</p>
<p>如果再要求M和N必须相邻，可先把M和N看成一个整体={M,N}，进行7个元素的集合{F,RA,G,E,T,S,}的全排列，在每一个排列中再进行 {M,N}的全排列，由乘法法则，排列个数为</p>
<p>P(7,7) <em> P(2,2) = 7! </em> 2! = 10080。</p>
<h4 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h4><p>有多少个5位数，每位数字都不相同，不能取0，且数字7和9不能相邻？</p>
<p>解：</p>
<p>由于所有的5位数字互不相同，且不能取0，故每一个5位数就是集合{1,2,…,9}的一个5-排列，其排列数为P(9,5)，其中7和9相邻的排列数为[c(7,3)4!2]4×2×P(7,3)，满足题目要求的5位数个数为</p>
<p>P(9,5) - 4 <em> 2 </em> P(7,3) = 15120 -1680 = 13440</p>
<h3 id="圆排列"><a href="#圆排列" class="headerlink" title="圆排列"></a>圆排列</h3><p>设A={an} ，从A中取r个(0≤r≤n)元素按某种顺序（如逆时针）排成一个圆圈，称为圆排列（循环排列）。</p>
<h4 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h4><p>设A={an}，A的r圆排列个数为P(n,r)/r。</p>
<h5 id="证明-3"><a href="#证明-3" class="headerlink" title="证明"></a>证明</h5><p>由于把一个圆排列旋转所得到另一个圆排列视为相同的圆排列，因此线排列a1a2…ar，a2a3…ara1，… ara1a2…ar-1在圆排列中是一个，即一个圆排列可产生r个不同的线排列；同理， r个不同的线排列对应一个圆排列。而总共有P(n,r)个线排列，故圆排列的个数为</p>
<p>​                              P(n,r)/r= n!/(r×(n-r)!)</p>
<h4 id="例1-2"><a href="#例1-2" class="headerlink" title="例1"></a>例1</h4><p>有8人围圆桌就餐，问有多少种就座方式？如果有两人不愿坐在一起，又有多少种就座方式？</p>
<p>解：</p>
<p>由上述定理知8人围圆桌就餐，有8!/8=7!=5040种就座方式。</p>
<p>又有两人不愿坐在一起，不妨设此二人为A、B，当A、B坐在一起时，相当于7人围圆桌就餐，有7!/7=6!种就座方式。 而A、B坐在一起时，又有两种情况，或者A在B的左面，或者A在B的右面，因此A、B坐在一起时，共有2×6!种就座方式，因此如果有两人不愿坐在一起，就座方式为</p>
<p>7!-2×6!= 5×6!=3600</p>
<h4 id="例2-2"><a href="#例2-2" class="headerlink" title="例2"></a>例2</h4><p>4男4女围圆桌交替就座有多少种就座方式？</p>
<p>解：</p>
<p>显然，这是一个圆排列问题。首先让4个男的围圆桌就座，有4!/4=3!种就座方式。 因为要求男女围圆桌交替就座，在男的坐定后，两两之间均需留有一个空位，女的就座相当于一个4元素集合的全排列，就座方式数为4!。由乘法法则知，就座方式数为</p>
<p>3!×4!=144</p>
<h3 id="重排列"><a href="#重排列" class="headerlink" title="重排列"></a>重排列</h3><p>从n个不同元素中，可重复选取r个按一定顺序排列起来，称为重排列。</p>
<h4 id="集合论定义-3"><a href="#集合论定义-3" class="headerlink" title="集合论定义"></a>集合论定义</h4><p>从重集B={k1 <em> b1, k2 </em> b2, … , kn * bn}中选取r个按一定顺序排列起来。</p>
<h4 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h4><p>重集B={∞ <em> b1, ∞ </em> b2, … , ∞ * bn} 的r−排列的个数为nr。</p>
<h5 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h5><p>构造B的r−排列如下：选择第一项时可从n个元素中任选一个，有n种选法，选择第二项时由于可以重复选取，仍有n种选法，…，同理，选择第r项时仍有n种选法，根据乘法法则，可得出r−排列的个数为nr。</p>
<h4 id="例1-3"><a href="#例1-3" class="headerlink" title="例1"></a>例1</h4><p>由数字1,2,3,4,5,6这六个数字能组成多少个五位数？又可组成多少大于34500的五位数？</p>
<p>解：</p>
<p>一个五位数的各位数字可重复出现，是一个典型的重排列问题，相当于重集B={∞ <em> 1,∞ </em> 2,…,∞*6}的5−排列，所求的五位数个数为6^5=7776。</p>
<p>大于34500的五位数可由下面三种情况组成：</p>
<p>万位选4,5,6中的一个，其余4位相当于重集B的4−排列，由乘法法则知，共有3×6^4个五位数；</p>
<p>万位是3，千位5,6中的一个，其余3位相当于重集B的3−排列，由乘法法则知，共有2×6^3个五位数；</p>
<p>万位是3，千位4中的一个，百位选5,6中的一个，其余2位相当于重集B的2−排列，由乘法法则知，共有2×6^2个五位数；</p>
<p>由加法法则知，大于34500的五位数个数为3×6^4 + 2×6^3 + 2×6^2=4392</p>
<h4 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h4><p>重集B={n1 <em> b1,n2 </em> b2,…,nk <em> bk}的全排列个数为n! / ( n1! </em> n2! <em> …… </em> nk! )，其中，n = n1 + n2 +…… +nk。</p>
<h5 id="证明：-1"><a href="#证明：-1" class="headerlink" title="证明："></a>证明：</h5><p>将B中的ni个bi看作不同的ni个元素，赋予上标1,2,…, ni，即b(1,i),b(2,i)……,b(ni,i), i=1, 2,…… k，如此，重集B就变成具有n1+n2+…+nk=n个不同的元素集合A = {b(1,1),b(2,1)……,b(n1,1),b(1,2),b(2,2)……,b(n2,2),……b(1,k),b(2,k)……,b(nk,k,}</p>
<p>显然，集合A的全排列个数为n!。又由于ni个bi赋予上标的方法有ni!种，于是对重集B的任一个全排列，都可以产生集合A的n1!×n2!×…×nk!个排列（由乘法法则），故重集B的全排列个数为n! / ( n1! <em> n2! </em> …… * nk! )。</p>
<p>注：利用组合数的计数方法同样可以得出证明。</p>
<h4 id="例2-3"><a href="#例2-3" class="headerlink" title="例2"></a>例2</h4><p>有四面红旗，三面蓝旗，二面黄旗，五面绿旗可以组成多少种由14面旗子组成的一排彩旗？</p>
<p>解：</p>
<p>这是一个重排列问题，是求重集{4<em>红旗,3</em>蓝旗,2<em>黄旗,5</em>绿旗}的全排列个数，根据定理，一排彩旗的种数为</p>
<p>14! / ( 4! <em> 3! </em> 2! * 5! ) = 2522520。</p>
<h4 id="例3-1"><a href="#例3-1" class="headerlink" title="例3"></a>例3</h4><p>用字母A、B、C组成五个字母的符号，要求在每个符号里，A至多出现2次，B至多出现1次，C至多出现3次，求此类符号的个数。</p>
<p>解：</p>
<p>这也是一个重排列问题。根据分析，符合题意的符号个数相当于求重集M={2<em>A,1</em>B,3*C}的5−排列个数，可分为三种情况：需要分别求M-{A}、M-{B}和M-{C}的全排列个数。根据加法法则，此类符号个数为</p>
<p>5! / (1! <em> 1! </em> 3!) + 5! / (2! <em> 0! </em> 3!) + 5! / (2! <em> 1! </em> 2!) = 60</p>
<h3 id="项链排列"><a href="#项链排列" class="headerlink" title="项链排列"></a>项链排列</h3><p>对圆排列，通过转动、平移、翻转、可重合的，即可看作项链排列。</p>
<p>若n个不同元素的r−项链排列个数为P(n,r)/(2×r)，具体参照Pólya定理。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>组合数学</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>数论1(辗转相除法 + 欧拉筛 + 杜教筛 + 模运算 + 快速幂)</title>
    <url>/2018/08/15/2018-08-15/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>图论2（强连通 + 2-SAT + 欧拉图 + 着色问题）</title>
    <url>/2018/08/14/2018-08-14/</url>
    <content><![CDATA[<h1 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h1><h2 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h2><p>所谓连通性，直观的讲，就是“连成一片”。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-15-%E5%9B%BE%E8%81%94%E9%80%9A%E5%88%A4%E6%96%AD.png" alt></p>
<p>我们发现，按照上面的划分方法，我们可以把G1分为三部分，因此，G1是不连通的，但是，这三个部分，我们把它们叫做图G1的三个连通分量。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>无向图G中，如果任意两顶点u和v，都能找到从一条u到v的路径。称无向图G是连通的。</p>
<p>当G为有向图时，若G中存在一条以 u为起点 v为终点的有向路P，则称从 u到 v是可达的。</p>
<p>如果G的任何两个顶点都是相互可达的 ，则称图G是强连通的；如果G的有向边被看作无向边时是连通的，则称有向图G是弱连通的 。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-15-%E8%BF%9E%E9%80%9A%E5%BC%BA%E5%BC%B1.png" alt></p>
<h4 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h4><p>所谓连通分量，指的是图中的极大连通子图。</p>
<p>有了连通分量的概念，我们可以对图的连通性换言之为：如果图G中只有唯一一个连通分量，那么G是连通的，我们称G为连通图。</p>
<h2 id="强连通"><a href="#强连通" class="headerlink" title="强连通"></a>强连通</h2><h3 id="无向图连通性"><a href="#无向图连通性" class="headerlink" title="无向图连通性"></a>无向图连通性</h3><p>在对无向图进行遍历时，对于连通图，仅需从图中任一顶点出发，进行深度优先遍历或广度优先遍历，便可访问到图中所有顶点；对于非连通图，则需从多个顶点出发进行遍历，而每次从一个新的起点出发进行遍历得到的顶点访问序列恰好是一个连通分量中的顶点集。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>对无向图的连通性判定，一般我们采用搜索的方法，这里我们首先要提到应用非常广泛的深度优先搜索算法DFS，DFS在图论算法中有非常重要的地位。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>对下图( a ) 所示无向图进行深度优先遍历，需分别从顶点 v 1 和 v 5 出发调用两次 DFS（或 BFS），得到的顶点序列分别为： v 1 v 2 v 3 v 4 和 v 5 v 6 。这两个顶点集分别加上所有依附于这些顶点的边，便构成了非连通图 G  的两个连通分量，如下图 ( b ) 所示。 </p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-15-%E6%97%A0%E5%90%91%E5%9B%BE%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png" alt></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>因此，要想判定一个无向图是否为连通图，或有几个连通分量，可以设置一个计数器 count ，初始时取值为 0 ，每调用一次遍历算法，就给 count 增 1 。这样，当整个遍历算法结束时，依据 count 的值，就可确定图的连通性了。算法用伪代码描述如下：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-15-%E6%97%A0%E5%90%91%E5%9B%BE%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E4%BC%AA%E4%BB%A3%E7%A0%81.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">无向图连通分支</span><br><span class="line">//无向图连通分支，dfs邻接阵形式，o（n^2）</span><br><span class="line">//返回分支数，id返回1..分支数的值</span><br><span class="line">//传入图的大小n和邻接阵mat，不相邻点边权0</span><br><span class="line">#define MAXN 100 </span><br><span class="line">void floodfill(int n,int mat[][MAXN],int* id,int now,int tag)&#123;</span><br><span class="line">int i; </span><br><span class="line">for (id[now]=tag,i=0;i&lt;n;i++) </span><br><span class="line">	if (!id[i]&amp;&amp;mat[now][i]) </span><br><span class="line">		floodfill(n,mat,id,i,tag); </span><br><span class="line">&#125;</span><br><span class="line">int find_components(int n,int mat[][MAXN],int* id)&#123; </span><br><span class="line">	int count,i; </span><br><span class="line">	for (i=0;i&lt;n;id[i++]=0); </span><br><span class="line">		for (count=i=0;i&lt;n;i++) </span><br><span class="line">			if (!id[i]) </span><br><span class="line">				floodfill(n,mat,id,i,++count); </span><br><span class="line">	return count; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有向图连通性"><a href="#有向图连通性" class="headerlink" title="有向图连通性"></a>有向图连通性</h3><p>假设，我们把一张有向图的所有边看做无向的，然后对转化后的无向图进行一次DFS，是不是就可以判断无向图的连通性呢？显然可以。</p>
<p>对于采用邻接矩阵表示的有向图G=&lt;E，V&gt;，如果存在一条边e(u,v),那么在矩阵中e(u,v)&gt;0，我们令e(v,u)=e(u,v)，这样就可以将一条有向边变成无向边。</p>
<p>之后，对于这个转化后的矩阵进行一次DFS，这样既可以判断有向图是否连通。</p>
<p>需要注意的是，一般情况下，我们在题目中应用到得不是简单的有向图是否连通，而是：求有向图的强连通分量。</p>
<h4 id="有向图的强连通分量"><a href="#有向图的强连通分量" class="headerlink" title="有向图的强连通分量"></a>有向图的强连通分量</h4><p>有向图G的极大强连通子图称为G的强连通分量(SCC)。</p>
<p>下图中，子图{1,2,3,4}为一个强连通分量，因为顶点 1,2,3,4 两两可达。{5},{6}也分别是两个强连通分量。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-15-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png" alt></p>
<p>直接根据定义，用双向遍历取交集的方法求强连通分量，时间复杂度为 O(N^2+M)。<br>更好的方法是 Kosaraju 算法或 和Tarjan 算法，两者的时间复杂度都是 O(N+M)。还有Gabow算法不介绍。</p>
<h4 id="Kosaraju-算法"><a href="#Kosaraju-算法" class="headerlink" title="Kosaraju 算法"></a>Kosaraju 算法</h4><p>Kosaraju算法的解释和实现都比较简单，为了找到强连通分支，首先对图G运行DFS，计算出各顶点完成搜索的时间f；然后计算图的逆图GT，对逆图也进行DFS搜索，但是这里搜索时顶点的访问次序不是按照顶点标号的大小，而是按照各顶点f值由大到小的顺序；逆图DFS所得到的森林即对应连通区域。具体流程如图(1~4)。</p>
<p>上面我们提及原图G的逆图GT，其定义为GT=(V, ET)，ET={(u, v):(v, u)∈E}}。也就是说GT是由G中的边反向所组成的，通常也称之为图G的转置。在这里值得一提的是，逆图GT和原图G有着完全相同的连通分支，也就说，如果顶点s和t在G中是互达的，当且仅当s和t在GT中也是互达的。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-15-k%E7%AE%97%E6%B3%95.JPG" alt></p>
<p>在这里顺便提一下在调用dfs的过程中，几种添加顶点到集合的顺序。一共有四种顺序：</p>
<ul>
<li><p>Pre-Order，在递归调用dfs之前将当前顶点添加到queue中</p>
</li>
<li><p>Reverse Pre-Order，在递归调用dfs之前将当前顶点添加到stack中</p>
</li>
<li><p>Post-Order，在递归调用dfs之后将当前顶点添加到queue中</p>
</li>
<li>Reverse Post-Order，在递归调用dfs之后将当前顶点添加到stack中</li>
</ul>
<p>最后一种的用途最广，至少目前看来是这样，比如步骤2-a以及拓扑排序中，都是利用的Reverse Post-Order来获取顶点集合。</p>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p> (1)对G执行深度优先搜索，求出每个顶点的后序遍历顺序号postOrder。    </p>
<p>(2)反转有向图G中的边，构造一个新的有向图G*。</p>
<p>(3)由最高的postOrder编号开始，对G*执行深度优先搜索。如果深度优先搜索未达到所有顶点，由未访问的最高postOrder编号的顶点开始，继续深度优先搜索。    </p>
<p>(4)步骤三所产生的森林中的每一棵树，对应于一个强连通分支。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define maxN 1024</span><br><span class="line">int marked[maxN];//用于记录某个点是否被访问过，0为没有被临幸过，1为被临幸过</span><br><span class="line">int id[maxN];//记录每个点所属的连通分量</span><br><span class="line">int count;//记录连通分量总数目</span><br><span class="line">void kosaraju(graph *g)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    memset(marked,0,sizeof(marked));</span><br><span class="line">    memset(id,0,sizeof(id));</span><br><span class="line">    count=0;</span><br><span class="line">    for(i=0;i&lt;g-&gt;V;i++)&#123;//之所以这里用循环就是因为g指向的无向图可能不是一个连通图，而是由多个连同分量组成</span><br><span class="line">        if(!marked[i])&#123;dfs(g,i); count++;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void dfs(graph *g,int v)&#123;</span><br><span class="line">    graphNode *t;</span><br><span class="line">    marked[v]=1;</span><br><span class="line">    id[v]=count;</span><br><span class="line">    t=g-&gt;adjlist[v].next;//t指向v的邻接点</span><br><span class="line">    while(t)&#123;</span><br><span class="line">        if(!marked[t-&gt;key])&#123;dfs(g,t-&gt;key);&#125;//这里是重点，就是你发现v到t-&gt;key有路径就把它算到跟自己在一个连通分量里了，这里有一个隐性前提，就是你提前知道t-&gt;key一定可以到v，所以你发现v可以到t-&gt;key的时候，你毫不犹豫把它算为跟自己一伙儿的了。Korasaju算法不同书上有不同的表述，区别是先遍历图g还是先遍历图g的逆向图，这只是顺序的区别。我把我看得版本完整说一下：（1）先DFS遍历图g的逆向图，记录遍历的逆后序。（什么叫逆后序？逆后序就是DFS时后序的逆序，注意逆后序不一定为DFS的前序。DFS前序为，访问某个顶点前，把它push进队列。DFS后序为访问完某个顶点后才把它push进队列。而DFS逆后序为访问完某个顶点后把它push进一个栈中。当DFS遍历完整个图后，后序队列的输出与逆后序栈的输出正好相反。）（2）然后按着图g逆向图的DFS遍历的逆后序序列遍历图g求所有的强连通分量，这一步的过程跟无向图求所有连通分量的算法一模一样！按着这里说的遍历顺序重复无向图求所有连通分量的步骤求出来的就是有向图的所有强连通分量，为什么呢？因为我们完成第一步后，按着第一步得到的逆后序要对有向图g进行DFS遍历的前一刻，前面这段过程就相当于我们完成了对这幅有向图g一个加工，把它加工成了一个无向图！也就是说，这个加工实现了我注释开头提到的那个隐性前提。所以后面按着无向图求所有连通分量的步骤求出来的就是有向图g的所有强连通分量。举个例子，比如有向图3-&gt;5-&gt;4-&gt;3，它的逆向图为3-&gt;4-&gt;5-&gt;3（你最好在纸上画下，就是个三角循环图），从逆向图的顶点3开始DFS，得到的逆后续为3，4,5 。按着这个顺序对原图进行DFS，DFS(3)时遇到5，则5肯定跟3在一个强连通分量中（为什么？因为我们逆向图DFS(5)时肯定能到达3，这就是隐形前提。所以正向图DFS(3)遇到5时，我们毫不犹豫把它算到自己一个强连通分量中。）</span><br><span class="line">        t=t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Tarjan-算法"><a href="#Tarjan-算法" class="headerlink" title="Tarjan 算法"></a>Tarjan 算法</h4><p>Tarjan 算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。定义 DFN(u)为节点 u 搜索的次序编号(时间戳)，Low(u)为 u 或 u 的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Low(u)=Min </span><br><span class="line">&#123; </span><br><span class="line"> DFN(u), </span><br><span class="line"> Low(v),(u,v)为树枝边，u为v的父节点</span><br><span class="line"> DFN(v),(u,v)为指向栈中节点的后向边(非横叉边) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 DFN(u)=Low(u)时，以 u 为根的搜索子树上所有节点是一个强连通分量。<br>算法伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tarjan(u) </span><br><span class="line">&#123; </span><br><span class="line">	DFN[u]=Low[u]=++Index // 为节点u设定次序编号和Low初值</span><br><span class="line">	Stack.push(u) // 将节点u压入栈中</span><br><span class="line">	for each (u, v) in E // 枚举每一条边</span><br><span class="line">		if (v is not visted) // 如果节点v未被访问过</span><br><span class="line">			tarjan(v) // 继续向下找</span><br><span class="line">			Low[u] = min(Low[u], Low[v]) </span><br><span class="line">		else if (v in S) // 如果节点v还在栈内</span><br><span class="line">			Low[u] = min(Low[u], DFN[v]) </span><br><span class="line">	if (DFN[u] == Low[u]) // 如果节点u是强连通分量的根</span><br><span class="line"> 		repeat </span><br><span class="line">			v = S.pop // 将v退栈，为该强连通分量中一个顶点</span><br><span class="line"> 			print v </span><br><span class="line">		until (u== v) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p>从节点 1 开 始 DFS ，把遍历到的节点加入栈中。搜索到节点 u=6 时 ，DFN[6]=LOW[6]，找到了一个强连通分量。退栈到 u=v 为止，{6}为一个强连通分量。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-15-a.png" alt></p>
<p>返回节点 5，发现 DFN[5]=LOW[5]，退栈后{5}为一个强连通分量。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-15-b.png" alt></p>
<p>返回节点 3，继续搜索到节点 4，把 4 加入堆栈。发现节点 4 向节点 1 有后向边，节点 1 还在栈中，所以 LOW[4]=1。节点 6 已经出栈，(4,6)是横叉边，返回 3，(3,4)为树枝边，所以 LOW[3]=LOW[4]=1。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-15-c.png" alt></p>
<p>继续回到节点 1 ，最后访问节点 2 。访问边 (2,4) ， 4 还在栈中，所以LOW[2]=DFN[4]=5。返回 1 后，发现 DFN[1]=LOW[1]，把栈中节点全部取出，组成一个连通分量{1,3,4,2}。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-15-d.png" alt></p>
<p>至此，算法结束。经过该算法，求出了图中全部的三个强连通分量{1,3,4,2},{5},{6}。可以发现，运行 Tarjan 算法的过程中，每个顶点都被访问了一次，且只进出了一次堆栈，每条边也只被访问了一次，所以该算法的时间复杂度为 O(N+M)。</p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void tarjan(int i)</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    DFN[i]=LOW[i]=++Dindex;</span><br><span class="line">    instack[i]=true;</span><br><span class="line">    Stap[++Stop]==i;</span><br><span class="line">    for (edge *e=V[i]; e; e=e-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        j=e-&gt;t;</span><br><span class="line">        if (!DFN[j])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(j);</span><br><span class="line">            if (LOW[j]&lt;LOW[i])</span><br><span class="line">                LOW[i]=LOW[j];</span><br><span class="line">        &#125;</span><br><span class="line">        else if (instack[j] &amp;&amp; DFN[j]&lt;LOW[i]</span><br><span class="line">                )</span><br><span class="line">            LOW[i]=DFN[j];</span><br><span class="line">    &#125;</span><br><span class="line">    if (DFN[i]==LOW[i])</span><br><span class="line">    &#123;</span><br><span class="line">        Bcnt++;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            j=Stap[Stop--];</span><br><span class="line">            instack[j]=false;</span><br><span class="line">            Belong[j]=Bcnt;</span><br><span class="line">        &#125;</span><br><span class="line">        while (j!=i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    Stop=Bcnt=Dindex=0;</span><br><span class="line">    memset(DFN,0,sizeof(DFN));</span><br><span class="line">    for (i=1; i&lt;=N; i++)</span><br><span class="line">        if (!DFN[i])</span><br><span class="line">            tarjan(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Gabow算法"><a href="#Gabow算法" class="headerlink" title="Gabow算法"></a>Gabow算法</h4><p>这个算法其实就是Tarjan算法的变异体，我们观察一下，只是它用第二个堆栈来辅助求出强连通分量的根，而不是Tarjan算法里面的dfn[]和backn[]数组。那么，我们说一下如何使用第二个堆栈来辅助求出强连通分量的根。 </p>
<p>我们使用类比方法，在Tarjan算法中，每次backn[i]的修改都是由于环的出现(不然，backn[i]的值不可能变小)，每次出现环，在这个环里面只剩下一个backnk[i]没有被改变(深度最低的那个)，或者全部被改变，因为那个深度最低的节点在另一个环内。那么Gabow算法中的第二堆栈变化就是删除构成环的节点，只剩深度最低的节点，或者全部删除，这个过程是通过出栈来实现，因为深度最低的那个顶点一定比前面的先访问，那么只要出栈一直到栈顶那个顶点的访问时间不大于深度最低的那个顶点。其中每个被弹出的节点属于同一个强连通分量。那有人会问：为什么弹出的都是同一个强连通分量？因为在这个节点访问之前，能够构成强连通分量的那些节点已经被弹出了，这个对Tarjan算法有了解的都应该清楚，那么Tarjan算法中的判断根我们用什么来代替呢？想想，其实就是看看第二个堆栈的顶元素是不是当前顶点就可以了。 </p>
<p>现在，你应该明白其实Tarjan算法和Gabow算法其实是同一个思想的不同实现，但是，Gabow算法更精妙，时间更少(不用频繁更新backn[])。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool map[100][100];//记录图形</span><br><span class="line">bool visited[100];//记录点是不是已经被访问过了</span><br><span class="line">bool del[100];//记录点是不是已经删除了</span><br><span class="line">int dfn[100];//记录点访问的次序</span><br><span class="line">stack&lt;int&gt;s1,s2;</span><br><span class="line">int dotn;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    int line;</span><br><span class="line">    cin&gt;&gt;dotn&gt;&gt;line;</span><br><span class="line">    for(int i=1;i&lt;=line;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        map[u][v]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(visited,0,sizeof(visited));</span><br><span class="line">    memset(del,0,sizeof(del));</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int u,int &amp;time)</span><br><span class="line">&#123;</span><br><span class="line">    visited[u]=1;</span><br><span class="line">    dfn[u]=++time;</span><br><span class="line">    s1.push(u);</span><br><span class="line">    s2.push(u);</span><br><span class="line">    for(int i=1;i&lt;=dotn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(map[u][i])</span><br><span class="line">        &#123;</span><br><span class="line">            if(!visited[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(i,time);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(!del[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    while(dfn[s2.top()]&gt;dfn[i])s2.pop();//注意这个地方</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(u==s2.top())</span><br><span class="line">    &#123;</span><br><span class="line">        while(u!=s1.top())</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;s1.top()&lt;&lt;&quot;   &quot;;</span><br><span class="line">            del[s1.top()]=1;</span><br><span class="line">            s1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;u&lt;&lt;endl;</span><br><span class="line">        del[s1.top()]=1;</span><br><span class="line">        s1.pop();</span><br><span class="line">        s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Gadow()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    int time=0;</span><br><span class="line">    for(int i=1;i&lt;=dotn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(i,time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    Gadow();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>强连通分支问题的最大应用就在于两个字：缩点！</p>
<p>所谓缩点，就是把图中属于同一个强连通分支中的点缩为一个点，这样，我们就得到了一个新的有向图，而且图中不存在回路。</p>
<p>POJ 1236 - Network of Schools（最小点基）</p>
<h4 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h4><p>有向图缩点一个很大的应用，就是2-SAT问题(2判定性问题 )。</p>
<p>POJ 3678 - Katu Puzzle</p>
<p>POJ 3683 - Priest John’s Busiest Day</p>
<h1 id="2-SAT-1"><a href="#2-SAT-1" class="headerlink" title="2-SAT"></a>2-SAT</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义 1:"></a>定义 1:</h2><p>布尔变量 x，假如逻辑运算“或”和“与”分别用“∨”和“∧ ”来表示，﹁x表示 x 的非，布尔表达式是用算术运算符号连接起来的变量所构成的代数表达式。给定每个变量 x 的一个值 p(x)，可以像计算代数表达式一样计算布表达式的值。如果存在一个真值分配，使得布尔表达式的取值为真，则这个布尔表达式称为可适定性的，简称 SAT。</p>
<p>例如（x1∨x2）∧(﹁x1∨﹁x2) 这个布尔表达式，如果 p(x1)=真，p(x2)=假，则表达式的值为真，则这个表达式是适定性的。不是所有的布尔表达式都是可适定的。</p>
<p>例如x1∧﹁x2∧(﹁x1∨x2)，则不管 p(x1),p(x2)取何值，表达式都不可能为真，因此这个布尔表达式是不可适定的。</p>
<p>适定性问题的一般形式 X=｛x1,x2..,xn｝为一个有限的布尔变量集，包含 x1,x2，..,xn的“或”和“与”，运算的 m 个句子 C1,C2,..,Cm,布尔表达式 C1∧C2∧,..,∧Cm 是否可适定。</p>
<p> 布尔表达式由用“与”连接起来的一些句子构成，则称这个表达式为“合取范式”。</p>
<h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义 2:"></a>定义 2:</h2><p>对于给定的句子 C1,C2,..,Cm,如果 max{|Ci|}=k(1≦i≦m),则称此适定性问题为 k 适定性问题，简称 k-SAT。</p>
<p>当 k&gt;2 时，k-SAT 是 NP 完全的，所以我们一般讨论2-SAT问题。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>下面我们从一道例题来认识 2-SAT 问题，并提出对一类 2-SAT 问题通用的解法。<br>Poi 0106 Peaceful Commission [和平委员会] </p>
<p>某国有 n 个党派，每个党派在议会中恰有 2 个代表。现在要成立和平委员会 ，该会满足：</p>
<p>每个党派在和平委员会中有且只有一个代表<br>如果某两个代表不和，则他们不能都属于委员会<br>代表的编号从 1 到 2n，编号为 2a-1、2a 的代表属于第 a 个党派</p>
<p>输入 n（党派数），m（不友好对数）及 m 对两两不和的代表编号<br>其中 1≤n≤8000，0≤m ≤20000<br>求和平委员会是否能创立。<br>若能，求一种构成方式。 </p>
<p>例：</p>
<p>输入：</p>
<p>3 2</p>
<p>1 3</p>
<p>2 4</p>
<p>输出：</p>
<p>1</p>
<p>4</p>
<p>5</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>原题可描述为：</p>
<p>有 n 个组，第 i 个组里有两个节点 Ai, Ai’ 。需要从每个组中选出一个。而某些点不可以同时选出（称之为不相容）。任务是保证选出的 n 个点都能两两相容。（在这里把 Ai,Ai’ 的定义稍稍放宽一些，它们同时表示属于同一个组的两个节点。也就是说，如果我们描述 Ai，那么描述这个组的另一个节点就可以用 Ai’）</p>
<p>初步构图</p>
<p>如果 Ai 与 Aj 不相容，那么如果选择了 Ai，必须选择 Aj ‘ ；同样，如果选择了 Aj，就必须选择 Ai ’ 。</p>
<p>Ai → Aj<code>Aj → Ai</code></p>
<p>这样的两条边对称</p>
<p>我们从一个例子来看：</p>
<p>假设 4 个组，不和的代表为：1 和 4，2 和 3，7 和 3，那么构图：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-15-2-sat%E9%97%AE%E9%A2%981.png" alt></p>
<p>假设：</p>
<p>首先选 1<br>3 必须选，2 不可选<br>5、6 可以任选一个<br>8 必须选，4、7 不可选</p>
<p>矛盾的情况为：<br>存在 Ai，使得 Ai 既必须被选又不可选。<br>得到算法 1：<br>枚举每一对尚未确定的 Ai, Ai‘ ，任选 1 个，推导出相关的组，若不矛盾，则可选择；否则选选另 1 个，同样推导。若矛盾，问题必定无解。</p>
<p>此算法正确性简要说明：</p>
<p>由于 Ai,Ai’ 都是尚未确定的，它们不与之前的组相关联，前面的选择不会影响 Ai,Ai’ 。<br>算法的时间复杂度在最坏的情况下为 O(nm)。</p>
<p>在这个算法中，并没有很好的利用图中边的对称性<br>观察图（1）可以发现，1 和 3 构成一个环，这样 1 和 3 要么都被选中，要么都不选。2和 4 也同样如此。</p>
<p>在每个一个环里，任意一个点的选择代表将要选择此环里的每一个点。不妨把环收缩成一个子节点。新节点的选择表示选择这个节点所对应的环中的每一个节点。</p>
<p>对于原图中的每条边 Ai → Aj（设 Ai 属于环 Si，Aj 属于环 Sj）如果 Si≠Sj，则在新图中连边：</p>
<p>Si → Sj </p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-15-2-sat%E9%97%AE%E9%A2%982.png" alt></p>
<p>这样构造的有向无环图和原图是等价的，这样我们就可以用之前介绍过的强连通分量的算法把图转化成有向无环图，在这个基础上，如果存在一对 Ai, Ai’属于同一个环，则判无解，否则将采用拓扑排序，以自底向上的顺序进行推导，一定能找到可行解。</p>
<p>下面给出 2-SAT 问题中常用的建边方式：</p>
<p>2-SAT 中元素关系常见有以下 11 种</p>
<p>A[x]</p>
<p>NOT A[x]</p>
<p>A[x] AND A[y]</p>
<p>A[x] AND NOT A[y]</p>
<p>A[x] OR A[y]</p>
<p>A[x] OR NOT A[y]</p>
<p>NOT (A[x] AND A[y]) </p>
<p>NOT (A[x] OR A[y]) </p>
<p>A[x] XOR A[y]</p>
<p>NOT (A[x] XOR A[y]) </p>
<p>A[x] XOR NOT A[y]</p>
<p>And 结果为 1：建边 ~x-&gt;y, ~y-&gt;x (两个数都为 1)<br>And 结果为 0：建边 y-&gt;~x , x-&gt;~y(两个数至少有一个为 0)<br>OR 结果为 1：建边 ~x-&gt;y ,  ~y-&gt;x(两个数至少有一个为 1)<br>OR 结果为 0：建边 x-&gt;~x , y-&gt;~y(两个数都为 0)<br>XOR 结果为 1：建边 x-&gt;~y , ~x-&gt;y , ~y-&gt;x , y -&gt; ~x (两个数一个为 0，一个为 1)<br>XOR 结果为 0：建边 x-&gt;y , ~x-&gt;~y , y-&gt;x ~y-&gt;~x(两个数同为 1 或者同为 0) </p>
<p>对于一般判定是不是有解的情况，我们可以直接采用 tarjan 算法求强联通，然后缩点，如果 x 与~x 染色相同，说明无解，否则有解。有的时候，可能需要用二分++tarjan 算法</p>
<h1 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h1><p>每个小点最后都会回到自己原来的位置上吗？注意，这些小点并不是沿着一个回路在运动，而是沿着三个交替出现的回路在运动。</p>
<p> <img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF.gif" alt></p>
<p>答案是肯定的。 math 版上的 <a href="https://www.reddit.com/r/math/comments/3hz9u9/will_each_jellyfish_in_this_gif_eventually_end_up/cubw779" target="_blank" rel="noopener">OmnipotentEntity</a> 给出了一个简短的证明。假设某个地方的小点出发后永远不会回到原地。由于小点的运动规律是三步一个周期，因此每三步之后从此处出发的小点将会拥有完全相同的命运——永远不会回到原地。既然从这里出发的小点会不断地发生有去无回的情况，那么总有一个时候小点会被用光，此时就再也没有小点能从这里出发了。但这与我们看到的实际情况相矛盾：每个地方的小点都是用之不竭的。</p>
<p>熟悉群论的朋友会很快发现，这个结论几乎是显然的。小点的每一步运动都形成了一个置换，三个置换的复合本质上也还是一个置换，而这个置换的足够多次幂一定会变成单位置换。这意味着，不但每个点都能回到自己原来的位置，而且所有点能同时回到自己原来的位置（后者可能需要更长的时间）。事实上，有限群中的任意一个元素都有一个有限的阶，因而如果某类变换操作能构成一个有限群的话，不断地执行某一个操作，或者不断地循环执行某几个操作，最后总有一个时刻你会发现，一切又都重新变回了原样。拿出一副新的扑克牌，每次洗牌时都把牌分成两半并把它们完美地交叉在一起，那么不断这样洗下去之后，整副牌总会在某个时候重新变得有序。找一个复原好了的魔方，循环执行几个固定的操作，魔方很快就会被彻底打乱，但最终一定会奇迹般地再次复原。</p>
<h2 id="欧拉图（E问题）"><a href="#欧拉图（E问题）" class="headerlink" title="欧拉图（E问题）"></a>欧拉图（E问题）</h2><h3 id="起源："><a href="#起源：" class="headerlink" title="起源："></a>起源：</h3><p>欧拉回路问题是图论中最古老的问题之一。它诞生于十八世纪的欧洲古城哥尼斯堡。普瑞格尔河流经这座城市，人们在两岸以及河中间的两个小岛之间建了七座桥（如图1）。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-14%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%981.png" alt></p>
<p>于是产生了这样一个问题：是否可以找到一种方案，使得人们从自己家里出发，不重复地走遍每一座桥，然后回到家中？这个问题如果用数学语言来描述，就是在图2中找出一条回路，使得它不重复地经过每一条边。这便是著名的“哥尼斯堡七桥问题”。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-14%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%982.png" alt></p>
<h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义：</strong></h3><p>​        欧拉回路：图G=(V,E) (无向图or有向图) 的一个回路，如果恰通过图G的每一条边，则该回路称为欧拉回路，具有欧拉回路的图称为欧拉图。欧拉图就是从图上的一点出发，经过所有边且只能经过一次，最终回到起点的路径。</p>
<p>​        欧拉通路：即可以不回到起点，但是必须经过每一条边，且只能一次。也叫”一笔画”问题。</p>
<p>​    欧拉图与半欧拉图：具有欧拉回路的图称为欧拉图，具有欧拉通路而无欧拉回路的图称为半欧拉图。</p>
<p>​    桥：设无向图G=&lt;V,E&gt;，若存在边集E的一个非空子集E1，使得p(G-E1)&gt;p(G)，而对于E1的任意真子集E2，均有p(G-E2)=p(G)，则称E1是G的边割集，或简称割集；若E1是单元集，即E1={e}，则称e为割边或桥。[p(G)表示图G的连通分支数.]</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-14-%E6%AC%A7%E6%8B%89%E5%9B%BE.png" alt></p>
<p>图中，图（4）为欧拉图，图（3）为半欧拉图，图（1）（2）不是欧拉图。</p>
<h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a><strong>性质：</strong></h3><p>　　欧拉回路：一个欧拉回路，删掉一个点，仍然是一个欧拉回路。从一个欧拉回路拖走一个小欧拉回路，结果也是一个欧拉回路。</p>
<h3 id="判定（充要）："><a href="#判定（充要）：" class="headerlink" title="判定（充要）："></a><strong>判定（充要）：</strong></h3><p>　　欧拉回路：1:  图G是连通的，不能有孤立点存在。</p>
<p>　　　　　　　2:  对于无向图来说度数为奇数的点个数为0;对于有向图来说每个点的入度必须等于出度。</p>
<p>　　欧拉通路：1:  图G是连通的，无孤立点存在。</p>
<p>　　　　　　　2:  对于无向图来说，度数为奇数的的点可以有2个或者0个，并且这两个奇点其中一个为起点另外一个为终点。对于有向图来说，可以存在两个点，其入度不等于出度，其中一个入度比出度大1，为路径的起点；另外一个出度比入度大1，为路径的终点。</p>
<h3 id="算法（求欧拉回路）："><a href="#算法（求欧拉回路）：" class="headerlink" title="算法（求欧拉回路）："></a><strong>算法（求欧拉回路）：</strong></h3><h4 id="Fleury算法"><a href="#Fleury算法" class="headerlink" title="Fleury算法:"></a><strong>Fleury算法:</strong></h4><p>设图G是一个无向欧拉图，则按照下面算法求欧拉回路:</p>
<p>1:任取G中一个顶点v0,令P0 = v0.</p>
<p>2:假设沿Pi = v0e1v1e2v2……eivi 走到了顶点 vi,按照下面方法从E(i) = E(G) -  {e1, e2, e3,…,ei} 中选e(i ＋　1),选择后删除e(i +１)这条边.</p>
<p>　　a):e(i+1)余vi关联</p>
<p>　　b):除非无别的边可选，否则e(i+1)不应是Gi = G – {e1,e2,…,ei} 中的桥.假若迫不得已选的是桥,除删除这条边之外,还应该再把孤立点从Gi中移除(选择桥边必然会形成孤立的点).</p>
<p>3:当步骤 2 无法继续执行时停止算法.</p>
<p>当算法停止时，所得到的简单回路 Pm = = v0e1v1e2v2e3v3……emvm  (vm = v0) 为图G的一条欧拉回路.</p>
<p><strong>下面用图来描述：</strong></p>
<p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093832441-1464795842.png" alt="img"></p>
<p>随便选择一个起点 v1。当前处在 v1 点，有两种走法 v1 – v9,v1 – v10，这俩条边都不是桥边，那么随便选择一个，&lt;v1, v10&gt;这条边吧。那么图就会成为这样.Eu = (走过的边集){&lt;v1, v10&gt;}</p>
<p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093833082-1968185223.png" alt="img"></p>
<p>当前到了 V10 点，有&lt;v10,v4&gt;,&lt;v10,v3&gt;,&lt;v10, v8&gt;，先看&lt;v10,v8&gt;这条边吧，如果选择了这条边那么图就会成为这样：</p>
<p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093833488-2076065400.png" alt="img"></p>
<p>很显然形成了两个图，上下两个图不连通，即&lt;v10, v8&gt;这条边就是所谓的桥边，算法中说除非别无他选，否则不应该选择桥边，那么这条边就不能选择。回到上面，由于&lt;v10,v4&gt;,&lt;v10,v3&gt;都不是桥边，所以随便选择&lt;v10,v4&gt;吧. Eu={&lt;v1, v10&gt;,&lt;v10,v4&gt;}</p>
<p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093833910-319654348.png" alt="img"></p>
<p>到了 v4 这个点，&lt;v4, v2&gt;这条边是桥边,但是别无选择，只好选择这条边.选择完这条边这时不仅要从原图中删除这条边，由于点4成为了孤点，所以这个点也该从原图删除。Eu={&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;}.</p>
<p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093834410-492154878.png" alt="img"></p>
<p>同理到达 v2 只好选择&lt;v2,v3&gt;，删除孤点 v2和边. Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;}.</p>
<p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093834941-273171314.png" alt="img"></p>
<p>别无他选，&lt;v3,v10&gt;。Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;&lt;v3,v10&gt;}.</p>
<p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093835473-1872025007.png" alt="img"></p>
<p>同样,选择&lt;v10, v8&gt;，Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;&lt;v3,v10&gt;,&lt;v10,v8&gt;}.</p>
<p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093835941-942659814.png" alt="img"></p>
<p>此时到了 v8 同第一次到达v10时的情况，不能选择&lt;v8,v9&gt;这条桥边,选择&lt;v8,v6&gt;,Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;&lt;v3,v10&gt;,&lt;v10,v8&gt;,&lt;v8,v6&gt;}.</p>
<p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093836457-215788402.png" alt="img"></p>
<p>到达v6，选择&lt;v6,v7&gt;,删点删边,Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;,&lt;v3,v10&gt;,&lt;v10,v8&gt;,&lt;v8,v6&gt;,&lt;v6,v7&gt;}.以下就不给图了(逃;</p>
<p>然后接下来的选择都是别无他选,依次选择&lt;v7,v8&gt;&lt;v8,v9&gt;&lt;v9,v1&gt;，最后得到的欧拉边集Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;,&lt;v3,v10&gt;,&lt;v10,v8&gt;,&lt;v8,v6&gt;,&lt;v6,v7&gt;,&lt;v7,v8&gt;&lt;v8,v9&gt;&lt;v9,v1&gt;},于是我们就得到了一条欧拉回路.</p>
<h5 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h5><p>这个算法在实现时也有很巧妙的方法。因为DFS本身就是一个入栈出栈的过程，所以我们直接利用DFS的性质来实现栈，其伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DFS(u):</span><br><span class="line">	While (u存在未被删除的边e(u,v))</span><br><span class="line">		删除边e(u,v)</span><br><span class="line">		DFS(v)</span><br><span class="line">	End</span><br><span class="line">	PathSize ← PathSize + 1</span><br><span class="line">	Path[ PathSize ] ← u</span><br></pre></td></tr></table></figure>
<h5 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void DFS(Graph &amp;G,SqStack &amp;S,int x,int t)</span><br><span class="line">&#123;</span><br><span class="line">       k=0;//一个标志,来标记当前访问的节点是否还有邻接边可供访问</span><br><span class="line">       Push(S,x); //将本次遍历边所经由的点入栈</span><br><span class="line">       for(i=t;i&lt;v;i++) //v是顶点数,e是边数</span><br><span class="line">        if(G[i][x]&gt;0)  </span><br><span class="line">         &#123;</span><br><span class="line">          k=1;</span><br><span class="line">          G[i][x]=0; G[x][i]=0; //此边已访问,删除此边</span><br><span class="line">          DFS(G,S,i,0);//寻找下一条关联的边,本次找到的是与x关联的i,在</span><br><span class="line">                        //下一层中将寻找与i关联的边</span><br><span class="line">          break;</span><br><span class="line">         &#125;//if,for</span><br><span class="line">          if(k==0)       //如果k=0,说明与当前顶点关联的边已穷尽</span><br><span class="line">       &#123;</span><br><span class="line">              Pop(S);</span><br><span class="line">              GetTop(S,m);</span><br><span class="line">              G[x][m]=1;G[m][x]=1;//恢复在上一层中被删除的边</span><br><span class="line">              a=x+1;//如果可能的话,从当前节点的下一条关联边开始搜寻</span><br><span class="line">              if(StackLength(S)!=e)//继续搜寻,边还没有全部遍历完</span><br><span class="line">              &#123;</span><br><span class="line">                     Pop(S); //还原到上一步去</span><br><span class="line">                     DFS(G,S,m,a);//</span><br><span class="line">              &#125;//if</span><br><span class="line">              else   //搜寻完毕,将最后节点也入栈</span><br><span class="line">                     Push(S,x);</span><br><span class="line">       &#125;//if</span><br><span class="line">&#125;//DFS</span><br><span class="line">void Euler(Graph &amp;G,int x)</span><br><span class="line">&#123;</span><br><span class="line">//G是存储图的邻接矩阵,都处理成无向图形式,值为1代表有边,0代表无边,不包括自回路,x是出发点</span><br><span class="line">InitStack(S);//用来存放遍历边时依次走过的顶点</span><br><span class="line">DFS(G,S,x,0);//深度优先遍历查找,0是指查询的起点</span><br><span class="line">//输出</span><br><span class="line"> while(!StackEmpty(S))</span><br><span class="line"> &#123;</span><br><span class="line">  GetTop(S,m);</span><br><span class="line">  printf(&quot;-&gt;v%d&quot;,m);</span><br><span class="line">  Pop(S);</span><br><span class="line"> &#125;//while</span><br><span class="line">&#125;//Euler</span><br></pre></td></tr></table></figure>
<p><strong>代码：</strong>    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1005;</span><br><span class="line">int n, m, flag, top, sum, du[N], ans[5005], map[N][N];</span><br><span class="line"></span><br><span class="line">void dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">    ans[++top] = x;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(map[x][i] &gt;= 1)</span><br><span class="line">        &#123;</span><br><span class="line">            map[x][i]--;</span><br><span class="line">            map[i][x]--;</span><br><span class="line">            dfs(i);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fleury(int x)</span><br><span class="line">&#123;</span><br><span class="line">    top = 1;</span><br><span class="line">    ans[top] = x;</span><br><span class="line">    while(top &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        int k = 0;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)//判断是否可扩展</span><br><span class="line">        &#123;</span><br><span class="line">            if(map[ans[top]][i] &gt;= 1)//若存在一条从ans[top]出发的边  那么就是可扩展</span><br><span class="line">            &#123;k = 1; break;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(k == 0)//该点x没有其他的边可以先走了（即不可扩展）， 那么就输出它</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%d &quot;, ans[top]);</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(k == 1)//如可扩展， 则dfs可扩展的哪条路线</span><br><span class="line">        &#123;</span><br><span class="line">            top--;//这需要注意</span><br><span class="line">            dfs(ans[top+1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(du, 0, sizeof(du));</span><br><span class="line">        memset(map, 0, sizeof(map));</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int x, y;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);</span><br><span class="line">            map[x][y]++; //记录边， 因为是无向图所以加两条边， 两个点之间可能有多条边</span><br><span class="line">            map[y][x]++;</span><br><span class="line">            du[x]++;</span><br><span class="line">            du[y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = 1; // flag标记开始点。 如果所有点度数全为偶数那就从1开始搜</span><br><span class="line">        sum = 0;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(du[i] % 2 == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                sum++;</span><br><span class="line">                flag = i;// 若有奇数边， 从奇数边开始搜</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum == 0 || sum == 2)</span><br><span class="line">            fleury(flag);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基本-套圈-法"><a href="#基本-套圈-法" class="headerlink" title="基本(套圈)法"></a><strong>基本(套圈)法</strong></h4><p>1.在图中任意找一个回路C；</p>
<p>2.将图中属于C的边删除；</p>
<p>3.在残留图的各个极大连通分量中求欧拉回路；</p>
<p>4.将各极大连通分量中的欧拉回路合并到C上。</p>
<h5 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h5><p>　　首先从一个节点(v0)出发，随便往下走(走过的边需要标记一下，下次就别走了)，当走到不能再走的时候，所停止的点必然也是起点(因为所有的点的度数都是偶数，能进去肯定还会出来，再者中间有可能再次经过起点，但是如果起点还能继续走，那么就要继续往下搜索，直到再次回来时不能往下搜索为止)，然后停止时，走过的路径形成了一个圈，但因为是随便走的，所以可能有些边还没走就回来了，那些剩下的边肯定也会形成一个或者多个环，然后可以从刚才终止的节点往前回溯，找到第一个可以向其他方向搜索的节点(vi)，然后再以这个点继续往下搜索，同理还会继续回到该点(vi)，于是这个环加上上次那个环就构成了一个更大的环，即可以想象成形成了一条从 v0 到 vi的路径，再由 vi 走了一个环回到 vi，然后到达v0 的一条更长的路径，如果当前的路径还不是最长的，那么继续按照上面的方法扩展。只需要在回溯时记录下每次回溯的边，最后形成的边的序列就是一条欧拉回路。如果要记录点的顺序的话，那么每访问一个点，就把这个点压入栈中，当某个点不能继续搜索时，即在标记不能走的边是，这个点成为了某种意义上的孤点，然后把这个点输出最后得到的就是一条欧拉回路路径的点的轨迹。</p>
<p>　　总之，求欧拉回路的方法是，使用深度优先搜索，如果某条边被搜索到，则标记这条边为已选择，并且即使回溯也不能将当前边的状态改回未选择，每次回溯时，记录回溯路径。深度优先搜索结束后，记录的路径就是欧拉回路。</p>
<p><strong>下面用图描述一遍：</strong></p>
<p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093836879-1824078027.png" alt="img"></p>
<p>假设我们选择从v1开始走,由于随便走，所以可能出现以下走法</p>
<p>第一步：v1 – v9</p>
<p>第二步：v9 – v8</p>
<p>第三步：v8 – v10</p>
<p>第四步：v10 – v1</p>
<p>此时由于走过的边不能再走，那么从 v1 就无法继续向下探索,所以往前回溯,记录边集Eu{&lt;v1, v10&gt;}，此时回溯到 v10 ,发现可以继续走，那么</p>
<p>第五步: v10 – v3</p>
<p>第六步: v3 – v2</p>
<p>第七步: v2 – v4</p>
<p>第八步: v4 – v10</p>
<p>发现已经无路可走，那么继续回溯，记录回溯路径得到Eu{&lt;v1,v10&gt;, &lt;v10, v4&gt;, &lt;v4, v2&gt;, &lt;v2, v3&gt;, &lt;v3, v10&gt;, &lt;v10, v8&gt;}，此时回溯到了 v8.发现可以向其他方向搜索, 那么</p>
<p>第九步：v8 – v6</p>
<p>第十步：v6 –v7</p>
<p>第十一步：v7– v8</p>
<p>又无路可走，继续回溯Eu{&lt;v1,v10&gt;, &lt;v10, v4&gt;, &lt;v4, v2&gt;, &lt;v2, v3&gt;, &lt;v3, v10&gt;, &lt;v10, v8&gt;, &lt;v8, v7&gt;, &lt;v7, v6&gt;,&lt;v6,v8&gt;,&lt;v8,v9&gt;,&lt;v9,v1&gt;}，到这里整个DFS就结束了，我们得到的边集Eu就是一条欧拉回路。</p>
<p><strong>具体实现与分析:</strong></p>
<p>使用链式前向星和DFS实现寻找欧拉回路的算法，用链式前向星存无向边时每条边要存储两次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXV = 100 + 7;</span><br><span class="line">const int MAXE = 100 * 100 + 7;</span><br><span class="line">int head[MAXV];</span><br><span class="line">int V, E;</span><br><span class="line"></span><br><span class="line">typedef struct EdgeNode</span><br><span class="line">&#123;</span><br><span class="line">    int to;</span><br><span class="line">    int w;</span><br><span class="line">    int next;   </span><br><span class="line">&#125;edgeNode;</span><br><span class="line">edgeNode Edges[MAXE];</span><br><span class="line"></span><br><span class="line">bool visit[2 * MAXE];</span><br><span class="line">stack&lt;int&gt; stv;</span><br><span class="line">queue&lt;int&gt; quv;//点集</span><br><span class="line">queue&lt;int&gt; que;//边集</span><br><span class="line"></span><br><span class="line">void EulerDFS(int now)</span><br><span class="line">&#123;</span><br><span class="line">    st.push(now);//每访问一个点，就把该点压入栈</span><br><span class="line">    for(int k = head[now]; k != -1; k = Edges[k].next)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visit[k])</span><br><span class="line">        &#123;</span><br><span class="line">            visit[k] = true;            //有向图每条边保存了两次，也要标记两次</span><br><span class="line">            if(k &amp; 1)</span><br><span class="line">                visit[k + 1] = true;</span><br><span class="line">            else</span><br><span class="line">                visit[k - 1] = true;</span><br><span class="line">            EulerDFS(Edges[k].to);</span><br><span class="line">            que.push(k);//回溯时记录边</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    quv.push(stv.top());//记录点</span><br><span class="line">    stv.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;V, &amp;E);</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    for(int i = 1; i &lt;= E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u, v, w;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        Edges[2 * i - 1].to = v;                //双向储存边</span><br><span class="line">        Edges[2 * i - 1].w = w;</span><br><span class="line">        Edges[2 * i - 1].next = head[u];</span><br><span class="line">        head[u] = 2 * i - 1;</span><br><span class="line">        Edges[2 * i].to = u;</span><br><span class="line">        Edges[2 * i].w = w;</span><br><span class="line">        Edges[2 * i].next = head[v];</span><br><span class="line">        head[v] = 2 * i;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(visit, false, sizeof(visit));</span><br><span class="line">    EulerDFS(1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-14-%E4%BE%8B%E9%A2%981b.png" alt></p>
<p>有N个盘子，每个盘子上写着一个仅由小写字母组成的英文单词。你需要给这些盘子按照合适的顺序排成一行，使得相邻两个盘子中，前一个盘子上面单词的末字母等于后一个盘子上面单词的首字母。请你编写一个程序，判断是否能达到这一要求。如果能，请给出一个合适的顺序。</p>
<h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>以26个英文字母作为顶点。对于每一个单词，在图中从它的首字母向末字母连一条有向边。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-14-%E4%BE%8B%E9%A2%981c.png" alt></p>
<p>问题转化为在图中寻找一条不重复地经过所有边的路径，即欧拉路径。这个问题能够在O(|E|)时间内解决。</p>
<h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p><strong>PKU 2337</strong></p>
<p>问题描述</p>
<p>给出一些字符串，让你首尾串起来串成一串，并且输出一个字典序最小的方案。如果不能，输出“**”。否则输出字典序最小的回路。</p>
<p><strong><em>输入</em></strong></p>
<p>2</p>
<p>6</p>
<p>aloha</p>
<p>arachnid</p>
<p>dog</p>
<p>gopher</p>
<p>rat</p>
<p>tiger</p>
<p>3</p>
<p>oak</p>
<p>maple</p>
<p>elm</p>
<p><strong>输出</strong></p>
<p>aloha.arachnid.dog.gopher.rat.tiger</p>
<p>**</p>
<p><strong>分析</strong></p>
<p>在没有特殊要求的情况下，DFS遍历图的结点顺序是可以任选的。但是这里由于加上了字典序最小的要求，所以DFS遍历时需要按照以下的优先顺序：</p>
<p>如果有不是桥的边，遍历这些边中字典序最小的边。</p>
<p>否则，遍历这些这些桥中字典序最小的边。</p>
<p>比如一个单词，abcde，那么就连接一条a到e的有向边。如此构成的图一共最多有26个节点。每条边都代表一个单词，那么就转化成了：找一条路，遍历所有的边。就是欧拉通路问题。</p>
<p>遍历欧拉通路的方法：</p>
<p>确定一个起点（出度-入度=1，或者等于0（如果存在欧拉回路的话））</p>
<p>从起点开始深搜（首先要保证图中存在欧拉回路或者通路）</p>
<p>dfs(vid, eid)</p>
<p>其中vid表示当前搜到的点。eid表示当前搜到的边（一个点可能会有很多边）</p>
<p>对于每条边，都是等它搜索完了后，把它代表的内容（这里是单词）压入一个栈中。</p>
<p>最后深搜结束后，依次弹栈就是答案。</p>
<h4 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h4><p><strong>DOOR MAN</strong></p>
<p>大意：给定N(&lt;=20)个房间,房间之间有门相隔，门的数目不超过100道，当前人在第M个房门，当前人每经过一道门的时候就把经过的门锁上，问有没有一条路可以使得我们走到第0个房门的时候所有的门都锁上了。 思路：我们可以把门看成是两个房间之间的边，那么问题可以转化成找一条欧拉路径。PS：判断的时候只要判断所有的边在一起就行了，所有的点不一定连通，当0点和M点不连通的时候，无解。注意这组数据。</p>
<h3 id="中国邮递员问题-CPP"><a href="#中国邮递员问题-CPP" class="headerlink" title="中国邮递员问题(CPP)"></a>中国邮递员问题(CPP)</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>一个邮递员从邮局出发，要走完他所管辖范围内的每一条街道，至少一次再返回邮局，如何选择一条尽可能短的路线？这就是中国邮递员问题（CPP），其命名是因为中国数学家管梅谷在1962年首先提出了这个问题。如果用顶点表示交叉路口，用边表示街道，那么邮递员所管辖的范围可用一个赋权图来表示，其中边的权重表示对应街道的长度。 </p>
<h4 id="图论语言"><a href="#图论语言" class="headerlink" title="图论语言"></a>图论语言</h4><p>中国邮递员问题可用图论语言叙述为：在一个具有非负权的赋权连通图G中，找出一条权最小的环游。这种环游称为最优环游。若G是欧拉图，则G的任意欧拉环游都是最优环游，从而可利用弗勒里算法求解。若G不是欧拉图，则G的任意一个环游必定通过某些边不止一次。将边e的两个端点再用一条权为w(e)的新边连接时，称边e为重复的。此时CPP与下述问题等价，若G是给定的有非赋权的赋权连通图，</p>
<p>（1）用添加重复边的方法求G的一个欧拉赋权母图 <img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D17/sign=f1b420a3edcd7b89ed6c3e840e244643/7acb0a46f21fbe094ed0e37d60600c338644adc8.jpg" alt="img"> ，使得  <img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D76/sign=9ab06f680155b31998f9807342a9af83/2934349b033b5bb5fc9903973dd3d539b600bc08.jpg" alt="img"> 尽可能小； </p>
<p>（2）求  <img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D17/sign=f1b420a3edcd7b89ed6c3e840e244643/7acb0a46f21fbe094ed0e37d60600c338644adc8.jpg" alt="img"> 的欧拉环游。 </p>
<p>此图图论中和中国邮递员问题类似的是旅行商问题，区别于中国邮递员问题，旅行商问题是说在边赋权的完全图中找一个权和最小的哈密尔顿圈。</p>
<p>埃德蒙兹（J.Edmonds）和约翰逊（E.L.Johnson)在1973年给出了求解（1）的多项式时间算法。</p>
<p>如果邮递员所通过的街道都是单向道，则对应的图应为有向图。1973年，埃德蒙兹和约翰逊证明此时CPP也有多项式时间算法。帕帕季米特里屋（C.H.Papadimitrious）在1976年证明，如果既有双向道，又有单向道，则CPP是NP困难的。</p>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>由于每边至少遍历一次，所以最短路的瓶颈就在于重复遍历。由于图一直保持连通性，所以两两奇点之间都存在欧拉路；又两两奇点之间的最短路可求；奇点个数为偶数。所以问题就等价于找一个奇点构成的完全图G’(V,E)的最小权匹配(Perfect Matching in General Graph)。V(G’)为原图G中的奇点，每条边为两奇点对应原图的最短路长度。</p>
<h4 id="奇偶点图作业法"><a href="#奇偶点图作业法" class="headerlink" title="奇偶点图作业法"></a>奇偶点图作业法</h4><ol>
<li><p>确定G中的奇点，构成G’。</p>
</li>
<li><p>确定G’两两结点在G中的最短路作为它们在G’中的边权。</p>
</li>
<li><p>对G’进行最小权匹配。</p>
</li>
<li><p>最小权匹配里的各匹配边所对应的路径在G中被重复遍历一次,得到欧拉图G’’。</p>
</li>
<li><p>对G’’找一条欧拉路即可。</p>
</li>
</ol>
<p>有向的中国邮路问题，比较复杂。</p>
<h2 id="哈密顿图（H问题）"><a href="#哈密顿图（H问题）" class="headerlink" title="哈密顿图（H问题）"></a>哈密顿图（H问题）</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/%E5%93%88%E5%AF%86%E9%A1%BF%E5%9C%88.png" alt></p>
<p>1857年，英国数学家汉密尔顿(Hamilton)提出了著名的汉密尔顿回路问题，其后，该问题进一步被发展成为所谓的“货郎担问题”，即赋权汉密尔顿回路最小化问题：这两个问题成为数学史上著名的难题。 </p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><strong>汉密尔顿路：</strong>给定图G，若存在一条路，经过图中每个结点恰好一次，这条路称作汉密尔顿路。  </p>
<p><strong>汉密尔顿回路：</strong>给定图G，若存在一条回路，经过图中每个结点恰好一次，这条回路称作汉密尔顿回路。  </p>
<p><strong>汉密尔顿图：</strong>具有汉密尔顿回路的图，称作汉密尔顿图。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>必须说明，汉密尔顿回路问题是一个NP完全问题(NP-Complete)，也就是说，至今没有一个行之有效的多项式时间的算法能够找到这类问题的最优解，只有一些近似算法。关于NPC问题，我们这里不做讨论。我们一般情况下，直接用DFS进行搜索，当然，如果图的点比较多的时候(一般n&gt;10)，这个算法是不现实的。</p>
<h3 id="旅行商问题-TSP"><a href="#旅行商问题-TSP" class="headerlink" title="旅行商问题(TSP)"></a>旅行商问题(TSP)</h3><p><a href="https://baike.baidu.com/pic/%E4%B8%AD%E5%9B%BD%E9%82%AE%E9%80%92%E5%91%98%E9%97%AE%E9%A2%98/11055168/0/d31b0ef41bd5ad6ea2c41f7288cb39dbb6fd3c6c?fr=lemma&amp;ct=single" target="_blank" rel="noopener"><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=ed589fa1bade9c82a265fe8d5c8080d2/d31b0ef41bd5ad6ea2c41f7288cb39dbb6fd3c6c.jpg" alt="img"></a></p>
<p>Traveling Salesman Problem，即旅行商问题， 旅行商人要拜访N个城市，他必须选择所要走的路径，路径的限制是每个城市只能拜访一次，而且最后要回到原来出发的城市。路径的选择目标是要求得的路径路程为所有路径之中的最小值，这是一个NP难问题。 </p>
<p>TSP的历史很久，最早的描述是1759年欧拉研究的骑士周游问题，即对于国际象棋棋盘中的64个方格，走访64个方格一次且仅一次，并且最终返回到起始点。</p>
<p>TSP由美国RAND公司于1948年引入，该公司的声誉以及线形规划]这一新方法的出现使得TSP成为一个知名且流行的问题。</p>
<h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><p>状压DP</p>
<h1 id="着色问题"><a href="#着色问题" class="headerlink" title="着色问题"></a>着色问题</h1><p>图的着色问题是由地图的着色问题引申而来的：用m种颜色为地图着色，使得地图上的每一个区域着一种颜色，且相邻区域颜色不同。问题处理：如果把每一个区域收缩为一个顶点，把相邻两个区域用一条边相连接，就可以把一个区域图抽象为一个平面图。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-15-%E5%9C%B0%E5%9B%BE%E9%97%AE%E9%A2%98.png" alt></p>
<p>通常所说的着色问题是指下述两类问题：</p>
<p>1．给定无环图G=(V,E)，用m种颜色为图中的每条边着色，要求每条边着一种颜色，并使相邻两条边有着不同的颜色，这个问题称为图的边着色问题。</p>
<p>2．给定无向图G=(V,E)，用m种颜色为图中的每个顶点着色，要求每个顶点着一种颜色，并使相邻两顶点之间有着不同的颜色，这个问题称为图的顶着色问题。</p>
<h2 id="边着色问题"><a href="#边着色问题" class="headerlink" title="边着色问题"></a>边着色问题</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>给图G的边着色，使得有共同顶点的边异色的最少颜色数，称为边色数。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-15-%E8%BE%B9%E7%9D%80%E8%89%B2%E5%9B%BE.png" alt></p>
<h4 id="妖怪图（snark-graph）"><a href="#妖怪图（snark-graph）" class="headerlink" title="妖怪图（snark graph）"></a>妖怪图（snark graph）</h4><p>妖怪图每个点都关联着3条边，用4种颜色可以把每条边涂上颜色，使得有公共端点的边异色，而用3种颜色办不到，切断任意3条边不会使它断裂成2个有边的图。</p>
<p><strong>单星妖怪和双星妖怪：</strong></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-15-%E5%A6%96%E6%80%AA%E5%9B%BE.png" alt></p>
<h4 id="时间表问题；"><a href="#时间表问题；" class="headerlink" title="时间表问题；"></a>时间表问题；</h4><p>设x1,x2,…,xm为m个工作人员，y1,y2,…,yn表为n种设备，工作人员对设备提出要求，使用时间均假定以单位时间计算，自然每一个工作人员在同一个时间只能使用一种设备，某一种设备在同一时间里只能为一个工作人员使用，问应如何合理安排，使得尽可能短时间里满足工作人员的要求？       </p>
<p>问题转换为X={x1,x2,…,xm}，Y={y1,y2,…,yn}的二分图G，工作人员xi要求使用设备yj，每单位时间对应一条从xi到yj的边，这样所得的二分图过xi ，yj的边可能不止一条。问题变为对所得二分图G的边着色问题。有相同颜色的边可以安排在同一时间里。</p>
<h3 id="定理："><a href="#定理：" class="headerlink" title="定理："></a>定理：</h3><p>二分图G的边色数＝图中顶点的最大度。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-15-%E4%BA%8C%E5%88%86%E5%9B%BE%E8%BE%B9%E8%89%B2.png" alt></p>
<h4 id="定理-Vizing-1964-："><a href="#定理-Vizing-1964-：" class="headerlink" title="定理(Vizing 1964)："></a>定理(Vizing 1964)：</h4><p>若图G为简单图，图中顶点最大度为d，则G的边色数为d或d+1。</p>
<p><strong><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-15-%E7%AC%AC%E4%B8%80%E7%AC%AC%E4%BA%8C%E7%B1%BB%E5%9B%BE.png" alt></strong></p>
<p>目前仍无有效区分(判别)任给定图属第几类图的有效方法。</p>
<h3 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h3><p>边的着色问题可以转化为顶点的着色问题。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-15-%E8%BE%B9%E7%82%B9%E7%9D%80%E8%89%B2.png" alt></p>
<h2 id="点着色问题"><a href="#点着色问题" class="headerlink" title="点着色问题"></a>点着色问题</h2><h3 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h3><p>给图G的顶点着色，使得相邻的顶点异色的最少颜色数，称为图G顶色数，简称色数；记作χ(G)。</p>
<h3 id="四色猜想："><a href="#四色猜想：" class="headerlink" title="四色猜想："></a>四色猜想：</h3><p>平面图的色数不大于5。</p>
<h3 id="色数的性质："><a href="#色数的性质：" class="headerlink" title="色数的性质："></a>色数的性质：</h3><p>（1）图G只有孤立点时，χ(G)=1；</p>
<p>（2）n个顶点的完全图G有χ(G)=n；</p>
<p>（3）若图G是n个顶点的回路，则χ(G)=2，        n为偶数。χ(G) =3，        n为奇数；</p>
<p>（4）图G是顶点数超过1的树时，χ(G)=2；</p>
<p>（5）若图G是二分图，则χ(G)=2。</p>
<h3 id="定理：-1"><a href="#定理：-1" class="headerlink" title="定理："></a>定理：</h3><p>图G=(V,E)的色数χ(G)=2的充要条件是：(1)|E|≥1；(2)G不存在边数为奇数的回路。</p>
<p>若图G=(V,E)，d=max{d(vi)},vi∈V，则χ(G)≤d+1。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>欧拉图</tag>
        <tag>哈密顿图</tag>
        <tag>连通图</tag>
        <tag>着色问题</tag>
      </tags>
  </entry>
  <entry>
    <title>ccpc-wannafly秦皇岛站集训部分题解</title>
    <url>/2018/08/13/2018-08-12/</url>
    <content><![CDATA[<h1 id="WANNAFLY-DAY1"><a href="#WANNAFLY-DAY1" class="headerlink" title="WANNAFLY_DAY1"></a>WANNAFLY_DAY1</h1><h2 id="Problem-A-Birthday"><a href="#Problem-A-Birthday" class="headerlink" title="Problem A. Birthday"></a>Problem A. Birthday</h2><p>恬恬的生日临近了。宇扬给她准备了一个大蛋糕。</p>
<p>正如往常一样，宇扬在蛋糕上插了n支蜡烛，并把蛋糕分为m个区域。因为某种原因，他必须把第i根蜡烛插在第ai个区域或第bi个区域。区域之间是不相交的。宇扬在一个区域内同时摆放x支蜡烛就要花费x2的时间。宇扬布置蛋糕所用的总时间是他在每个区域花的时间的和。</p>
<p>宇扬想快些见到恬恬，你能告诉他布置蛋糕最少需要多少时间吗？</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个整数n，m（1 ≤ n ≤ 50， 2 ≤ m ≤ 50）。<br>接下来n行，每行两个整数ai, bi（1 ≤ ai, bi ≤ m）。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个整数表示答案</p>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>standard input<br>3 3<br>1 2<br>1 2<br>1 2</p>
<p>standard output</p>
<p>5</p>
<p>standard input </p>
<p>3 3<br>1 2<br>2 3<br>1 3</p>
<p>standard output</p>
<p>3</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>考虑费用流时把每个part拆成n个点，选择第i个点的代表为放置i块蛋糕和(i - 1)块蛋糕的时间差，这个时间差是增的，因此在费用流的过程中必定会从小到大选择<br>具体建图：左边n个点代表n个蛋糕，右边m * n个点代表m个part,每个part拆成n个点。源点向每个左边的点连一条流量1费用0的边，每个右边的点向汇点连一条流量1费用0的编。每个蛋糕向可以放的两个part的所有点连边，连向第i个点的费用为i^2 - (i - 1)^2，流量为1。这样求最小费用流既为答案。</p>
<h2 id="Problem-B-Board"><a href="#Problem-B-Board" class="headerlink" title="Problem B. Board"></a>Problem B. Board</h2><p>恬恬有一个n × n的数组。她在用这个数组玩游戏：</p>
<p>开始时，数组中每一个元素都是0。</p>
<p>恬恬会做某些操作。在一次操作中，她可以将某一行的所有元素同时加上一个值，也可以将某一列的所有元素同时加上一个值。</p>
<p>在几次操作后，一个元素被隐藏了。你能帮助她回忆隐藏的数是几吗？</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数n（1 ≤ n ≤ 1000）。<br>接下来n行每行n个整数表示数组a。<br>第(i + 1)行的第j个元素表示aij（aij = −1或0 ≤ aij ≤ 100000）。−1表示隐藏的元素</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>仅一个整数表示答案</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>standard input<br>3<br>1 2 1<br>0 -1 0<br>0 1 0</p>
<p> standard output</p>
<p>1</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>把格子N染色，第i行第j列格子的颜色为(i + j) % N。那么每次操作时，必定是N种不同的颜色都有一格被操作到，因此最后任何颜色格子的和必定是相等的。因此只需要记录每种颜色格子的和，并算出缺失格子的颜色C，用其余颜色的和减去颜色C的和即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1005;</span><br><span class="line">int map[maxn][maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	int x,y;</span><br><span class="line">	while(cin&gt;&gt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int i=0;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int j=0;j&lt;n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				cin&gt;&gt;map[i][j];</span><br><span class="line">				if(map[i][j]==-1) </span><br><span class="line">				&#123;</span><br><span class="line">					x=i;</span><br><span class="line">					y=j;	</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		for(int i=0;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(i==x) continue;</span><br><span class="line">			int minn=0x3f3f3f;</span><br><span class="line">			for(int j=0;j&lt;n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				minn=min(minn,map[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">			for(int j=0;j&lt;n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				map[i][j]-=minn;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=0;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(i==y) continue;</span><br><span class="line">			int minn=0x3f3f3f;</span><br><span class="line">			for(int j=0;j&lt;n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				minn=min(minn,map[j][i]);</span><br><span class="line">			&#125;</span><br><span class="line">			for(int j=0;j&lt;n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				map[j][i]-=minn;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int ans1=0,ans2=0;</span><br><span class="line">		for(int i=0;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(map[i][y]!=0 &amp;&amp; map[i][y]!=-1) ans1=map[i][y];</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=0;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(map[x][i]!=0 &amp;&amp; map[x][i]!=-1) ans2=map[x][i];</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans1+ans2&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Problem-C-Circle"><a href="#Problem-C-Circle" class="headerlink" title="Problem C. Circle"></a>Problem C. Circle</h2><p>现在我们要把1 . . . n这n个数字首尾连接组成一个环，使得相邻元素互质的对数尽可能多。请输出最大对数。</p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>一行一个整数n(1 ≤ n ≤ 1000)。</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>一行一个整数表示答案。</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p>standard input </p>
<p>4</p>
<p>standard output<br>4</p>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>样例的一种构造方法为1 4 3 2。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>因为(i,i+1)=1且(1,n)=1，所以把1…n依次放进一个环，就可以啦。答案为n。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+7;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	while(cin&gt;&gt;t)&#123;</span><br><span class="line">	cout&lt;&lt;t&lt;&lt;endl;	</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Problem-D-土龙弟弟"><a href="#Problem-D-土龙弟弟" class="headerlink" title="Problem D. 土龙弟弟"></a>Problem D. 土龙弟弟</h2><h2 id="Problem-E-Growth"><a href="#Problem-E-Growth" class="headerlink" title="Problem E. Growth"></a>Problem E. Growth</h2><p>弱弱有两个属性a和b，这两个属性初始的时候均为0，每一天他可以通过努力，让a涨1点或b涨1点。</p>
<p>为了激励弱弱努力学习，我们共有n种奖励，第i种奖励有xi，yi，zi三种属性，若a ≥ xi且b ≥ yi，则弱<br>弱在接下来的每一天都可以得到zi的分数。</p>
<p>问m天以后弱弱最多能得到多少分数。</p>
<h3 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h3><p>第一行一个两个整数n和m（1 ≤ n ≤ 1000，1 ≤ m ≤ 2000000000）。<br>接下来n行，每行三个整数xi，yi，zi（1 ≤ xi, yi ≤ 1000000000，1 ≤ zi ≤ 1000000）。</p>
<h3 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h3><p>一行一个整数表示答案。</p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h3><p>standard input<br>2 4<br>2 1 10<br>1 2 20</p>
<p> standard output</p>
<p>50</p>
<h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>在样例中，弱弱可以这样规划：第一天a涨1，第二天b涨1，第三天b涨1，第四天a涨1。<br>共获得0 + 0 + 20 + 30 = 50分</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>把奖励的x拿出来从小到大排序，得到x1,x2,…,xn。<br>把奖励的y拿出来从小到大排序，得到y1,y2,…,yn。<br>用v[i][j]表示a值到达xi，b值达到yi时接下来每天可以得到的奖励。<br>v[i][j] = v[i - 1][j] + v[i][j - 1] - v[i - 1][j - 1] + t[i][j]<br>其中t[i][j]为满足x=i，y=j的奖励的总和。<br>用f[i][j]表示a值达到xi，b值达到yj时已经拿到的奖励的最大值。<br>f[i][j] + (x[i + 1] - x[i] - 1) <em> t[i][j] + t[i + 1][j] -&gt; f[i + 1][j]<br>f[i][j] + (y[j + 1] - y[j] - 1) </em> t[i][j] + t[i][j + 1] -&gt; f[i][j + 1]<br>最后统计一下答案就可以了。</p>
<h2 id="Problem-F-Kingdom"><a href="#Problem-F-Kingdom" class="headerlink" title="Problem F. Kingdom"></a>Problem F. Kingdom</h2><p>X王国有n位官员，编号从1到n。国王是1号官员。除了国王以外，每个官员都有一个上司。我们称这个<br>官员是这个上司的下属。上司的编号总比下属小。</p>
<p>我们定义一个官员的影响力为他所有下属的影响力之和再加1。例如，一个没有下属的官员的影响力<br>是1。国王的影响力总是n。</p>
<p>任何一位有下属的官员总是选择他的下属中影响力最高的作为他的心腹（有若干下属影响力相同的话则<br>会选择编号最小的）。</p>
<p>一位官员得到一条消息后，他就要把消息传达给国王。我们定义一位官员的花费为他将消息传达给国王<br>的花费。国王自己的花费为0。如果一位官员是他上司的心腹，则他的花费等于他上司的花费，否则他<br>的花费为他上司的花费加1。</p>
<p>由于时代和平，消息并不需要传递的太快。我们希望你决定每位官员（除了国王）的上司，使得所有官<br>员的花费之和和尽量小。</p>
<h3 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h3><p>一个整数n（1 ≤ n ≤ 8000）表示包括国王在内的官员的总数。</p>
<h3 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h3><p>一个整数表示最大的花费之和。</p>
<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a>Example</h3><p>standard input<br>4</p>
<p> standard output</p>
<p>2</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>f[i]代表i个点时的答案，g[i][j]代表若干颗树加起来，size和为i，每棵树size&lt;=j时，这些树的代价和最大是多少<br>从1到n枚举i，在i固定时枚举心腹的影响力大小更新f[i]，然后用类似背包的思路更新g[i][1]~g[i][i]<br>复杂度O(N^2)</p>
<h2 id="Problem-G-Matrix"><a href="#Problem-G-Matrix" class="headerlink" title="Problem G. Matrix"></a>Problem G. Matrix</h2><p>弱弱有一个n × m的矩阵，第i行第j列位置上的值为aij。<br>弱弱定义以(x, y)为顶点，大小为k的三角形为：</p>
<p>第x行y位置，<br>第x + 1行y − 1，y，y + 1位置，<br>. . .，<br>第x + k − 1行y − k + 1，. . .，y + k − 1位置组成的区域。</p>
<p>比如说，以(1, 3)为顶点，大小为3的三角形为</p>
<p>OOXOOOO<br>OXXXOOO<br>XXXXXOO<br>OOOOOOO<br>中打叉的位置。</p>
<p>现在弱弱想要知道所有大小为k的三角形中，重心位置离顶点最近的是哪个？重心是三角形中每个位置<br>按照它们的值加权平均所得的点。<br>请输出这个最小距离（欧几里得距离）。</p>
<h3 id="Input-5"><a href="#Input-5" class="headerlink" title="Input"></a>Input</h3><p>第一行一个三个整数n，m，k（1 ≤ n ≤ 1000，1 ≤ m ≤ 1000，1 ≤ k ≤ min n,(m + 1)/2</p>
<p>接下来n行，每行m个整数aij（1 ≤ aij ≤ 1000）表示每个位置的重量。</p>
<h3 id="Output-5"><a href="#Output-5" class="headerlink" title="Output"></a>Output</h3><p>一行一个数表示答案。相对误差或绝对误差在10−5（1e-5）之内均会被判断为正确。</p>
<h3 id="Example-4"><a href="#Example-4" class="headerlink" title="Example"></a>Example</h3><p>standard input<br>2 3 2<br>1 1 1<br>1 1 1</p>
<p>standard output</p>
<p>0.7500000000</p>
<h3 id="Note-2"><a href="#Note-2" class="headerlink" title="Note"></a>Note</h3><p>只有一个大小为2的三角形。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>w个格子的重心的坐标为（∑xi<em>wi / ∑wi, ∑yi</em>wi / ∑wi)。<br>那么其实我们只要维护∑xi<em>wi，∑yi</em>wi，∑wi就可以了。<br>假设我们现在有一个顶点为(x, y)的三角形，我们想要推到顶点为(x, y+1)的三角形，观察两者之间的差异，会发现在推过去的过程中，其实就是删去了一个斜条，又加入了一个斜条。<br>同理，从(x, y)到(x+1, y)其实只是删去了两个斜条，加上了底上的横条，而这些关键的值都是可以通过前缀和的方法维护。</p>
<h2 id="Problem-H-Mountain"><a href="#Problem-H-Mountain" class="headerlink" title="Problem H. Mountain"></a>Problem H. Mountain</h2><p>平面上有n座山，每座山都有左右两面，第i座山的高度为ai，现在弱弱在第一座山的左边山脚下（高度为0），他想要依此爬过这些山，到达第n座山的右边山脚下。</p>
<p>除了简单的爬上爬下，还有一种特殊操作。</p>
<p>如果弱弱目前在第i座山右面的海拔x的位置，且第j(i &lt; j)座山的海拔大于等于x，且第i + 1, . . . , j − 1座山中没有一座山的海拔高于x，那么他可以使用绳索滑到第j座山左面海拔x的位置。</p>
<p>弱弱想找到一种方式，使得他在行程中海拔变化的幅度最小。请输出最小幅度。</p>
<h3 id="Input-6"><a href="#Input-6" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数n（1 ≤ n ≤ 1000）。<br>接下来一行n个整数ai（1 ≤ ai ≤ 1000）表示每座山的高度。</p>
<h3 id="Output-6"><a href="#Output-6" class="headerlink" title="Output"></a>Output</h3><p>一行一个整数表示答案。</p>
<h3 id="Example-5"><a href="#Example-5" class="headerlink" title="Example"></a>Example</h3><p>standard input<br>5<br>1 3 5 4 2</p>
<p>standard output</p>
<p>10</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>考虑山中最高的一座，最优操作一定是从第一座山的左下角开始不停地往上爬，然后从最高的山不停地往下爬爬到最后一座山的右下角。<br>所以答案为最高山的高度*2。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1007], n;</span><br><span class="line">int main()&#123;</span><br><span class="line"> while(cin&gt;&gt;n)&#123;</span><br><span class="line">  int cnt = 0;</span><br><span class="line">  a[0] = 0;</span><br><span class="line">  int cur = 0;</span><br><span class="line">  for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">   cin&gt;&gt;a[i];</span><br><span class="line">   if(a[i] &gt;= a[cur])&#123;</span><br><span class="line">    cnt += abs(a[i] - a[cur]);</span><br><span class="line">    cur = i;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while(cur&lt;n)&#123;</span><br><span class="line">   int cur2 = cur+1;</span><br><span class="line">   for(int i = cur2;i&lt;=n;i++)&#123;</span><br><span class="line">    if(a[i] &gt;= a[cur2])&#123;</span><br><span class="line">     cur2 = i;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cnt+=abs(a[cur2]-a[cur]);</span><br><span class="line">   cur = cur2;</span><br><span class="line">  &#125;</span><br><span class="line">  cnt+=a[n];</span><br><span class="line">  cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Problem-I-清明梦超能力者黄"><a href="#Problem-I-清明梦超能力者黄" class="headerlink" title="Problem I. 清明梦超能力者黄"></a>Problem I. 清明梦超能力者黄</h2><p>黄YY是一个清明梦超能力者，同时也是一个记忆大师。他能够轻松控制自己在梦中的一切，在醒来之<br>后还能清晰的记得梦中所有的细节，这让他的朋友们都十分羡慕。</p>
<p>又是一个晚上，黄YY又到了自己的梦中，并且随手造出了一棵有n个点的树，树上每个点有一个初始颜<br>色0。为了让这棵树不那么单调，黄YY拿起了画笔在上面尽情上色。每一次上色可以用u, v, c来描述，代<br>表黄YY把u, v这条路径上的点都染色成了c。</p>
<p>正当黄YY开心的完成了m次染色，准备在早上醒来之时向朋友们炫耀。但现实中的黄YY由于过于兴奋<br>滚到了床下，撞到了脑袋，在剧痛中醒来。由于脑部受到了严重创伤，黄YY对刚才梦境中发生的一切<br>发生了严重的信息丢失。</p>
<p>但英俊潇洒的黄YY当然不希望自己的窘态被朋友们发现。为了证明自己还是那个清明梦超能力者，他<br>希望告诉朋友们自己上色后每个节点的颜色。同时为了更进一步证明他还是个记忆大师，他希望干脆直<br>接说出每个点在倒数第k次染色时的颜色。</p>
<p>当然，现在的黄YY已经成了弱智了，作为黄YY最亲密的朋友，你快来帮帮黄YY吧！</p>
<h3 id="Input-7"><a href="#Input-7" class="headerlink" title="Input"></a>Input</h3><p>第一行三个整数n, m, k，代表树的点数，黄YY染色的次数，以及最后求颜色时，倒数的次数<br>（1 ≤ n, m, k ≤ 100000）。</p>
<p>接下来n − 1行，每行u, v代表u, v两点之间有一条边。这里保证1 ≤ u, v ≤ n，且无重边与自环，是一棵<br>标准的树。</p>
<p>接下来m行，每一行三个数字u, v, c代表黄YY在第这次用c颜色的画笔从u涂到了v。</p>
<h3 id="Output-7"><a href="#Output-7" class="headerlink" title="Output"></a>Output</h3><p>一行n个数字，输出每个点倒数第k次染色时的颜色。如果本身不足k次，输出0。</p>
<h3 id="Example-6"><a href="#Example-6" class="headerlink" title="Example"></a>Example</h3><p>standard input </p>
<p>3 3 2</p>
<p>1 2</p>
<p>2 3</p>
<p>1 2 1</p>
<p>2 3 2</p>
<p>1 3 3</p>
<p>standard output</p>
<p>1 2 2</p>
<h3 id="Note-3"><a href="#Note-3" class="headerlink" title="Note"></a>Note</h3><p>对于点1在第一次和第三次染色的时候分别被染色为1, 3，倒数第二次的颜色就是1。</p>
<p>对于点2在第一、二、三次染色的时候分别被染色为1, 2, 3，倒数第二次的颜色就是2。</p>
<p>对于点3在第二次和第三次染色的时候分别被染色为2, 3，倒数第二次的颜色就是2。</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>首先每条路径从LCA处分开可以拆成两条链<br>假设链A-&gt;B执行了第i次染色操作，假设A是B的祖先，那么我们在B点加入一个”插入i”的事件，在A的父亲点加入一个”删除i”的事件<br>然后dfs整颗树求解，每个点维护一个线段树。处理一个点时先合并所有儿子的线段树，然后再处理这个点上的事件，得到线段树之后询问第K大值既可得到答案。<br>复杂度分析：<br>Node<em> merge(Node</em> a, Node* b) {<br>    if (a == NULL) return b;<br>    if (b == NULL) return a;<br>    a-&gt;sum += b-&gt;sum;<br>    a-&gt;child[0] = merge(a-&gt;child[0], b-&gt;child[0]);<br>    a-&gt;child[1] = merge(a-&gt;child[1], b-&gt;child[1]);<br>    return a;<br>}<br>考虑以上的线段树合并，每次合并会减少一个区间。而在事件点插入、删除的时候会产生至多log个区间，因此复杂度为O(NLogN)</p>
<h2 id="Problem-J-最短路"><a href="#Problem-J-最短路" class="headerlink" title="Problem J. 最短路"></a>Problem J. 最短路</h2><p>给一个连通图，每次询问两点间最短路。每条边的长度都是1。</p>
<h3 id="Input-8"><a href="#Input-8" class="headerlink" title="Input"></a>Input</h3><p>第一行两个整数n和m，表示图的点数和边数（1 ≤ n ≤ 100000, 1 ≤ m ≤ n + 100）。</p>
<p>接下来m行每行两个整数a和b，表示一条边（1 ≤ a, b ≤ n）。保证没有自环和重边。保证图连通。</p>
<p>接下来一个整数q表示询问的个数（1 ≤ q ≤ 100000）。</p>
<p>接下来q行每行两个整数a和b表示询问a和b之间的最短路。</p>
<h3 id="Output-8"><a href="#Output-8" class="headerlink" title="Output"></a>Output</h3><p>每个询问输出一行表示答案</p>
<h3 id="Example-7"><a href="#Example-7" class="headerlink" title="Example"></a>Example</h3><p>input</p>
<p>4 5<br>1 2<br>2 3<br>1 4<br>4 3<br>2 4<br>4<br>1 4<br>1 2<br>2 4<br>1 3</p>
<p>output</p>
<p>1<br>1<br>1<br>2</p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>本题十分直接。我们不断地把度数为1的点删掉，把度数为2的点收缩，最后会得到一个图，和原图的点数与边数之差相同，且新图中每个点的度数都至少是3。这就是说我们会得到一个200个点300条边以内的图。新图可以用Floyd算法预处理所有点对之间最短路。询问时，将询问转化到新图上即可。转化时需要注意细节。</p>
<h1 id="WANNAFLY-DAY2"><a href="#WANNAFLY-DAY2" class="headerlink" title="WANNAFLY_DAY2"></a>WANNAFLY_DAY2</h1><h2 id="Problem-A-Tobaku-Mokushiroku-Kaiji"><a href="#Problem-A-Tobaku-Mokushiroku-Kaiji" class="headerlink" title="Problem A. Tobaku Mokushiroku Kaiji"></a>Problem A. Tobaku Mokushiroku Kaiji</h2><p>开司正在与另外一人玩石头剪刀布。双方各有一些代表石头、剪刀、布的卡牌，每局两人各出一张卡<br>牌，根据卡牌的内容决定这一局的胜负。胜负规则为：石头赢剪刀、剪刀赢布、布赢石头、相同为平<br>局。每张卡牌至多被使用一次。<br>已知双方的卡牌数量，问开司最多赢几局？</p>
<h3 id="Input-9"><a href="#Input-9" class="headerlink" title="Input"></a>Input</h3><p>一行六个数字a, b, c, d, e, f(0 ≤ a, b, c, d, e, f ≤ 50)，a, b, c分别表示开司的石头、剪刀、布的牌的数<br>量，d, e, f分别表示此时另一人的石头、剪刀、布的牌的数量。</p>
<h2 id="Output-9"><a href="#Output-9" class="headerlink" title="Output"></a>Output</h2><p>一个整数表示开司最多赢几局</p>
<h3 id="Example-8"><a href="#Example-8" class="headerlink" title="Example"></a>Example</h3><p>in</p>
<p>29 7 41 14 12 42</p>
<p>out</p>
<p>33</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int a[6];</span><br><span class="line">	for(int i = 0;i&lt;6;i++)</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	cout&lt;&lt;min(a[0],a[4])+min(a[1],a[5])+min(a[2],a[3])&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Problem-E-Eustia-of-the-Tarnished-Wings"><a href="#Problem-E-Eustia-of-the-Tarnished-Wings" class="headerlink" title="Problem E. Eustia of the Tarnished Wings"></a>Problem E. Eustia of the Tarnished Wings</h2><p>Novus Aither是一个潜藏着多个势力的城市。每个势力都有一个唯一的领导人，每个领导人有一个属性<br>值。如果两个势力的领导人的属性值分别为a, b，且|a − b| ≤ m，说明这两个领导人的思想有一定的相似<br>之处，这两个势力可以合并，新的领导人可以指定为原来的两个领导人中的任意一个。新产生的势力可<br>以依照相同的的规则，继续与其他势力合并。问在所有可能的合并情况中，最少会剩下几个势力。</p>
<h3 id="Input-10"><a href="#Input-10" class="headerlink" title="Input"></a>Input</h3><p>第一行两个空格隔开的整数n(1 ≤ n ≤ 106<br>), m(0 ≤ m109<br>)。n代表当前势力的个数。m的含义如题目描<br>述。<br>第二行n个空格隔开的整数di(0 ≤ di ≤ 109<br>)，代表第i个势力的领导人的属性值。</p>
<h3 id="Output-10"><a href="#Output-10" class="headerlink" title="Output"></a>Output</h3><p>输出一个数表示势力的最少数量。</p>
<p>Example<br>standard input<br>4 1<br>2 1 3 10</p>
<p>standard output</p>
<p>2</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">const int maxn = 1e6+7;</span><br><span class="line">ll a[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">	ios::sync_with_stdio(false);</span><br><span class="line">	cin.tie(0);</span><br><span class="line">	ll n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	for(int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a,a+n);</span><br><span class="line">	int cnt = 1;</span><br><span class="line">	for(int i = 1;i&lt;n;i++)&#123;</span><br><span class="line">		if(a[i]-a[i-1]&gt;m)</span><br><span class="line">			cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="WANNAFLY-DAY3"><a href="#WANNAFLY-DAY3" class="headerlink" title="WANNAFLY_DAY3"></a>WANNAFLY_DAY3</h1><h2 id="Problem-D-Shopping"><a href="#Problem-D-Shopping" class="headerlink" title="Problem D. Shopping"></a>Problem D. Shopping</h2><p>你要买n件物品，其中有一些是凳子。<br>商场正在举行促销活动，如果购物车中有至少一个凳子，那么你可以半价购买这个购物车中最贵的一个<br>物品。<br>你有m辆购物车，请最小小化你的花费。</p>
<h3 id="Input-11"><a href="#Input-11" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数t表示数据组数(1 ≤ t ≤ 100)。</p>
<p>每组数据第一行两个整数n, m (1 ≤ n, m ≤ 1000)，接下来n行每行两个整数ai<br>, bi，分别表示第i件物品的<br>价格以及它是否是凳子(1 ≤ ai ≤ 105<br>, 0 ≤ bi ≤ 1)。</p>
<h3 id="Output-11"><a href="#Output-11" class="headerlink" title="Output"></a>Output</h3><p>每组数据输出一行一个实数表示最小花费，保留一位小数。</p>
<p>Example<br>stdin<br>2<br>5 1<br>1 0<br>2 1<br>3 1<br>4 0<br>5 0<br>5 10<br>1 0<br>2 1<br>3 1<br>4 0<br>5 0</p>
<p>stdout</p>
<p>12.5<br>10.5</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line">const int maxn = 1007;</span><br><span class="line">struct node&#123;</span><br><span class="line">	double cost;</span><br><span class="line">	int flag;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line">int cmp(node a,node b)&#123;</span><br><span class="line">	return a.cost&gt;b.cost;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">		int cnt = 0;</span><br><span class="line">		double all = 0;</span><br><span class="line">		for(int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">			cin&gt;&gt;a[i].cost;</span><br><span class="line">			cin&gt;&gt;a[i].flag;</span><br><span class="line">			if(a[i].flag==1)</span><br><span class="line">				cnt++;</span><br><span class="line">			all+=a[i].cost;</span><br><span class="line">		&#125;</span><br><span class="line">		if(cnt&gt;m)</span><br><span class="line">			cnt = m;</span><br><span class="line">		sort(a,a+n,cmp);</span><br><span class="line">		for(int i = 0;i&lt;cnt;i++)&#123;</span><br><span class="line">			all-=(a[i].cost/2.0);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%.1lf\n&quot;,all);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="WANNAFLY-DAY4"><a href="#WANNAFLY-DAY4" class="headerlink" title="WANNAFLY_DAY4"></a>WANNAFLY_DAY4</h1><h2 id="7-贵族用户"><a href="#7-贵族用户" class="headerlink" title="7 贵族用户"></a>7 贵族用户</h2><p>终于活成了自己讨厌的样子。<br>充钱能让你变得更强。</p>
<p>在暖婊这个游戏里面，如果你充了 x 元钱，那么你能获得 10x 个钻石。同时暖婊也有 m 档VIP，如果你往暖婊里面充了 ai 个钻石，那么你能成为第 i 档贵族用户。当你成为为第 i 档贵族用户。当你成为第 i 档贵族用户之后，那么你可以获得 pi% 的优惠。</p>
<p>你需要 k 件材料合成衣服，其中第 i 件材料原价为 di 个钻石，你一共需要 ci 件这种材料。<br>当你获得 p 的优惠时，这个材料的真实价格为 ⌈di(1 − p)⌉。<br>请问栗子米最少需要氪多少钱，这里我们规定只能氪整数的钱。</p>
<h3 id="7-2-输入格式"><a href="#7-2-输入格式" class="headerlink" title="7.2 输入格式"></a>7.2 输入格式</h3><p>第一行一个整数 T(T ≤ 1000)，表示数据组数。<br>每组数据第一行两个整数 m, k(1 ≤ m, k ≤ 15)。</p>
<p>接下来 m 行每行两个正整数 1 ≤ ai ≤ 105<br>, 1 ≤ pi ≤ 100，保证 ai &lt; ai+1, pi ≤ pi+1。<br>接下来 k 行每行两个正整数 1 ≤ ci<br>, di ≤ 1000。</p>
<h3 id="7-3-输出格式"><a href="#7-3-输出格式" class="headerlink" title="7.3 输出格式"></a>7.3 输出格式</h3><p>对于每组数据，输出一个整数，表示至少要氪多少钱。</p>
<h3 id="7-4-样例输入"><a href="#7-4-样例输入" class="headerlink" title="7.4 样例输入"></a>7.4 样例输入</h3><p>1<br>1 1<br>100 100<br>100 100</p>
<h3 id="7-5-样例输出"><a href="#7-5-样例输出" class="headerlink" title="7.5 样例输出"></a>7.5 样例输出</h3><p>10</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int m,k;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int a;</span><br><span class="line">	int p;</span><br><span class="line">&#125;vip[20];</span><br><span class="line">struct cost&#123;</span><br><span class="line">	int cc;</span><br><span class="line">	int dd;</span><br><span class="line">&#125;dim[20];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		cin&gt;&gt;m&gt;&gt;k;</span><br><span class="line">		for(int i = 0;i&lt;m;i++)&#123;</span><br><span class="line">			cin&gt;&gt;vip[i].a&gt;&gt;vip[i].p;</span><br><span class="line">			if(vip[i].a%10)</span><br><span class="line">				vip[i].a+=10-(vip[i].a%10);</span><br><span class="line">		&#125;</span><br><span class="line">		int ans = 0;</span><br><span class="line">		for(int i = 0;i&lt;k;i++)&#123;</span><br><span class="line">			cin&gt;&gt;dim[i].cc&gt;&gt;dim[i].dd;</span><br><span class="line">			ans+=dim[i].cc*dim[i].dd;</span><br><span class="line">		&#125;</span><br><span class="line">		if(ans%10)</span><br><span class="line">			ans+=10-(ans%10);</span><br><span class="line">		int minx = ans;</span><br><span class="line">		for(int u = 0;u&lt;m;u++)&#123;</span><br><span class="line">			int ans2 = 0;</span><br><span class="line">			for(int i = 0;i&lt;k;i++)&#123;</span><br><span class="line">				ans2 += dim[i].cc*(ceil((1-((double)vip[u].p/100.0))*dim[i].dd));</span><br><span class="line">			&#125;</span><br><span class="line">			if(ans2%10)&#123;</span><br><span class="line">				ans2+=10-(ans2%10);</span><br><span class="line">			&#125;</span><br><span class="line">			if(ans2&lt;=vip[u].a)&#123;</span><br><span class="line">				ans2 = vip[u].a;</span><br><span class="line">			&#125;</span><br><span class="line">			minx = min(minx,ans2);</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;minx/10&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="WANNAFLY-DAY6"><a href="#WANNAFLY-DAY6" class="headerlink" title="WANNAFLY_DAY6"></a>WANNAFLY_DAY6</h1><h2 id="F平衡二叉树"><a href="#F平衡二叉树" class="headerlink" title="F平衡二叉树"></a>F平衡二叉树</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-13-%E9%A2%985.png" alt></p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 70;</span><br><span class="line">ll n,d;</span><br><span class="line">ll a,b;</span><br><span class="line">ll c[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;d;</span><br><span class="line">	a = 1;</span><br><span class="line">	b = 0;</span><br><span class="line">	memset(c,0,sizeof(c));</span><br><span class="line">	for(int i = 0;i&lt;n-1;i++)</span><br><span class="line">		a*=2;</span><br><span class="line">	a-=1;</span><br><span class="line">	for(int i = 0;i&lt;=d;i++)&#123;</span><br><span class="line">		c[i] = 1;</span><br><span class="line">	&#125;</span><br><span class="line">	c[d+1] = 2;</span><br><span class="line">	for(int i = d+2;i&lt;n-1-d;i++)&#123;</span><br><span class="line">		c[i] = c[i-1]+c[i-d-1];</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i = 0;i&lt;n-1-d;i++)</span><br><span class="line">		b+=c[i];</span><br><span class="line">	cout&lt;&lt;a-b&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="H卡牌游戏"><a href="#H卡牌游戏" class="headerlink" title="H卡牌游戏"></a>H卡牌游戏</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-13-%E9%A2%981.png" alt></p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	for(int u = 1;u&lt;=t;u++)&#123;</span><br><span class="line">		long double x,y;</span><br><span class="line">		int z;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		cin&gt;&gt;z;</span><br><span class="line">		printf(&quot;Case #%d: &quot;,u);</span><br><span class="line">		long double ans = 0;</span><br><span class="line">		for(int i = 0;i&lt;z;i++)&#123;</span><br><span class="line">			ans += x/y;</span><br><span class="line">			x--;</span><br><span class="line">			y--;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%Lf\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="WANNAFLY-DAY7"><a href="#WANNAFLY-DAY7" class="headerlink" title="WANNAFLY_DAY7"></a>WANNAFLY_DAY7</h1><h2 id="A-机器学习"><a href="#A-机器学习" class="headerlink" title="A.机器学习"></a>A.机器学习</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-13-%E9%A2%987.png" alt="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/7WIGFX9JGWV%5DBD0A9XRS%5DG8.png"></p>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	double n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	printf(&quot;%.2lf\n&quot;,n);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D最小生成树"><a href="#D最小生成树" class="headerlink" title="D最小生成树"></a>D最小生成树</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-13-%E9%A2%986.png" alt></p>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">ll a[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	ll minx = 0x3fffffff;</span><br><span class="line">	ll sum = 0;</span><br><span class="line">	for(int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		minx = min(minx,a[i]);</span><br><span class="line">		sum+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sum += minx*(n-1);</span><br><span class="line">	sum-=minx;</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="G区间权值"><a href="#G区间权值" class="headerlink" title="G区间权值"></a>G区间权值</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-13-%E9%A2%984.png" alt></p>
<h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e7+7;</span><br><span class="line">const int maxn = 300007;</span><br><span class="line">const int mod = 1e9+7;</span><br><span class="line">ll a[maxn] = &#123;0&#125;;</span><br><span class="line">ll w[maxn] = &#123;0&#125;;</span><br><span class="line">ll dpa[maxn] = &#123;0&#125;;</span><br><span class="line">ll dpb[maxn] = &#123;0&#125;;</span><br><span class="line">ll dpl[maxn] = &#123;0&#125;;</span><br><span class="line">ll dpr[maxn] = &#123;0&#125;;</span><br><span class="line">int n;</span><br><span class="line">void init()&#123;</span><br><span class="line">	for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">		int tmp = min(i,n-i+1);</span><br><span class="line">		dpb[i] = tmp*dpa[n]%mod;</span><br><span class="line">		dpb[i] -= dpl[tmp-1];</span><br><span class="line">		dpb[i] -= dpr[n-tmp+2];</span><br><span class="line">		dpb[i]%=mod;</span><br><span class="line">		dpb[i] *= w[i];</span><br><span class="line">		dpb[i]%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	ios::sync_with_stdio(false);</span><br><span class="line">	cin.tie(0);</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		dpa[i] = a[i];</span><br><span class="line">		dpa[i]+=dpa[i-1];</span><br><span class="line">		dpa[i]%=mod;</span><br><span class="line">		dpl[i] = dpl[i-1];</span><br><span class="line">		dpl[i]+=dpa[i];</span><br><span class="line">		dpl[i]%=mod;</span><br><span class="line">	&#125; </span><br><span class="line">	dpr[n+1] = 0;</span><br><span class="line">	for(int i = n;i&gt;=1;i--)&#123;</span><br><span class="line">		dpr[i] = dpr[i+1];</span><br><span class="line">		dpr[i]+=dpa[n]-dpa[i-1];</span><br><span class="line">		dpr[i]%=mod;</span><br><span class="line">	&#125; </span><br><span class="line">	for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;w[i];</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans = 0;</span><br><span class="line">	init();</span><br><span class="line">	for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">		ans+=dpb[i];</span><br><span class="line">		ans%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="I联通块计数"><a href="#I联通块计数" class="headerlink" title="I联通块计数"></a>I联通块计数</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-13-%E9%A2%983.png" alt></p>
<h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e7+7;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">const ll mod = 998244353;</span><br><span class="line">int n;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll dp[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">	for(int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">		dp[i] = a[i];</span><br><span class="line">		dp[i]%=mod;</span><br><span class="line">		if(i&gt;0)&#123;</span><br><span class="line">			dp[i]*=dp[i-1];</span><br><span class="line">			dp[i]%=mod;</span><br><span class="line">			dp[i]+=a[i];</span><br><span class="line">			dp[i]%=mod;</span><br><span class="line">			dp[i]+=dp[i-1];</span><br><span class="line">			dp[i]%=mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	ll ans = 1;</span><br><span class="line">	for(int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		ans+=(a[i]*(a[i]+1)/2)%mod;</span><br><span class="line">		ans%=mod;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	init();</span><br><span class="line">	if(n&gt;0)&#123;</span><br><span class="line">		ans+=dp[n-1];</span><br><span class="line">		ans%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans%mod&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="J寻找复读机"><a href="#J寻找复读机" class="headerlink" title="J寻找复读机"></a>J寻找复读机</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-8-13-%E9%A2%982.png" alt></p>
<h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e3+7;</span><br><span class="line">int n,m;</span><br><span class="line">int vis[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	memset(vis,0,sizeof(vis));</span><br><span class="line">	string str1, tmp;</span><br><span class="line">	int d;</span><br><span class="line">	while(m--)&#123;</span><br><span class="line">		cin&gt;&gt;d;</span><br><span class="line">		cin&gt;&gt;tmp;</span><br><span class="line">		if(str1==tmp)&#123;</span><br><span class="line">			if(vis[d]!=-1)</span><br><span class="line">				vis[d]++;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			vis[d]=-1;</span><br><span class="line">		&#125;</span><br><span class="line">		str1 = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	int flag = 0;</span><br><span class="line">	for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">		if(vis[i]!=-1)&#123;</span><br><span class="line">			if(flag==0)&#123;</span><br><span class="line">				cout&lt;&lt;i;</span><br><span class="line">				flag = 1;</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">				cout&lt;&lt;&apos; &apos;&lt;&lt;i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM/ICPC</tag>
        <tag>wannafly</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title>sg函数与nim博弈</title>
    <url>/2018/07/28/2018-07-28/</url>
    <content><![CDATA[<p>内容：sg函数</p>
<p>时间：2018-7-28</p>
<p>课件by.浅悠悠</p>
<p>主讲人：王骏</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%871.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%872.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%873.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%874.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%875.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%876.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%877.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%878.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%879.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%8710.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%8711.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%8712.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%8713.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%8714.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%8715.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%8716.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%8717.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%8718.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%8719.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%8720.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%8721.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%8722.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%8723.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-28/%E5%B9%BB%E7%81%AF%E7%89%8724.jpg" alt></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>sg函数</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>7.26图论基础专项训练题解</title>
    <url>/2018/07/26/2018-07-26/</url>
    <content><![CDATA[<h1 id="问题-A-签到题之青蛙爬楼梯"><a href="#问题-A-签到题之青蛙爬楼梯" class="headerlink" title="问题 A: 签到题之青蛙爬楼梯"></a>问题 A: 签到题之青蛙爬楼梯</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 117  解决: 37<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=0&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1784" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1784&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1784&amp;getkey=3D275E187A" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1784" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>楼梯有n阶台阶，青蛙每次可以跳1~n阶台阶，问青蛙共有多少种上楼梯的方法。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入仅一行，一个整数n（n&lt;=50）</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出n阶台阶对应上楼梯的方法。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>本题作为水题，不作为图论题。样例提示（1，1，1），（1，2），（2，1），（3）共4种方法</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>第n阶台阶，我们可以从n-1跳到n，可以从n-2跳到n……可以从1跳到n，也可以从0跳到n。那么要求第n阶的数量，只需求前n-1阶，前n-2阶……前1阶的方法，所以我们列出关系式为F(n)=F(n-1)+F(n-2)+……+F(1)+1。同理，第n-1阶的关系式为F(n-2)+F(n-3)+……+F(1)+1。两个式子合并得F(n)=2*F(n-1)。由于F(1)=1,所以F(n)=2^(n-1)。</p>
<h2 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    ll a = pow(2,n-1);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-B-排名"><a href="#问题-B-排名" class="headerlink" title="问题 B: 排名"></a>问题 B: 排名</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 60  解决: 24<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=1&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1785" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1785&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1785&amp;getkey=40F8E5A0BF" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1785" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 N 个比赛队（1&lt;=N&lt;=500），编号依次为 1，2，3……N 进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即 P1 赢 P2，用 P1，P2 表示，排名时 P1 在 P2之前。现在请你编程序确定排名。</p>
<p>符合条件的排名可能不是唯一的。此时要求输出时编号小的队伍在前。输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。</p>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>输入有若干组。每组中的第一行为二个数N（1&lt;=N&lt;=500）。M；当中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中。每行也有两个整数P1。P2表示即P1队赢了P2队。</p>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>给出一个符合要求的排名。输出时队伍号之间有空格。最后一名后面没有空格。</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 4</span><br><span class="line">4 3</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 4 3</span><br></pre></td></tr></table></figure>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>拓扑排序模板题，唯一可能出现问题的地方就是题目要求同样拓扑序的两个编号小的要在前面，这点可以通过将普通拓扑排序中的队列改为使用优先队列或者堆来实现。</p>
<h2 id="代码参考-1"><a href="#代码参考-1" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=510;</span><br><span class="line">int graph[maxn][maxn];//保存图</span><br><span class="line">int degree[maxn];//保存入度</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(graph,0,sizeof(graph));</span><br><span class="line">        memset(degree,0,sizeof(degree));</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int u,v;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">            if(!graph[u][v])</span><br><span class="line">            &#123;</span><br><span class="line">                graph[u][v]=1;</span><br><span class="line">                degree[v]++;//的入度++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            if(degree[i]==0)</span><br><span class="line">            q.push(i);</span><br><span class="line">        bool first=1;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int cur=q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            if(first)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;cur;</span><br><span class="line">                first=0;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                cout&lt;&lt;&quot; &quot;&lt;&lt;cur;</span><br><span class="line">            for(int i=1;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(graph[cur][i]==1)</span><br><span class="line">                &#123;</span><br><span class="line">                    degree[i]--;//相连的点的入度减1</span><br><span class="line">                    if(degree[i]==0)//假设入度为0，增加队列</span><br><span class="line">                        q.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-C-系兄弟就来砍我"><a href="#问题-C-系兄弟就来砍我" class="headerlink" title="问题 C: 系兄弟就来砍我"></a>问题 C: 系兄弟就来砍我</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 34  解决: 10<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=2&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1787" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1787&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1787&amp;getkey=584D6A6FD5" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1787" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>渣渣灰因为一句“大家好，我系渣渣辉，系兄弟就来砍我”引得众粉丝纷纷拿两米长的大刀寻找。现有n个据点，编号（1~n），有m条单向路使据点相连。每个据点仅有一个人。这n个人中有k个粉丝。其中渣渣灰在s据点处。请问这k个粉丝到渣渣灰的最短距离是多少</p>
<h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>首行输入nmks。(k&lt;=n&lt;=100m&lt;=500)s为渣渣灰所在位置</p>
<p>接下来m行，每行输入xyz，表示从x到y的距离是z，由于是单向边，则y到x的距离不一定是z。</p>
<p>接下来k个数字，表示粉丝所在据点。</p>
<h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>对于每一个粉丝，输出对应的最短距离。</p>
<h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3 2 1</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br><span class="line">3 1 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></table></figure>
<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>数据保证k个粉丝均能到达渣渣灰的据点</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>首先，既然要求k个点到s点的最短路，我们可以反过来求s到这k个点的最短路。这样就变成了单源最短路问题，dijkstra算法和spfa算法都可以做。由于图为有向图，我们在存图时反向存图即可，原本a[i][j]表示i-&gt;j，我们可以将它重新定义为j-&gt;i，或者存图时直接写成a[j][i]即可。</p>
<h2 id="代码参考-2"><a href="#代码参考-2" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 107;</span><br><span class="line">const int inf = 0x3f3f3f3f; //需将road及dis初始化为正无穷inf</span><br><span class="line">int n,m,k,s;</span><br><span class="line">int dis[maxn];  //储存各个点到源点的最短距离,dis[s]为0</span><br><span class="line">int road[maxn][maxn];   //两点之间直接距离关系</span><br><span class="line">bool vis[maxn];     //判断源点到该点的距离是否为最短距离</span><br><span class="line">int fans[maxn];</span><br><span class="line">void dijkstra(int s)</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    vis[s] = true;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        dis[i] = road[s][i];</span><br><span class="line">    for(int u = 1; u&lt;n; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        int minD = inf,k = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[i]&lt;minD)</span><br><span class="line">            &#123;</span><br><span class="line">                k = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[k] = true;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[k]+road[k][i]&lt;dis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i]=dis[k]+road[k][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s;</span><br><span class="line">    memset(road,inf,sizeof(road));</span><br><span class="line">    for(int i = 1; i&lt;=m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int tmp;</span><br><span class="line">        int x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;tmp;</span><br><span class="line">        road[y][x]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra(s);</span><br><span class="line">    for(int i = 0; i&lt;k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;fans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0; i&lt;k-1; i++)</span><br><span class="line">        cout&lt;&lt;dis[fans[i]]&lt;&lt;&apos; &apos;;</span><br><span class="line">    cout&lt;&lt;dis[fans[k-1]]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-D-躁动的小Z"><a href="#问题-D-躁动的小Z" class="headerlink" title="问题 D: 躁动的小Z"></a>问题 D: 躁动的小Z</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 7  解决: 2<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=3&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1669" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1669&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:外部导入][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1669&amp;getkey=F81CC9CF2B" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1669" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>你猜怎么样？小Z追到Gakki了！Gakki邀请小Z去她家共进晚餐，小Z喜出望外。小Z的家和Gakki的家隔着几个街区，所以他决定乘坐公交车前往</p>
<p>Gakki家赴约。小Z的家在公交站台的起始站（编号为1），而Gakki家正好在末站（编号为n）。城市中有许多公交站台，有些站台之间可以通过公交</p>
<p>线路互相到达。现在给你n个公交站台和m条不同的公交线路的时间花费，请你帮助小Z分析一下最短的可以从家里来到Gakki身边的路径？</p>
<h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>有多组测试样例。</p>
<p>第一行两个正整数n,m(2≤n≤10^5,0≤m≤10^5)，代表站台数与公交线路数量。</p>
<p>接下来m行每行三个正整数a[i],b[i],w[i],代表从公交站a[i]到b[i]需要花费的时间为w[i]。(1≤a[i],b[i]≤n,1≤w[i]≤10^6)</p>
<p>注意：公交线路可能会产生环，并且两个站台之间可能有多条公交线路。</p>
<h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>单独一行，输出花费时间最小时小Z经过的公交站台编号，以空格隔开；如果小Z无法到达Gakki的家，则输出-1.</p>
<h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 6</span><br><span class="line">1 2 2</span><br><span class="line">2 5 5</span><br><span class="line">2 3 4</span><br><span class="line">1 4 1</span><br><span class="line">4 3 3</span><br><span class="line">3 5 1</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 4 3 5</span><br></pre></td></tr></table></figure>
<h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>半年前写的代码。其实原理很简单，在dijkstra算法模板的基础上加上一个pre数组，用于记录该节点的上一个节点，即该点是经过哪一点才到达该点的。pre数组具体在边松弛的过程中进行重新赋值，松弛成功就将pre值记录k点，及该点是由起点经过k点后所得到的。最后把pre数组中的值递归输出一遍即可。</p>
<h2 id="代码参考-3"><a href="#代码参考-3" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt; </span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define max 900000</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">	int d; </span><br><span class="line">	int pre;</span><br><span class="line">&#125;path;</span><br><span class="line">path to[1000 + 2];</span><br><span class="line">int g[1000 + 2][1000 + 2], vis[1000 + 2]; </span><br><span class="line">void fun(int ddd) &#123;</span><br><span class="line">	if (ddd == 1) &#123;</span><br><span class="line">		printf(&quot;%d&quot;, ddd);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	int j= to[ddd].pre;</span><br><span class="line">	fun(j);</span><br><span class="line">	printf(&quot; %d&quot;, ddd);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m, a, b, v, i, j, min, k, from;</span><br><span class="line">	while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123; </span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		for (i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">			for (j = 0; j &lt;= n; j++) &#123;</span><br><span class="line">				g[i][j] = max;</span><br><span class="line">			&#125;</span><br><span class="line">			to[i].d = max;</span><br><span class="line">		&#125;</span><br><span class="line">		for (i = 0; i &lt; m; i++) &#123; </span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;v);</span><br><span class="line">			g[a][b] = v;</span><br><span class="line">			g[b][a] = v;</span><br><span class="line">		&#125;</span><br><span class="line">		for (i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">			to[i].d = g[1][i];</span><br><span class="line">			if (g[1][i] != max) &#123;</span><br><span class="line">				to[i].pre = 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[1] = 1;</span><br><span class="line">		for (i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">			min = max;</span><br><span class="line">			for (j = 2; j &lt;= n; j++) &#123;</span><br><span class="line">				if (to[j].d &lt; min&amp;&amp;vis[j] == 0) &#123;</span><br><span class="line">					min = to[j].d;</span><br><span class="line">					k = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[k] = 1;</span><br><span class="line">			for (j = 2; j &lt;= n; j++) &#123;</span><br><span class="line">				if (to[j].d &gt; to[k].d + g[k][j] &amp;&amp; vis[j] == 0) &#123;</span><br><span class="line">					to[j].d = to[k].d + g[k][j];</span><br><span class="line">					to[j].pre = k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fun(n);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-E-逛街"><a href="#问题-E-逛街" class="headerlink" title="问题 E: 逛街"></a>问题 E: 逛街</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 8  解决: 2<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=4&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1788" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1788&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1788&amp;getkey=7BBB5CA0F9" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1788" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设渣渣灰有一个女朋友，他的女朋友要他陪着一起去公园。由于渣渣灰不喜欢运动，所以他想找一条最短的路到达公园。由于途中会有许多消费点，而每到一个消费点女朋友就要购物，而渣渣灰比较抠，所以假如有多条最短路，则他会选择途中消费点最便宜的。给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s终点t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。</p>
<h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>输入nm，点的编号是1~n然后是m行，每行4个数 abdp，表示a和b之间有一条边，且其长度为d，花费为p。最后一行是两个数 st;起点s，终点。n和m为0时输入结束。<br>(1&lt;n&lt;=1000 0&lt;m&lt;100000 s != t)</p>
<h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>输出 一行有两个数， 最短距离及其花费。</p>
<h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2 5 6</span><br><span class="line">2 3 4 5</span><br><span class="line">1 3</span><br><span class="line"></span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 11</span><br></pre></td></tr></table></figure>
<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>输入样例的空行只是为了让大家分辨数据，输入有没有空行都没关系。输出样例没有空行。</p>
<h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>同上一道题的方法，我们再创建一个value数组储存花费情况。在松弛时对value进行改变。松弛成功则value（s-&gt;i）=value(s-&gt;k-&gt;i)。若最短路相等则对value值进行比较，即value（s-&gt;i）=min(value(s-&gt;k-&gt;i),value（s-&gt;i))。s为源点，i为当前终点，k为中间点。最终输出最短路及对应value值即可。</p>
<h2 id="代码参考-4"><a href="#代码参考-4" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">#define Min(a,b) a&gt;b?b:a</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">	int adj,val;</span><br><span class="line">&#125;g[1005][1005];</span><br><span class="line">int dist[1005];//距离</span><br><span class="line">int value[1005];//费用</span><br><span class="line">int used[1005];//标记</span><br><span class="line">int n,m,i,j;</span><br><span class="line">void Dijkstra(int s)</span><br><span class="line">&#123;</span><br><span class="line">	memset(dist,0x3f,sizeof(dist));</span><br><span class="line">	memset(value,0x3f,sizeof(value));</span><br><span class="line">	memset(used,0,sizeof(used));</span><br><span class="line">	dist[s]=0;//从起点开始</span><br><span class="line">	value[s]=0;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		int k,u=-1,d[1005];</span><br><span class="line">		int min=INF;</span><br><span class="line">		memset(d,0,sizeof(d));</span><br><span class="line">		for(i=1;i&lt;=n;i++)</span><br><span class="line">			if(used[i]==0&amp;&amp;dist[i]&lt;min)//找出从起点到下一个最小距离的顶点</span><br><span class="line">			&#123;</span><br><span class="line">				min=dist[i];</span><br><span class="line">				u=i;//记录下标</span><br><span class="line">			&#125;</span><br><span class="line">		if(u==-1)//判断所有顶点是否都到达过</span><br><span class="line">			return ;</span><br><span class="line">		for(i=1,k=0;i&lt;=n;i++)</span><br><span class="line">			if(dist[u]==dist[i]&amp;&amp;used[i]==0)</span><br><span class="line">				d[k++]=i;//从起点到下一个要访问的顶点的最小距离可能有多个</span><br><span class="line">		for(i=0;i&lt;k;i++)</span><br><span class="line">			used[d[i]]=1;</span><br><span class="line">		for(i=0;i&lt;k;i++)//多个满足的点分别进行迪杰斯特拉最短路查找</span><br><span class="line">			for(j=1;j&lt;=n;j++)</span><br><span class="line">				if(g[d[i]][j].adj!=INF &amp;&amp; (dist[d[i]]+g[d[i]][j].adj)&lt;=dist[j])</span><br><span class="line">				&#123;//原理与 main()函数中建立邻接矩阵一样</span><br><span class="line">					if((dist[d[i]]+g[d[i]][j].adj)&lt;dist[j])</span><br><span class="line">						value[j]=value[d[i]]+g[d[i]][j].val;</span><br><span class="line">					else</span><br><span class="line">						value[j]=Min(value[j],value[d[i]]+g[d[i]][j].val);</span><br><span class="line">					dist[j]=dist[d[i]]+g[d[i]][j].adj;</span><br><span class="line">				&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) &amp;&amp; (n||m))</span><br><span class="line">	&#123;</span><br><span class="line">		int a,b,d,p;</span><br><span class="line">		memset(g,0x3f,sizeof(g));</span><br><span class="line">		for(i=1;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;d,&amp;p);</span><br><span class="line">			if(d&lt;=g[a][b].adj)//处理路径距离问题</span><br><span class="line">			&#123;</span><br><span class="line">				if(d==g[a][b].adj)//如果距离相等，则存放最少的费用</span><br><span class="line">					g[a][b].val=g[b][a].val=Min(p,g[a][b].val);</span><br><span class="line">				else//否则，存放新路径距离的费用</span><br><span class="line">					g[a][b].val=g[b][a].val=p;</span><br><span class="line">				g[a][b].adj=g[b][a].adj=d;//填充路径距离</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int s,t;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;s,&amp;t);</span><br><span class="line">		Dijkstra(s);</span><br><span class="line">		printf(&quot;%d %d\n&quot;,dist[t],value[t]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-F-足球"><a href="#问题-F-足球" class="headerlink" title="问题 F: 足球"></a>问题 F: 足球</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 3  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=5&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1786" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1786&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1786&amp;getkey=C290CA1E34" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1786" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>yoyo得到了一个足球，这个足球与其他的足球一样，表面有 12 个正五边形和 20 个正六边形组成，足球的每个面初始的时候都为白色。现在yoyo把这个足球拆解开来，32个面编号为1~32。爱画画的yoyo希望将足球的某些面涂为黑色（可能是 0 个），在每次涂色操作中，慢慢只可以将某一些相邻或者联通的面一起涂为黑色（两个面相邻当且仅当他们共用一条边）。例如，yoyo可以在一次涂色操作中将面 1、2、3、4、5 涂为黑色，但是他不可以将面11 和 24 涂为白色，因为面 11 和 24 是不相邻也不联通的。求yoyo所需要的最少的涂色次数。</p>
<h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p>第一行包含一个整数 t，表示有t组测试数据，对于每组测试数据：</p>
<p>输入包含一行，该行包含 32 个整数，每个数的值等于 0 时表示白色，等于 1 时表示黑色。</p>
<h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p>对于每组测试数据，输出Case c: ans，其中 c 为测试数据编号，ans 为最少的操作次数。</p>
<h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case 1: 1</span><br><span class="line">Case 2: 0</span><br><span class="line">Case 3: 2</span><br></pre></td></tr></table></figure>
<h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>除了相邻的数面也相邻外，面 1 和面 13 是相邻的，面 13 和面 17 是相邻的，面 17 和面 32 是相邻的，面 15 和面 32 是相邻的，面 19 和面 32 是相邻的。</p>
<p>PS:1和32不相邻。</p>
<h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p>先把所有相邻的点赋值为1，再用Floyd算法把所有点之间的最短距离打表求出来。之后每输入一组样例，则对样例中的1dfs深搜，然后深搜把所有相邻为1且值为1的点重新赋值为0。最后记录下主循环中dfs的次数即可。</p>
<h2 id="代码参考-5"><a href="#代码参考-5" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 32 + 1;</span><br><span class="line">int dis[maxn][maxn];</span><br><span class="line">int vis[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(dis,0x3f3f3f3f,sizeof(dis));</span><br><span class="line">    dis[32][32] = 0;</span><br><span class="line">    for(int i = 1; i &lt; maxn - 1; i++)&#123;</span><br><span class="line">        dis[i][i] = 0;</span><br><span class="line">        dis[i][i + 1] = 1;</span><br><span class="line">        dis[i + 1][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[1][13] = dis[13][1] = 1;</span><br><span class="line">    dis[17][13] = dis[13][17] = 1;</span><br><span class="line">    dis[17][32] = dis[32][17] = 1;</span><br><span class="line">    dis[15][32] = dis[32][15] = 1;</span><br><span class="line">    dis[19][32] = dis[32][19] = 1;</span><br><span class="line">    for(int k = 1; k &lt; maxn; k++)&#123;</span><br><span class="line">        for(int i = 1; i &lt; maxn; i++)</span><br><span class="line">            for(int j = 1; j &lt; maxn; j++)</span><br><span class="line">                if(dis[i][j] &gt; dis[i][k]+dis[k][j])</span><br><span class="line">                    dis[i][j] = dis[i][k]+dis[k][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x)&#123;</span><br><span class="line">    vis[x] = 0;</span><br><span class="line">    for(int i = 1; i &lt; maxn; i++)&#123;</span><br><span class="line">        if(vis[i]&amp;&amp;dis[x][i]==1)</span><br><span class="line">            dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    for(int u = 1;u &lt;= t;u++)&#123;</span><br><span class="line">        for(int i = 1;i &lt; maxn; i++)</span><br><span class="line">            cin&gt;&gt;vis[i];</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i = 1; i &lt; maxn; i++)&#123;</span><br><span class="line">            if(vis[i])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;&quot;Case &quot;&lt;&lt;u&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-G-牌"><a href="#问题-G-牌" class="headerlink" title="问题 G: 牌"></a>问题 G: 牌</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 2  解决: 2<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=6&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1789" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1789&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1789&amp;getkey=86CA76A96B" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1789" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>有n张牌，每个牌有一个a属性和1个b属性，第i张牌的属性为ai，bi。现在每次从牌中选两张牌i，j，得到一个ai <em> bj + bi </em> aj的分数，然后从这两张牌中去掉1张牌。经过n-1次操作之后就剩1张牌了。问经过n-1次操作后得到的最大的分数和是多少。</p>
<h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>首行输入n，代表n个点</p>
<p>接下来n行，每一行两个属性ab第i行代表第i张牌，属性为ai，bi。数据范围保持在200以内。</p>
<h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>输出最大分数</p>
<h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2 4</span><br><span class="line">3 3</span><br><span class="line">1 7</span><br><span class="line">2 5</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">108</span><br></pre></td></tr></table></figure>
<h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p>主要是删除牌的问题。但是假如我们将每张牌看成1个结点，属性的乘积得到的分数为1条路径，那么n张牌构成了n个结点n*（n-1）/2条边的强联通无向图，那么只需求每次分数最大的最小生成树即可。</p>
<h2 id="代码参考-6"><a href="#代码参考-6" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt; </span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define max 900000</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">	int d; </span><br><span class="line">	int pre;</span><br><span class="line">&#125;path;</span><br><span class="line">path to[1000 + 2];</span><br><span class="line">int g[1000 + 2][1000 + 2], vis[1000 + 2]; </span><br><span class="line">void fun(int ddd) &#123;</span><br><span class="line">	if (ddd == 1) &#123;</span><br><span class="line">		printf(&quot;%d&quot;, ddd);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	int j= to[ddd].pre;</span><br><span class="line">	fun(j);</span><br><span class="line">	printf(&quot; %d&quot;, ddd);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m, a, b, v, i, j, min, k, from;</span><br><span class="line">	while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123; </span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		for (i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">			for (j = 0; j &lt;= n; j++) &#123;</span><br><span class="line">				g[i][j] = max;</span><br><span class="line">			&#125;</span><br><span class="line">			to[i].d = max;</span><br><span class="line">		&#125;</span><br><span class="line">		for (i = 0; i &lt; m; i++) &#123; </span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;v);</span><br><span class="line">			g[a][b] = v;</span><br><span class="line">			g[b][a] = v;</span><br><span class="line">		&#125;</span><br><span class="line">		for (i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">			to[i].d = g[1][i];</span><br><span class="line">			if (g[1][i] != max) &#123;</span><br><span class="line">				to[i].pre = 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[1] = 1;</span><br><span class="line">		for (i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">			min = max;</span><br><span class="line">			for (j = 2; j &lt;= n; j++) &#123;</span><br><span class="line">				if (to[j].d &lt; min&amp;&amp;vis[j] == 0) &#123;</span><br><span class="line">					min = to[j].d;</span><br><span class="line">					k = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[k] = 1;</span><br><span class="line">			for (j = 2; j &lt;= n; j++) &#123;</span><br><span class="line">				if (to[j].d &gt; to[k].d + g[k][j] &amp;&amp; vis[j] == 0) &#123;</span><br><span class="line">					to[j].d = to[k].d + g[k][j];</span><br><span class="line">					to[j].pre = k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fun(n);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="常用模板代码"><a href="#常用模板代码" class="headerlink" title="常用模板代码"></a>常用模板代码</h1><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=510;</span><br><span class="line">int graph[maxn][maxn];//保存图</span><br><span class="line">int degree[maxn];//保存入度</span><br><span class="line">int TOP[maxn];//保存已删除点</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">    	int now = 0；//指针作用记录TOP中可插入的位置</span><br><span class="line">        memset(graph,0,sizeof(graph));</span><br><span class="line">        memset(degree,0,sizeof(degree));</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int u,v;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">            if(!graph[u][v])</span><br><span class="line">            &#123;</span><br><span class="line">                graph[u][v]=1;</span><br><span class="line">                degree[v]++;//v的入度++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;int&gt;q;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            if(degree[i]==0)</span><br><span class="line">            q.push(i);</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int cur=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            TOP[now++]=cur;</span><br><span class="line">            for(int i=1;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(graph[cur][i]==1)</span><br><span class="line">                &#123;</span><br><span class="line">                    degree[i]--;//相连的点的入度减1</span><br><span class="line">                    if(degree[i]==0)//假设入度为0，增加队列</span><br><span class="line">                        q.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //这里可以添加输出，排序已保存在TOP数组中</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dijkstra（单元最短路径）"><a href="#dijkstra（单元最短路径）" class="headerlink" title="dijkstra（单元最短路径）"></a>dijkstra（单元最短路径）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 107;</span><br><span class="line">const int inf = 0x3f3f3f3f; //需将road及dis初始化为正无穷inf</span><br><span class="line">int n,m,k,s;</span><br><span class="line">int dis[maxn];  //储存各个点到源点的最短距离,dis[s]为0</span><br><span class="line">int road[maxn][maxn];   //两点之间直接距离关系</span><br><span class="line">bool vis[maxn];     //判断源点到该点的距离是否为最短距离</span><br><span class="line"></span><br><span class="line">void dijkstra(int s)</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    vis[s] = true;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        dis[i] = road[s][i];</span><br><span class="line">    for(int u = 1; u&lt;n; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        int minD = inf,k = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[i]&lt;minD)</span><br><span class="line">            &#123;</span><br><span class="line">                k = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[k] = true;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[k]+road[k][i]&lt;dis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i]=dis[k]+road[k][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    memset(road,inf,sizeof(road));</span><br><span class="line">    //主函数添加程序与数据以及调用dijkstra</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SPFA（单元最短路径，可带负环）"><a href="#SPFA（单元最短路径，可带负环）" class="headerlink" title="SPFA（单元最短路径，可带负环）"></a>SPFA（单元最短路径，可带负环）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define N 105</span><br><span class="line">int res[N];//存储源点到每个顶点的最短距离值</span><br><span class="line">int g[N][N];</span><br><span class="line">int cnt[N];//每个点入队次数，判断是否出现负环</span><br><span class="line">int que[N*N];//队列</span><br><span class="line">bool in_que[N];//标记一个点是否已在队列中</span><br><span class="line">int front;//队首位置</span><br><span class="line">int rear;//队尾位置</span><br><span class="line">void spfa(int n,int src)</span><br><span class="line">&#123;</span><br><span class="line">    rear=front=0;</span><br><span class="line">    que[++rear]=src;</span><br><span class="line">    memset(res,0x3f3f3f3f,sizeof(res));</span><br><span class="line">    memset(in_que,0,sizeof(in_que));</span><br><span class="line">    res[src]=0;</span><br><span class="line">    while(front&lt;rear)</span><br><span class="line">    &#123;</span><br><span class="line">        int cur=que[++front];</span><br><span class="line">        in_que[cur]=0;</span><br><span class="line">        int i;</span><br><span class="line">        for(i=1; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(res[cur]+g[cur][i]&lt;res[i])</span><br><span class="line">            &#123;</span><br><span class="line">                res[i]=res[cur]+g[cur][i];</span><br><span class="line">                if(!in_que[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    que[++rear]=i;</span><br><span class="line">                    in_que=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Floyed（全源最短路径）"><a href="#Floyed（全源最短路径）" class="headerlink" title="Floyed（全源最短路径）"></a>Floyed（全源最短路径）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int k=0; k&lt;n; ++k)</span><br><span class="line">  for (int i=0; i&lt;n; ++i)</span><br><span class="line">    for (int j=0; j&lt;n; ++j)</span><br><span class="line">            /*</span><br><span class="line">            实际中为防止溢出，往往需要选判断 dist[i][k]和dist[k][j]</span><br><span class="line">            都不是Inf ，只要一个是Inf，那么就肯定不必更新。 </span><br><span class="line">            */</span><br><span class="line">      if (dist[i][k] + dist[k][j] &lt; dist[i][j] )</span><br><span class="line">        dist[i][j] = dist[i][k] + dist[k][j];</span><br></pre></td></tr></table></figure>
<h2 id="Prim最小生成树"><a href="#Prim最小生成树" class="headerlink" title="Prim最小生成树"></a>Prim最小生成树</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Prim()&#123;</span><br><span class="line">	int i,j,k,tmp,ans;</span><br><span class="line">	for(i=1;i&lt;=n;i++)</span><br><span class="line">	dis[i]=inf;//初始化 </span><br><span class="line">	dis[1]=0;</span><br><span class="line">	for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		tmp=inf;</span><br><span class="line">		for(j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			if(!vis[j]&amp;&amp;tmp&gt;dis[j])&#123;</span><br><span class="line">				tmp=dis[j];</span><br><span class="line">				k=j;</span><br><span class="line">			&#125;//找出最小距离的节点 </span><br><span class="line">		&#125;</span><br><span class="line">		vis[k]=1;//把访问的节点做标记</span><br><span class="line">		for(j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			if(!vis[j]&amp;&amp;dis[j]&gt;map[k][j])</span><br><span class="line">			dis[j]=map[k][j];//更新最短距离 </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1007;</span><br><span class="line">int n,m;</span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    int l;</span><br><span class="line">&#125; edge[maxn];</span><br><span class="line">int fa[maxn];</span><br><span class="line">int init()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0; i&lt;maxn; i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">int findfa(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return fa[x] == x ? x : (fa[x] = findfa(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int merge_1(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    fa[findfa(x)] = findfa(y);</span><br><span class="line">&#125;</span><br><span class="line">int kruskal()</span><br><span class="line">&#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for(int i = 0; i&lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int fx = findfa(edge[i].x);</span><br><span class="line">        int fy = findfa(edge[i].y);</span><br><span class="line">        if(fx!=fy)</span><br><span class="line">        &#123;</span><br><span class="line">            merge_1(fx,fy);</span><br><span class="line">            cnt++;</span><br><span class="line">            sum+=edge[i].l;</span><br><span class="line">            if(cnt&gt;=n-1)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    //此处填写边以及点等待输入数据，填写完成后须对边的权值进行排序</span><br><span class="line">    kruskal();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>最小生成树</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>图论1（拓扑排序 + 最短路 + 最小生成树）</title>
    <url>/2018/07/26/2018-07-26-1/</url>
    <content><![CDATA[<p>内容：图论基础</p>
<p>时间：2018-7-26</p>
<p>课件by.浅悠悠</p>
<p>主讲人：王骏</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%871.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%872.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%873.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%874.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%875.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%876.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%877.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%878.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%879.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8710.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8711.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8712.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8713.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8714.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8715.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8716.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8717.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8718.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8719.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8720.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8721.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8722.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8723.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8724.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8725.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8726.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8727.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8728.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8729.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8730.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8731.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8732.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8733.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8734.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8735.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8736.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8737.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8738.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8739.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8740.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8741.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8742.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8743.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8744.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8745.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8746.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8747.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8748.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8749.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8750.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8751.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8752.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8753.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8754.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8755.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8756.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8757.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8758.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8759.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8760.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8761.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8762.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8763.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8764.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8765.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8766.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8767.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8768.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8769.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8770.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8771.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8772.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8773.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8774.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8775.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8776.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8777.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8778.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8779.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8780.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8781.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8782.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8783.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8784.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8785.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8786.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8787.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-26/%E5%B9%BB%E7%81%AF%E7%89%8788.jpg" alt></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>最小生成树</tag>
        <tag>拓扑排序</tag>
        <tag>SPFA算法</tag>
      </tags>
  </entry>
  <entry>
    <title>7.20-C++标本模板库stl</title>
    <url>/2018/07/20/2018-07-20-1/</url>
    <content><![CDATA[<p>内容：stl</p>
<p>时间：2018-7-20</p>
<p>主讲人：王骏</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%871.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%872.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%873.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%874.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%875.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%876.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%877.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%878.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%879.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8710.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8711.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8712.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8713.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8714.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8715.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8716.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8717.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8718.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8719.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8720.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8721.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8722.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8723.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8724.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8725.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8726.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8727.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8728.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8729.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8730.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8731.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8732.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8733.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8734.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8735.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8736.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8737.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8738.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8739.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8740.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8741.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8742.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8743.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8744.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8745.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8746.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8747.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8748.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8749.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8750.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8751.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8752.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8753.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8754.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8755.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8756.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8757.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8758.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8759.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8760.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8761.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8762.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8763.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8764.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8765.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8766.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8767.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8768.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8769.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8770.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8771.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8772.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8773.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8774.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8775.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8776.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8777.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8778.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8779.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/ppt-7-20/%E5%B9%BB%E7%81%AF%E7%89%8780.jpg" alt></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>7.20-stl专项训练题解</title>
    <url>/2018/07/20/2018-07-20/</url>
    <content><![CDATA[<h1 id="问题A"><a href="#问题A" class="headerlink" title="问题A"></a>问题A</h1><p>问题A同问题B，具体方法在问题B中介绍，此处仅贴代码</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>首行输入t，代表t组测试样例</p>
<p>对于每一行，输入四个整数a，b，c，d</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>对于每组样例，输出一个整数表示答案</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 9;</span><br><span class="line">ll a[4], sum[4] = &#123; 0 &#125;;</span><br><span class="line">ll dp[maxn * 4][maxn * 4];</span><br><span class="line">//打表，递推公式C(a,b) = C(a,b-1)+C(a-1,b-1)</span><br><span class="line">void init() &#123;</span><br><span class="line">	dp[0][0] = 0;</span><br><span class="line">	for (int i = 1; i &lt; 4 * maxn; i++) &#123;</span><br><span class="line">		dp[i][0] = 1;</span><br><span class="line">		for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">			dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];</span><br><span class="line">		&#125;</span><br><span class="line">		dp[i][i] = 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">	init();//打表</span><br><span class="line">	ll ans = 1;</span><br><span class="line">	//这一步可要可不要，其实就是将a,a+b,a+b+c,a+b+c+d存进sum里</span><br><span class="line">	for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">		!i ? sum[i] = 0 : sum[i] = sum[i - 1];</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		sum[i] += a[i];</span><br><span class="line">		if (a[i] &gt; sum[i] - a[i]) a[i] = sum[i] - a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	//将对应3组排列组合相乘，及C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)</span><br><span class="line">	for (int i = 1; i &lt; 4; i++) &#123;</span><br><span class="line">		ans *= dp[sum[i]][a[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-B-yoyo思维题-困难"><a href="#问题-B-yoyo思维题-困难" class="headerlink" title="问题 B: yoyo思维题(困难)"></a>问题 B: yoyo思维题(困难)</h1><p>问题A同问题B</p>
<p>提交: 4  解决: 2<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=1&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1731" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1731&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1731&amp;getkey=4DE1A19111" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1731" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小琳，小花，小薇，yoyo，他们每个人手上有一堆牌，牌的张数分别为x1，x2，x3，x4，每张牌都不一样。现有n名同学，n=x1+x2+x3+x4。每名同学均需要一张牌，于是他们按顺序每人随机到四个人那里拿取牌顶的一张牌，最后一个人刚好拿到剩下的最后一张牌。排队拿牌的同学的顺序是固定的，选择拿谁的牌是不确定的。假如发牌的人手上的牌发完了，则要拿牌的同学会选择其他发牌的人。请问有多少种取法取走所有的牌。</p>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>首行输入t，代表t组测试样例</p>
<p>对于每一行，输入四个整数a，b，c，d，输入为均不超过500的正整数</p>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>对于每组样例，输出一个整数表示答案，答案对10^9+7取模</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5 4 2 3</span><br></pre></td></tr></table></figure>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2522520</span><br></pre></td></tr></table></figure>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>本题作为思维题，并未用到stl，仅锻炼一下大家解决问题的能力。用到的数学知识相对多一点。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目大致可以理解为4堆牌a,b,c,d，每次从一堆牌里拿出牌顶的一张牌，问共有多少种拿法。其实我们可以一堆一堆的分析，假设只有一堆a时只有1种拿法，那两堆a,b时我们可以认为是从a个牌中插入b张牌，用数学表达式就是C(b,a+b);那么三堆的话我们可以把前两堆看成一堆，那么表达式就是C(c,a+b+c)，这是我们需要与前两堆的组成方法相乘，就是C(b,a+b)C(c,a+b+c)。4堆的话就是C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)。所以答案就是C(a,a)C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)。此外，有一公式C(a,b) = C(a,b-1)+C(a-1,b-1)，所以我们用数组来代替C(m,n)操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 501;</span><br><span class="line">const ll mod = 1000000007;</span><br><span class="line">ll a[4], sum[4] = &#123; 0 &#125;;</span><br><span class="line">ll dp[maxn * 4][maxn * 4];</span><br><span class="line">//打表，递推公式C(a,b) = C(a,b-1)+C(a-1,b-1)</span><br><span class="line">void init() &#123;</span><br><span class="line">	dp[0][0] = 0;</span><br><span class="line">	for (int i = 1; i &lt; 4 * maxn; i++) &#123;</span><br><span class="line">		dp[i][0] = 1;</span><br><span class="line">		for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">			dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];</span><br><span class="line">			dp[i][j] %= mod;</span><br><span class="line">		&#125;</span><br><span class="line">		dp[i][i] = 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">	init();//打表</span><br><span class="line">	ll ans = 1;</span><br><span class="line">	//这一步可要可不要，其实就是将a,a+b,a+b+c,a+b+c+d存进sum里</span><br><span class="line">	for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">		!i ? sum[i] = 0 : sum[i] = sum[i - 1];</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		sum[i] += a[i];</span><br><span class="line">		if (a[i] &gt; sum[i] - a[i]) a[i] = sum[i] - a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	//将对应3组排列组合相乘，及C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)</span><br><span class="line">	for (int i = 1; i &lt; 4; i++) &#123;</span><br><span class="line">		ans *= dp[sum[i]][a[i]];</span><br><span class="line">		ans %= mod;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-C-悠派计算器"><a href="#问题-C-悠派计算器" class="headerlink" title="问题 C: 悠派计算器"></a>问题 C: 悠派计算器</h1><p>提交: 4  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=2&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1732" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1732&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1732&amp;getkey=C0EA34F688" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1732" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>yoyo的小老弟小渣渣灰特别懒，兴趣爱好并不多，就睡觉一个。为了多睡会儿懒觉，他把数学老师布置的作业全部推给yoyo计算。yoyo很头疼，于是请你帮他写一个计算器帮忙计算。现有多个数学表达式，请你写一个计算器算出结果，表达式只包含’+’’-‘’*’’/‘’%’’(‘’)’操作，其中表达式中’-‘作为减运算符，不会作为负号出现，此外’/‘为整除运算符，’%’为取余运算符。表达式保证合法。</p>
<h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>输入第一行t，表示共有t行测试用例，接下来t行每一行均为一个合法的数学表达式。保证每个数在[09999]范围内，保证计算过程中不会出现超范围情况。（注：没有空格）</p>
<h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>输出计算结果</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">0*1</span><br><span class="line">5%6</span><br><span class="line">1-2*(3+4*5%6)+7/8-9*10%11*12</span><br><span class="line">(1+2*3)</span><br><span class="line">1-(100%5)</span><br><span class="line">(3+2*5)/(5)</span><br><span class="line">(11-11)+(33)*64-11</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">5</span><br><span class="line">-135</span><br><span class="line">7</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2101</span><br></pre></td></tr></table></figure>
<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>数据很水，不用考虑long long或取余等情况。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>逆波兰表达式是一种十分有用的表达式，它将复杂表达式转换为可以依靠简单的操作得到计算结果的表达式。例如(a+b)<em>(c+d)转换为ab+cd+</em></p>
<p>如果当前字符为变量或者为数字，则压栈，如果是运算符，则将栈顶两个元素弹出作相应运算，结果再入栈，最后当表达式扫描完后，栈里的就是结果。</p>
<p>例如(a+b)<em>(c+d)转换为ab+cd+</em>   计算机在计算普通表达式时，要对运算优先级用递归进行判断，对于更为复杂的表达式会使计算机运算效率变低甚至崩溃。而逆波兰表达式只需要进行简单的入栈出栈操作就可以完成任何普通表达式的运算。</p>
<p>普通表达式——&gt;逆波兰表达式</p>
<p>(1)a+b——&gt;a b +</p>
<p>(2)a+(b-c)——&gt;a b c - +</p>
<p>(3)a+(b-c)<em>d——&gt;a b c -  d </em> +</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 100007;</span><br><span class="line">map&lt;char,int&gt;Pri;//其实可以不必用map，只是为了方便大家理解map而多添加的一步</span><br><span class="line">stack&lt;int&gt;num;</span><br><span class="line">stack&lt;char&gt;Ope;</span><br><span class="line">char str[maxn];</span><br><span class="line">//初始化</span><br><span class="line">void init()&#123;</span><br><span class="line">    Pri[&apos;+&apos;] = Pri[&apos;-&apos;] = 1;</span><br><span class="line">    Pri[&apos;*&apos;] = Pri[&apos;/&apos;] = Pri[&apos;%&apos;] = Pri[&apos;(&apos;] = Pri[&apos;)&apos;] = 2;</span><br><span class="line">    while(!num.empty())</span><br><span class="line">        num.pop();</span><br><span class="line">    while(!Ope.empty())</span><br><span class="line">        Ope.pop();</span><br><span class="line">&#125;</span><br><span class="line">//基本运算操作</span><br><span class="line">void operation_1(int &amp;a,int &amp;b, char c)&#123;</span><br><span class="line">    if(c == &apos;+&apos;)</span><br><span class="line">        a += b;</span><br><span class="line">    else if(c == &apos;-&apos;)</span><br><span class="line">        a = b-a;</span><br><span class="line">    else if(c == &apos;*&apos;)</span><br><span class="line">        a *= b;</span><br><span class="line">    else if(c == &apos;/&apos;)</span><br><span class="line">        a = b/a;</span><br><span class="line">    else if(c == &apos;%&apos;)</span><br><span class="line">        a = b%a;</span><br><span class="line">&#125;</span><br><span class="line">//遇到+或者)时执行的操作</span><br><span class="line">void operation_2()&#123;</span><br><span class="line">    char ch = Ope.top();</span><br><span class="line">        while(ch != &apos;(&apos;&amp;&amp;!Ope.empty())&#123;</span><br><span class="line">            Ope.pop();</span><br><span class="line">            int a = num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            int b = num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            operation_1(a,b,ch);</span><br><span class="line">            num.push(a);</span><br><span class="line">            if(!Ope.empty())</span><br><span class="line">                ch = Ope.top();</span><br><span class="line">        &#125;</span><br><span class="line">        if(!Ope.empty()&amp;&amp;Ope.top() == &apos;(&apos;)</span><br><span class="line">            Ope.pop();</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;getchar();</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        cin.getline(str,maxn);</span><br><span class="line">        stringstream s(str);</span><br><span class="line">        init();</span><br><span class="line">        char tmp;</span><br><span class="line">        while(s &gt;&gt; tmp)&#123;</span><br><span class="line">        	//遇到数字字符时，需要判断下一位是否依旧是数字，是的话需要合并</span><br><span class="line">            if(tmp &gt;= &apos;0&apos; &amp;&amp; tmp &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                int t = 0;</span><br><span class="line">                do&#123;</span><br><span class="line">                    if(Pri[tmp])&#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    t *= 10;</span><br><span class="line">                    t += tmp - &apos;0&apos;;</span><br><span class="line">                &#125;while(s &gt;&gt; tmp);</span><br><span class="line">                num.push(t);</span><br><span class="line">            &#125;</span><br><span class="line">            //遇到&apos;)&apos;时</span><br><span class="line">            if(tmp == &apos;)&apos;)&#123;</span><br><span class="line">                operation_2();</span><br><span class="line">            &#125;</span><br><span class="line">            //遇到&apos;+&apos; ‘-’时</span><br><span class="line">            else if(Pri[tmp]==1)&#123;</span><br><span class="line">                if(!Ope.empty()&amp;&amp;Ope.top()!=&apos;(&apos;)&#123;</span><br><span class="line">                    operation_2();</span><br><span class="line">                &#125;</span><br><span class="line">                Ope.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(Pri[tmp])&#123;</span><br><span class="line">                Ope.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = num.top();</span><br><span class="line">        num.pop();</span><br><span class="line">        while(!num.empty()&amp;&amp;!Ope.empty())&#123;</span><br><span class="line">            operation_1(ans,num.top(),Ope.top());</span><br><span class="line">            Ope.pop();</span><br><span class="line">            num.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return  0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-D-留胡子"><a href="#问题-D-留胡子" class="headerlink" title="问题 D: 留胡子"></a>问题 D: 留胡子</h1><p>提交: 53  解决: 6<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=3&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1733" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1733&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1733&amp;getkey=3B707F894D" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1733" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>众所周知，刘虎子同学爱留胡子，人送外号刘胡子。为了留一抹性感又忧郁的小胡子，刘虎子专门与yoyo合作研发了一套算法，俗称油胡子算法。油胡子算法原理很简单，要想获得油胡子，首先将胡子从左到右分为n撮胡子，第i撮胡子的平均长度为xi。现每次从n中选出最左边的相邻胡子长度之差的绝对值为1的两撮胡子，减掉较长的1撮胡子，减掉的那撮胡子可以认为从n撮胡子中删除，剩下n-1撮胡子待修剪，再将剩下的n-1撮胡子从左到右重新排列成相邻的数继续如此操作，直到没有两撮相邻差的绝对值为1的胡子为止。此时的胡子称为完美油胡子。请问刘虎子同学最多需要剪多少次才能得到自己心仪的性感小胡子。</p>
<h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>输入第一行为n，接下来一行n个数x1x2…xi…xn。</p>
<h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>输出最多执行次数。</p>
<h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">3 2 3 1 0 1</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p><strong>用栈来维护每次合并完的数，每入栈一个数以后栈顶和次栈顶比较，如果可以合并就合并为新的栈顶，并且再次与次栈顶比较直至无法合并，在合并过程中统计次数即可。</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,x;</span><br><span class="line">int ans=0;     //最大操作次数</span><br><span class="line">stack&lt;int&gt; st;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		//将x与当前栈顶元素st.top()比较，若栈不空且st.top()比x大1，则合并一次(此时即当前栈顶元素出栈)</span><br><span class="line">		//然后x与次栈顶比较，以此类推，直到不满足栈不空且st.top()比x大1</span><br><span class="line">		while(!st.empty() &amp;&amp; st.top()-x==1)</span><br><span class="line">		&#123;</span><br><span class="line">			st.pop();</span><br><span class="line">			ans++;</span><br><span class="line">		&#125;</span><br><span class="line">		//若栈不空且x比st.top()大1，则合并一次</span><br><span class="line">		//(此时即x&quot;出栈&quot;，也就是忽略此x继续看下一个输入的x 但栈不发生任何变化)</span><br><span class="line">		if(!st.empty() &amp;&amp; x-st.top()==1)</span><br><span class="line">			ans++;</span><br><span class="line">		//其他情况(x为第一个元素或不满足上述两种情况)：将x入栈</span><br><span class="line">		else</span><br><span class="line">			st.push(x);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-E-卜卦"><a href="#问题-E-卜卦" class="headerlink" title="问题 E: 卜卦"></a>问题 E: 卜卦</h1><p>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?id=1734" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1734" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1734" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1734&amp;getkey=7E5D1F2620" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1734" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>赵神是一个特别特别闷骚的人。别看他平日表现很高冷，其实他一直暗恋着自己的小迷妹小花花，一日不见兮，思之如狂。马上快七夕了，赵神想卜一卦算一下他的爱情幸运数，于是他找到了yoyo半仙替他卜卦。yoyo半仙需要赵神的3个幸运数字以及小花花的3个幸运数字方可进行卜卦。已知赵神的3个幸运数字是’5’’2’’0’而小花花的幸运数字是abc，(保证由5，2，0，a，b，c，这6个数各不相同，且abc均为30以内的素数)。卜卦规则如下：<br>由{520abc}组成的6个各不相同数中选取最小的3个数作为加数，其余最大的3个数作为基数。每一个数若加上加数仅能被基数整除，其他素数均不能整除，则该数称为幸运数。其中第1314个幸运数为爱情幸运数。<br>现在你刚好知道小花花的幸运数，请你帮yoyo完成卜卦吧。PS：顺利完成任务后则会收获赵神珍藏版kiss一枚。</p>
<h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>首行输入t，代表t组测试样例</p>
<p>接下来t行输入三个数abc。</p>
<h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>输出第1314个幸运值</p>
<h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">7 3 11</span><br><span class="line">7 11 13</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">29541015622</span><br><span class="line">1775105893556</span><br></pre></td></tr></table></figure>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>待写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int fort = 1314;</span><br><span class="line">ll coeff[6];</span><br><span class="line">int cmp(ll a,ll b)&#123;</span><br><span class="line">    return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        cin&gt;&gt;coeff[0]&gt;&gt;coeff[1]&gt;&gt;coeff[2];</span><br><span class="line">        coeff[3] = 5;</span><br><span class="line">        coeff[4] = 2;</span><br><span class="line">        coeff[5] = 0;</span><br><span class="line">        sort(coeff,  coeff + 6, cmp);</span><br><span class="line">        priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; pq;</span><br><span class="line">        set&lt;ll&gt;s;</span><br><span class="line">        set&lt;ll&gt;ans;</span><br><span class="line">        pq.push(1);</span><br><span class="line">        s.insert(1);</span><br><span class="line">        for(int i = 0;;i++)&#123;</span><br><span class="line">            ll x = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            if(i)&#123;</span><br><span class="line">                for(int k = 3;k &lt; 6;k++)&#123;</span><br><span class="line">                    ans.insert(x - coeff[k]);</span><br><span class="line">                    if(ans.size()==fort)</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(ans.size()==fort)&#123;</span><br><span class="line">                    /*int ttt = 1;</span><br><span class="line">                    for(set&lt;ll&gt;::iterator it = ans.begin();it!=ans.end();it++)</span><br><span class="line">                        cout&lt;&lt;ttt++&lt;&lt;&apos; &apos;&lt;&lt;*it&lt;&lt;endl;*/</span><br><span class="line">                    set&lt;ll&gt;::reverse_iterator it = ans.rbegin();</span><br><span class="line">                    cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 0;j&lt;3;j++)&#123;</span><br><span class="line">                ll x2=x*coeff[j];</span><br><span class="line">                if(!s.count(x2))&#123;</span><br><span class="line">                    s.insert(x2);</span><br><span class="line">                    pq.push(x2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-F-成绩互评"><a href="#问题-F-成绩互评" class="headerlink" title="问题 F: 成绩互评"></a>问题 F: 成绩互评</h1><p>提交: 117  解决: 40<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=5&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1738" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1738&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1738&amp;getkey=9C71BFBEA7" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1738" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>学生互评作业的简单规则是这样定的：每个人的作业会被k个同学评审，得到k个成绩。系统需要去掉一个最高分和一个最低分，将剩下的分数取平均，就得到这个学生的最后成绩。本题就要求你编写这个互评系统的算分模块。</p>
<h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p>输入第一行给出3个正整数N（3&lt; N &lt;= 104，学生总数）、k（3&lt;= k &lt;= 10，每份作业的评审数）、M（&lt;= 20，需要输出的学生数）。随后N行，每行给出一份作业得到的k个评审成绩（在区间[0 100]内），其间以空格分隔。</p>
<h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p>按非递减顺序输出最后得分最高的M个成绩，保留小数点后3位。分数间有1个空格，行首尾不得有多余空格。</p>
<h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 5 3</span><br><span class="line">88 90 85 99 60</span><br><span class="line">67 60 80 76 70</span><br><span class="line">90 93 96 99 99</span><br><span class="line">78 65 77 70 72</span><br><span class="line">88 88 88 88 88</span><br><span class="line">55 55 55 55 55</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">87.667 88.000 96.000</span><br></pre></td></tr></table></figure>
<h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p><strong>total数组保存各个同学的平均分，v数组保存每次接收得到的分数，排序后取前m名，按递增输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int cmp(double a, double b) &#123;</span><br><span class="line">	return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int N, K, M;</span><br><span class="line">	while (cin &gt;&gt; N &gt;&gt; K &gt;&gt; M) &#123;</span><br><span class="line">		vector&lt;double&gt;v(K);</span><br><span class="line">		vector&lt;double&gt;v2(N);</span><br><span class="line">		for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">			double sum = 0;</span><br><span class="line">			for (int j = 0; j &lt; K; j++) &#123;</span><br><span class="line">				cin &gt;&gt; v[j];</span><br><span class="line">				sum += v[j];</span><br><span class="line">			&#125;</span><br><span class="line">			sort(v.begin(), v.end(), cmp);</span><br><span class="line">			sum -= v[0] + v[K - 1];</span><br><span class="line">			sum /= K - 2;</span><br><span class="line">			v2[i] = sum;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(v2.begin(), v2.end(), cmp);</span><br><span class="line">		for (int i = M - 1; i &gt; 0; i--)</span><br><span class="line">			printf(&quot;%.3lf &quot;, v2[i]);</span><br><span class="line">		printf(&quot;%.3lf\n&quot;, v2[0]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-G-列车"><a href="#问题-G-列车" class="headerlink" title="问题 G: 列车"></a>问题 G: 列车</h1><p>提交: 18  解决: 10<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=6&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1736" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1736&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1736&amp;getkey=EDCA6F0278" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1736" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>火车站的列车调度铁轨的结构如下图所示。<br><img src="http://www.liuchuo.net/wp-content/uploads/2016/07/Snip20160719_118.png" alt="img">tle=”” align=”” /&gt;</p>
<p>两端分别是一条入口（Entrance）轨道和一条出口（Exit）轨道，它们之间有N条平行的轨道。每趟列车从入口可以选择任意一条轨道进入，最后从出口离开。在图中有9趟列车，在入口处按照{8，4，2，5，3，9，1，6，7}的顺序排队等待进入。如果要求它们必须按序号递减的顺序从出口离开，则至少需要多少条平行铁轨用于调度？</p>
<h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>输入第一行给出一个整数N (2 &lt;= N &lt;= 105)，下一行给出从1到N的整数序号的一个重排列。数字间以空格分隔。</p>
<h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>在一行中输出可以将输入的列车按序号递减的顺序调离所需要的最少的铁轨条数。</p>
<h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">8 4 2 5 3 9 1 6 7</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p><strong>必须要车号大的先出，小的后出。所以列车排队的每一队必须是从大到小排列（从右往左看），才能保证开出去的车也是从大到小的。</strong> <strong>对于每一个想要进入并列铁轨的车，如果车号大于每一队的队尾的车号，说明不能进入已经有的队伍，必须进入新的铁轨</strong> <strong>否则，选择一个最接近它车号的尾部车号的队伍进入</strong> <strong>其实无需保存每一个并行队列的所有值，只需要保存当前队伍的车尾（就是每一列最左边 即 每一列的最小值）即可</strong> <strong>因为每一次都是需要排序比较大小的，所以用set自动排序</strong> <strong>首先把set里面放入一个0值。每一次set的最后一个值s.rbegin()都是当前所有队列队尾的最大值.</strong> <strong>如果当前想要进入排队队伍的t值比集合里面最大值小，就移除第一个比他大的值，然后把t插入集合中。表示的是将t值插入了最接近它车号的队伍的队尾</strong> <strong>否则就直接插入进去t值。作为新的队伍。</strong>s.upper_bound(t)返回的是第一个大于t的迭代器的位置<strong> </strong>在前面加星号表示取这个位置的值<strong> </strong>所以s.erase(*(s.upper_bound(t)));表示删除当前这个刚好大于t的位置处的值<strong> </strong>因为一开始插入了一个没有的0，所以最后输出是s.size()-1。** </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, t;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    set&lt;int&gt; s;</span><br><span class="line">    s.insert(0);</span><br><span class="line">    for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        if(t &lt; *s.rbegin()) &#123;</span><br><span class="line">            s.erase(*(s.upper_bound(t)));</span><br><span class="line">        &#125;</span><br><span class="line">        s.insert(t);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s.size() - 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-H-新浪关注"><a href="#问题-H-新浪关注" class="headerlink" title="问题 H: 新浪关注"></a>问题 H: 新浪关注</h1><p>提交: 24  解决: 14<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=7&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1737" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1737&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1737&amp;getkey=EB2FC0BAF0" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1737" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>新浪微博上有个“悄悄关注”，一个用户悄悄关注的人，不出现在这个用户的关注列表上，但系统会推送其悄悄关注的人发表的微博给该用户。现在我们来做一回网络侦探，根据某人的关注列表和其对其他用户的点赞情况，扒出有可能被其悄悄关注的人。</p>
<h2 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h2><p>输入首先在第一行给出某用户的关注列表，格式如下：</p>
<p>人数N 用户1 用户2 …… 用户N</p>
<p>其中N是不超过5000的正整数，每个“用户i”（i=1 … N）是被其关注的用户的ID，是长度为4位的由数字和英文字母组成的字符串，各项间以空格分隔。</p>
<p>之后给出该用户点赞的信息：首先给出一个不超过10000的正整数M，随后M行，每行给出一个被其点赞的用户ID和对该用户的点赞次数（不超过1000），以空格分隔。注意：用户ID是一个用户的唯一身份标识。题目保证在关注列表中没有重复用户，在点赞信息中也没有重复用户。</p>
<h2 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h2><p>我们认为被该用户点赞次数大于其点赞平均数、且不在其关注列表上的人，很可能是其悄悄关注的人。根据这个假设，请你按用户ID字母序的升序输出可能是其悄悄关注的人，每行1个ID。如果其实并没有这样的人，则输出“Bing Mei You”。</p>
<h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 GAO3 Magi Zha1 Sen1 Quan FaMK LSum Eins FatM LLao</span><br><span class="line">8</span><br><span class="line">Magi 50</span><br><span class="line">Pota 30</span><br><span class="line">LLao 3</span><br><span class="line">Ammy 48</span><br><span class="line">Dave 15</span><br><span class="line">GAO3 31</span><br><span class="line">Zoro 1</span><br><span class="line">Cath 60</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ammy</span><br><span class="line">Cath</span><br><span class="line">Pota</span><br></pre></td></tr></table></figure>
<h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p><strong>将关注的人存储在集合set里，将点赞的人和点赞的次数存储在map中，并统计点赞的平均次数sum / M，遍历map，如果map的值大于平均次数，且在set中找不到该用户名，就输出当前用户名（因为map中的键是已经按照字典序排序过的，所以直接输出就可以），并用flag标记是否有过输出，如果从始至终没有输出，说明没有悄悄关注的人，就输出Bing Mei You</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int m, n;</span><br><span class="line">	while (cin &gt;&gt; n) &#123;</span><br><span class="line">		set&lt;string&gt;id;</span><br><span class="line">		while (n--) &#123;</span><br><span class="line">			string name;</span><br><span class="line">			cin &gt;&gt; name;</span><br><span class="line">			id.insert(name);</span><br><span class="line">		&#125;</span><br><span class="line">		cin &gt;&gt; m;</span><br><span class="line">		map&lt;string, int&gt;mm;</span><br><span class="line">		int sum = 0;</span><br><span class="line">		for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">			int cnt;</span><br><span class="line">			string str;</span><br><span class="line">			cin &gt;&gt; str &gt;&gt; cnt;</span><br><span class="line">			mm[str] = cnt;</span><br><span class="line">			sum += cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		sum /= m;</span><br><span class="line">		int flag = 0;</span><br><span class="line">		for (auto it : mm) &#123;</span><br><span class="line">			if (it.second &gt; sum&amp;&amp;id.find(it.first) == id.end()) &#123;</span><br><span class="line">				cout &lt;&lt; it.first &lt;&lt; endl;</span><br><span class="line">				flag = 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!flag)</span><br><span class="line">			cout &lt;&lt; &quot;Bing Mei You&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-I-礼物"><a href="#问题-I-礼物" class="headerlink" title="问题 I: 礼物"></a>问题 I: 礼物</h1><p>提交: 94  解决: 44<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=8&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1739" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1739&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1739&amp;getkey=09962A88B1" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1739" target="_blank" rel="noopener">TestData</a>)]</p>
<h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>四月一日快到了，Vayko想了个愚人的好办法——送礼物。嘿嘿，不要想的太好，这礼物可没那么简单，Vayko为了愚人，准备了一堆盒子，其中有一个盒子里面装了礼物。盒子里面可以再放零个或者多个盒子。假设放礼物的盒子里不再放其他盒子。<br>用()表示一个盒子，B表示礼物，Vayko想让你帮她算出愚人指数，即最少需要拆多少个盒子才能拿到礼物。 </p>
<h2 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h2><p>本题目包含多组测试，请处理到文件结束。<br>每组测试包含一个长度不大于1000只包含’(‘’)’和’B’三种字符的字符串，代表Vayko设计的礼物透视图。<br>你可以假设，每个透视图画的都是合法的。 </p>
<h2 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h2><p>对于每组测试，请在一行里面输出愚人指数。</p>
<h2 id="样例输入-7"><a href="#样例输入-7" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((((B)()))())</span><br><span class="line">(B)</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-7"><a href="#样例输出-7" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h2><p><strong>看上去像是编译原理的文法识别，要用到栈，其实不是，只要看准备上面红色的字，就知道，只有三种字符()B，且待处理的串为合法的文法，所以要知道包装盒的个数，只要知道B前面有多少(字符，但可能有(()B)这种情况，B前面有)，但因为合法，所以可以在B之前的找到(与)相匹配，就剔除掉了，所以盒子的个数就是B之前的串中(的个数减去)的个数。</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	string str;</span><br><span class="line">	while (cin &gt;&gt; str) &#123;</span><br><span class="line">		int sco = 0;</span><br><span class="line">		for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">			if (str[i] == &apos;(&apos;)</span><br><span class="line">				sco++;</span><br><span class="line">			else if (str[i] == &apos;)&apos;)</span><br><span class="line">				sco--;</span><br><span class="line">			else if (str[i] == &apos;B&apos;)</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; sco &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题-J-Sunscreen"><a href="#问题-J-Sunscreen" class="headerlink" title="问题 J: Sunscreen"></a>问题 J: Sunscreen</h1><p>题意：有C头奶牛要去沐光浴，太阳光太强烈会晒坏皮肤，太弱又会没效果。每头牛都有一个太阳光适宜的范围经行沐光浴，分别给出minspf_i和maxspf_i。  有L种防晒霜，每种防晒霜可以把所受阳光固定于一个值spf_i，每种有cover_i瓶。  问最多会有几头牛得到合适的光晒强度？ </p>
<p><strong>题解：贪心策略，在满足minspf的条件下，尽量将spf的防晒霜涂到maxspf小的奶牛身上，因为maxspf大的奶牛有更多的选择。这里就需要一个优先队列来储存满足minspf的奶牛的maxspf的值。     具体解题步骤如下：</strong></p>
<p><strong>1.将奶牛按照minspf升序排列，将防晒霜按照spf升序排列。</strong></p>
<p><strong>2.枚举防晒霜，将minspf&lt;=spf的奶牛的maxspf存到优先队列中，然后值小的先出队列，看是否满足maxspf&gt;=spf，更新记录值。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 12505;</span><br><span class="line">struct spf &#123;</span><br><span class="line">	int max;</span><br><span class="line">	int min;</span><br><span class="line">	friend bool operator &lt; (spf a, spf b) &#123;</span><br><span class="line">		return a.min &lt; b.min;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;cow[MAXN], bot[MAXN];</span><br><span class="line">struct cmp &#123;</span><br><span class="line">	bool operator()(const int a, const int b)const &#123;</span><br><span class="line">		return a &gt; b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int C, L, i;</span><br><span class="line">	priority_queue&lt;int, vector&lt;int&gt;, cmp&gt;pq;</span><br><span class="line">	while (cin &gt;&gt; C &gt;&gt; L) &#123;</span><br><span class="line">		for (i = 0; i &lt; C; i++)</span><br><span class="line">			cin &gt;&gt; cow[i].min &gt;&gt; cow[i].max;</span><br><span class="line">		for (i = 0; i &lt; L;i++)</span><br><span class="line">			cin &gt;&gt; bot[i].min &gt;&gt; bot[i].max;</span><br><span class="line">		sort(cow, cow + C);</span><br><span class="line">		sort(bot, bot + L);</span><br><span class="line">		int cur = 0, ans = 0;</span><br><span class="line">		for(int i=0;i&lt;L;i++)&#123;</span><br><span class="line">			while(cur &lt; C&amp;&amp;cow[cur].min &lt;= bot[i].min) &#123; </span><br><span class="line">				pq.push(cow[cur].max); </span><br><span class="line">				cur++; </span><br><span class="line">			&#125;</span><br><span class="line">			while(!pq.empty()&amp;&amp;bot[i].max) &#123; </span><br><span class="line">				int maxSPF = pq.top(); </span><br><span class="line">				pq.pop();</span><br><span class="line">				if(maxSPF &gt;= bot[i].min)&#123;</span><br><span class="line">					ans++; </span><br><span class="line">					bot[i].max--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>[少年班]天分与平凡，青春与坚守</title>
    <url>/2018/07/14/2018-07-14/</url>
    <content><![CDATA[<p>好久没看电影了，不知何种原因，最近忽然又怀念起那段天天刷电影，写感想的感觉。不过为什么选择少年班呢？或许是因为剧中的IMC大赛与即将参加的ACM大赛很类似吧，想提高一下学习算法的动力；或许是因为时隔两年，也在大学中度过了两年，看看如今再看这部电影又是什么感觉，是否还秉持着初心呢；或许是经历过许许多多次起起伏伏，遇见过形形色色想遇或不想遇的人或事，又怀念起那段那段青涩的高中岁月；或许只是单纯的想再看看这部电影吧。不管为何，总之现在思绪万千。就让我将这万千的思绪草草记录一下吧。</p>
<p>这部电影剧情很简单，讲述的是几个天才少年与一个平凡少年被发掘功课数学难题却因青春的叛逆与时代的变迁而成长的故事。故事以主人公以吴未的少年班回忆而展开，主人公吴未就是那个平凡的少年。</p>
<p>少年班，顾名思义就是大学里专为年纪轻轻却智商非凡的天才们开设的精英班，某知名大学老师周知庸曾经就是少年班的成员，他的梦想是攻克IMC的题目，但曾经的他未能实现，于是将希望寄托在新时代的少年身上。在他的坚持下从全国各地找到了几名心仪的人选，其中包括了吴未。</p>
<p>然而，像其他天才系列电影一样，天才们拥有着平凡人所羡慕的才能之外，往往却拥有着平凡人所不能理解的烦恼。天才少年方厚政年纪最小，却智商超群，可谓前途无量，只是他IQ高。EQ却低，因此没有什么朋友。天才少年麦克因家庭原因而性格叛逆，打架斗殴无所不为。天才少年王大法无拘无束，自由散漫，因此总让别人捉摸不透，不想与之有交集。天才少女周兰品学兼优，是典型的别人家的子，但也是因为优秀而让所有人都敬而远之。但是和其他电影不同的是，这些天才们不可思议的烦恼其实我们都能理解。毕竟曾经或现在处于青春期的我们哪一个人曾经没有过类似的烦恼呢？他们的性格不过是我们所有人青春期各种性格的集合并放大罢了。</p>
<p>当然，我们的主人公也有着自己的烦恼，身为平凡人的代表，当他进入少年班后从之前的全校第二摇身一变变成班上的倒数第一，这种落差估计每个处于青春期的孩子都受不了吧。于是他一边仰望着天才们过人的天赋，一边忍受着天才们怪异的性格，一边照顾着正处于青春期幼稚的天才们，一边独自默默努力着，为了自己心中的荣誉。然而，努力在这满是天才的地方却显得那么多余。就在他一筹莫展，开始疑惑为何老师选中他的时候，周知庸老师出现，解开了她的心结。“运送金枪鱼的时候，要在里面混进几条鲶鱼，否则金枪鱼就会因懒惰而死，到不了岸。”老师鼓励他做好自己鲶鱼的身份，因为天才们离开了它的照顾就会堕入深渊。尽管是鲶鱼，但吴未却似乎找到了自己的归宿，并以此为荣，从此，吴未以天才们的快乐为快乐，以天才们的梦想为梦想，就在自己喜欢的人面前，也只能呼喊着天才们所喜欢的校花名字。</p>
<p>IMC马上开始了，老师想进各种办法激励着天才们去努力钻研，但是恃才傲物并且正处于青春期的天才们又怎会把新鲜的大学生活浪费在学习上呢？趁着大学生活的新鲜感犹在，天才们渐渐被校花江依琳所吸引，从此各种各样的新奇表白开始了。只有吴未从一开始就暗恋着同班的天才少女周兰。尽管周兰从来都看不起吴未，并且单恋这少年班的迈克。</p>
<p>比赛前一天，几名少年班朝夕相处的小伙伴们在酒后发泄着各种各样青春期的passion，来到女生宿舍楼下，大声表白校花，那一刻，漫天飞舞的纸花，洋洋洒洒，似乎整个世界都在期待着几个天才少年去改变。</p>
<p>比赛的一个月里，天才们尽管出现各种各样的矛盾，但在吴未的调节下，无伤大雅。但一次偶遇，校花与富家公子哥之间的隐曲之事深深刺激到了天才们。他们落荒而逃，逃得那么彻底。</p>
<p>老师闻讯，拿起了酒杯，向舞台赶去。天才们旧气难言，拿起了自制的化学炸药，向富二代的车赶去。老师将酒水泼向校花，门外传来雷鸣般的爆炸。这一刻，老师的梦想毁了，天才们的前途毁了，然而，世界依然有活力地在转，一如既往。</p>
<p>然而，老师仍心怀希望，尽力将此事最小化解决。这边，王大法作为被开除的学生被家人拖走，那边，吴未望向楼上的橱窗，老师站在橱窗望着吴未。这一刻，吴未明白，自己的价值将要发挥了。就这样，吴未顶替其他天才们而被学校开除。</p>
<p>奔驰的归家车上，吴未哭的撕心裂肺，将自己仅有的一枚荣誉勋章扔向窗外，像扔去回忆一样。身后周兰，方厚政，迈克，追的精疲力尽，他们将过去的笔记本扔向追不上的公交车，像追随友谊一样。</p>
<p>最终，天才们并没有解出题，也没有改变世界，但他们最终都找到了自己的方向。周知庸老师最后没能实现自己的天才梦，也丢掉了工作，像人间蒸发一样，随旧时代而去，但他却找到了自己的人生伴侣。吴未，平淡无味，但又快乐的漂浮着。</p>
<p>这部影片最大的亮点就在于其真实性。首先，少年班的故事从1978年起一直延续着。然而，随着时代的发展，如今的少年班已不复存在了。旧时代里，时代的推进是由天才们推进的，这就是为何周知庸老师为何执着于天才的原因之一。就像他说的，“高斯十七岁就发现了第二相反定理，这些天才当时他们不敢发表，因为怕人们不信。”因为这种理念的支撑，让他对所有平凡人带上了有色眼镜，以至于四十多岁依旧单身。然而，过去毕竟是过去，世界上有很多天才，但只有一个高斯，只有一个牛顿，只有一个爱因斯坦。牛顿他们所带表的这类基础科学并不是一个人所完成的，它需要所处时代的支持以及现有技术的支撑，就像牛顿自己也说过，自己是站在巨人肩膀上的，况且牛顿从未说过自己是天才，自己只是热爱探索而已，因此，想要天才改变世界的周知庸老师从一开始就错了，因为他不懂平凡人的价值，所以，他没有牛顿的成就，与牛顿唯一的共同点就是一直单身。世界是一个多元化的世界，不只是理论的世界，如果说基础科学是时代质的飞跃，那应用科学就是时代量的积累、倘若基础科学离开了应用科学，那么世界依旧停滞不前，基础科学反而成为了最没用的东西。故事的结尾，天才们并没有从事科研工作，而是选择了自己所喜欢的岗位，他们没有改变世界，只是生活的比平凡人更潇洒。平凡与天赋，其实离开谁都不行，正是因为天才们的研发，广大平凡的劳动者的坚持工作与制作，才使得这个世界不断推进向前。</p>
<p>然而，少年班不适宜于当下最主要的原因还是心智的为题。尽管天才们智商超群，但是年纪与经历更重要。十几岁就步入大学校门，尽管他们智商达标了，但心智并未达标。电影中表现的淋淋尽致。他们从未接触过社会，也并不懂得什么是责任，当然，那个时代的我们都一样，在心智上，人人都是平等的。我们就来分析一下各个主人公吧。</p>
<p>首先是主人公方厚政。作为年纪最小的天才，他的心情，性格，全都写在了脸上。目测智商150，心理年龄只有9岁。遇到委屈就哭，遇到自己看不上的事就挖苦，总之这个世界上只有自己是最厉害的，当面对丰富多彩的大学生活，他又怎会抵挡住各种各样的新鲜事物而去专心钻研呢。主人公迈克，看似成熟，其实心智同样幼稚，面对所有事第一个想到的就是用拳头来解决，从不会考虑后果。主人公王大法自由散漫，每天吃着馒头，听着经文，一副玩世不恭的样子。主人公周兰，可以说是所有优秀的女孩的代表，可以说是比较正常的一个，但正处于花季年纪的她并不适合大学生活，成绩优异不懂打扮的她让人只能敬而远之。尽管是天才，但是如今的大学并不只是学习知识的地方，如果说初中是每个人最会做梦的年纪，高中洋溢着每个人最具浓厚的青春，走向社会是一个人成长为打人的标志，那么大学时代则是每一个人从孩子长成大人的过度期，因此嚷处于做梦年纪的孩子直接去面向社会的残酷未免太过残忍。</p>
<p>校花江依琳可谓是剧中较完美的一个人，他承载着天才们对女性最完美的幻想。她可以说是剧中EQ最高的一位。尽管他是天才们放弃比赛的导火线，但是天才们又有几个真正懂得感情呢。她对方厚政的感情其实就是姐姐对弟弟的照顾，而对于心智只有9岁的方厚政来说，又怎会冬的何谓男女之情呢。方厚政对待像话的感觉也不过是弟弟对大姐姐的仰慕之情。王大法测试时便已说过他所期望的爱情是门当户对，显然校花并不是他所期待的人，因此他对校花的感情量自己都不会说清楚。至于迈克，校花也许的确对迈克有点好感，但迈克显然给不了校花幸福，首先，迈克并不知道什么是责任，测试时便已清楚他的情绪宣泄是暴力，倘若青春期那股passion磨灭了，后果自行脑补。其次迈克给不了校花真正需要的。之所以前期近似完美的校花最后会有那么一出戏，其实很容易看出的。江依琳需要一场舞蹈独秀以支撑日后的发展，身为天才的少年们有谁能给呢，因此江依琳选择了富家公子哥，这都是情理之中。而此时的天才们只顾自己的感受，仗着长久以来老师的庇护去炸车。所以，当看到周知庸老师泼江依琳水时，我倒有点替校花感到冤枉，自己争取来的前途就因为接近了天才们而被老师给毁了。而周老师之所以泼水，也许是曾经旧时代里被戏弄过，旧火新火全发泄在了江依琳身上。</p>
<p>周知庸老师，典型旧时代的人，因为自己未能拿奖的遗憾，而把希望寄托在新时代的少年天才们身上。也许努力学习没有错，但他忽略了当今世界已不是简简单单努力学习就能改变的了。当一个人不愿接受新时代时，他已经被这个时代所遗弃，成为旧时代的古董。当他最后不在从事教育事业，专心于交际时，此刻的他应该是幸福的。</p>
<p>不过，周老师错了吗，没人能说他错了。至少20多年来，他一直秉持着初心，坚守着梦想，对于现代人来说，这一点是多么的可贵呢。社会这个大染缸将每一个青春期怀穿着梦想的少年少女染成形形色色为生活而忙碌的机器，又有几个人能站出来说我要改变这个世界呢。我感觉说这话的人并不丢人，反而是那些早已面目全非的人让人可悲。</p>
<p>不知不觉，恭喜我又成功把我给绕进去了。我竟然有分不清自己的立场了，呵呵。不过不论什么样的人，坚持做好自己就好。正处于大学生活的我们，无论何时都要坚持自己的梦想，不必在意那些圆滑的人说你不够圆滑，不必在意那些所谓成熟的人说你不够成熟，不要照原样接受别人的生活。选择坚守，选择理想，选择倾听自己内心深处的呼唤。因为在这个充满怀疑的世界，我们依旧需要梦想。</p>
]]></content>
      <categories>
        <category>心路历程</category>
        <category>影评</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title>回忆若一指流沙，散落了谁的风华</title>
    <url>/2018/06/11/2018-06-11/</url>
    <content><![CDATA[<p>宁静的夏天，天空中繁星点点。带上浓浓的睡意与滴滴答答的雨点，我们踏上了前往宁夏的航线。凌晨五点半，我们在的闹钟呼唤下出发了。</p>
<p>后天，同样的时间，宁夏理工学院，我们要比赛。伴着飞机超重又失重的压抑，我知道，起飞了。望着机窗外一览众山小的风景，顿时有一种憧憬，又有一种壮志凌云。</p>
<p>在宁夏，没有高楼大厦，但远处的山峰鳞次栉比。没有车水马龙，但广阔的天空一碧如洗。一切都安顿好之后，我们便奔向当地特色小吃而去。宁夏理工学院，坐落在湖心的一座岛屿之上，可以说，一座岛屿即一座城。很快我们便摸不清方向了。此时，一个小姐姐跑过来跟我们搭讪。由于比赛都发的队服，很是显眼，显然，她是被我们的队服吸引而来的。就这样莫名其妙的，我们渐渐熟悉。在她的带领下，我们逛了校园，逛了小吃摊……</p>
<p>宁夏昼长夜短，即使到了晚上八九点，天依然为褪色。就这样逛着逛着，吃着吃着，天就黑了，当我们看时间时，已是十点多了。我们留下了联系方式，各自归宿。</p>
<p>第2天，宁夏理工学院组织我们所有参赛者一起去旅游，地点是沙湖，即沙漠中的一片绿洲。我们队和昨天的小姐姐约好今天一起游玩，而我们队刚好缺了一个教练，就这样理所当然的，她以我们教练的身份一起踏上了沙漠的旅程。</p>
<p>一路上，我们划过了湖泊，翻过了沙漠，跨过了沙丘，因为她的出现，在她的陪伴下，我们的旅程不再显得单调乏味。在沙漠中，偶然发现某片沙地里满是荆棘，当跨过荆棘之后，望到了一片花海。尽管花在强烈的阳光下已奄奄一息，然而它们仿佛在用生命证明自己存在的意义。同伴们纷纷前往亭下避暑，只有我守着安静的沙漠，等待着花开。</p>
<p>第3天，终于要比赛了。经过了上一次失败的经验，这次尽管最后一次提交因为时间到了没有提交成功，不过好在前两个半小时成功A了3道题，我们队最终斩获一枚铜奖，也算是这么多月的训练也算有了一个回报。</p>
<p>临别时，小姐姐教练来为我们送行，并带来当地的特产。因为赶飞机，我们草草照相留念之后，便踏上了返程的飞机。</p>
<p>戴上耳机，梳理着三天的回忆。其实我们每个人来到这个世界上，就只能义无反顾的前进。在人生的道路上，除了自己，其他人都只能伴我们走过一程。这一程，或长或短，也许转瞬已尽，也许直通彼岸，但永远不会是永远。当走完这一程，余下的路需由自己来走完。然而不必逗留着，因为每时每刻，都会有新的过客伴你走过新的一程。尽管离别之后，我们可能会永远不见，但彼此走过的那份欢乐，永远藏在心里。</p>
<p>谢谢你伴我们走过这三天，也许今后永远不会再见，但我们走过的那段旅程以及旅程中的你我永远不会失散。</p>
]]></content>
      <categories>
        <category>心路历程</category>
        <category>散文</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title>API函数配置读写文件</title>
    <url>/2018/06/03/2018-06-03/</url>
    <content><![CDATA[<p>cfg_op.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">	//获取配置项</span><br><span class="line">	int GetCfgItem(char *pFileName/*in*/, char*pKey/*in*/, char *pValue/*in out*/, int *pValueLen/*out*/);</span><br><span class="line">	//写配置项</span><br><span class="line">	int WriteCfgItem(char*pFileName/*in*/, char *pKey/*in*/, char *pValue/*in*/, int *ValueLen/*in*/);</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>cfg_op.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define Maxline 2048</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">	int GetCfgItem(char *pFileName, char*pKey, char *pValue, int *pValueLen)</span><br><span class="line">	&#123;</span><br><span class="line">		int ret = 0;</span><br><span class="line">		FILE *fp = NULL;</span><br><span class="line">		char lineBuf[Maxline];</span><br><span class="line">		char *pTmp = NULL, *pEnd = NULL, *pBegin = NULL;</span><br><span class="line">		fp = fopen(pFileName, &quot;r&quot;);</span><br><span class="line">		if (fp == NULL) &#123;</span><br><span class="line">			ret = -1;</span><br><span class="line">			return ret;</span><br><span class="line">		&#125;</span><br><span class="line">		while (!feof(fp)) &#123;</span><br><span class="line">			memset(lineBuf, 0, sizeof(lineBuf));</span><br><span class="line">			fgets(lineBuf, Maxline, fp);</span><br><span class="line">			printf(&quot;lineBuf:%s &quot;, lineBuf);</span><br><span class="line"></span><br><span class="line">			pTmp = strchr(lineBuf, &apos;=&apos;);</span><br><span class="line">			if (pTmp == NULL) &#123;	//没有=号</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			pTmp = strstr(lineBuf, pKey);</span><br><span class="line">			if (pTmp == NULL) &#123;	//判断key是不是在//所在行 是不是有key</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			pTmp = pTmp + strlen(pKey);	//	mykey1 = myvalue11111111==&gt;&quot;myvalue11111111&quot;</span><br><span class="line">			pTmp = strchr(pTmp, &apos;=&apos;);</span><br><span class="line">			if (pTmp == NULL) &#123;	//判断所在行是不是有key</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			pTmp++;</span><br><span class="line">			printf(&quot;pTmp:%s &quot;, pTmp);</span><br><span class="line">			//获取value起点</span><br><span class="line">			while (1) &#123;</span><br><span class="line">				if (*pTmp == &apos; &apos;) &#123;</span><br><span class="line">					pTmp++;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					pBegin = pTmp;</span><br><span class="line">					if (*pBegin == &apos;\n&apos;) &#123;</span><br><span class="line">						//没有配置value</span><br><span class="line">						printf(&quot;配置项:%s 没有配置value \n&quot;, pKey);</span><br><span class="line">						goto End;</span><br><span class="line">					&#125;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			//获取value结束点</span><br><span class="line">			while (1) &#123;</span><br><span class="line">				if (*pTmp == &apos; &apos; || *pTmp == &apos;\n&apos;) &#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					pTmp++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			pEnd = pTmp;</span><br><span class="line">			//赋值</span><br><span class="line">			*pValueLen = pEnd - pBegin;</span><br><span class="line">			memcpy(pValue, pBegin, pEnd - pBegin);</span><br><span class="line">		&#125;</span><br><span class="line">	End:</span><br><span class="line">		if (fp == NULL)</span><br><span class="line">			fclose(fp);</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">	int WriteCfgItem(char*pFileName, char *pKey, char *pValue, int *ValueLen)</span><br><span class="line">	&#123;</span><br><span class="line">		int rv = 0, iTag = 0, length = 0;</span><br><span class="line">		FILE *fp = NULL;</span><br><span class="line">		char lineBuf[Maxline];</span><br><span class="line">		char *pTmp = NULL, *pBegin = NULL, *pEnd = NULL;</span><br><span class="line">		char filebuf[1024 * 8] = &#123; 0 &#125;;</span><br><span class="line">		if (pFileName == NULL || pKey == NULL || pValue == NULL) &#123;</span><br><span class="line">			rv = -1;</span><br><span class="line">			printf(&quot;SetCfgItem() err. param err \n&quot;);</span><br><span class="line">			goto End;</span><br><span class="line">		&#125;</span><br><span class="line">		fp = fopen(pFileName, &quot;r+&quot;);</span><br><span class="line">		if (fp == NULL) &#123;</span><br><span class="line">			rv = -2;</span><br><span class="line">			printf(&quot;fopen() err.\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (fp == NULL) &#123;</span><br><span class="line">			fp = fopen(pFileName, &quot;w+t&quot;);</span><br><span class="line">			if (fp == NULL) &#123;</span><br><span class="line">				rv = -3;</span><br><span class="line">				printf(&quot;fopen() err.\n&quot;);</span><br><span class="line">				goto End;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fseek(fp, 0L, SEEK_END);//把文件指针从0位置开始，移动到文件末尾</span><br><span class="line">		//获取文件长度</span><br><span class="line">		length = ftell(fp);</span><br><span class="line">		fseek(fp, 0L, SEEK_SET);</span><br><span class="line">		if (length &gt; 1024 * 8) &#123;</span><br><span class="line">			rv = -3;</span><br><span class="line">			printf(&quot;文件超过1024*8,nunsupport&quot;);</span><br><span class="line">			goto End;</span><br><span class="line">		&#125;</span><br><span class="line">		while (!feof(fp)) &#123;</span><br><span class="line">			//读每一行</span><br><span class="line">			memset(lineBuf, 0, sizeof(lineBuf));</span><br><span class="line">			pTmp = fgets(lineBuf, Maxline, fp);</span><br><span class="line">			if (pTmp == NULL) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			//key关键字是否在本行</span><br><span class="line">			pTmp = strstr(lineBuf, pKey);</span><br><span class="line">			if (pTmp == NULL)//key关键字不在本行，copy到filebuf中</span><br><span class="line">			&#123;</span><br><span class="line">				strcat(filebuf, lineBuf);</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			else//key关键字在本行中，替换旧的行，再copy到filebuf中</span><br><span class="line">			&#123;</span><br><span class="line">				sprintf(lineBuf, &quot;%s = %s\n&quot;, pKey, pValue);</span><br><span class="line">				strcat(filebuf, lineBuf);</span><br><span class="line">				//若存在key</span><br><span class="line">				iTag = 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//若key关键字，不存在 追加</span><br><span class="line">		if (iTag == 0) &#123;</span><br><span class="line">			fprintf(fp, &quot;%s = %s\n&quot;, pKey, pValue);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;//若key关键字，存在，则重新创建文件</span><br><span class="line">			if (fp != NULL) &#123;</span><br><span class="line">				fclose(fp);</span><br><span class="line">				fp = NULL;//避免野指针</span><br><span class="line">			&#125;</span><br><span class="line">			fp = fopen(pFileName, &quot;w+t&quot;);</span><br><span class="line">			if (fp == NULL) &#123;</span><br><span class="line">				rv = -4;</span><br><span class="line">				printf(&quot;fopen() err.\n&quot;);</span><br><span class="line">				goto End;</span><br><span class="line">			&#125;</span><br><span class="line">			fputs(filebuf, fp);</span><br><span class="line">		&#125;</span><br><span class="line">	End:</span><br><span class="line">		if (fp != NULL) &#123;</span><br><span class="line">			fclose(fp);</span><br><span class="line">		&#125;</span><br><span class="line">		return rv;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&quot;cfg_op.h&quot;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define CFGNAME &quot;d:/mycfg.ini&quot;</span><br><span class="line">//读配置项</span><br><span class="line">int GetCfg() &#123;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	char name[1024] = &#123; 0 &#125;;</span><br><span class="line">	char value[1024] = &#123; 0 &#125;;</span><br><span class="line">	int vlen = 0;</span><br><span class="line">	printf(&quot;\n请输入Key:&quot;);</span><br><span class="line">	scanf(&quot;%s&quot;, name);</span><br><span class="line">	ret = GetCfgItem(CFGNAME, name, value, &amp;vlen);</span><br><span class="line">	if (ret != 0) &#123;</span><br><span class="line">		printf(&quot;func GetCfgItem err:%d \n&quot;, ret);</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;value:%s \n&quot;);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line">//写配置项</span><br><span class="line">int TWriteCfg() &#123;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	char name[1024] = &#123; 0 &#125;;</span><br><span class="line">	char value[1024] = &#123; 0 &#125;;</span><br><span class="line">	int vlen = 0;</span><br><span class="line">	printf(&quot;\n请输入Key:&quot;);</span><br><span class="line">	scanf(&quot;%s&quot;, name);</span><br><span class="line">	printf(&quot;\n请输入Value:&quot;);</span><br><span class="line">	scanf(&quot;%s&quot;, value);</span><br><span class="line">	WriteCfgItem(CFGNAME, name, value, &amp;vlen);</span><br><span class="line">	if (ret != 0) &#123;</span><br><span class="line">		printf(&quot;func WriteCfgItem err:%d \n&quot;, ret);</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;您的输入是：%s = %s \n&quot;, name, value);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show_menu() &#123;</span><br><span class="line">	printf(&quot;==========================\n&quot;);</span><br><span class="line">	printf(&quot;1.测试写配置文件\n&quot;);</span><br><span class="line">	printf(&quot;2.测试读配置文件\n&quot;);</span><br><span class="line">	printf(&quot;0.退出\n&quot;);</span><br><span class="line">	printf(&quot;==========================\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int choice;</span><br><span class="line">	show_menu();</span><br><span class="line">	while (~scanf(&quot;%d&quot;, &amp;choice)) &#123;</span><br><span class="line">		//显示一个菜单</span><br><span class="line">		switch (choice) &#123;</span><br><span class="line">		case 1:</span><br><span class="line">			TWriteCfg();</span><br><span class="line">			break;</span><br><span class="line">		case 2:</span><br><span class="line">			GetCfg();</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			exit(0);</span><br><span class="line">		&#125;</span><br><span class="line">		system(&quot;pause&quot;);</span><br><span class="line">		system(&quot;cls&quot;);</span><br><span class="line">		show_menu();</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>API</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客训练赛19之托米专场</title>
    <url>/2018/06/01/2018-06-01/</url>
    <content><![CDATA[<h2 id="托米的简单表示法"><a href="#托米的简单表示法" class="headerlink" title="托米的简单表示法"></a><a href="https://www.nowcoder.com/acm/contest/111/A" target="_blank" rel="noopener">托米的简单表示法</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>   作为故事主角的托米是一名老师。  </p>
</blockquote>
<p>  一天，他正在为解析算术表达式的课程准备课件。 在课程的第一部分，他只想专注于解析括号。 他为他的学生发明了一个有趣的正确括号序列的几何表示，如下图所示: </p>
<p>  几何表示的定义： </p>
<p>  <strong>1.</strong>          <strong>对于一个括号序列A，我们定义g(A)是A的几何表示形式,则          “()”的表示是一个1*1的方块，高度为1;</strong>            <strong>2.对于一个括号序列A，”(A)”的表示是由一个比g(A)宽2个单位高1个单位的矩形包围g(A)，它的高度为A+1; 3.对于两个括号序列A和B，A+B的几何表示形式为把g(B)放置在g(A)右边的一个单位，且高度为A和B的高度的较大值。 其中+指的是字符串的连接符。</strong>  </p>
<p>​                              </p>
<p>  在完成课件后，托米老师开始玩他做好的图片。 他将图像的有限区域交替地涂成黑色和白色，使最外面的区域全部涂成黑色。 对于上面的例子，这个着色如下所示： </p>
<p>  <img src="https://uploadfiles.nowcoder.com/images/20180529/301599_1527594747449_9C23C3C01AAE429614DCD886F400FAF2" alt="img"></p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入的第一行包含一个整数T，表示指定测试用例的数量。</span><br><span class="line">每个测试用例前面都有一个空白行。</span><br><span class="line">每个测试用例由一个合法括号序列组成。 每行只包含字符&apos;(&apos;和&apos;)&apos;。</span><br></pre></td></tr></table></figure>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于每个测试用例，输出一行包含一个整数,表示相应几何表示的黑色部分的面积。</span><br></pre></td></tr></table></figure>
<p> 示例1 </p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line"></span><br><span class="line">((()))</span><br><span class="line"></span><br><span class="line">(())(()(()))</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第二个测试案例是上图中显示的案例。</span><br></pre></td></tr></table></figure>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1≤T≤10</span><br><span class="line">一个合法括号序列长度≤4 x 105</span><br></pre></td></tr></table></figure>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这道题提交了好多次，一直WA。后来改成long long就过了。原理很简单，就是遇见左括号入栈，遇见右括号出栈。在入栈出栈时执行操作。先入栈的高度比后入栈的最高高度要高1，初始宽度为1，每执行一次出栈操作，出栈元素前一个元素的宽度等于他自身宽度加上出栈元素宽度再加1。而出栈元素的面积等于宽乘高减去包含元素的面积。就这样，每次出栈时，前一个元素宽度加上该元素宽度加1，前元素将要减去的面积area等于出栈元素的面积minu。而出栈元素的面积area等于高乘宽减去将要减去的面积minu。最终由于0位置没有面积，就是全域，那他的minu即将要减去的面积就是总面积。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 200010;</span><br><span class="line">char str[maxn*2];</span><br><span class="line">ll high[maxn],wed[maxn],area[maxn],minu[maxn],mystack[maxn];</span><br><span class="line">ll fun()&#123;</span><br><span class="line">    int cnt = 1,head = 1,tail = 1,len = strlen(str);</span><br><span class="line">    memset(high,0,sizeof(high));</span><br><span class="line">    memset(wed,0,sizeof(wed));</span><br><span class="line">    memset(minu,0,sizeof(minu));</span><br><span class="line">    memset(mystack,0,sizeof(mystack));</span><br><span class="line">    for(int i = 0;i &lt; len;i++)&#123;</span><br><span class="line">        if(str[i] == &apos;(&apos;)&#123;</span><br><span class="line">            mystack[tail++]=cnt++;</span><br><span class="line">            high[mystack[tail - 1]]++;</span><br><span class="line">            wed[mystack[tail - 1]] = 1;</span><br><span class="line">            if(high[mystack[tail - 2]] &lt;= high[mystack[tail - 1]])</span><br><span class="line">                high[mystack[tail - 2]] = high[mystack[tail - 1]] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(str[i] == &apos;)&apos;)&#123;</span><br><span class="line">            if(tail &gt; 1)&#123;</span><br><span class="line">                if(high[mystack[tail-2]] &lt;= high[mystack[tail-1]])</span><br><span class="line">                    high[mystack[tail-2]] = high[mystack[tail-1]] + 1;</span><br><span class="line">                tail--;</span><br><span class="line">                wed[mystack[tail - 1]] += wed[mystack[tail]] + 1;</span><br><span class="line">                area[mystack[tail]] = wed[mystack[tail]] * high[mystack[tail]] - minu[mystack[tail]];</span><br><span class="line">                minu[mystack[tail - 1]] += area[mystack[tail]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return minu[0];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%s&quot;,str);</span><br><span class="line">        cout &lt;&lt; fun() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="托米的饮料"><a href="#托米的饮料" class="headerlink" title="托米的饮料"></a><a href="https://www.nowcoder.com/acm/contest/111/E" target="_blank" rel="noopener">托米的饮料</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>   好了，现在是小托米的故事啦~~~  </p>
</blockquote>
<p>  可爱的小托米得到了n瓶饮料. </p>
<p>但他不小心把开盖的工具弄丢了,所以他只能利用饮料瓶来开盖.</p>
<p>已知第i个瓶子的品牌为a</p>
<p>i</p>
<p>,且其能打开b</p>
<p>i</p>
<p>品牌的瓶子.</p>
<p>问有几瓶饮料托米无法喝到.</p>
<p><strong>被用于打开饮料瓶的瓶子不一定需要被打开.</strong></p>
<p><strong>一个瓶子不能打开其本身.</strong></p>
<h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行一个整数n,表示饮料的瓶数.</span><br><span class="line">接下来n行,每行两个整数ai,bi.</span><br></pre></td></tr></table></figure>
<h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出一行一个整数,表示小托米无法喝到的饮料瓶数.</span><br></pre></td></tr></table></figure>
<p> 示例1 </p>
<h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure>
<h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p> 示例2 </p>
<h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure>
<h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="备注-1"><a href="#备注-1" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1≤n≤100</span><br><span class="line">1≤ ai,bi≤ 1000</span><br></pre></td></tr></table></figure>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>本题坑人之处在于理解题意。因为没理解题意导致提交了好多次才提交成功。本题实质很简单，就是每个瓶子对应有一个编号b，可以开这个编号b除了自己以外的所有的瓶子。但仅限于该瓶子，其他瓶子也只能执行自己的编号b。首先输入完成时记录下所有编号的瓶子个数，把n赋给瓶子个数cnt，因为一开始n个瓶子都没打开。接着对b按顺序进行遍历，如果对应编号的瓶子不存在，则不执行操作，否则接着判断，如果a和b不同，则cnt减去该瓶子的数量，然后数量置零，因为该类瓶子已经打开完了，之后不需要再打开，否则执行完操作后再加1，因为不能打开自己。最后cnt就是剩下没打开的数量。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int vis[1010]=&#123;0&#125;,a[1010],b[1010];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int cnt = n;</span><br><span class="line">    for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">        vis[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(vis[b[i]])&#123;</span><br><span class="line">            cnt-=vis[b[i]];</span><br><span class="line">            vis[b[i]]=0;</span><br><span class="line">            if(a[i]==b[i])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                vis[b[i]]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="托米搭积木"><a href="#托米搭积木" class="headerlink" title="托米搭积木"></a><a href="https://www.nowcoder.com/acm/contest/111/F" target="_blank" rel="noopener">托米搭积木</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>  小托米真的很可爱呀(&gt;_&lt;) </p>
</blockquote>
<p>  这天,可爱的小托米得到了n堆积木,且第i堆积木初始时有ai块积木. </p>
<h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行两个整数n,m.</span><br><span class="line">第二行n个整数,第i个整数代表ai的值.</span><br><span class="line">接下来m行,每行代表一个操作:</span><br><span class="line">第一个整数t代表操作的类型</span><br><span class="line">若t=1,则接下来两个整数v,x,代表操作1.</span><br><span class="line">若t=2,则接下来一个整数y,代表操作2.</span><br><span class="line">若t=3,则接下来一个整数q,代表操作3.</span><br></pre></td></tr></table></figure>
<h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于每个操作3,输出其对应的答案.</span><br></pre></td></tr></table></figure>
<p> 示例1 </p>
<h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 11</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">3 2</span><br><span class="line">3 9</span><br><span class="line">2 10</span><br><span class="line">3 1</span><br><span class="line">3 10</span><br><span class="line">1 1 10</span><br><span class="line">2 10</span><br><span class="line">2 10</span><br><span class="line">3 1</span><br><span class="line">3 10</span><br><span class="line">3 9</span><br></pre></td></tr></table></figure>
<h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">9</span><br><span class="line">11</span><br><span class="line">20</span><br><span class="line">30</span><br><span class="line">40</span><br><span class="line">39</span><br></pre></td></tr></table></figure>
<h3 id="备注-2"><a href="#备注-2" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1≤n,m≤ 105</span><br><span class="line">1≤ai≤109</span><br><span class="line">1≤t≤3</span><br><span class="line">1≤v≤ n,1≤ x≤109</span><br><span class="line">1≤y≤104</span><br><span class="line">1≤q≤n</span><br></pre></td></tr></table></figure>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>很简单的一道题，3种操作，第1操作是把第i位置的数该为另一个数x，第2个操作是所有数加v，第3个操作是查询某一位置的数。首先分析，第1种操作和第3种操作时间复杂度都是O(1),第2中操作如果每位加v的话时间复杂度O(n)。所以优化在于第2操作。不过对于此操作我们可以降维优化，因为是所有数都加v，那么我们只需把v记录下来，每次查询时对查询的数直接加v就行了。这样就又遇到了一个问题，就是假如所有的数现在的状态是加v，而i位置元素现在变成了x，这样就会造成所有元素相加不一致。解决也很简单，只需每次变成x后，给x减去v就行了，这样查询时再加上v结果并没变。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">int m,n;</span><br><span class="line">int a[100010], cnt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    int t,x,y;</span><br><span class="line">    cnt=0;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        if(t==3)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            cout&lt;&lt;a[x]+cnt&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(t==2)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            cnt+=x;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(t==1)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            a[x]=y;</span><br><span class="line">            a[x]-=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title>[心路历程]心境决定处境，心界决定眼界</title>
    <url>/2018/05/31/2018-05-31/</url>
    <content><![CDATA[<p>有时候，人们会因为看到别人取得的成就而感到迷茫。假如你身处此境，你往往会失去思考，失去冷静，忘记自己所走过的道路，忽略即将要走的路，从而打乱了最初的计划，进而迷失方向，愈发迷惘。这种感觉就像走在路上的你忽然掉进了水里，快要淹死的感觉。也许彼岸就在不远处，你只需游几步就能上岸，但此刻的你并没有精力寻找彼岸的方向，因为你的心思全放在了如何不被突如其来的大水淹没，于是你拼命的寻找救命稻草，以阻止自己下沉。就这样，在慌乱的过程中，阻止了你上岸的步伐。</p>
<p>假如一开始你没有目标，那么此时这种状态并非坏事。因为当你在水里抓住救命稻草之后，会寻找彼岸的方向。如果你足够冷静，此刻你会总结你和他的差距在哪里，从而为自己确立目标，并参考他的经历为自己制定计划。如果你不够冷静，那此时你也许会照搬别人的做法，以别人的目标为自己的目标。这样也许会走很多弯路，做许多无用功，但至少比之前毫无目标浑浑噩噩要好得多，同时这段经历也会成为你如何成长道路上的一比财富。</p>
<p>倘若你一开始就有自己的目标，有属于自己的彼岸，而当你看到有人已经走到人生的彼岸时，你会怀疑自己走过的路，即使彼岸就在前方，你也会动摇，因为你还没有到达彼岸，没有见过彼岸的风景。假如此时的你停下脚步眺望对方的彼岸，那无疑是致命的。它就像突如其来的潮水，可能会拖延了你前行的道路，更有可能会动摇你前行路上的决心，甚至改变你前进的方向。</p>
<p>我有一个计算机系的舍友，他的目标是考研。自大一以来一直成绩优异，大二时便已轻松通过四六级，而且交际甚广，可谓前程平坦，身边阳光明媚。但此时，某人给他发了一个自己做的贺卡程序，看起来挺酷，此时他开始动摇了。因为自进校以来同学们一直都是面对黑窗口敲代码，敲出来的也是黑窗口，从来没有想过有人能够编出应用来。他说，当他收到那份礼物时，心中交错的并不是喜悦，而是迷惘。就好像春天的果树看着繁花满庭，而自己却总是开不出花，便开始抱怨自己的价值，而忘记了自己的果实要等到秋天才能品尝。于是当他看到别人已经拥有了强大的实力并且取得相应的成果，而自己还停留在课本中的C语言基础知识，不会应用，顿时思绪万千，怀疑自己走的道路，怀疑学校的课程安排。那种感觉，就像走着走着掉进水里一样。</p>
<p>此时，他拼命的寻找救命稻草。终于，他抓到了第一根救命稻草。他开始跟着别人做项目，一起写程序，别人打比赛，他便开始模拟比赛。在这段时间，他感到生活变得充实，做事也有动力，因为他也想拥有像那个人一样的实力，像那个人一样去打比赛。但正当他感觉找到目标时，选拔结果出来了，正式比赛的名额没有他，他落选了。此时的他顿时感觉自己又失去了方向。于是他又开始寻找救命稻草。他抓到的第二根救命稻草是校外的编程培训班。于是他果断交了大笔费用去报了培训班。在培训班里，他又燃起了希望，因为在这里，老师讲的一些东西都是课本上所没有的，老师还经常在课堂上带他们写一些小应用，这些都是他们以前不曾经历过的。由于这种模式以前没有接触过，所以便对学的东西燃起了兴趣，即使一切都是从头开始学习，即使许多东西以前都学过。就这样过了两个月，当他冷静下来，重新审视自己时，才发现自己真正要走的路的还是考研，而这段时间所学的技术只是就业路上的一个工具。而培训班中的许多东西其实学校的课程里都有，只是他从未重视过，没接触过的东西未来也会学习。就这样，他又开始了最初的考研复习之路。</p>
<p>那么，当我们在前行的路上看到别人已经到达人生的彼岸或者接近人生的彼岸时该怎么办呢。</p>
<p>其实，一个人的心境决定了这个人的处境。假如心中拥抱黑暗，那么眼之所见也会变得暗淡。即使前程平坦，阳光盎然，你也望不见人生的彼岸。假如心中充满光明，那么黑夜也会为你亮起星光。即使道路坎坷，前程黑暗，你也会收获自信坚定向前。</p>
<p>以我为例，记得之前比赛失利，没有获奖，而朋友却在其他项目中表现优异，此时的我就像《三体》中经历水滴之战惨败而侥幸逃跑的舰队队长一样，当看到章北海率领的舰队未雨绸缪时，眼前是一片黑暗，不由自主地感叹:”好黑，真tm的黑啊”。此刻的我早已迷失了方向，整日思绪想的是同样是付出，朋友们一个个却硕果累累，而我却像墙角的蘑菇怎么也沐浴不到阳光。为了这场比赛，准备了一个多月，那段时间翘了许多节课，一心研究算法，而最后连个证明自己这段时间的成果都没有。眼前面临的是各种各样的考试，以及英语四级考试，顿时怀疑自己之前的付出是否值得。其实在不久之后又有一次比赛，而此时的我却整日处于悲观之中，害怕下次比赛同样拿不到成绩，害怕考试失利，害怕英语四级。此刻的我，感到人人都各有所长，就只有自己一直处于失败当中，人人都比我成功。于是我把自己包裹起来，不喜欢与人交流，感觉每个人都很虚伪，从此变得越来越冷漠。就这样，我一边准备比赛，一边疯狂复习，一边孤独，一边迷惘。由于同时选择多种方向，最终也一事无成。马上就要比赛了，此刻的我偶然间望见教室的窗外阳光依旧明媚，回忆起之前努力奋斗的日子里也是同样的阳光，望着这从未消逝的阳光，我重新总结了一下这段时间的经历，终于明白，其实阳光很好，世界很好，所有人都很好，只是我的心态变得暗淡了。当我重新投入到阳光灿烂的日子里，此时发现，其实许多人都在羡慕我。尽管我没有拿到奖，但这段时间我的实力已经突飞猛进。虽然我没有收获奖杯，但我却收获了成长，坚定了方向。</p>
<p>所以，心界决定了眼界。当你凝视黑暗的时候，黑暗也在呼唤着你。倘若一个人心中见不到光，那么对他而言，整个世界都是黑暗的。当看到别人取得的成就时，只会是羡慕嫉妒恨，自怨自艾。也许有人会说，悲观，是一种远见。但当一个人始终以悲观的态度看待世界，那么所看到的整个世界只剩下冷漠，背叛，黑暗，而你收获的也只有孤独，失望，迷茫。</p>
<p>不妨敞开心扉，让阳光渗透到我们的心中。此时你会发现，当你看到别人的成就时，更多的是送去祝福，而不是怀疑自己。这样，就不会迷失方向，同时别人的经历中总结经验，化作自己前行的垫脚石。</p>
<p>阳光很好，我亦很好，整个世界更好。</p>
]]></content>
      <categories>
        <category>心路历程</category>
        <category>散文</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++结构体中的深copy和浅copy&amp;&amp;结构体偏移量的两种求法</title>
    <url>/2018/05/30/2018-05-30/</url>
    <content><![CDATA[<h2 id="浅copy："><a href="#浅copy：" class="headerlink" title="浅copy："></a>浅copy：</h2><p>编译器仅仅拷贝了结构体的值，而没有创建新的内存空间，而是共享同一块内存空间。当结构体成员中含有Buf的时候，拷贝之后释放内存就不会出现问题。但是如果结构体中含有指针变量的时候，编译器只会copy指针变量，而对应的内存空间却不会缺不再多分配。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECUFE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">typedef struct note &#123;</span><br><span class="line">	char a[64];</span><br><span class="line">	int b;</span><br><span class="line">	char*c;</span><br><span class="line">&#125;note;</span><br><span class="line">void my_copy(note*from, note*to) &#123;</span><br><span class="line">	*to = *from;</span><br><span class="line">	//memcpy(to,from,sizeof(note));//和上述操作等效</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	note d, e;</span><br><span class="line">	strcpy(d.a, &quot;123&quot;);</span><br><span class="line">	d.b = 456;</span><br><span class="line">	while ((d.c = (char*)malloc(64 * sizeof(char))) == NULL)</span><br><span class="line">		exit(1);</span><br><span class="line">	strcpy(d.c, &quot;789&quot;);</span><br><span class="line">	printf(&quot;d的值为：\n&quot;);</span><br><span class="line">	printf(&quot;%s\n%d\n%s\n&quot;, d.a, d.b, d.c);</span><br><span class="line">	my_copy(&amp;d, &amp;e);</span><br><span class="line">	printf(&quot;e的值为：\n&quot;);</span><br><span class="line">	printf(&quot;%s\n%d\n%s\n&quot;, e.a, e.b, e.c);</span><br><span class="line">	if (d.c != NULL) &#123;</span><br><span class="line">		free(d.c);</span><br><span class="line">		d.c = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	if (e.c != NULL) &#123;</span><br><span class="line">		free(e.c);</span><br><span class="line">		e.c = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以此样例为例，输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d的值为：</span><br><span class="line">123</span><br><span class="line">456</span><br><span class="line">789</span><br><span class="line">e的值为：</span><br><span class="line">123</span><br><span class="line">456</span><br><span class="line">789</span><br></pre></td></tr></table></figure>
<p>然后接着某些编译器如vs的编译器就会报错。出错位置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (e.c != NULL) &#123;</span><br><span class="line">		free(e.c);</span><br><span class="line">		e.c = NULL;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这是由于将结构体d内存元素直接赋给结构体e时，即进行 <em> e= </em> d操作时，由于结构体中含有指针元素，d结构体中的指针已经动态分配内存，而操作完成之后e中指针的值也会写上d动态分配内存的地址，因此d和e指向同一内存空间。这样当d中指针d.c释放内存之后，由于e.c仍然指向该部分内存，而不指向空，此时会强制释放掉e.c所指向内存，由于此处内存已经释放过了，处于不能被访问状态，而e.c又强制释放该内存，就会造成vs编译器报错。这就是前copy的弊端。</p>
<h2 id="深copy："><a href="#深copy：" class="headerlink" title="深copy："></a>深copy：</h2><p>编译器会为拷贝的对象分配一定的内存空间。</p>
<p>以上述代码为例，只需在进行 <em> e= </em> d操作之后再为e.c重新分配内存，然后执行strcpy(e,d)即可。这样e.c和d.c分别指向两块不同的内存，这样就不会出现上面那种错误。</p>
<p>代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define _CRT_SECUFE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">typedef struct note &#123;</span><br><span class="line">	char a[64];</span><br><span class="line">	int b;</span><br><span class="line">	char*c;</span><br><span class="line">&#125;note;</span><br><span class="line">void my_copy(note*from, note*to) &#123;</span><br><span class="line">	*to = *from;</span><br><span class="line">	//memcpy(to,from,sizeof(note));//和上述操作等效</span><br><span class="line">	while ((to-&gt;c = (char*)malloc(64 * sizeof(char))) == NULL)</span><br><span class="line">		exit(1);</span><br><span class="line">	strcpy(to-&gt;c, from-&gt;c);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	note d, e;</span><br><span class="line">	strcpy(d.a, &quot;123&quot;);</span><br><span class="line">	d.b = 456;</span><br><span class="line">	while ((d.c = (char*)malloc(64 * sizeof(char))) == NULL)</span><br><span class="line">		exit(1);</span><br><span class="line">	strcpy(d.c, &quot;789&quot;);</span><br><span class="line">	printf(&quot;d的值为：\n&quot;);</span><br><span class="line">	printf(&quot;%s\n%d\n%s\n&quot;, d.a, d.b, d.c);</span><br><span class="line">	my_copy(&amp;d, &amp;e);</span><br><span class="line">	printf(&quot;e的值为：\n&quot;);</span><br><span class="line">	printf(&quot;%s\n%d\n%s\n&quot;, e.a, e.b, e.c);</span><br><span class="line">	if (d.c != NULL) &#123;</span><br><span class="line">		free(d.c);</span><br><span class="line">		d.c = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	if (e.c != NULL) &#123;</span><br><span class="line">		free(e.c);</span><br><span class="line">		e.c = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="偏移量的求法"><a href="#偏移量的求法" class="headerlink" title="偏移量的求法"></a>偏移量的求法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct note&#123;</span><br><span class="line">    char name[64];</span><br><span class="line">    int age;</span><br><span class="line">    int sex;</span><br><span class="line">&#125;a,*p;</span><br><span class="line">p=&amp;a;</span><br></pre></td></tr></table></figure>
<p>以p为例求p-&gt;age偏移量</p>
<h3 id="直接法"><a href="#直接法" class="headerlink" title="直接法"></a>直接法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int offsize = (int)&amp;(p-&gt;age)-(int)p;</span><br></pre></td></tr></table></figure>
<h3 id="间接法"><a href="#间接法" class="headerlink" title="间接法"></a>间接法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int offsize = (int)&amp;(((*note)0)-&gt;age);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>关于模拟或暴力类型题的时间复杂度降维优化举例</title>
    <url>/2018/05/29/2018-05-29/</url>
    <content><![CDATA[<p>首先，一般的模拟类型的题如果按照题面做一般就入坑了。因为此类题如果按照题面一步一步模拟，那时间复杂度会相当大，如果此模拟题数据不是很水，一般都不会通过，所以时间复杂度至少要降维处理。而模拟题一般的做法是推导，把模拟的过程推成一个公式，而公式的时间复杂度为常数，即O(1),即实现由0(…)0(N)-&gt;0(…)0(1)的降维过程。但推导公式往往是一件很麻烦的事情，因此推导公式是模拟类题的关键。以下两道题原本是用模拟或暴力来解决，但其实它们都是可以优化的，例如第一题只需要求周期内的数与周期即可，不用遍历全部数，第2题只需对该数n进行分析即可，时间复杂度0(1)，不用从1遍历到n一个个进行统计。</p>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>百度熊对数学一直都非常感兴趣。最近在学习斐波那契数列的它，向你展示了一个数字串，它称之为“斐波那契”串：</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11235813471123581347112358…</span><br></pre></td></tr></table></figure>
<p>聪明的你当然一眼就看出了这个串是这么构造的：</p>
<ol>
<li><p>先写下两位在0~9范围内的数字a, b，构成串ab；</p>
</li>
<li><p>取串最后的两位数字相加，将和写在串的最后面。</p>
</li>
</ol>
<p>上面百度熊向你展示的串就是取a = b = 1构造出来的串。</p>
<p>显然，步骤1之后不停地进行步骤2，数字串可以无限扩展。现在，百度熊希望知道串的第n位是什么数字。</p>
<p>输入数据的第一行为一个整数T（1 ≤ T ≤1000）, 表示有T组测试数据；每组测试数据为三个正整数a, b, n（0 ≤ a, b &lt; 10, 0 &lt; n ≤109）。</p>
<p>对于每组测试数据，输出一行“Case #c: ans”（不包含引号） c是测试数据的组数，从1开始。</p>
<p>提示：</p>
<ol>
<li><p>对于第一、二组数据，串为112358134711235…</p>
</li>
<li><p>对于第三组数据，串为14591459145914…</p>
</li>
</ol>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 2</span><br><span class="line">1 1 8</span><br><span class="line">1 4 8</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case #1: 1</span><br><span class="line">Case #2: 3</span><br><span class="line">Case #3: 9</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 500;</span><br><span class="line">int t, c, d, n, cyc, cnt;</span><br><span class="line">int a[maxn], vis[maxn];</span><br><span class="line">int init()&#123;</span><br><span class="line">    memset(a,0,sizeof(a));</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    a[1] = c;</span><br><span class="line">    a[2] = d;</span><br><span class="line">    cnt = 2;</span><br><span class="line">    while(!vis[a[cnt-1]*10+a[cnt-0]])&#123;</span><br><span class="line">        vis[a[cnt-1]*10+a[cnt]] = cnt;</span><br><span class="line">        int tmp = a[cnt-1] + a[cnt];</span><br><span class="line">        if(tmp&lt;10)</span><br><span class="line">            a[++cnt]=tmp;</span><br><span class="line">        else&#123;</span><br><span class="line">            a[++cnt]=tmp/10;</span><br><span class="line">            a[++cnt]=tmp%10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return vis[a[cnt-1]*10+a[cnt]];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    for(int i = 1;i&lt;=t;i++)&#123;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; d &gt;&gt; n;</span><br><span class="line">        int res = init();</span><br><span class="line">        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i&lt;&lt;&quot;: &quot;;</span><br><span class="line">        if(cnt&gt;=n)</span><br><span class="line">            cout&lt;&lt;a[n]&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;a[res+(n-res)%(cnt-res)]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h2><p>试计算在区间 11 到 nn 的所有整数中，数字 xx（0 \leq x \leq 90≤x≤9）共出现了多少次？例如，在 11 到 1111 中，即在 11、22、33、44、55、66、77、88、99、1010、1111 中，数字 11 出现了 4 次。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入共 1 行，包含 2 个整数 nn、xx，之间用一个空格隔开。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共 1 行，包含一个整数，表示 xx 出现的次数。</p>
<h3 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于 100% 的数据，1 \leq n \leq 1,000,0001≤n≤1,000,000，0 \leq x \leq 90≤x≤9。</p>
<p>忽略每行输出的末尾多余空格</p>
<h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11 1</span><br></pre></td></tr></table></figure>
<h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, x;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    int cnt = 0, res = 1, re = 1;</span><br><span class="line">    int tmp = n;</span><br><span class="line">    if(x)&#123;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            int mod = tmp%10;</span><br><span class="line">            cnt+=(res-re)/10*mod;</span><br><span class="line">            if(mod&gt;x)</span><br><span class="line">                cnt+=re;</span><br><span class="line">            else if(mod==x)</span><br><span class="line">                cnt+=n%re+1;</span><br><span class="line">            re*=10;</span><br><span class="line">            res*=10;</span><br><span class="line">            res+=re;</span><br><span class="line">            tmp/=10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        for(int i = 1;i&lt;=n;i++)</span><br><span class="line">            for(int j=i;j;j/=10)</span><br><span class="line">                if(j%10==x)cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模拟</tag>
        <tag>ACM/ICPC</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>[C结构体]结构体的内存对齐</title>
    <url>/2018/05/28/2018-05-28/</url>
    <content><![CDATA[<h2 id="结构体内存对齐规则："><a href="#结构体内存对齐规则：" class="headerlink" title="结构体内存对齐规则："></a>结构体内存对齐规则：</h2><p>第一个成员在与结构体变量偏移量为0的地址处。<br>其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。</p>
<p>对齐数 = min（编译器默认的一个对齐数 ，该成员大小）<br>VS 中默认的值为 8<br>Linux 中默认的值为 4</p>
<p>结构体总大小为最大对齐数（每个成员变量除了第一个成员，都有一个对齐数）的整数倍。</p>
<p>如果嵌套了结构体的情况，嵌套的结构体对齐到自己最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。<br>结构体的对齐数为结构体当中所有对齐数中的最大对齐数。</p>
<h2 id="为什么存在内存对齐？"><a href="#为什么存在内存对齐？" class="headerlink" title="为什么存在内存对齐？"></a>为什么存在内存对齐？</h2><p>平台原因（移植原因）：<br>不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。<br>性能原因：<br>数据结构（尤其是栈）应该尽可能地在自然边界上对齐。<br>原因在于，为了访问未对齐的内存，处理器需要做两次内存访问；而对齐的内存访问仅需一次访问。</p>
<p>总的来讲：结构体的内存对齐是拿空间来换取时间的做法。</p>
<h2 id="手动设置对齐模数"><a href="#手动设置对齐模数" class="headerlink" title="手动设置对齐模数"></a>手动设置对齐模数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//显示当前packing alignment的字节数，以warning message的形式显示</span><br><span class="line">#pragma pack(show)</span><br><span class="line">//将当前指定的packing alignment数组进行压栈操作，这里的栈是the internal compiler stack，同时设置当前的packing alignment为n，如果n没有指定，则将当前的packing alignment数组压栈。</span><br><span class="line">#pragma pack(push)</span><br><span class="line">//从internal compiler stack中删除最顶端的reaord；如果没有指定n，则当前栈顶record即为新的packing alignment数值；如果指定了n，则n成为新的packing alignment值。</span><br><span class="line">#pragma pack(pop)</span><br><span class="line">//制定packing的数值，以字节为单位，缺省数值是8，合法的数值分别是1，2，4，8，16</span><br><span class="line">#pragma pack(n)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>[C指针进阶]二级指针做输入的3种内存模型</title>
    <url>/2018/05/26/2018-05-26/</url>
    <content><![CDATA[<p>对于指针，我们只需要从两个角度进行分析即可。</p>
<p>第一角度，站在C/C++编译器的角度看待指针，对形参，如指针类型，c编译器只会把他当做一个指针变量来看。（分配四个字节的内存） </p>
<p>第二角度，我们只有在是用指针所指向的内存空间的时候我们才去关心内存是一维的还是二维的。 </p>
<p>今天分析的二维指针三种内存模型都是指针做输入的情况，在主调函数中分配内存。 </p>
<p>在分析指针之前，先回顾一下内存四区的知识。首先我们知道内存分为5大区，我们暂把BSS段与数据段合称为全局区或者常量区，构成内存四区。以下是内存5大区具体概况。</p>
<h2 id="内存5大区"><a href="#内存5大区" class="headerlink" title="内存5大区"></a>内存5大区</h2><ul>
<li><p><strong>BSS段( bss segment )</strong></p>
<p>通常是指用来存放程序中<code>未初始化的全局变量和静态变量</code> （这里注意一个问题:一般的书上都会说全局变量和静态变量是会自动初始化的,那么哪来的未初始化的变量呢?变量的初始化可以分为显示初始化和隐式初始化,全局变量和静态变量如果程序员自己不初始化的话的确也会被初始化,那就是不管什么类型都初始化为0,这种没有显示初始化的就 是我们这里所说的未初始化。既然都是0那么就<code>没必要把每个0都存储起来</code>,从而节省磁盘空间,这是BSS的主要作用）的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。 BSS节不包含任何数据,只是简单的维护开始和结束的地址,即总大小。以便内存区能在运行时分配并被有效地清零。BSS节在应用程序的二进制映象文件中并不存在,即不占用 磁盘空间 而只在运行的时候占用内存空间 ,所以如果全局变量和静态变量未初始化那么其可执行文件要小很多。</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong>数据段(data segment)</strong></p>
<p>通常是指用来存放程序中已经<code>初始化的全局变量和静态变量</code>的一块内存区域。数据段属于静态内存分配,可以分为只读数据段和读写数据段。字符串常量等,但一般都是放在只读数据段中。</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong>代码段(code segment/text segment)</strong></p>
<p>通常是指用来存放<code>程序执行代码的一块内存区域</code>。这部分区域的大小在程序运行前就已经确定,并且内存区域通常属于只读, 某些架构也允许代码段为可写,即允许修改程序。在代码段中,也有可能包含一些只读的常数变量,例如字符串常量等,但一般都是放在只读数据段中 。</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong>堆(heap)</strong></p>
<p>堆是用于存放进程运行中被<code>动态分配的内存段</code>,它的大小并不固定,可动态扩张或 缩减。当进程调用malloc等函数分配内存时,新分配的内存就被动态添加到堆上(堆被扩张); 当利用free等函数释放内存时,被释放的内存从堆中被剔除(堆被缩减)</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong>栈 (stack)</strong></p>
<p>栈又称堆栈, 是<code>用户存放程序临时创建的局部变量</code>,也就是说我们函数括弧“{}” 中定义的变量(但不包括static声明的变量,static意味着在数据段中存放变 量)。除此以外, 在函数被调用时,其参数也会被压入发起调用的进程栈中,并且待到调用结束后,函数的返回值 也会被存放回栈中。由于栈的先进先出特点,所以 栈特别方便用来保存/恢复调用现场。从这个意义上讲,我们可以把堆栈看成一个寄存、交换临时数据的内存区。 </p>
</li>
</ul>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-25-%E5%86%85%E5%AD%985%E5%8C%BA.png" alt="内存分区图"></p>
<h2 id="二阶指针做输入的3种内存模型"><a href="#二阶指针做输入的3种内存模型" class="headerlink" title="二阶指针做输入的3种内存模型"></a>二阶指针做输入的3种内存模型</h2><p>接下来我们来讨论二阶指针做输入的3种内存模型。</p>
<h3 id="第1种"><a href="#第1种" class="headerlink" title="第1种"></a>第1种</h3><p>首先第一种就是指针数组，以字符型指针数组为例定义方式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char*p1[10];</span><br></pre></td></tr></table></figure>
<p>指针数组的实质是表示存放指针的数组。 </p>
<h3 id="第2种"><a href="#第2种" class="headerlink" title="第2种"></a>第2种</h3><p>第二种为二维数组，以字符型二维数组为例定义方式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char p2[3][4];</span><br></pre></td></tr></table></figure>
<h3 id="第3种"><a href="#第3种" class="headerlink" title="第3种"></a>第3种</h3><p>第三种为二维指针，以字符型二维指针为例定义方式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char **p3;</span><br></pre></td></tr></table></figure>
<p>二维指针是一个存放指针的指针，因此使用前需先开辟一段空间。 </p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="指针数组与二维指针的区别："><a href="#指针数组与二维指针的区别：" class="headerlink" title="指针数组与二维指针的区别："></a>指针数组与二维指针的区别：</h4><p>由于二维指针储存的是指针，因此二维指针首先需要开辟空间，然后再在子元素上继续开辟空间，因此需要两步完成。</p>
<p>而指针数组由于本质上是数组，因此省略了第1步，只需在子元素上继续开辟空间。因此只需要1步完成。</p>
<p>以动态分配内存为例：</p>
<p>第1步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ptr =malloc(3 *sizeof(char *));//等价于 *ptr [3];</span><br></pre></td></tr></table></figure>
<p>第2步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ptr =malloc(3 *sizeof (char *));等价于 *ptr [3];</span><br><span class="line">for(i =0;i&lt;3;i++)</span><br><span class="line">    ptr[i] =malloc(sizeof(char)*10);//表示可以存放长度为10 的字符串。</span><br></pre></td></tr></table></figure>
<p>指针数组只需第2步，二维指针则需要1,2步。</p>
<p>而除此之外，基本再没有什么区别。他们的步长都是4，即一个指针的内存大小。</p>
<h4 id="指针数组与数组指针的区别："><a href="#指针数组与数组指针的区别：" class="headerlink" title="指针数组与数组指针的区别："></a>指针数组与数组指针的区别：</h4><p>首先，我们知道，二维数组ptr[2].[2]，ptr的实质是一个数组指针。我们知道，对于一维指针数组a[2]，a本质是指针，只不过a是一个常量指针，即a的值不能被修改。那么对于二维数组ptr[2].[2],ptr是一个常量数组指针，即ptr的值不可修改。</p>
<p>那么，他们本质的区别是什么呢。首先，对于char <em>p[3]，他的步长是4。即一个指针的内存大小。 </em> (p+1)=p[1],(int)(p+1)-(int)p=4。对于char( <em>p )[3],他的步长是3，即一个数组内存大小。 </em>(p+1) = p[1].[3],(int)(p+1)-(int)p=3。所以这就是为什么指针数组和数组指针不能相互赋值的原因。</p>
<h2 id="内存模型示意图"><a href="#内存模型示意图" class="headerlink" title="内存模型示意图"></a>内存模型示意图</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-26-%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下是针对二维指针的3种内存模型进行排序的实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">/*排序并输出第1种内存模型:指针数组*/</span><br><span class="line">void sort_myArray1(char **myArray, int len) &#123;</span><br><span class="line">	printf(&quot;排序前：\n&quot;);</span><br><span class="line">	for (int i = 0; i &lt; len; i++)</span><br><span class="line">		printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">	printf(&quot;******************\n&quot;);</span><br><span class="line">	for (int i = 0; i &lt; len; i++)	/*改变指针的指向*/</span><br><span class="line">		for (int j = len - 1; j &gt; i; j--) &#123;</span><br><span class="line">			if (strcmp(myArray[j], myArray[j - 1])&gt;0) &#123;</span><br><span class="line">				char *tmp = myArray[j];</span><br><span class="line">				myArray[j] = myArray[j - 1];</span><br><span class="line">				myArray[j - 1] = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	printf(&quot;排序后：\n&quot;);</span><br><span class="line">	for (int i = 0; i &lt; len; i++)</span><br><span class="line">		printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/*排序并输出第2种内存模型：二维数组（数组指针）*/</span><br><span class="line">void sort_myArray2(char(*myArray)[4], int len) &#123;</span><br><span class="line">	printf(&quot;排序前：\n&quot;);</span><br><span class="line">	for (int i = 0; i &lt; len; i++)</span><br><span class="line">		printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">	printf(&quot;******************\n&quot;);</span><br><span class="line">	for (int i = 0; i &lt; len; i++)	/*改变指针所指向内存的值*/</span><br><span class="line">		for (int j = len - 1; j &gt; i; j--) &#123;</span><br><span class="line">			if (strcmp(myArray[j], myArray[j - 1])&gt;0) &#123;</span><br><span class="line">				char tmp[4];</span><br><span class="line">				strcpy(tmp, myArray[j]);</span><br><span class="line">				strcpy(myArray[j], myArray[j - 1]);</span><br><span class="line">				strcpy(myArray[j - 1], tmp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	printf(&quot;排序后：\n&quot;);</span><br><span class="line">	for (int i = 0; i &lt; len; i++)</span><br><span class="line">		printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/*排序并输出第3种内存模型：二维指针*/</span><br><span class="line">void sort_myArray3(char **myArray, int len) &#123;</span><br><span class="line">	printf(&quot;排序前：\n&quot;);</span><br><span class="line">	for (int i = 0; i &lt; len; i++)</span><br><span class="line">		printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">	printf(&quot;******************\n&quot;);</span><br><span class="line">	for (int i = 0; i &lt; len; i++)	/*改变指针所指向内存的值，也可以改写成改变指针的指向*/</span><br><span class="line">		for (int j = len - 1; j &gt; i; j--) &#123;</span><br><span class="line">			if (strcmp(myArray[j], myArray[j - 1])&gt;0) &#123;</span><br><span class="line">				char tmp[4];</span><br><span class="line">				strcpy(tmp, myArray[j]);</span><br><span class="line">				strcpy(myArray[j], myArray[j - 1]);</span><br><span class="line">				strcpy(myArray[j - 1], tmp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	printf(&quot;排序后：\n&quot;);</span><br><span class="line">	for (int i = 0; i &lt; len; i++)</span><br><span class="line">		printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/*为二级指针分配动态内存并赋值*/</span><br><span class="line">char**get_myArray3(int len) &#123;</span><br><span class="line">	char**myArray = NULL;</span><br><span class="line">	while ((myArray = (char**)malloc(3 * sizeof(char*))) == NULL) &#123;</span><br><span class="line">		printf(&quot;Error.\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">		while ((myArray[i] = (char*)calloc(100, sizeof(char))) == NULL) &#123;</span><br><span class="line">			printf(&quot;Error.\n&quot;);</span><br><span class="line">			exit(1);</span><br><span class="line">		&#125;</span><br><span class="line">		sprintf(myArray[i], &quot;%d%d%d&quot;, i + 1, i + 2, i + 3);</span><br><span class="line">	&#125;</span><br><span class="line">	return myArray;</span><br><span class="line">&#125;</span><br><span class="line">/*将动态分配的内存空间释放掉*/</span><br><span class="line">void init_myArray3(char**myArray, int len) &#123;</span><br><span class="line">	for (int i = 0; i &lt; len; i++)</span><br><span class="line">		if (myArray[i] != NULL) &#123;</span><br><span class="line">			free(myArray[i]);</span><br><span class="line">			myArray[i] = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	char*p1[] = &#123; &quot;123&quot;,&quot;456&quot;,&quot;789&quot; &#125;;		/*第1种内存模型：指针数组*/</span><br><span class="line">	char p2[3][4] = &#123; &quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot; &#125;;	/*第2种内存模型：多维数组*/</span><br><span class="line">	char**p3 = get_myArray3(3);				/*第3种内存模型：二维指针*/</span><br><span class="line">	sort_myArray1(p1, sizeof(p1) / sizeof(p1[0]));	/*数组的指针个数*/</span><br><span class="line">	sort_myArray2(p2, sizeof(p2) / sizeof(p2[0]));	/*数组的行数*/</span><br><span class="line">	sort_myArray3(p3, 3);	/*由于sizeof(p3)为4，即一个指针的大小，故不能用sizeof(p3) / sizeof(p2[3])*/</span><br><span class="line">	init_myArray3(p3, 3);</span><br><span class="line">	if (p3 != NULL)</span><br><span class="line">		free(p3);	/*释放掉二维指针分配的内存*/</span><br><span class="line">	p3 = NULL;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>[C常量]C语言中的伪装大佬——伪常量const</title>
    <url>/2018/05/25/2018-05-25-1/</url>
    <content><![CDATA[<p>为什么要介绍C语言的const呢？首先声明它和C++中的const不一样。许多人经常.CPP和.C混用，导致C++与C的const分不清，有时候莫名其妙的错误，包括我。当然，这只是原因之一。最主要的原因是C语言的const实在是太虚伪了。所以今天把C语言中这个狡猾的const列出来，以免之后犯错。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>首先以int为例定义整形常量a的两种方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int a;</span><br><span class="line">int const a;</span><br></pre></td></tr></table></figure>
<p>当然，这两种方法其实是一样的，都代表的是整形常量。对于其他类型也是同样的方法。</p>
<p>不过对于指针，就有点特别了。首先强调，const和 <em> 的优先级是 </em> 优先级高于const。以下是以字符串为例的</p>
<p>3种定义方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const char *p;	//char const *p;</span><br><span class="line">char * const p;</span><br><span class="line">const char * const p;	//char const * const p;</span><br></pre></td></tr></table></figure>
<p>第一种指的是p是指向常量字符型数的指针，所指向的内存数据不可以被修改，但是本身可修改。</p>
<p>第2种指的是p是指向字符型数的常指针，所指向的内存数据可以被修改，但是本身不可被修改。</p>
<p>第3种是指向常量字符型数的常指针，所指向的内存数据补可被修改，本身也不可被修改。</p>
<h2 id="伪常量"><a href="#伪常量" class="headerlink" title="伪常量"></a>伪常量</h2><p>用法介绍完了，但为什么说C的const是伪常量呢？因为常量是不可被更改的，但const可以通过简介赋值所改变。我们首先说一下C中的const使用时需要注意的一些细节。</p>
<p>const是伪常量，无法用于数组的初始化和全局变量的初始化,本质就是限定一个变量不能直接赋值。</p>
<p>　　如以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 #define A 10</span><br><span class="line">2 int arr[A];</span><br><span class="line">3 </span><br><span class="line">4 //const本质，伪常量 ,无法用于数组初始化和全局变量初始化</span><br><span class="line">5 /*</span><br><span class="line">6 const int B = 10;</span><br><span class="line">7 int arr[B];</span><br><span class="line">8 */</span><br></pre></td></tr></table></figure>
<p>　　但是如果局部变量是能够初始化编译并运行的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 void main()</span><br><span class="line">2 &#123;</span><br><span class="line">3     const int B = 10;</span><br><span class="line">4     int arr[B];</span><br><span class="line">5 &#125;</span><br></pre></td></tr></table></figure>
<p>　　const是伪常量，都知道常量是不能改变值的。例如这样是根本无法编译的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 void main() &#123;</span><br><span class="line">2     //num在栈区，只有栈区会自动回收释放</span><br><span class="line">3     //局部const常量在栈区，而不在静态区(静态区会一直存在)</span><br><span class="line">4     const int num = 10;//num就是一个常量</span><br><span class="line">5     //num = 11; //const本质，限定一个变量不能直接赋值</span><br><span class="line">6 &#125;</span><br></pre></td></tr></table></figure>
<p>　　前面一直强调const是伪常量，因为可以间接的去改变它的值。利用指针变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 void main() &#123;</span><br><span class="line"> 2     //num在栈区，只有栈区会自动回收释放</span><br><span class="line"> 3     //局部const常量在栈区，而不在静态区(静态区会一直存在)</span><br><span class="line"> 4     const int num = 10;//num就是一个常量</span><br><span class="line"> 5     //num = 11; //error const本质，限定一个变量不能直接赋值</span><br><span class="line"> 6 </span><br><span class="line"> 7     //间接改变常量值</span><br><span class="line"> 8     const int *p = &amp;num;//定义一个指针指向一个常量，存储num的地址</span><br><span class="line"> 9     int *pv = (int *)p;//对指向常量的指针进行强制转换</span><br><span class="line">10     *pv = 8;//对指针指向内容赋值</span><br><span class="line">11 </span><br><span class="line">12     printf(&quot;%d&quot;,num); //8</span><br><span class="line">13 </span><br><span class="line">14 &#125;</span><br></pre></td></tr></table></figure>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>c语言的const是冒牌货。C语言const的含义是被称为一个不能被改变的普通变量 ，它会分配内存。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>指针</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>[组合数学]取石子</title>
    <url>/2018/05/25/2018-05-25/</url>
    <content><![CDATA[<p>为什么要写关于这道题的博客呢？首先本题本人用python成功ac，要知道很少有人用Python做算法题。而且本人已经好几个月没用Python了，所以记录一下。此外，本题用到了排列组合打表，整理好代码，以后要用模板就不用再找了。</p>
<h2 id="取石子"><a href="#取石子" class="headerlink" title="取石子"></a><a href="https://www.nowcoder.com/acm/contest/113/A" target="_blank" rel="noopener">取石子</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出四堆石子，石子数分别为a,b,c,d。规定每次只能从堆顶取走石子，问取走所有石子的方案数。</p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在一行内读入四个由空格分隔的整数a,b,c,d， 输入均为不超过500的正整数</span><br></pre></td></tr></table></figure>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出一个整数表示答案，答案对109+7取模</span><br></pre></td></tr></table></figure>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 5 4 2</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2522520</span><br></pre></td></tr></table></figure>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><p>输入均为不超过500的正整数</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>我们一堆一堆的考虑。第一堆a，第2堆b，第3堆c，第4堆d。假如只有一堆，则只有1种情况，即C(a,a)。假如有两堆，我们可以当做这两堆石子的排列组合。可以算出两堆石子的方案数。即C(b,a+b)。第三堆我们可以把前两堆看成一堆，然后继续排列组合，即C(c,a+b+c)。第4队即C(d,a+b+c+d)。最后全部相乘即可，即C(a,a) <em> C(b,a+b) </em> C(c,a+b+c)*C(d,a+b+c+d)。</p>
<h4 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h4><p>首先想到暴力枚举，虽然一定超时。以下是代码。只需要把所有情况列一遍即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">ll a[4];</span><br><span class="line">ll cnt = 0;</span><br><span class="line">void dfs(ll a, ll b, ll c, ll d) &#123;</span><br><span class="line">	if (!a&amp;&amp;!b&amp;&amp;!c&amp;&amp;!d) &#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		cnt %= 1000000000 + 7;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	if (a)</span><br><span class="line">		dfs(a - 1, b, c, d);</span><br><span class="line">	if (b)</span><br><span class="line">		dfs(a, b - 1, c, d);</span><br><span class="line">	if (c)</span><br><span class="line">		dfs(a, b, c - 1, d);</span><br><span class="line">	if (d)</span><br><span class="line">		dfs(a, b, c, d - 1);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	for (int i = 0; i &lt; 4; i++)</span><br><span class="line">		scanf(&quot;%lld&quot;, &amp;a[i]);</span><br><span class="line">	dfs(a[0], a[1], a[2], a[3]);</span><br><span class="line">	printf(&quot;%lld\n&quot;, cnt);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><p>由于数据过大，c++没有大数类，所以用python首先A了一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f = input().split()</span><br><span class="line">ans = 1</span><br><span class="line">sum = [int(f[0]),0,0,0]</span><br><span class="line">for i in range(1,4):</span><br><span class="line">    sum[i]=sum[i-1]+int(f[i])</span><br><span class="line">    for j in range(sum[i]-int(f[i])+1,sum[i]+1):</span><br><span class="line">        ans*=j</span><br><span class="line">for i in range(1,4):</span><br><span class="line">    for j in range(1,int(f[i])+1):</span><br><span class="line">        ans//=j</span><br><span class="line">ans%=1000000007</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure>
<h4 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h4><p>由于acm不能用python，所以只能再考虑c++。首先由于涉及到除法，所以不能直接取余。</p>
<p>我没知道公式：C(M,N)=C(M-1,N)+C(M-1，N-1)，这样把除法转化成加法，就可以模运算了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 501;</span><br><span class="line">const ll mod = 1000000007;</span><br><span class="line">ll a[4], sum[4] = &#123; 0 &#125;;</span><br><span class="line">ll dp[maxn * 4][maxn * 4];</span><br><span class="line">void init() &#123;</span><br><span class="line">	dp[0][0] = 0;</span><br><span class="line">	for (int i = 1; i &lt; 4 * maxn; i++) &#123;</span><br><span class="line">		dp[i][0] = 1;</span><br><span class="line">		for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">			dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];</span><br><span class="line">			dp[i][j] %= mod;</span><br><span class="line">		&#125;</span><br><span class="line">		dp[i][i] = 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	init();</span><br><span class="line">	ll ans = 1;</span><br><span class="line">	for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">		!i ? sum[i] = 0 : sum[i] = sum[i - 1];</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		sum[i] += a[i];</span><br><span class="line">		if (a[i] &gt; sum[i] - a[i]) a[i] = sum[i] - a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 1; i &lt; 4; i++) &#123;</span><br><span class="line">		ans *= dp[sum[i]][a[i]];</span><br><span class="line">		ans %= mod;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="C-M-N-模板"><a href="#C-M-N-模板" class="headerlink" title="C(M,N)模板"></a>C(M,N)模板</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">	dp[0][0] = 0;</span><br><span class="line">	for (int i = 1; i &lt; 4 * maxn; i++) &#123;</span><br><span class="line">		dp[i][0] = 1;</span><br><span class="line">		for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">			dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];</span><br><span class="line">			dp[i][j] %= mod;</span><br><span class="line">		&#125;</span><br><span class="line">		dp[i][i] = 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>Python</tag>
        <tag>组合数学</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据库]关系数据库标准语言sql</title>
    <url>/2018/05/22/2018-05-22/</url>
    <content><![CDATA[<p>有些人生而成功，像你。有些人生而失败，像我。——随笔</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SQL（Structured Query Language）</p>
<p>结构化查询语言，是关系数据库的标准语言。</p>
<p>SQL是一个通用的、功能极强的关系数据库语言。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="综合统一"><a href="#综合统一" class="headerlink" title="综合统一"></a>综合统一</h4><p>集数据查询，数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体。</p>
<p>可以独立完成数据库生命周期中的全部活动：</p>
<ul>
<li>定义关系模式，插入数据，建立数据库； </li>
<li>对数据库中的数据进行查询和更新； </li>
<li>数据库重构和维护 </li>
<li>数据库安全性、完整性控制等</li>
</ul>
<p>用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据的运行。</p>
<p>数据操作符统一</p>
<h4 id="高度非过程化"><a href="#高度非过程化" class="headerlink" title="高度非过程化"></a>高度非过程化</h4><p>非关系数据模型的数据操纵语言“面向过程”，必须制定存取路径。</p>
<p>SQL只要提出“做什么”，无须了解存取路径。</p>
<p>存取路径的选择以及SQL的操作过程由系统自动完成。</p>
<h4 id="面向集合的操作方式"><a href="#面向集合的操作方式" class="headerlink" title="面向集合的操作方式"></a>面向集合的操作方式</h4><p>非关系数据模型采用面向记录的操作方式，操作对象是一条记录。</p>
<p>SQL采用集合操作方式 </p>
<ul>
<li><p>操作对象、查找结果可以是元组的集合 </p>
</li>
<li><p>一次插入、删除、更新操作的对象可以是元组的集合</p>
</li>
</ul>
<h4 id="以同一种语法结构提供多种使用方式"><a href="#以同一种语法结构提供多种使用方式" class="headerlink" title="以同一种语法结构提供多种使用方式"></a>以同一种语法结构提供多种使用方式</h4><p>SQL是独立的语言，能够独立地用于联机交互的使用方式。</p>
<p>SQL又是嵌入式语言，SQL能够嵌入到高级语言（例如C，C++，Java）程序中，供程序员设计程序时使用。</p>
<h4 id="语言简洁，易学易用"><a href="#语言简洁，易学易用" class="headerlink" title="语言简洁，易学易用"></a>语言简洁，易学易用</h4><p>SQL功能极强，完成核心功能只用了9个动词。</p>
<table>
<thead>
<tr>
<th>SQL功能</th>
<th>动词</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据查询</td>
<td>SELECT</td>
</tr>
<tr>
<td>数据定义</td>
<td>CREATE, DROP, ALTER</td>
</tr>
<tr>
<td>数据操纵</td>
<td>INSERT, UPDATE, DELETE</td>
</tr>
<tr>
<td>数据控制</td>
<td>GRANT, REVOKE</td>
</tr>
</tbody>
</table>
<h3 id="SQL基本概念"><a href="#SQL基本概念" class="headerlink" title="SQL基本概念"></a>SQL基本概念</h3><p>SQL支持关系数据库三级模式结构</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-22-sql%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F.png" alt></p>
<h4 id="基本表"><a href="#基本表" class="headerlink" title="基本表"></a>基本表</h4><p>本身独立存在的表</p>
<p>SQL中一个关系就对应一个基本表</p>
<p>一个(或多个)基本表对应一个存储文件</p>
<p>一个表可以带若干索引</p>
<h4 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h4><p>逻辑结构组成了关系数据库的内模式</p>
<p>物理结构是任意的，对用户透明</p>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>从一个或几个基本表</p>
<p>导出的表数据库中只存放视图的定义而不存放视图对应的数据</p>
<p>视图是一个虚表</p>
<p>用户可以在视图上再定义视图</p>
<h2 id="学生-课程数据库"><a href="#学生-课程数据库" class="headerlink" title="学生-课程数据库"></a>学生-课程数据库</h2><h3 id="学生-课程模式-S-T"><a href="#学生-课程模式-S-T" class="headerlink" title="学生-课程模式 S-T :"></a>学生-课程模式 S-T :</h3><p>学生表：Student(Sno,Sname,Ssex,Sage,Sdept)    </p>
<p>课程表：Course(Cno,Cname,Cpno,Ccredit)    </p>
<p>学生选课表：SC(Sno,Cno,Grade)</p>
<h3 id="Student表"><a href="#Student表" class="headerlink" title="Student表"></a>Student表</h3><table>
<thead>
<tr>
<th style="text-align:center">学  号 Sno</th>
<th style="text-align:center">姓  名 Sname</th>
<th style="text-align:center">性  别  Ssex</th>
<th style="text-align:center">年  龄  Sage</th>
<th style="text-align:center">所 在 系  Sdept</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">200215121</td>
<td style="text-align:center">李勇</td>
<td style="text-align:center">男</td>
<td style="text-align:center">20</td>
<td style="text-align:center">CS</td>
</tr>
<tr>
<td style="text-align:center">200215122</td>
<td style="text-align:center">刘晨</td>
<td style="text-align:center">女</td>
<td style="text-align:center">19</td>
<td style="text-align:center">CS</td>
</tr>
<tr>
<td style="text-align:center">200215123</td>
<td style="text-align:center">王敏</td>
<td style="text-align:center">女</td>
<td style="text-align:center">18</td>
<td style="text-align:center">MA</td>
</tr>
<tr>
<td style="text-align:center">200515125</td>
<td style="text-align:center">张立</td>
<td style="text-align:center">男</td>
<td style="text-align:center">19</td>
<td style="text-align:center">IS</td>
</tr>
</tbody>
</table>
<h3 id="Course表"><a href="#Course表" class="headerlink" title="Course表"></a>Course表</h3><table>
<thead>
<tr>
<th style="text-align:center">课程号 Cno</th>
<th style="text-align:center">课程名 Cname</th>
<th style="text-align:center">先行课 Cpno</th>
<th style="text-align:center">学分 Ccredit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">数据库</td>
<td style="text-align:center">5</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">数学</td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">信息系统</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">操作系统</td>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">数据结构</td>
<td style="text-align:center">7</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">数据处理</td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">PASCAL语言</td>
<td style="text-align:center">6</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<h3 id="SC表"><a href="#SC表" class="headerlink" title="SC表"></a>SC表</h3><table>
<thead>
<tr>
<th style="text-align:center">学 号 Sno</th>
<th style="text-align:center">课程号   Cno</th>
<th style="text-align:center">成绩     Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">200215121</td>
<td style="text-align:center">1</td>
<td style="text-align:center">92</td>
</tr>
<tr>
<td style="text-align:center">200215121</td>
<td style="text-align:center">2</td>
<td style="text-align:center">85</td>
</tr>
<tr>
<td style="text-align:center">200215121</td>
<td style="text-align:center">3</td>
<td style="text-align:center">88</td>
</tr>
<tr>
<td style="text-align:center">200215122</td>
<td style="text-align:center">2</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">200215122</td>
<td style="text-align:center">3</td>
<td style="text-align:center">80</td>
</tr>
</tbody>
</table>
<h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><p>SQL的数据定义功能: 模式定义、表定义、视图和索引的定义</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-22-sql%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89.png" alt></p>
<h3 id="模式的定义与删除"><a href="#模式的定义与删除" class="headerlink" title="模式的定义与删除"></a>模式的定义与删除</h3><p>[例1]定义一个学生-课程模式S-T</p>
<p><strong>CREATE SCHEMA “S-T” AUTHORIZATION WANG;</strong></p>
<p>为用户WANG定义了一个模式S-T</p>
<p>[例2]<strong>CREATE SCHEMA AUTHORIZATION WANG；</strong></p>
<p>&lt;模式名&gt;隐含为用户名WANG</p>
<p>如果没有指定&lt;模式名&gt;，那么&lt;模式名&gt;隐含为&lt;用户名&gt;</p>
<h4 id="定义模式"><a href="#定义模式" class="headerlink" title="定义模式"></a>定义模式</h4><p>定义模式实际上定义了一个<strong>命名空间</strong></p>
<p>在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。</p>
<p>在<strong>CREATE SCHEMA</strong>中可以接受<strong>CREATE TABLE</strong>，<strong>CREATE VIEW</strong>和<strong>GRANT</strong>子句。</p>
<p><strong>CREATE SCHEMA [&lt;模式名&gt;] AUTHORIZATION &lt;用户名&gt;[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]</strong></p>
<p>[例3]</p>
<p><strong>CREATE SCHEMA TEST AUTHORIZATION ZHANG</strong></p>
<p>​     <strong>CREATE TABLE TAB1(COL1 SMALLINT，</strong></p>
<p>​                                             <strong>COL2 INT，</strong></p>
<p>​                                            <strong>COL3 CHAR(20)，</strong></p>
<p>​                                            <strong>COL4 NUMERIC(10，3)，</strong></p>
<p>​                                            <strong>COL5 DECIMAL(5，2)</strong></p>
<p>​                                          <strong>)；</strong></p>
<p>​    为用户ZHANG创建了一个模式TEST，并在其中定义了一个表TAB1。</p>
<h4 id="删除模式"><a href="#删除模式" class="headerlink" title="删除模式"></a>删除模式</h4><p><strong>DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;</strong></p>
<p>CASCADE(级联)    </p>
<p>删除模式的同时把该模式中所有的数据库对象全部删除RESTRICT(限制)   </p>
<p>如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。</p>
<p>当该模式中没有任何下属的对象时才能执行。</p>
<p>[例4]  <strong>DROP SCHEMA TEST CASCADE；</strong></p>
<p>​         删除模式ZHANG</p>
<p>​         同时该模式中定义的表TAB1也被删除</p>
<h3 id="基本表的定义、删除与修改"><a href="#基本表的定义、删除与修改" class="headerlink" title="基本表的定义、删除与修改"></a>基本表的定义、删除与修改</h3><h4 id="定义基本表"><a href="#定义基本表" class="headerlink" title="定义基本表"></a>定义基本表</h4><p><strong>CREATE TABLE &lt;表名&gt;</strong></p>
<p>​      <strong>（&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ]</strong></p>
<p>​    <strong>[，&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] …</strong></p>
<p>​    <strong>[，&lt;表级完整性约束条件&gt; ] ）；</strong></p>
<p>如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级。</p>
<p>[例5]  建立“学生”表Student，学号是主码，姓名取值唯一。</p>
<p>CREATE TABLE Student</p>
<p>​                    (Sno   CHAR(9) <strong>PRIMARY KEY</strong>， /<em> 列级完整性约束条件 </em>/</p>
<p>​            Sname  CHAR(20) <strong>UNIQUE</strong>，     /<em> Sname取唯一值</em>/  </p>
<p>​            Ssex    CHAR(2)，</p>
<p>​            Sage   SMALLINT，</p>
<p>​             Sdept  CHAR(20)</p>
<p>​            )；</p>
<p>​            [，<strong>PRIMARY KEY （Sno）</strong>] </p>
<p>[例6] 建立一个“课程”表Course</p>
<p>CREATE TABLE  Course</p>
<p>​               ( Cno       CHAR(4) PRIMARY KEY，</p>
<p>​                 Cname  CHAR(40)，</p>
<p>​                 Cpno     CHAR(4) ，    /<em> 先行课 </em>/</p>
<p>​                    Ccredit  SMALLINT，</p>
<p>​                FOREIGN KEY (Cpno) REFERENCES  Course(Cno)    /<em> Cpno是外码，被参照表是Course，被参照列是Cno </em>/</p>
<p>​             ); </p>
<p>[例7]  建立一个“学生选课”表SC</p>
<p>CREATE TABLE  SC</p>
<p>​           (Sno  CHAR(9)，</p>
<p>​        Cno  CHAR(4)，</p>
<p>​        Grade    SMALLINT，</p>
<p>​           PRIMARY KEY (Sno，Cno)，/<em> 主码由两个属性构成，必须作为表级完整性进行定义</em>/</p>
<p>​    FOREIGN KEY (Sno) REFERENCES Student(Sno)，    /<em> 表级完整性约束条件，Sno是外码，被参照表是Student </em>/ </p>
<p>​    FOREIGN KEY (Cno) REFERENCES Course(Cno)     /<em> 表级完整性约束条件， Cno是外码，被参照表是Course</em>/    </p>
<p>); </p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>SQL中域的概念用数据类型来实现</p>
<p>定义表的属性时 需要指明其数据类型及长度</p>
<p>选用哪种数据类型</p>
<ul>
<li><p>取值范围</p>
</li>
<li><p>要做哪些运算</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR(n)</td>
<td>长度为n的定长字符串</td>
</tr>
<tr>
<td>VARCHAR(n)</td>
<td>最大长度为n的变长字符串</td>
</tr>
<tr>
<td>INT</td>
<td>长整数（也可以写作INTEGER）</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>短整数</td>
</tr>
<tr>
<td>NUMERIC(p，d)</td>
<td>定点数，由p位数字（不包括符号、小数点）组成，小数后面有d位数字</td>
</tr>
<tr>
<td>REAL</td>
<td>取决于机器精度的浮点数</td>
</tr>
<tr>
<td>Double Precision</td>
<td>取决于机器精度的双精度浮点数</td>
</tr>
<tr>
<td>FLOAT(n)</td>
<td>浮点数，精度至少为n位数字</td>
</tr>
<tr>
<td>DATE</td>
<td>日期，包含年、月、日，格式为YYYY-MM-DD</td>
</tr>
<tr>
<td>TIME</td>
<td>时间，包含一日的时、分、秒，格式为HH:MM:SS</td>
</tr>
</tbody>
</table>
<h4 id="模式与表"><a href="#模式与表" class="headerlink" title="模式与表"></a>模式与表</h4><p>每一个基本表都属于某一个模式</p>
<p>一个模式包含多个基本表</p>
<h5 id="定义基本表所属模式"><a href="#定义基本表所属模式" class="headerlink" title="定义基本表所属模式"></a>定义基本表所属模式</h5><p>方法一：在表名中明显地给出模式名 </p>
<p>Create table “S-T”.Student（……）;   /<em>模式名为 S-T</em>/</p>
<p>Create table “S-T”.Cource（……）;</p>
<p>Create table “S-T”.SC（……）; </p>
<p>方法二：在创建模式语句中同时创建表 </p>
<p>方法三：设置所属的模式</p>
<p>创建基本表（其他数据库对象也一样）时，若没有指定模式，系统根据搜索路径来确定该对象所属的模式。</p>
<p>RDBMS会使用模式列表中第一个存在的模式作为数据库对象的模式名 。</p>
<p>若搜索路径中的模式名都不存在，系统将给出错误 </p>
<p>显示当前的搜索路径： SHOW search_path; </p>
<p>搜索路径的当前默认值是：$user， PUBLIC</p>
<p>先搜索与用户名相同的模式，若不存在，则使用PUBLIC </p>
<h5 id="模式与表-1"><a href="#模式与表-1" class="headerlink" title="模式与表"></a>模式与表</h5><p>DBA用户可以设置搜索路径，然后定义基本表</p>
<p>​      <strong>SET search_path TO “S-T”，PUBLIC；</strong></p>
<p>​     <strong>Create table Student（……）;</strong> </p>
<p>  结果建立了S-T.Student基本表。</p>
<p>RDBMS发现搜索路径中第一个模式名S-T存在，就把该模式作为基本表Student所属的模式。</p>
<h4 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h4><p>ALTER TABLE &lt;表名&gt;</p>
<p>[ ADD [&lt;新列名&gt; &lt;数据类型&gt;].[完整性约束 ]]</p>
<p>[ DROP &lt;完整性约束名&gt; ]</p>
<p>[ ALTER COLUMN&lt;列名&gt; &lt;数据类型&gt; ]；</p>
<p>  <strong>MODIFY</strong></p>
<p>  <strong>约束（属性名）</strong></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>sql语言</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据库]数据库概论基础整理</title>
    <url>/2018/05/21/2018-05-21/</url>
    <content><![CDATA[<p>努力，努力，再努力。因为我要在这虚假的世界里为她撑起一片童话的天空。——随笔</p>
<h2 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h2><h3 id="四个基本概念"><a href="#四个基本概念" class="headerlink" title="四个基本概念"></a>四个基本概念</h3><h4 id="数据（Data）"><a href="#数据（Data）" class="headerlink" title="数据（Data）"></a>数据（Data）</h4><p>数据(Data)：数据库中存储的基本对象。</p>
<p>定义：描述事物的符号记录</p>
<p>种类：文本、图形、图像、音频、视频、学生的档案记录、货物的运输情况等</p>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>数据与其语义是不可分的。</p>
<p>eg：</p>
<p>54是一个数据</p>
<p>语义1：学生某门课的成绩</p>
<p>语义2：某人的体重</p>
<p>语义3：计算机系2011级学生人数</p>
<p>eg:</p>
<p>学生档案中的学生记录</p>
<p>（张三，男，19941014，陕西西安市，计算机系，2011）</p>
<p>语义：学生姓名、性别、出生年月、籍贯、所在院系、入学时间</p>
<p>解释：张三是个大学生，1994年10月14日出生，陕西省西安市人，2011年考入计算机系</p>
<h4 id="数据库（DB）"><a href="#数据库（DB）" class="headerlink" title="数据库（DB）"></a>数据库（DB）</h4><p>数据库(Database,简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。</p>
<h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><p>数据按一定的数据模型组织、描述和储存</p>
<p>可为各种用户共享</p>
<p>冗余度较小</p>
<p>数据独立性较高</p>
<p>易扩展</p>
<h4 id="数据库管理系统（DBMS）"><a href="#数据库管理系统（DBMS）" class="headerlink" title="数据库管理系统（DBMS）"></a>数据库管理系统（DBMS）</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>位于用户与操作系统之间的一层数据管理软件。</p>
<p>是基础软件，是一个大型复杂的软件系统</p>
<h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><p>科学地组织和存储数据、高效地获取和维护数据。</p>
<h5 id="数据库在计算机系统中的位置"><a href="#数据库在计算机系统中的位置" class="headerlink" title="数据库在计算机系统中的位置"></a>数据库在计算机系统中的位置</h5><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-21-DBMS.png" alt></p>
<h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><table>
<thead>
<tr>
<th><strong>数据定义功能</strong></th>
<th>提供数据定义语言(DDL)</th>
<th>定义数据库中的数据对象</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据组织、存储和管理</strong></td>
<td>分类组织、存储和管理各种数据</td>
<td>确定组织数据的文件结构和存取方式</td>
<td>实现数据之间的联系</td>
<td>提供多种存取方法提高存取效率</td>
<td></td>
</tr>
<tr>
<td><strong>数据操纵功能</strong></td>
<td>提供数据操纵语言(DML)</td>
<td>实现对数据库的基本操作  (增删改查)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>数据库的事务管理和运行管理</strong></td>
<td>数据库在建立、运行和维护时由DBMS统一管理和控制</td>
<td>保证数据的安全性、完整性、多用户对数据的并发使用</td>
<td>发生故障后的系统恢复</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>数据库的建立和维护功能(实用程序和管理工具)</strong></td>
<td>数据库初始数据装载转换</td>
<td>数据库转储</td>
<td>介质故障恢复</td>
<td>数据库的重组织</td>
<td>性能监视分析等</td>
</tr>
<tr>
<td><strong>其它功能</strong></td>
<td>DBMS与网络中其它软件系统的通信</td>
<td>两个DBMS系统的数据转换</td>
<td>异构数据库之间的互访和互操作</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="数据库系统（DBS"><a href="#数据库系统（DBS" class="headerlink" title="数据库系统（DBS)"></a>数据库系统（DBS)</h4><p>Database System，在计算机系统中引入数据库后的系统。</p>
<h5 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h5><p>数据库</p>
<p>数据库管理系统（及其开发工具）</p>
<p>应用系统</p>
<p>数据库管理员</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-05-21-DBS.png" alt></p>
<h3 id="数据管理技术的产生和发展"><a href="#数据管理技术的产生和发展" class="headerlink" title="数据管理技术的产生和发展"></a>数据管理技术的产生和发展</h3><h4 id="什么是数据管理"><a href="#什么是数据管理" class="headerlink" title="什么是数据管理"></a>什么是数据管理</h4><p>对数据进行分类、组织、编码、存储、检索和维护</p>
<p>是数据处理的中心问题</p>
<p>数据处理：对各种数据进行收集、存储、加工和传播。</p>
<h4 id="数据管理技术的发展过程"><a href="#数据管理技术的发展过程" class="headerlink" title="数据管理技术的发展过程"></a>数据管理技术的发展过程</h4><p>人工管理阶段(20世纪40年代中–50年代中)</p>
<p>文件系统阶段(20世纪50年代末–60年代中)</p>
<p>数据库系统阶段(20世纪60年代末–现在)</p>
<h4 id="数据管理技术的发展动力"><a href="#数据管理技术的发展动力" class="headerlink" title="数据管理技术的发展动力"></a>数据管理技术的发展动力</h4><p>应用需求的推动</p>
<p>计算机硬件的发展</p>
<p>计算机软件的发展</p>
<h3 id="数据库系统的特点"><a href="#数据库系统的特点" class="headerlink" title="数据库系统的特点"></a>数据库系统的特点</h3><h4 id="数据结构化"><a href="#数据结构化" class="headerlink" title="数据结构化"></a>数据结构化</h4><p>整体数据的结构化是数据库的主要特征之一。</p>
<h5 id="整体结构化"><a href="#整体结构化" class="headerlink" title="整体结构化"></a>整体结构化</h5><p>不再仅仅针对某一个应用，而是面向全组织</p>
<p>不仅数据内部结构化，整体是结构化的，数据之间具有联系</p>
<h5 id="数据库中实现的是数据的真正结构化"><a href="#数据库中实现的是数据的真正结构化" class="headerlink" title="数据库中实现的是数据的真正结构化"></a>数据库中实现的是数据的真正结构化</h5><p>数据的结构用数据模型描述，无需程序定义和解释</p>
<p>数据可以变长</p>
<p>数据的最小存取单位是数据项</p>
<h4 id="数据的共享性高，冗余度低，易扩充"><a href="#数据的共享性高，冗余度低，易扩充" class="headerlink" title="数据的共享性高，冗余度低，易扩充"></a>数据的共享性高，冗余度低，易扩充</h4><p>数据库系统从整体角度看待和描述数据，数据面向整个系统，可以被多个用户、多个应用共享使用。</p>
<h5 id="数据共享的好处"><a href="#数据共享的好处" class="headerlink" title="数据共享的好处"></a>数据共享的好处</h5><p>减少数据冗余，节约存储空间</p>
<p>避免数据之间的不相容性与不一致性</p>
<p>使系统易于扩充</p>
<h4 id="数据独立性高"><a href="#数据独立性高" class="headerlink" title="数据独立性高"></a>数据独立性高</h4><p>数据独立性是由DBMS的二级映像功能来保证的。</p>
<h5 id="物理独立性"><a href="#物理独立性" class="headerlink" title="物理独立性"></a>物理独立性</h5><p>指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。当数据的物理存储改变了，应用程序不用改变。</p>
<h5 id="逻辑独立性"><a href="#逻辑独立性" class="headerlink" title="逻辑独立性"></a>逻辑独立性</h5><p>指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，用户程序也可以不变。</p>
<h4 id="数据由DBMS统一管理和控制"><a href="#数据由DBMS统一管理和控制" class="headerlink" title="数据由DBMS统一管理和控制"></a>数据由DBMS统一管理和控制</h4><h5 id="DBMS提供的数据控制功能"><a href="#DBMS提供的数据控制功能" class="headerlink" title="DBMS提供的数据控制功能"></a>DBMS提供的数据控制功能</h5><p>(1)数据的安全性（Security）</p>
<p>保护保护数据，以防止不合法的使用造成的数据的泄密和破坏。</p>
<p>(2)数据的完整性（Integrity）</p>
<p>检查将数据控制在有效的范围内，或保证数据之间满足一定的关系。</p>
<p>(3)并发（Concurrency）</p>
<p>控制对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。</p>
<p>(4)数据库恢复（Recovery）</p>
<p>将数据库从错误状态恢复到某一已知的正确状态。</p>
<h5 id="应用程序与数据的对应关系-数据库系统"><a href="#应用程序与数据的对应关系-数据库系统" class="headerlink" title="应用程序与数据的对应关系(数据库系统)"></a>应用程序与数据的对应关系(数据库系统)</h5><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-05-21-DBS2.png" alt></p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="两大类数据模型"><a href="#两大类数据模型" class="headerlink" title="两大类数据模型"></a>两大类数据模型</h3><p>数据模型分为两类（分属两个不同的层次）</p>
<p>(1) 概念模型</p>
<p>也称信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计。</p>
<p>(2) 逻辑模型和物理模型</p>
<p>逻辑模型主要包括网状模型、层次模型、关系模型、面向对象模型等，按计算机系统的观点对数据建模，用于DBMS实现。</p>
<p>物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。</p>
<p>设计人员了解和选择物理模型。</p>
<p><strong>客观对象的抽象过程—两步抽象</strong></p>
<p>现实世界中的客观对象抽象为概念模型；</p>
<p>把概念模型转换为某一DBMS支持的数据模型。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-21%E4%B8%A4%E5%A4%A7%E6%A8%A1%E5%9E%8B.png" alt></p>
<h3 id="数据模型组成元素"><a href="#数据模型组成元素" class="headerlink" title="数据模型组成元素"></a>数据模型组成元素</h3><p>数据结构，数据操作，完整性约束条件</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>描述数据库的组成对象，以及对象之间的联系</p>
<p>数据结构是对系统静态特性的描述（描述对象类型的集合）</p>
<h5 id="描述的内容"><a href="#描述的内容" class="headerlink" title="描述的内容"></a>描述的内容</h5><p>与数据类型、内容、性质有关的对象（域、属性、关系）</p>
<p>与数据之间联系有关的对象</p>
<h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><p>对数据库中各种对象(型)的实例(值)允许执行的操作及有关的操作规则</p>
<h5 id="数据操作的类型"><a href="#数据操作的类型" class="headerlink" title="数据操作的类型"></a>数据操作的类型</h5><p>查询</p>
<p>更新(包括插入、删除、修改)</p>
<h5 id="数据模型对操作的定义"><a href="#数据模型对操作的定义" class="headerlink" title="数据模型对操作的定义"></a>数据模型对操作的定义</h5><p>操作的确切含义</p>
<p>操作符号</p>
<p>操作规则（如优先级）</p>
<p>实现操作的语言</p>
<p><strong>数据操作是对系统动态特性的描述</strong></p>
<h4 id="数据的完整性约束条件"><a href="#数据的完整性约束条件" class="headerlink" title="数据的完整性约束条件"></a>数据的完整性约束条件</h4><p>一组完整性规则的集合。</p>
<p>完整性规则：给定的数据模型中数据及其联系所具有的制约和储存规则</p>
<p>用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。</p>
<h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>反映和规定本数据模型必须遵守的基本的通用的完整性约束条件。例如在关系模型中，任何关系必须满足实体完整性和参照完整性两个条件。</p>
<p>提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。如：退休</p>
<h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><p>概念模型用于信息世界的建模</p>
<p>是现实世界到机器世界的一个中间层次</p>
<p>是数据库设计的有力工具</p>
<p>数据库设计人员和用户之间进行交流的语言</p>
<h4 id="对概念模型的基本要求"><a href="#对概念模型的基本要求" class="headerlink" title="对概念模型的基本要求"></a>对概念模型的基本要求</h4><p>较强的语义表达能力</p>
<p>能够方便、直接地表达应用中的各种语义知识</p>
<p>简单、清晰、易于用户理解</p>
<h4 id="信息世界中的基本概念"><a href="#信息世界中的基本概念" class="headerlink" title="信息世界中的基本概念"></a>信息世界中的基本概念</h4><h5 id="实体（Entity）"><a href="#实体（Entity）" class="headerlink" title="实体（Entity）"></a>实体（Entity）</h5><p>客观存在并可相互区别的事物称为实体。</p>
<p>可以是具体的人、事、物或抽象的概念。如：选课</p>
<h5 id="属性（Attribute）"><a href="#属性（Attribute）" class="headerlink" title="属性（Attribute）"></a>属性（Attribute）</h5><p>实体所具有的某一特性称为属性。</p>
<p>一个实体可以由若干个属性来刻画。</p>
<h5 id="码（Key）"><a href="#码（Key）" class="headerlink" title="码（Key）"></a>码（Key）</h5><p> 唯一标识实体的属性集称为码。如：Snum</p>
<h5 id="域（Domain）"><a href="#域（Domain）" class="headerlink" title="域（Domain）"></a>域（Domain）</h5><p>属性的取值范围称为该属性的域。  如：Grade</p>
<h5 id="实体型（Entity-Type）"><a href="#实体型（Entity-Type）" class="headerlink" title="实体型（Entity Type）"></a>实体型（Entity Type）</h5><p> 用实体名及其属性名集合来抽象和刻画同类实体称为实体型 如：Student(Snum,Sname,Grade )</p>
<h5 id="实体集（Entity-Set）"><a href="#实体集（Entity-Set）" class="headerlink" title="实体集（Entity Set）"></a>实体集（Entity Set）</h5><p>同一类型实体的集合称为实体集</p>
<h5 id="联系（Relationship）"><a href="#联系（Relationship）" class="headerlink" title="联系（Relationship）"></a>联系（Relationship）</h5><p>现实世界中事物内部以及事物之间的联系在信息世界中反映为实体内部的联系和实体之间的联系。</p>
<p>实体内部的联系通常是指组成实体的各属性之间的联系</p>
<p>实体之间的联系通常是指不同实体集之间的联系</p>
<h4 id="两个实体型之间的联系"><a href="#两个实体型之间的联系" class="headerlink" title="两个实体型之间的联系"></a>两个实体型之间的联系</h4><p>用图形来表示两个实体型之间的这三类联系</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-21%E4%B8%A4%E5%A4%A7%E5%AE%9E%E4%BD%93.png" alt></p>
<h5 id="一对一联系（1-1）"><a href="#一对一联系（1-1）" class="headerlink" title="一对一联系（1:1）"></a>一对一联系（1:1）</h5><p> 如果对于实体集A中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记为1:1</p>
<p>实例</p>
<p>一个班级只有一个正班长，一个班长只在一个班中任职</p>
<h5 id="一对多联系（1：n）"><a href="#一对多联系（1：n）" class="headerlink" title="一对多联系（1：n）"></a>一对多联系（1：n）</h5><p>如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，则称实体集A与实体集B有一对多联系，记为1:n</p>
<p>实例</p>
<p>一个班级中有若干名学生，每个学生只在一个班级中学习</p>
<h5 id="多对多联系（m-n）"><a href="#多对多联系（m-n）" class="headerlink" title="多对多联系（m:n）"></a>多对多联系（m:n）</h5><p>如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中也有m个实体（m≥0）与之联系，则称实体集A与实体B具有多对多联系，记为m:n</p>
<p>实例</p>
<p>课程与学生之间的联系：一门课程同时有若干个学生选修，一个学生可以同时选修多门课程</p>
<h4 id="两个以上实体型之间的联系"><a href="#两个以上实体型之间的联系" class="headerlink" title="两个以上实体型之间的联系"></a>两个以上实体型之间的联系</h4><h5 id="两个以上实体型之间一对多联系"><a href="#两个以上实体型之间一对多联系" class="headerlink" title="两个以上实体型之间一对多联系"></a>两个以上实体型之间一对多联系</h5><p>若实体集E1，E2，…，En存在联系，对于实体集Ej（j=1，2，…，i-1，i+1，…，n）中的给定实体，最多只和Ei中的一个实体相联系，则我们说Ei与E1，E2，…，Ei-1，Ei+1，…，En之间的联系是一对多的</p>
<p>实例</p>
<p>课程、教师与参考书三个实体型一门课程可以有若干个教师讲授，使用若干本参考书，每一个教师只讲授一门课程，每一本参考书只供一门课程使用课程与教师、参考书之间1：n</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-21%E4%B8%A4%E4%B8%AA%E4%BB%A5%E4%B8%8A1%EF%BC%9An.png" alt></p>
<h5 id="两个以上实体型间的多对多联系"><a href="#两个以上实体型间的多对多联系" class="headerlink" title="两个以上实体型间的多对多联系"></a>两个以上实体型间的多对多联系</h5><p>两个以上实体型间的多对多联系</p>
<p>实例</p>
<p>供应商、项目、零件三个实体型,一个供应商可以供给多个项目多种零件,每个项目可以使用多个供应商供应的零件,每种零件可由不同供应商供给</p>
<h4 id="单个实体型内的联系"><a href="#单个实体型内的联系" class="headerlink" title="单个实体型内的联系"></a>单个实体型内的联系</h4><h5 id="一对一联系"><a href="#一对一联系" class="headerlink" title="一对一联系"></a>一对一联系</h5><h5 id="一对多联系"><a href="#一对多联系" class="headerlink" title="一对多联系"></a>一对多联系</h5><p>实例</p>
<p>职工实体型内部具有领导与被领导的联系,某一职工（干部）“领导”若干名职工,一个职工仅被另外一个职工直接领导,这是一对多的联系</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-21%E5%AE%9E%E4%BD%93%E5%86%85%E9%83%A8-1%EF%BC%9An.png" alt></p>
<h5 id="多对多联系"><a href="#多对多联系" class="headerlink" title="多对多联系"></a>多对多联系</h5><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-21%E5%AE%9E%E4%BD%93%E5%86%85%E9%83%A8-m%EF%BC%9An.png" alt></p>
<h4 id="概念模型的一种表示方法"><a href="#概念模型的一种表示方法" class="headerlink" title="概念模型的一种表示方法"></a>概念模型的一种表示方法</h4><h5 id="实体－联系方法-E-R方法"><a href="#实体－联系方法-E-R方法" class="headerlink" title="实体－联系方法(E-R方法)"></a>实体－联系方法(E-R方法)</h5><p>用E-R图来描述现实世界的概念模型</p>
<p>E-R方法也称为E-R模型</p>
<h5 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h5><p><strong>实体型</strong></p>
<p>用矩形表示，矩形框内写明实体名。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-21%E5%AE%9E%E4%BD%93%E5%9E%8B.png" alt></p>
<p><strong>属性</strong></p>
<p>用椭圆形表示，并用无向边将其与相应的实体连接起来</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-21-ER%E5%B1%9E%E6%80%A7.png" alt></p>
<p><strong>联系</strong></p>
<p>联系本身：   用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:n或m:n）</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-21-ER%E5%85%B3%E7%B3%BB.png" alt></p>
<p>联系的属性：</p>
<p>联系本身也是一种实体型，也可以有属性。如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来 </p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-21-ER%E8%81%94%E7%B3%BB%E5%B1%9E%E6%80%A7.png" alt></p>
<h3 id="最常用的数据模型"><a href="#最常用的数据模型" class="headerlink" title="最常用的数据模型"></a>最常用的数据模型</h3><h4 id="非关系模型（格式化模型）"><a href="#非关系模型（格式化模型）" class="headerlink" title="非关系模型（格式化模型）"></a>非关系模型（格式化模型）</h4><p>层次模型(Hierarchical Model)  实体-&gt;记录</p>
<p>网状模型(Network Model)       属性-&gt;字段（数据项）</p>
<h5 id="非关系模型中数据结构基本单位"><a href="#非关系模型中数据结构基本单位" class="headerlink" title="非关系模型中数据结构基本单位"></a>非关系模型中数据结构基本单位</h5><p>基本层次联系：两个记录以及它们之间的一对多（包括一对一）的联系。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-21-%E5%9F%BA%E6%9C%AC%E5%B1%82%E6%AC%A1%E8%81%94%E7%B3%BB.png" alt></p>
<h4 id="关系模型-Relational-Model"><a href="#关系模型-Relational-Model" class="headerlink" title="关系模型(Relational Model)"></a>关系模型(Relational Model)</h4><h4 id="面向对象模型-Object-Oriented-Model）"><a href="#面向对象模型-Object-Oriented-Model）" class="headerlink" title="面向对象模型(Object Oriented Model）"></a>面向对象模型(Object Oriented Model）</h4><h4 id="对象关系模型-Object-Relational-Model"><a href="#对象关系模型-Object-Relational-Model" class="headerlink" title="对象关系模型(Object Relational Model)"></a>对象关系模型(Object Relational Model)</h4><h3 id="层次模型-最早的模型"><a href="#层次模型-最早的模型" class="headerlink" title="层次模型(最早的模型)"></a>层次模型(最早的模型)</h3><p>层次模型用树形结构来表示各类实体以及实体间的联系  </p>
<p><strong>满足下面两个条件的基本层次联系的集合为层次模型</strong></p>
<ol>
<li>有且只有一个结点没有双亲结点，这个结点称为根结点</li>
<li>根以外的其它结点有且只有一个双亲结点</li>
</ol>
<p><strong>层次模型中的几个术语</strong></p>
<p>根结点，双亲结点，兄弟结点（同一双亲的节点），叶结点（没有子女的节点）</p>
<h3 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h3><p>网状数据库系统采用网状模型作为数据的组织方式</p>
<p>满足下面两个条件的基本层次联系的集合：</p>
<ol>
<li>允许一个以上的结点无双亲；</li>
<li>一个结点可以有多于一个的双亲。</li>
</ol>
<p>表示方法(与层次数据模型相同)</p>
<p>实体型：用记录类型描述每个结点表示一个记录类型（实体）</p>
<p>属性：用字段描述每个记录类型可包含若干个字段</p>
<p>联系：用结点之间的连线表示记录类型（实体）之间的一对多的父子联系</p>
<h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>关系数据库系统采用关系模型作为数据的组织方式。</p>
<p>在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。</p>
<h4 id="关系（Relation）"><a href="#关系（Relation）" class="headerlink" title="关系（Relation）"></a>关系（Relation）</h4><p>一个关系对应通常说的一张表</p>
<h4 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h4><p>表中的一行即为一个元组</p>
<h4 id="属性（Attribute）-1"><a href="#属性（Attribute）-1" class="headerlink" title="属性（Attribute）"></a>属性（Attribute）</h4><p>表中的一列即为一个属性，给每一个属性起一个名称即属性名</p>
<h4 id="主码（Key）"><a href="#主码（Key）" class="headerlink" title="主码（Key）"></a>主码（Key）</h4><p>表中的某个属性或属性组，它可以唯一确定一个元组。</p>
<h4 id="域（Domain）-1"><a href="#域（Domain）-1" class="headerlink" title="域（Domain）"></a>域（Domain）</h4><p>属性的取值范围。</p>
<h4 id="分量"><a href="#分量" class="headerlink" title="分量"></a>分量</h4><p>元组中的一个属性值。</p>
<h4 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h4><p>对关系的描述</p>
<p>关系名（属性1，属性2，…，属性n）</p>
<p>学生（学号，姓名，年龄，性别，系，年级）</p>
<h4 id="术语对比"><a href="#术语对比" class="headerlink" title="术语对比"></a>术语对比</h4><table>
<thead>
<tr>
<th>关系术语</th>
<th>一般表格的术语</th>
</tr>
</thead>
<tbody>
<tr>
<td>关系名</td>
<td>表名</td>
</tr>
<tr>
<td>关系模式</td>
<td>表头（表格的描述）</td>
</tr>
<tr>
<td>关系</td>
<td>（一张）二维表</td>
</tr>
<tr>
<td>元组</td>
<td>记录或行</td>
</tr>
<tr>
<td>属性</td>
<td>列</td>
</tr>
<tr>
<td>属性名</td>
<td>列名</td>
</tr>
<tr>
<td>属性值</td>
<td>列值</td>
</tr>
<tr>
<td>分量</td>
<td>一条记录中的一个列值</td>
</tr>
<tr>
<td>非规范关系</td>
<td>表中有表（大表中嵌有小表）</td>
</tr>
</tbody>
</table>
<p>关系必须是规范化的，满足一定的规范条件最基本的规范条件：关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表。</p>
<h4 id="数据操作-1"><a href="#数据操作-1" class="headerlink" title="数据操作"></a>数据操作</h4><p>查询</p>
<p>插入</p>
<p>删除</p>
<p>更新</p>
<p>数据操作是集合操作，操作对象和操作结果都是关系，即若干元组的集合</p>
<p>存取路径对用户隐蔽，用户只要指出“干什么”，不必详细说明“怎么干”</p>
<h4 id="关系的完整性约束条件"><a href="#关系的完整性约束条件" class="headerlink" title="关系的完整性约束条件"></a>关系的完整性约束条件</h4><p>实体完整性</p>
<p>参照完整性</p>
<p>用户定义的完整性</p>
<h2 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h2><p>从数据库管理系统角度看，数据库系统通常采用三级模式结构，是数据库系统内部的系统结构。</p>
<p>从数据库最终用户角度看（数据库系统外部的体系结构） ，数据库系统的结构分为:</p>
<p>单用户结构</p>
<p>主从式结构分布式结构</p>
<p>客户／服务器</p>
<p>浏览器／应用服务器／数据库服务器多层结构等</p>
<h3 id="数据库系统模式的概念"><a href="#数据库系统模式的概念" class="headerlink" title="数据库系统模式的概念"></a>数据库系统模式的概念</h3><h4 id="“型”-和“值”-的概念"><a href="#“型”-和“值”-的概念" class="headerlink" title="“型” 和“值” 的概念"></a>“型” 和“值” 的概念</h4><h5 id="型-Type"><a href="#型-Type" class="headerlink" title="型(Type)"></a>型(Type)</h5><p>对某一类数据的结构和属性的说明</p>
<h5 id="值-Value"><a href="#值-Value" class="headerlink" title="值(Value)"></a>值(Value)</h5><p>是型的一个具体赋值例如学生记录</p>
<p>型：  （学号，姓名，性别，系别，年龄，籍贯）一个记录</p>
<p>值：  （900201，李明，男，计算机，22，江苏）</p>
<h4 id="模式（Schema）"><a href="#模式（Schema）" class="headerlink" title="模式（Schema）"></a>模式（Schema）</h4><p>数据库逻辑结构和特征的描述</p>
<p>是型的描述</p>
<p>反映的是数据的结构及其联系</p>
<p>模式是相对稳定的</p>
<h4 id="实例（Instance）"><a href="#实例（Instance）" class="headerlink" title="实例（Instance）"></a>实例（Instance）</h4><p>模式的一个具体值</p>
<p>反映数据库某一时刻的状态</p>
<p>同一个模式可以有很多实例实例</p>
<p>随数据库中的数据的更新而变动</p>
<p>例如：在学生选课数据库模式中，包含学生记录、课程记录和学生选课记录 </p>
<p>2013年的一个学生数据库实例，包含：</p>
<p>2013年学校中所有学生的记录</p>
<p>学校开设的所有课程的记录</p>
<p>所有学生选课的记录 </p>
<p>2012年度学生数据库模式对应的实例与2013年度学生数据库模式对应的实例是不同的 </p>
<h3 id="数据库系统的三级模式结构"><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h3><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-21-%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F.png" alt></p>
<h4 id="模式（Schema也称逻辑模式）"><a href="#模式（Schema也称逻辑模式）" class="headerlink" title="模式（Schema也称逻辑模式）"></a>模式（Schema也称逻辑模式）</h4><p>数据库中全体数据的逻辑结构和特征的描述</p>
<p>所有用户的公共数据视图，综合了所有用户的需求</p>
<p><strong>一个数据库只有一个模式</strong></p>
<h5 id="模式的地位："><a href="#模式的地位：" class="headerlink" title="模式的地位："></a>模式的地位：</h5><p>是数据库系统模式结构的中间层与数据的物理存储细节和硬件环境无关</p>
<p>与具体的应用程序、开发工具及高级程序设计语言无关</p>
<h5 id="模式的定义"><a href="#模式的定义" class="headerlink" title="模式的定义"></a>模式的定义</h5><p>数据的逻辑结构（数据项的名字、类型、取值范围等）</p>
<p>数据之间的联系</p>
<p>数据有关的安全性、完整性要求</p>
<h4 id="外模式（External-Schema也称子模式或用户模式）"><a href="#外模式（External-Schema也称子模式或用户模式）" class="headerlink" title="外模式（External Schema也称子模式或用户模式）"></a>外模式（External Schema也称子模式或用户模式）</h4><p>数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述</p>
<p>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</p>
<h5 id="模式与外模式的关系：一对多"><a href="#模式与外模式的关系：一对多" class="headerlink" title="模式与外模式的关系：一对多"></a>模式与外模式的关系：一对多</h5><p>外模式通常是模式的子集</p>
<p>一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求</p>
<p>对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同</p>
<h5 id="外模式与应用的关系：一对多"><a href="#外模式与应用的关系：一对多" class="headerlink" title="外模式与应用的关系：一对多"></a>外模式与应用的关系：一对多</h5><p>同一外模式也可以为某一用户的多个应用系统所使用</p>
<p>但一个应用程序只能使用一个外模式</p>
<h5 id="外模式的用途"><a href="#外模式的用途" class="headerlink" title="外模式的用途"></a>外模式的用途</h5><p>保证数据库安全性的一个有力措施</p>
<p>每个用户只能看见和访问所对应的外模式中的数据</p>
<h4 id="内模式（Internal-Schema也称存储模式）"><a href="#内模式（Internal-Schema也称存储模式）" class="headerlink" title="内模式（Internal Schema也称存储模式）"></a>内模式（Internal Schema也称存储模式）</h4><p>一个数据库只有一个内模式</p>
<h5 id="是数据物理结构和存储方式的描述"><a href="#是数据物理结构和存储方式的描述" class="headerlink" title="是数据物理结构和存储方式的描述"></a>是数据物理结构和存储方式的描述</h5><h5 id="是数据在数据库内部的表示方式"><a href="#是数据在数据库内部的表示方式" class="headerlink" title="是数据在数据库内部的表示方式"></a>是数据在数据库内部的表示方式</h5><p>记录的存储方式（堆存储，顺序存储，聚簇存储）</p>
<p> 索引的组织方式（B+树索引，按hash索引存储）</p>
<p>数据是否压缩存储</p>
<p>数据是否加密</p>
<p>数据存储记录结构的规定</p>
<p>数据库的二级映像功能与数据独立性</p>
<h3 id="数据库的二级映像功能与数据独立性"><a href="#数据库的二级映像功能与数据独立性" class="headerlink" title="数据库的二级映像功能与数据独立性"></a>数据库的二级映像功能与数据独立性</h3><p>三级模式是对数据的三个抽象级别</p>
<p>二级映象在DBMS内部实现这三个抽象层次的联系和转换</p>
<h4 id="外模式／模式映象"><a href="#外模式／模式映象" class="headerlink" title="外模式／模式映象"></a>外模式／模式映象</h4><p>模式：描述的是数据的全局逻辑结构</p>
<p>外模式：描述的是数据的局部逻辑结构 </p>
<p>同一个模式可以有任意多个外模式 </p>
<p>每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系</p>
<p>映象定义通常包含在各自外模式的描述中</p>
<h5 id="保证数据的逻辑独立性"><a href="#保证数据的逻辑独立性" class="headerlink" title="保证数据的逻辑独立性"></a>保证数据的逻辑独立性</h5><p>当模式改变时，数据库管理员修改有关的外模式／模式映象，使外模式保持不变</p>
<p>应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。</p>
<h4 id="模式／内模式映像"><a href="#模式／内模式映像" class="headerlink" title="模式／内模式映像"></a>模式／内模式映像</h4><p>模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。例如，说明逻辑记录和字段在内部是如何表示的</p>
<p>数据库中模式／内模式映象是唯一的</p>
<p>该映象定义通常包含在模式描述中</p>
<h5 id="保证数据的物理独立性"><a href="#保证数据的物理独立性" class="headerlink" title="保证数据的物理独立性"></a>保证数据的物理独立性</h5><p>当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变</p>
<p>应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。</p>
<h5 id="数据库模式"><a href="#数据库模式" class="headerlink" title="数据库模式"></a>数据库模式</h5><p>即全局逻辑结构是数据库的中心与关键 </p>
<p>独立于数据库的其他层次 </p>
<p>设计数据库模式结构时应首先确定数据库的逻辑模式</p>
<h5 id="数据库的内模式"><a href="#数据库的内模式" class="headerlink" title="数据库的内模式"></a>数据库的内模式</h5><p>依赖于它的全局逻辑结构</p>
<p>独立于数据库的用户视图，即外模式</p>
<p>独立于具体的存储设备  </p>
<p>将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率 </p>
<h5 id="数据库的外模式"><a href="#数据库的外模式" class="headerlink" title="数据库的外模式"></a>数据库的外模式</h5><p>面向具体的应用程序</p>
<p>定义在逻辑模式之上</p>
<p>独立于存储模式和存储设备</p>
<p>当应用需求发生较大变化，相应外模式不能满足其视图要求时，该外模式就得做相应改动 </p>
<p>设计外模式时应充分考虑到应用的扩充性 </p>
<h5 id="特定的应用程序"><a href="#特定的应用程序" class="headerlink" title="特定的应用程序"></a>特定的应用程序</h5><p>在外模式描述的数据结构上编制的</p>
<p>依赖于特定的外模式</p>
<p>与数据库的模式和存储结构独立</p>
<p>不同的应用程序有时可以共用同一个外模式</p>
<h5 id="数据库的二级映像"><a href="#数据库的二级映像" class="headerlink" title="数据库的二级映像"></a>数据库的二级映像</h5><p>保证了数据库外模式的稳定性</p>
<p>从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改 </p>
<p><strong>数据与程序之间的独立性，使得数据的定义和描述可以从应用程序中分离出去</strong> </p>
<h5 id="数据的存取由DBMS管理"><a href="#数据的存取由DBMS管理" class="headerlink" title="数据的存取由DBMS管理"></a>数据的存取由DBMS管理</h5><p>用户不必考虑存取路径等细节</p>
<p>简化了应用程序的编制</p>
<p>大大减少了应用程序的维护和修改</p>
<h2 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h2><p>数据库</p>
<p>数据库管理系统（及其开发工具）</p>
<p>应用系统</p>
<p>数据库管理员</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM全国邀请赛热身赛题2并查集</title>
    <url>/2018/05/19/2018-05-19/</url>
    <content><![CDATA[<p>真是糟糕的一天，愿不要影响到明天邀请赛发挥。</p>
<p>题意：</p>
<p>有n个人。m次询问。每次询问包含两个数x和y，代表第x人和和第y人中有一个人是叛徒，一个不是叛徒。如果遇到第i次询问和之前询问出现冲突，则该询问为谎言。如果m条询问没有谎言，则输出1，和最大可能叛徒数，否则输出-1，遇到第几条时判断是谎言。</p>
<p>例：</p>
<p>输入</p>
<p>3 3</p>
<p>1 2</p>
<p>2 3</p>
<p>3 1</p>
<p>输出</p>
<p>-1 3</p>
<p>输入</p>
<p>5 4</p>
<p>1 2</p>
<p>2 3</p>
<p>3 4</p>
<p>4 1</p>
<p>输出</p>
<p>1 3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXX = 100010;</span><br><span class="line">int fa[MAXX], r[MAXX];</span><br><span class="line">int vis[MAXX];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	if (fa[x] == x) return fa[x];</span><br><span class="line">	int tmp = fa[x];</span><br><span class="line">	fa[x] = find(fa[x]);</span><br><span class="line">	r[x] = (r[tmp] + r[x]) % 2;</span><br><span class="line">	return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void fun(int x, int y)&#123;</span><br><span class="line">	int fx = find(x), fy = find(y);</span><br><span class="line">	if (fx == fy)   return;</span><br><span class="line">	fa[fy] = fx;</span><br><span class="line">	r[fy] = (r[x] + 1 - r[y]) % 2;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		int N, M, x, y, flag = 0, cnt = 0;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;N, &amp;M);</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		for (int i = 0; i &lt;= N; i++)   fa[i] = i, r[i] = 0;</span><br><span class="line">		for (int i = 1; i &lt;= M; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;x, &amp;y);</span><br><span class="line">			if (!vis[x])</span><br><span class="line">				cnt++;</span><br><span class="line">			if (!vis[y])</span><br><span class="line">				cnt++;</span><br><span class="line">			vis[x] = vis[y] = 1;</span><br><span class="line">			if (flag)</span><br><span class="line">				continue;</span><br><span class="line">			if (find(x) == find(y)) &#123;</span><br><span class="line">				if (r[x] == r[y])</span><br><span class="line">					flag = i;</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">				fun(x, y);</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag)</span><br><span class="line">			printf(&quot;-1 %d\n&quot;, flag);</span><br><span class="line">		else &#123;</span><br><span class="line">			int cnt2 = 0;</span><br><span class="line">			for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">				find(i);</span><br><span class="line">				if (r[i] == 1 || !vis[i])</span><br><span class="line">					cnt2++;</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;1 %d\n&quot;, cnt - cnt2 &gt; cnt2 ? cnt - cnt2 : cnt2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客小白月赛&amp;&amp;艾教习题总结</title>
    <url>/2018/05/16/2018-05-16/</url>
    <content><![CDATA[<h2 id="管道取珠"><a href="#管道取珠" class="headerlink" title="管道取珠"></a>管道取珠</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/%E7%AE%A1%E9%81%93%E5%8F%96%E7%8F%A0_1.jpg" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/%E7%AE%A1%E9%81%93%E5%8F%96%E7%8F%A0_2.jpg" alt></p>
<p><strong>输入</strong></p>
<p>第一行包含两个整数n, m，分别表示上下两个管道中球的数目。 第二行为一个AB字符串，长度为n，表示上管道中从左到右球的类型。其中A表示浅色球，B表示深色球。 第三行为一个AB字符串，长度为m，表示下管道中的情形。</p>
<p><strong>输出</strong></p>
<p>仅包含一行，即为 Sigma(Ai^2) i从1到k 除以1024523的余数。</p>
<p><strong>输入示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">AB</span><br><span class="line">B</span><br></pre></td></tr></table></figure>
<p><strong>输出示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<p><strong>数据规模及约定</strong></p>
<p>约30%的数据满足 n, m ≤ 12；<br>约100%的数据满足n, m ≤ 500。</p>
<p><strong>题解</strong></p>
<p>这题思路比较妙，我们需要先想想 ∑ai2 有什么意义。如果我们构造出这样一个游戏场景，即两个人同时玩两份同样的如题目所述的管道取珠的游戏，那么这两个人游戏结束后取到的珠子颜色序列一模一样的方案数就是题目里要求的答案。</p>
<p>令这两个人分别是 p1 和 p2。于是设 f[i][j][k] 表示 p1 取了第二个管道中的前 i 个珠子，第一个管道中的前 j 个珠子；p2 取了第一个管道的前 k 个珠子，这个状态下颜色序列相同的方案数，转移显然。</p>
<p>注：n为12以内一般是阶乘的题，n为30以内可以考虑状态压缩，莫队，线段树等各种情况，50左右选择二分，100以上需要另想方法。</p>
<h2 id="问号猜数"><a href="#问号猜数" class="headerlink" title="问号猜数"></a>问号猜数</h2><p>有一堆数按照递增的顺序排列，然而这些数的某些位我们并不知道，我们知道的只是这些数是从小到大排列的，现在依次给出这些数，不知道的位用？表示。我们需要猜这个数能满足递增条件的最小数。例如：</p>
<p>??</p>
<p>1?</p>
<p>?1</p>
<p>???</p>
<p>?99</p>
<p>?9?</p>
<p>?4?5</p>
<p>第一个数是10，第2个11，第3个21，第4个100，第5个199，第6个290，第7个1405。</p>
<p><strong>题解</strong></p>
<p>用贪心虽然比较快，但代码不容易写，须考虑情况挺多。因此我们分析一下。首先n&lt;=6，代表最大位数是6，也就是说最大的数也就是百万位。因此直接从1枚举，另设指针指向第1个数，每枚举到某个数满足该指针指向的数，则将指针指向下一个数，然后继续枚举，因此扫描一遍之后就得到所有的答案了。</p>
<p>接下来，假如n&lt;=15，由于数是递增的，则将枚举用二分来完成。假如n&gt;=100，这时再考虑贪心。</p>
<h2 id="取牌去牌"><a href="#取牌去牌" class="headerlink" title="取牌去牌"></a>取牌去牌</h2><p>有n张牌，每个牌有一个a属性和1个b属性，第i张牌的属性为ai，bi。现在每次从牌中选两张牌ii.j，得到一个ai <em> bj + bi </em> aj的分数，然后从这两张牌中去掉1张牌。经过n-1次操作之后就剩1张牌了。问经过n-1次操作后得到的最大的分数和是多少。</p>
<p><strong>题解</strong></p>
<p>主要是删除牌的问题。但是假如我们将每张牌看成1个结点，属性的乘积得到的分数为1条路径，那么n张牌构成了n个结点n*（n-1）/2条边的强联通无向图，那么只需求每次分数最大的最小生成树即可。</p>
<h2 id="铁索连环"><a href="#铁索连环" class="headerlink" title="铁索连环"></a>铁索连环</h2><p>有n个数，现在有m次查询，每次查询[l,r]范围所有不同的数。假设n很大</p>
<p><strong>题解</strong></p>
<p>我的思路是打表记录上一个相同元素的位置，比如a[1-10]=1,2,4,3,2,4,5,6,3,4,那么b[1-10]=0,0,0,0,2,3,0,0,4,6。这样l，r的范围内只需扫描1遍即可，扫到0结果加1，扫到非0的数看该下标是否 &lt; l，是则加1，否则不处理。时间复杂度是0mn。</p>
<p>艾教的方法不是很懂，不过举了一个例子，假如(3(3(3(3(3)))))，查询范围为括号所示，那么只需将第5个3赋为1，其他3赋为0即可。看起来最后就像一条链子捆绑着相同的元素。</p>
<h2 id="狭路相逢"><a href="#狭路相逢" class="headerlink" title="狭路相逢"></a>狭路相逢</h2><p>有一个图，每条路上都有强盗，每个节点都有驴友，假如到某条路上，该路上的强盗抢劫你的条件是强盗人数大于等于你们人数。你们每经过一个节点可以拉驴友入伍结伴而行，问（忘记问什么了，尴尬~QAQ~）</p>
<p><strong>题解</strong></p>
<p>并查集</p>
<h2 id="区间gcd"><a href="#区间gcd" class="headerlink" title="区间gcd"></a>区间gcd</h2><p>给定l，r，问多少种gcd(l,r)==gcd(l2.r2)</p>
<p><strong>题解</strong></p>
<p>1、两个条件，从1到n，最大公约数呈递减阶梯式。</p>
<p>2、gcd(gcd（a,b）,gcd(c,d))==gcd(a,d)</p>
<p>根据性质2可以用st表列出范围内l，r的最大公约数，即1，n最大公约数</p>
<p>根据性质1，二分求解</p>
<h2 id="信号误差"><a href="#信号误差" class="headerlink" title="信号误差"></a>信号误差</h2><p>艾教给女朋友传情发信号，信号是01串（16位）组成的字母，但是有情敌的干扰，途中可能至多会有两位进制会发生改变。问如何设置01串才能无视干扰准确将信号传给女盆友。例如1111111111111111，那么该2个1也是比0多，所以无视干扰。但每次只能处理一个字母，效率太慢。</p>
<p><strong>题解</strong></p>
<p>图论。将距离2以内的所有结点全部连起来。贪心选取结点，可以直接选择第一个结点开始。</p>
<h2 id="牛客小白月赛"><a href="#牛客小白月赛" class="headerlink" title="牛客小白月赛"></a>牛客小白月赛</h2><h3 id="音标"><a href="#音标" class="headerlink" title="音标"></a><a href="https://www.nowcoder.com/acm/contest/87/A" target="_blank" rel="noopener">音标</a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>  我们规定元音字母有a、e、i、o、u，并且规定半元音字母y也是元音字母。 </p>
<p>  Cwbc在学习英语，XHRlyb为了让Cwbc的记忆更加深刻，于是她让Cwbc把每个字符串的所有字母都变成一个<strong>恰好**</strong>不大于它本身的小写元音字母**。 </p>
<h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入数据有多行，每行有一个仅包含小写字母的字符串。</span><br></pre></td></tr></table></figure>
<h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出数据应有多行，每行有一个变化后的字符串。</span><br></pre></td></tr></table></figure>
<p> 示例1 </p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aeiou</span><br></pre></td></tr></table></figure>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aeiou</span><br></pre></td></tr></table></figure>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">元音字母变为一个恰好不大于它本身的字母，也就是元音字母本身</span><br></pre></td></tr></table></figure>
<p> 示例2 </p>
<h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bfjpv</span><br></pre></td></tr></table></figure>
<h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aeiou</span><br></pre></td></tr></table></figure>
<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入样例是由元音字母a、e、i、o、u的后一个字母组成，每个字母变为一个恰好不大于它本身的字母，也就是a、e、i、o、u。</span><br></pre></td></tr></table></figure>
<h4 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每行字符串长度不超过2×105，字符串总长度不超过106。</span><br></pre></td></tr></table></figure>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>upper_bound的应用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">char s[210000];</span><br><span class="line">char a[]=&quot;aeiouy&quot;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin&gt;&gt;s)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;s[i];i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i]=a[upper_bound(a,a+6,s[i])-a-1];</span><br><span class="line">        &#125;</span><br><span class="line">        puts(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="躲藏"><a href="#躲藏" class="headerlink" title="躲藏"></a><a href="https://www.nowcoder.com/acm/contest/87/B" target="_blank" rel="noopener">躲藏</a></h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>XHRlyb和她的小伙伴Cwbc在玩捉迷藏游戏。<br> Cwbc藏在多个不区分大小写的字符串中。<br> 好奇的XHRlyb想知道，在每个字符串中Cwbc作为子序列分别出现了多少次。<br> 由于Cwbc可能出现的次数过多，你只需要输出每个答案对<strong>2000120420010122</strong>取模后的结果。<br> 聪明的你在仔细阅读题目后，一定可以顺利的解决这个问题！</p>
<h4 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入数据有多行，每行有一个字符串。</span><br></pre></td></tr></table></figure>
<h4 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出数据应有多行，每行表示一个答案取模后的结果。</span><br></pre></td></tr></table></figure>
<p> 示例1 </p>
<h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cwbc</span><br></pre></td></tr></table></figure>
<h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cwbc作为子序列仅出现了1次。</span><br></pre></td></tr></table></figure>
<p> 示例2 </p>
<h4 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">acdcecfwgwhwibjbkblcmcnco</span><br></pre></td></tr></table></figure>
<h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">81</span><br></pre></td></tr></table></figure>
<h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cwbc作为子序列出现了34=81次。</span><br></pre></td></tr></table></figure>
<h4 id="备注-1"><a href="#备注-1" class="headerlink" title="备注:"></a>备注:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每行字符串长度不超过2×105，字符串总长度不超过106。</span><br></pre></td></tr></table></figure>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>一个memset导致超时，也是够无语。时间复杂度4 <em> On，加上memset是5 </em> On，就差1个On就超时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;ctype.h&gt;</span><br><span class="line">char str[200010];</span><br><span class="line">long long dp[5][200010];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int i;</span><br><span class="line">	while (scanf(&quot;%s&quot;, str + 2) != EOF) &#123;</span><br><span class="line">		dp[1][0] = &apos;c&apos;, dp[2][0] = &apos;w&apos;, dp[3][0] = &apos;b&apos;,dp[4][0] = &apos;c&apos;;</span><br><span class="line">		for (i = 2; str[i]; i++) &#123;</span><br><span class="line">			dp[0][i] = 1;</span><br><span class="line">			str[i] = tolower(str[i]);</span><br><span class="line">			for (int k = 1; k &lt; 5; k++) &#123;</span><br><span class="line">				dp[k][i] = dp[k][i - 1];</span><br><span class="line">				if (str[i] == dp[k][0]) &#123;</span><br><span class="line">					dp[k][i] += dp[k - 1][i];</span><br><span class="line">					dp[k][i] %= 2000120420010122;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%lld\n&quot;, dp[4][i - 1]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="博弈"><a href="#博弈" class="headerlink" title="博弈"></a><a href="https://www.nowcoder.com/acm/contest/87/C" target="_blank" rel="noopener">博弈</a></h3><p> 博弈双方都是绝顶聪明的，并且XHRlyb先手，请你来帮XHRlyb预测这一局游戏谁会获胜。 </p>
<p>  如果博弈双方谁也无法取胜，那么判定为平局。 </p>
<h4 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入数据有多行，每行有三个正整数，l，r，k。</span><br></pre></td></tr></table></figure>
<h4 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出数据应有多行，如果这一局XHRlyb获胜，那么请输出XHRlyb；如果Cwbc获胜，请输出Cwbc；如果两人平局，请输出Draw。</span><br></pre></td></tr></table></figure>
<p> 示例1 </p>
<h4 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 3 2</span><br></pre></td></tr></table></figure>
<h4 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XHRlyb</span><br></pre></td></tr></table></figure>
<p> 示例2 </p>
<h4 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 4 2</span><br></pre></td></tr></table></figure>
<h4 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cwbc</span><br></pre></td></tr></table></figure>
<h4 id="备注-2"><a href="#备注-2" class="headerlink" title="备注:"></a>备注:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 ≤ l ≤ r ≤ 105。</span><br><span class="line">1 ≤ k ≤ 100。</span><br><span class="line">1 ≤ T ≤ 1000。</span><br></pre></td></tr></table></figure>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>水dp，l，r写反了，一直报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int dp[100005];</span><br><span class="line">int sum[100005];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int l, r, k;</span><br><span class="line">	while (cin &gt;&gt; l &gt;&gt; r &gt;&gt; k) &#123;</span><br><span class="line">		memset(dp, 0, sizeof(dp));</span><br><span class="line">		memset(sum, 0, sizeof(sum));</span><br><span class="line">		if (k == 1) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;Draw&quot; &lt;&lt; endl;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i = 1; i &lt; k; i++) &#123;</span><br><span class="line">			dp[i] = 1;</span><br><span class="line">			sum[i] = (sum[i - 1] + 1);</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i = k; i &lt;= r; i++) &#123;</span><br><span class="line">			dp[i] = (dp[i / k] * k + 1);</span><br><span class="line">			sum[i] = (sum[i - 1] + dp[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		if (abs(sum[r] - sum[l - 1]) % 2 == 1)</span><br><span class="line">			cout &lt;&lt; &quot;XHRlyb&quot; &lt;&lt; endl;</span><br><span class="line">		else</span><br><span class="line">			cout &lt;&lt; &quot;Cwbc&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>线性dp</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>陕西师范大学第七届程序设计竞赛题解</title>
    <url>/2018/05/14/2018-05-14/</url>
    <content><![CDATA[<h2 id="WWX的520"><a href="#WWX的520" class="headerlink" title="WWX的520"></a><a href="https://www.nowcoder.com/acm/contest/121/A" target="_blank" rel="noopener">WWX的520</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>520，因为谐音为我爱你，所以也被称之为表白日。</p>
<p>这一天，人们借机把藏在心底的洪荒之力通过表白、撒娇、传情、送礼、结婚等形式释放出来，商家也会趁势开展各类优惠促销活动，掀起一波或浪漫或虐狗的节日热浪。</p>
<p>这一天，也是送男朋友礼物、送女朋友礼物、送自己礼物、送亲朋好友礼物的好时机。</p>
<p>在520即将到来之际，wwx准备为她的女朋友购买一批礼物。于是他列出了一份礼物清单，但由于预算有限，必须删掉一种礼物。经过深思熟虑，他决定删掉价格第k高的礼物，你能帮帮他，找出是哪一种礼物吗?</p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行是一个整数T（1&lt;=T&lt;=80），表示有T组数据.</span><br><span class="line">对于每一组数据，首先一行输入N(3&lt;=N&lt;=1000)，接下来的N行每行输入一个字符串和一个整数，以空格间隔，分别作为每种礼物的名字和价格。</span><br><span class="line">接下来一行输入k，表示要删去第k(1&lt;=&lt;=N)高的礼物</span><br><span class="line">礼物的名字的长度不超过30，礼物的价格不超过1000，且均为整数。</span><br></pre></td></tr></table></figure>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于每组输入数据，依次输出它的组号和要删去的礼物的名字和价格,以空格间隔。</span><br><span class="line">若两种商品的价格相同，则比较礼物名字的字典序大小。即:两种礼物的价格相同时，字典序大者若为第k高，字典序小者则为第k+1高。</span><br></pre></td></tr></table></figure>
<p>示例1</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">Apple 18</span><br><span class="line">Book 30</span><br><span class="line">Milk 8000</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">Apple 300</span><br><span class="line">Bananas  200</span><br><span class="line">Bracelet 200</span><br><span class="line">Candy 200</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1: Apple 18</span><br><span class="line">#2: Bracelet 200</span><br></pre></td></tr></table></figure>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.</span><br><span class="line">可用strcmp(s1,s2)函数进行字符串的比较。</span><br><span class="line">2.</span><br><span class="line">对于样例一中第二组数据:Apple 300是价格第一大，Candy 200是价格第二高，Bracelet</span><br><span class="line">200是价格第三大。</span><br></pre></td></tr></table></figure>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>直接按照价格从大到小排序，如果价格相同按照字母序从大到小排序。排完序之后直接输出第k位的礼物名称与价格即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node &#123;</span><br><span class="line">	string str;</span><br><span class="line">	int v;</span><br><span class="line">&#125;a[1005];</span><br><span class="line">int cmp(node a, node b) &#123;</span><br><span class="line">	if (a.v == b.v) &#123;</span><br><span class="line">		return a.str&gt;b.str;</span><br><span class="line">	&#125;</span><br><span class="line">	return a.v&gt;b.v;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">	for (int z = 1; z &lt;= t; z++) &#123;</span><br><span class="line">		int n, k;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; a[i].str;</span><br><span class="line">			cin &gt;&gt; a[i].v;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a, a + n, cmp);</span><br><span class="line">		cin &gt;&gt; k;</span><br><span class="line">		cout &lt;&lt; &quot;#&quot; &lt;&lt; z &lt;&lt; &quot;: &quot; &lt;&lt; a[k - 1].str &lt;&lt; &quot; &quot; &lt;&lt; a[k - 1].v &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配环境"><a href="#配环境" class="headerlink" title="配环境"></a><a href="https://www.nowcoder.com/acm/contest/121/B" target="_blank" rel="noopener">配环境</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>​      黑猫在给校赛配环境，结果被服务器的各种入站规则出站规则搞得头疼，想到自己要上传GVIM、EMACS、VSCODE、Jetbrain全家桶、Visual Studio、Gedit、Microsoft Office Word、Eclipse等等，完全不知道要要花费多少时间才能上传完校赛需要的环境。 </p>
<p>​      黑猫跑去问ddjing，谁知道ddjing说：“我要去实习了，没功夫解决这个问题，你去问问其他人吧。“ </p>
<p>​      于是黑猫想请你帮他解决这个问题。 </p>
<p>​      服务器总传输速度为每秒M个单位（本题出现的所有单位都统一），黑猫现在需要上传总共n个软件（按优先级顺序从高到低给出），每个软件的大小分别为v1、v2….vn，每个软件为保持稳定连接，上传需要一个最小的传输速度为m1、m2…mn。 </p>
<p>​      服务器带宽分配的策略是：按优先级满足每一个软件要求的传输速度。如果服务器剩余的带宽不能满足某个软件最小传输速度的话，服务器将继续寻找下去，直到找到能满足最小传输速度的软件。 </p>
<p>​      如果目前服务器的总传输速度不能满足所有还需要上传的软件的话，服务器将把传输速度全部给予当前优先级最高的（即使不能满足其最小传输速度）。 </p>
<p>​      如果目前对所有软件都满足了其最小传输速度的话，服务器将把剩余所有传输速度全部给予当前优先级最高的软件。 </p>
<h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行给出一个正整数，表示服务器总带宽M</span><br><span class="line">第二行给出整数n，表示需要上传的n个软件。</span><br><span class="line">第三行为n个正整数，第i个数表示vi。</span><br><span class="line">第四行为n个正整数，第i个数表示mi。</span><br><span class="line">( 1 &lt;= M &lt;= 1000,  1 &lt;= n &lt;= 100 , 1 &lt;=  vi &lt;= 1000 ,  1 &lt;= mi &lt;= 1000 )</span><br></pre></td></tr></table></figure>
<h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出一行，为上传完毕所有软件所需要的时间，保留两位小数。</span><br></pre></td></tr></table></figure>
<p> 示例1 </p>
<h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">6</span><br><span class="line">1 1 4 5 1 4 </span><br><span class="line">10 9 8 7 6 5</span><br></pre></td></tr></table></figure>
<h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.60</span><br></pre></td></tr></table></figure>
<p> 示例2 </p>
<h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">6</span><br><span class="line">10 9 8 7 6 5</span><br><span class="line">1 1 4 5 1 4</span><br></pre></td></tr></table></figure>
<h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.50</span><br></pre></td></tr></table></figure>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>原本是一道水题，结果成功被题面绕进去了。其实只需要把所有软件的大小V加起来除以宽带大小M即可。所谓最小速度都是迷惑人的。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int M, n;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;M, &amp;n);</span><br><span class="line">	double tmp, ans = 0;</span><br><span class="line">	for (int i = 0; i &lt; n;i++) &#123;</span><br><span class="line">		scanf(&quot;%lf&quot;, &amp;tmp);</span><br><span class="line">		ans += tmp;</span><br><span class="line">	&#125;	</span><br><span class="line">	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%lf&quot;, &amp;tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	ans /= M;</span><br><span class="line">	printf(&quot;%.2lf\n&quot;, ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一段超时代码，成功将题面的过程给模拟了出来，当时没仔细看数据是怎么得到的，一直超时很不可思议。因此总结出了经验，以后做题一定得分析出数据是怎么得到的，有时候就很容易找到规律或者发现玄机。另外下面的代码总结出了一个新的方法，就是利用滚动数组实现删除元素，虽然vector有删除功能，但删除效率低。以下的方法是利用滚动数组，将未删除的元素重新压入数组，删除的元素不进行操作，然后清空数组，这样循环操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">int M, n;</span><br><span class="line">struct node&#123;</span><br><span class="line">	double v;</span><br><span class="line">	int m;</span><br><span class="line">&#125;a[1005];</span><br><span class="line">int vis[1005];</span><br><span class="line">vector&lt;int&gt;vv[2];</span><br><span class="line">int main() &#123;</span><br><span class="line">	cin &gt;&gt; M &gt;&gt; n;</span><br><span class="line">	double ans = 0, wei;</span><br><span class="line">	int ff[2] = &#123; 0,1 &#125;;</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; a[i].v;</span><br><span class="line">	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i].m;</span><br><span class="line">		vv[ff[0]].push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	int flag = 1;</span><br><span class="line">	while (flag &gt;= 0) &#123;</span><br><span class="line">		flag = -1;</span><br><span class="line">		wei = M;</span><br><span class="line">		double mint = inf;</span><br><span class="line">		vv[ff[1]].clear();</span><br><span class="line">		vector&lt;int&gt;::iterator it;</span><br><span class="line">		for (it = vv[ff[0]].begin(); it != vv[ff[0]].end(); it++) &#123;</span><br><span class="line">			if (a[*it].v &lt;= 0) &#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;			vis[*it] = 0;</span><br><span class="line">			vv[ff[1]].push_back(*it);</span><br><span class="line">			if (flag &lt; 0)</span><br><span class="line">				flag = *it;</span><br><span class="line">			if (a[*it].v &lt;= wei) &#123;</span><br><span class="line">				vis[*it] = 1;</span><br><span class="line">				wei -= a[*it].m;</span><br><span class="line">				if (*it != flag)</span><br><span class="line">					mint = min(mint, a[*it].v / a[*it].m);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag &lt; 0)</span><br><span class="line">			break;</span><br><span class="line">		mint = min(mint, a[flag].v / (vis[flag] ? a[flag].m + wei : wei));</span><br><span class="line">		for (it = vv[ff[1]].begin(); it != vv[ff[1]].end(); it++) &#123;</span><br><span class="line">			if (a[*it].v &lt;= 0 || !vis[*it] || flag == *it)</span><br><span class="line">				continue;</span><br><span class="line">			a[*it].v -= a[*it].m*mint;</span><br><span class="line">		&#125;</span><br><span class="line">		a[flag].v -= (vis[flag] ? a[flag].m + wei : wei)*mint;</span><br><span class="line">		ans += mint;</span><br><span class="line">		ff[0] = ff[0] ^ ff[1];</span><br><span class="line">		ff[1] = ff[0] ^ ff[1];</span><br><span class="line">		ff[0] = ff[0] ^ ff[1];</span><br><span class="line">		//cout &lt;&lt; flag &lt;&lt; &quot; &quot; &lt;&lt; mint &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%.2lf\n&quot;, ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="iko和她的糖"><a href="#iko和她的糖" class="headerlink" title="iko和她的糖"></a><a href="https://www.nowcoder.com/acm/contest/121/C" target="_blank" rel="noopener">iko和她的糖</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>​      iko超级超级喜欢吃糖，有一天iko想出去玩，她计划从1点走到N点（按1,2,3，…，n的顺序走），每个点都有一个补给站，第i点的补给站有a[i]颗糖，从i点走到i+1点会消耗掉b[i]颗糖，iko在出游的途中可以选择三个补给站，iko想知道她走完全程到达N点时口袋里最多还能剩下几颗糖（初始时iko的口袋里一颗糖都没有）。 </p>
<h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行输入N（3&lt;=N&lt;=1000）</span><br><span class="line">第二行输入N个数代表a[1].......a[N]  (0&lt;=a[i]&lt;=1000 )</span><br><span class="line">第三行输入N-1个数代表b[1]......b[N-1]  ( 1&lt;=b[i]&lt;=1000 )</span><br></pre></td></tr></table></figure>
<h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出一个数字表示iko到达n点时口袋里最多剩下的糖，</span><br><span class="line">若不能到达N点输出-1。</span><br></pre></td></tr></table></figure>
<p> 示例1 </p>
<h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 3 4</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>
<h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure>
<p> 示例2 </p>
<h3 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 5 2 4</span><br><span class="line">3 2 2 2</span><br></pre></td></tr></table></figure>
<h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>首先，3个补给站必须得选择第1个，因为一开始没有糖，而每条路都需要消耗糖，所以必须拿起点的糖。之后就很好理解了，每走一条路记录当前走过的补给站最大的两个，如果哪一条路糖果不够了，就把最大的补给站加上，如果还不够就把次大的也加上。每次记录走到这条路经过的最大补给站记录下来，然后现有糖果减去消耗的糖果，如果为负就把之前的最大补给站的糖果加上。例如第2组数据，初始是3，走到第1条路剩余糖果为0，此时记录的最大补给站是4，然后走到下一条路糖果变成了-2，那就把最大补给站的加上，现在剩余糖果是2。此时最大补给站记录5，再往下走是2，剩余糖果是0，继续走，消耗2个为-2，则加上最大补给站的糖5。最终就是3。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1005;</span><br><span class="line">int N, cur, MAX1, MAX2, flag, a[maxn];</span><br><span class="line">void check(int &amp;cnt) &#123;</span><br><span class="line">	while (cnt&amp;&amp;cur &lt; 0) &#123;</span><br><span class="line">		cur += MAX1;</span><br><span class="line">		MAX1 = MAX2;</span><br><span class="line">		cnt--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void fun(int i) &#123;</span><br><span class="line">	if (MAX1 &lt;= a[i]) &#123;</span><br><span class="line">		MAX2 = MAX1;</span><br><span class="line">		MAX1 = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	else if (MAX2 &lt; a[i]) &#123;</span><br><span class="line">		MAX2 = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (cin &gt;&gt; N) &#123;</span><br><span class="line">		memset(a, 0, sizeof(a));</span><br><span class="line">		MAX1 = -1, MAX2 = -1, flag = 0;</span><br><span class="line">		int tmp, cnt = 3;</span><br><span class="line">		cur = 0;</span><br><span class="line">		for (int i = 0; i &lt; N; i++)</span><br><span class="line">			cin &gt;&gt; a[i];</span><br><span class="line">		for (int i = 0; i &lt; N - 1; i++) &#123;</span><br><span class="line">			fun(i);</span><br><span class="line">			cin &gt;&gt; tmp;</span><br><span class="line">			cur -= tmp;</span><br><span class="line">			if (cur &lt; 0) &#123;</span><br><span class="line">				check(cnt);</span><br><span class="line">			&#125;</span><br><span class="line">			if (cur &lt; 0)</span><br><span class="line">				flag = 1;</span><br><span class="line">		&#125;</span><br><span class="line">		fun(N - 1);</span><br><span class="line">		if (flag)</span><br><span class="line">			printf(&quot;-1\n&quot;);</span><br><span class="line">		else &#123;</span><br><span class="line">			if (cnt == 2)</span><br><span class="line">				cur += MAX1 + MAX2;</span><br><span class="line">			else if (cnt == 1)</span><br><span class="line">				cur += MAX1;</span><br><span class="line">			printf(&quot;%d\n&quot;, cur);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ZQ的睡前故事"><a href="#ZQ的睡前故事" class="headerlink" title="ZQ的睡前故事"></a><a href="https://www.nowcoder.com/acm/contest/121/D" target="_blank" rel="noopener">ZQ的睡前故事</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>​      ZQ是一个拥有n女朋友的万人迷，她的每一个女朋友每天晚上都会挨个给他打电话，要他讲了睡前故事才能睡觉。可是，每次他的女朋友都会挑他在吃鸡的时候打电话，ZQ总是因为挂机被舍友赶出宿舍，于是，ZQ告诉他的女朋友们，别打电话了，他会主动打过去给他们讲故事，再打电话就分手！ </p>
<p>​      于是，ZQ把他的女朋友名字写在纸上，画成一圈，顺时针编号为1~n，然后从1开始顺时针数。在每一次数数中，ZQ数k个就停下来，然后给选中的女朋友打电话讲故事。   </p>
<h3 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先输入一个t，然后t组数据，每行包含两个数字n,k，n&lt;20,k&gt;0</span><br></pre></td></tr></table></figure>
<h3 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">按顺序输出每轮被选中的女朋友的编号。</span><br></pre></td></tr></table></figure>
<p> 示例1 </p>
<h3 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10 3</span><br><span class="line">5 2</span><br><span class="line">11 4</span><br></pre></td></tr></table></figure>
<h3 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 6 9 2 7 1 8 5 10 4</span><br><span class="line">2 4 1 5 3</span><br><span class="line">4 8 1 6 11 7 3 2 5 10 9</span><br></pre></td></tr></table></figure>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>约瑟夫环。由于数据比较水，所以多种方法求解，这里不介绍了。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, k, t;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">	while (t--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span><br><span class="line">		int i = 0;</span><br><span class="line">		int cnt = n;</span><br><span class="line">		int vis[20] = &#123; 0 &#125;;</span><br><span class="line">		while (cnt) &#123;</span><br><span class="line">			int kk = k;</span><br><span class="line">			while (vis[i%n])</span><br><span class="line">				i++;</span><br><span class="line">			for (int j = 1; j &lt; kk; j++) &#123;</span><br><span class="line">				i++;</span><br><span class="line">				while (vis[i%n])</span><br><span class="line">					i++;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[i%n] = 1;</span><br><span class="line">			cnt--;</span><br><span class="line">			cnt ? printf(&quot;%d &quot;, i%n + 1) : printf(&quot;%d\n&quot;, i%n + 1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="附加：hdu5135-Little-Zu-Chongzhi’s-Triangles"><a href="#附加：hdu5135-Little-Zu-Chongzhi’s-Triangles" class="headerlink" title="附加：hdu5135 Little Zu Chongzhi’s Triangles"></a>附加：hdu5135 Little Zu Chongzhi’s Triangles</h2><p>题意：</p>
<p>有n条边组三角形，每个三角形必须由3条边组成，三角形边不可以重复利用，不可以共线，只能是分开的三角形。问这n条边组成的所有三角形的面积和最大为多少。</p>
<h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>原本状压dp求解，但数据比较水，因此递归还没有记忆化搜索直接就过了。每次从n条边里面选择3条边组成三角形，方程maxx[i],[j] = max(maxx[i-1],[j],[1~n] );由于状态是集合，因此需要状压以下。这里主要说的是一个常犯的错误。我没找到vis是当前状态是否已经选过，尤其是搜索时vis的作用非常重要。但本题用深搜时犯了一个错误，就是在vis=1,与vis=0之间多了一个continue，即vis=1，continue，dfs，vis=0，导致状态更改，数据一直错误。正确顺序应该是continue，vis=1，dfs，vis=0。因此之后比赛时一定要注意此细节。在vis=1与vis=0之间一定要注意是否有其他条件导致循环结束而状态还未还原。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int vis[15];</span><br><span class="line">double a[15];</span><br><span class="line">double dfs(int x) &#123;</span><br><span class="line">	double ans = 0, maxx = 0;</span><br><span class="line">	for (int i = x; i&lt;n; i++) &#123;</span><br><span class="line">		if (vis[i])</span><br><span class="line">			continue;</span><br><span class="line">		vis[i] = 1;</span><br><span class="line">		for (int j = i + 1; j&lt; n; j++) &#123;</span><br><span class="line">			if (vis[j])</span><br><span class="line">				continue;</span><br><span class="line">			vis[j] = 1;</span><br><span class="line">			for (int k = j + 1; k&lt;n; k++) &#123;</span><br><span class="line">				if (vis[k])</span><br><span class="line">					continue;</span><br><span class="line">				if (a[k] &gt;= a[i] + a[j] || a[j] &gt;= a[i] + a[k] || a[i] &gt;= a[j] + a[k])</span><br><span class="line">					continue;</span><br><span class="line">				vis[k] = 1;</span><br><span class="line">				double c = (a[i] + a[k] + a[j]) / 2.0;</span><br><span class="line">				ans = sqrt(c*(c - a[i])*(c - a[j])*(c - a[k]));</span><br><span class="line">				ans += dfs(i + 1);</span><br><span class="line">				maxx = max(maxx, ans);</span><br><span class="line"></span><br><span class="line">				vis[k] = 0;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[j] = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[i] = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return maxx;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (cin &gt;&gt; n) &#123;</span><br><span class="line">		if (!n)</span><br><span class="line">			break;</span><br><span class="line">		memset(a, 0, sizeof(a));</span><br><span class="line">		for (int i = 0; i&lt;n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		double ans = dfs(0);</span><br><span class="line">		printf(&quot;%.2lf\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title>2018计蒜之道初赛第一场A题百度无人车</title>
    <url>/2018/05/12/2018-05-12/</url>
    <content><![CDATA[<h2 id="百度无人车"><a href="#百度无人车" class="headerlink" title="百度无人车"></a><a href="https://nanti.jisuanke.com/t/26980" target="_blank" rel="noopener">百度无人车</a></h2><p>百度一共制造了 n 辆无人车，其中第 ii 辆车的重量为 a_i\ \mathrm{kg}ai kg。</p>
<p>由于车辆过重会增大轮胎的磨损程度，现在要给这 n 辆车减轻重量。每将一辆车减轻 1\ \mathrm{kg}1 kg需要消耗 p 万百度币，总预算为 s 万百度币。</p>
<p>现在希望你设计一种最优的减重方案，使得最重的车辆的重量是所有减重方案中最小的。任何时候，每辆车的重量必须大于等于 1\ \mathrm{kg}1 kg。并且减重方案只能减轻整数 \mathrm{kg}kg。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入一个整数 n，表示百度无人车的数量。</p>
<p>接下来一行输入 n 个整数，其中第 ii 个整数 a_iai表示第 ii 辆车的重量。</p>
<p>接着一行输入两个整数 p,s，分别表示把一辆车减重 1\ \mathrm{kg}1 kg 需要花费 p 万百度币，总的预算是 s 万百度币。</p>
<p>保证 1 \le n \le 200001≤n≤20000，1 \le a_i \le 200001≤ai≤20000，1 \le p \le 200001≤p≤20000，1 \le s \le 10^{18}1≤s≤1018。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示经过你设计的最优减重方案后，最重的车辆的重量是多少 \mathrm{kg}kg。</p>
<h4 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">6 7 8 9</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>
<h4 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<h4 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">11 14 6 13 11</span><br><span class="line">4 68</span><br></pre></td></tr></table></figure>
<h4 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>每1kg消耗p元，一共s元，因此一共可以减s/p（kg），直接s=s/p就行了。先对整个数组进行排序，然后再进行操作。一开始用二分，时间复杂度Onlogn，通不过，因此换了一种线性的方法，时间复杂度On。首先建一个差分数组，储存该元素和前一个元素的差值。以1， 2， 4， 6， 9为例，差分数组为1,1,2,2,3。然后从后往前操作。假设s=s/p之后s为10，首先s与第n个元素差分数组比较，如果大，则s-3=7。再和第n-1比较，由于该位置后面还有一个元素，因此若要改变该元素使最大值变小，需同时改变这两个数，后面以此类推三个四个数等等。s和b[n-1]<em>2即2 </em> 2比较，大，则s=7-2<em>2=3。再和b[n-2] </em> 3比较。比它小，则证明最大部分再该部分。b[n-2]=b[n-2]-s/3即1，结束循环。现在的差分数组为1,1,1,0,0，现在依次从从b[1]加到b[n就好了，即3。另外由于最小值为1，因此需要对第一个元素特判一下，如果小于1需改为1。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 200007;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int a[maxn], b[maxn];</span><br><span class="line">ll p, s, n;</span><br><span class="line">int main() &#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	a[0] = 0;</span><br><span class="line">	for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a + 1, a + n + 1);</span><br><span class="line">	for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">		b[i] = a[i] - a[i - 1];</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; p &gt;&gt; s;</span><br><span class="line">	s /= p;</span><br><span class="line">	ll ans = 0;</span><br><span class="line">	for (int i = n; i&gt;0; i--) &#123;</span><br><span class="line">		if (s &gt;= b[i] * (n - i + 1)) &#123;</span><br><span class="line">			s -= b[i] * (n - i + 1);</span><br><span class="line">			b[i] = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			b[i] -= s / (n - i + 1);</span><br><span class="line">			for (int j = 2; j &lt;= i; j++)</span><br><span class="line">				ans += b[j];</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (i == 1 &amp;&amp; b[i] &lt;= 1)</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	if (b[1] &lt;= 1)</span><br><span class="line">		b[1] = 1;</span><br><span class="line">	ans += b[1];</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>贪心</tag>
        <tag>差分数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Wannafly挑战赛15</title>
    <url>/2018/05/11/2018-05-11/</url>
    <content><![CDATA[<h2 id="最小化价格"><a href="#最小化价格" class="headerlink" title="最小化价格"></a>最小化价格</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>  要求一种方式，使得每组人都到一个各不相同的地点，最小化选择的价格 </p>
<p>  每个队伍的人都要在同一个地方每个地方只能有一个队伍</p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行n,m</span><br><span class="line">第二行n个数，表示每组的人数</span><br><span class="line">接下来m行，每行两个数，表示可容纳的最大人数和选择的价格</span><br></pre></td></tr></table></figure>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出最小化选择的价格，无解输出-1</span><br></pre></td></tr></table></figure>
<p>示例1</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">2 3 4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所有数据小于1e5</span><br></pre></td></tr></table></figure>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先对地点以价格从小到大排序，如果相同按容量从小到大排序。由于集合每次插入自动排序，而且可以执行删除操作，因此我们可以用集合储存队伍。然后将队伍放入集合中。对排完序的地点进行遍历，每个地点对容量进行判断，直接对集合up_bound-1操作，就是能被该地点容纳的人数最多的队伍。若存在该队伍，将该队伍从集合中删除，意为该队伍匹配到该地点。然后将总价格加上该地点所需的价格。否则不执行操作，意为当前没有队伍能和该地点匹配。最后对集合判断是否为空，若为空，则证明队伍已经匹配完毕，输出总价格即可，否则意为不是所有队伍都能被容纳，输出-1。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int const maxn = 100020;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int pri;</span><br><span class="line">	int num;</span><br><span class="line">&#125;loc[maxn];</span><br><span class="line">int cmp(node a, node b) &#123;</span><br><span class="line">	if (a.pri == b.pri)</span><br><span class="line">		return a.num &lt; b.num;</span><br><span class="line">	else</span><br><span class="line">		return a.pri &lt; b.pri;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, m, tmp, ans = 0;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	multiset&lt;int&gt;a;</span><br><span class="line">	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; tmp;</span><br><span class="line">		a.insert(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">		cin &gt;&gt; loc[i].num &gt;&gt; loc[i].pri;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(loc, loc + m, cmp);</span><br><span class="line">	multiset&lt;int&gt;::iterator it;</span><br><span class="line">	for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">		if (a.empty())</span><br><span class="line">			break;</span><br><span class="line">		it = a.upper_bound(loc[i].num);</span><br><span class="line">		if (it == a.begin())</span><br><span class="line">			continue;</span><br><span class="line">		it--;</span><br><span class="line">		ans += loc[i].pri;</span><br><span class="line">		a.erase(it);</span><br><span class="line">	&#125;</span><br><span class="line">	if (a.empty())</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	else</span><br><span class="line">		cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="车辆安排"><a href="#车辆安排" class="headerlink" title="车辆安排"></a>车辆安排</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>有n个队伍，每个队伍的人数小于等于5，每辆车最多坐5个人，要求一个队伍的人都在一辆车上，求最少的车数</p>
<h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行n</span><br><span class="line">第二行n个数，表示每个队伍的人数</span><br></pre></td></tr></table></figure>
<h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出最少车数</span><br></pre></td></tr></table></figure>
<p>示例1</p>
<h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3 4 5</span><br></pre></td></tr></table></figure>
<h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="备注-1"><a href="#备注-1" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n≤1e5</span><br><span class="line">每个数小于等于5</span><br></pre></td></tr></table></figure>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>设置一个数组，分别储存1,2,3,4,5人队伍的个数。总车数=人数为5的队伍数+（人数为4+1或4的队伍数）+（人数为3+2或3+1+1或3的队伍数）+（人数为2+2+1或2+1+1+1或2的队伍数）+（人数为1*5或1的队伍数），（组合方式按优先级排列）。时间复杂度O(1)。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, tmp;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	int a[6] = &#123; 0 &#125;, sum = 0;</span><br><span class="line">	while (n--) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;tmp);</span><br><span class="line">		a[tmp]++;</span><br><span class="line">	&#125;</span><br><span class="line">	sum += a[5] + a[4] + a[3];</span><br><span class="line">	a[1] = a[1] - a[4];</span><br><span class="line">	if (a[3] - a[2] &gt; 0)</span><br><span class="line">		a[1] -= 2 * (a[3] - a[2]);</span><br><span class="line">	a[2] -= a[3];</span><br><span class="line">	if (a[2] &lt; 0)</span><br><span class="line">		a[2] = 0;</span><br><span class="line">	a[1] -= a[2] / 2;</span><br><span class="line">	if (a[2] % 2 == 0) &#123;</span><br><span class="line">		sum += a[2] / 2;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		sum += a[2] / 2 + 1;</span><br><span class="line">		a[1] -= 3;</span><br><span class="line">	&#125;</span><br><span class="line">	if (a[1] &lt; 0)</span><br><span class="line">		a[1] = 0;</span><br><span class="line">	a[1] % 5 == 0 ? sum += a[1] / 5 : sum += a[1] / 5 + 1;</span><br><span class="line">	printf(&quot;%d\n&quot;, sum);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>约瑟夫问题(约瑟夫问题)，n个人，1 2报数 1出队( 就是体育课的时候1 2报数 1出队，2留下)，q次询问，每次求第x个人是第几个出队的</p>
<h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行两个数n,q</span><br><span class="line">接下来q行，每行一个数x，表示询问</span><br></pre></td></tr></table></figure>
<h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一行输出一个询问的答案</span><br></pre></td></tr></table></figure>
<p>示例1</p>
<h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 4围成一圈，第一轮：1 2报数，1出队，2留下，3出队，4留下，第二轮，2出队，4留下</span><br></pre></td></tr></table></figure>
<h3 id="备注-2"><a href="#备注-2" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">q≤500000</span><br><span class="line">n和x≤1e18</span><br></pre></td></tr></table></figure>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll unsigned long long int</span><br><span class="line">map&lt;ll, ll&gt;ma;</span><br><span class="line">vector&lt;ll&gt;v;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, q , cnt;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	ma[1] = 1;</span><br><span class="line">	cnt = 1;</span><br><span class="line">	for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">		if (i % 2 == 0)</span><br><span class="line">			v.push_back(i);</span><br><span class="line">		else &#123;</span><br><span class="line">			ma[i] = ++cnt;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll it = 0;</span><br><span class="line">	if (n % 2)</span><br><span class="line">		it++;</span><br><span class="line">	while (!v.empty()) &#123;</span><br><span class="line">		if (it == v.size())</span><br><span class="line">			it = 0;</span><br><span class="line">		ma[*(v.begin() + it)] = ++cnt;</span><br><span class="line">		v.erase(v.begin() + it);</span><br><span class="line">		if (v.empty())</span><br><span class="line">			break;</span><br><span class="line">		if (it == v.size())</span><br><span class="line">			it = 0;</span><br><span class="line">		it++;</span><br><span class="line">	&#125;</span><br><span class="line">	while (q--) &#123;</span><br><span class="line">		int x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		cout &lt;&lt; ma[x] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>wannafly</tag>
      </tags>
  </entry>
  <entry>
    <title>[计算几何]二维计算几何基础</title>
    <url>/2018/05/09/2018-05-09/</url>
    <content><![CDATA[<p>三寸青笺，写不尽对你的思念。——随笔</p>
<p>用解析几何借助计算机处理几何问题存在着两大缺陷：</p>
<p>1）方程解的情况复杂，例如Ax+By+C=0；</p>
<p>2）存在着浮点误差积累。</p>
<p>计算几何采用了介于代数与几何之间的方式解决几何问题。它利用几何特性辅助简单的代数运算解决几何问题，既能精确求解，有提高了算法效率，并且不失几何的优美特性。</p>
<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><h3 id="向量-1"><a href="#向量-1" class="headerlink" title="向量"></a>向量</h3><p>向量：既有大小又有方向的量。</p>
<h4 id="向量的比较"><a href="#向量的比较" class="headerlink" title="向量的比较"></a>向量的比较</h4><p>在平面坐标系下，某点的坐标用（x，y）表示，向量和点一样，也可以用x,y表示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Point&#123;	//点</span><br><span class="line">    double x,y;</span><br><span class="line">    Point(double x=0,double y=0):x(x),y(y) &#123;&#125;	//构造函数方便代码编写</span><br><span class="line">&#125;;</span><br><span class="line">typedef Point Vector;	//向量。从程序实现上，Vector只是Point的别名</span><br></pre></td></tr></table></figure>
<h4 id="向量的加减乘除"><a href="#向量的加减乘除" class="headerlink" title="向量的加减乘除"></a>向量的加减乘除</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//向量+向量=向量，点+向量=点</span><br><span class="line">Vector operator + (Vector A, Vector B) &#123;</span><br><span class="line">	return Vector(A.x + B.x, A.y + B.y);</span><br><span class="line">&#125;</span><br><span class="line">//点-点=向量</span><br><span class="line">Vector operator - (Point A, Point B) &#123;</span><br><span class="line">	return Vector(A.x - B.x, A.y - B.y);</span><br><span class="line">&#125;</span><br><span class="line">//向量*数=向量</span><br><span class="line">Vector operator * (Vector A, double p) &#123;</span><br><span class="line">	return Vector(A.x * p, A.y * p);</span><br><span class="line">&#125;</span><br><span class="line">//向量/数=向量</span><br><span class="line">Vector operator / (Vector A, double p) &#123;</span><br><span class="line">	return Vector(A.x / p, A.y / p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="向量的比较-1"><a href="#向量的比较-1" class="headerlink" title="向量的比较"></a>向量的比较</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool operator &lt; (const Point&amp; a, const Point&amp; b) &#123;</span><br><span class="line">	return a.x &lt; b.x || (a.x == b.x&amp;&amp;a.y &lt; b.y);</span><br><span class="line">&#125;</span><br><span class="line">//减下误差的必要比较</span><br><span class="line">const double eps=1e-8;</span><br><span class="line">int dcmp(double x)</span><br><span class="line">&#123;</span><br><span class="line">    if(fabs(x)&lt;eps) return 0;</span><br><span class="line">    if(x&gt;0) return 1;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">bool operator ==(const point&amp; a,const point&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    return dcmp(a.x-b.x)==0&amp;&amp;dcmp(a.y-b.y)==0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面的“相等”函数用到“三态函数”dcmp,减少了精度问题。另外，向量有一个所谓的“极角”，即从x轴正半轴旋转到该向量方向所需要的角度。C标注库里的atan2函数就是用来求极角的。如向量（x,y）的极角就是atan2（y，x）（单位：弧度）</p>
<h3 id="向量內积（点积）"><a href="#向量內积（点积）" class="headerlink" title="向量內积（点积）"></a>向量內积（点积）</h3><p>点积，向量α和β的点积等于二者长度的乘积再乘上它们夹角的余弦。当夹角大于90°时点积为负。两向量的点积为一个标量 α·β，它的大小为α·β=|α||β|cosθ，其中θ是&lt;α,β&gt;</p>
<p>余弦为偶函数，因此点积满足交换率。如果两向量垂直，点积为0。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/%E7%82%B9%E7%A7%AF%E5%85%AC%E5%BC%8F.png" alt></p>
<h4 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h4><p>α在β的投影α’与β的长度乘积</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/%E7%82%B9%E7%A7%AF%E5%9B%BE%E7%A4%BA.png" alt></p>
<p>由定义易知当两向量夹角为锐角时点积值为正，夹角钝角为负，垂直为0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double dot(Vector A,Vector B)&#123;    //向量点积</span><br><span class="line">    return A.x*B.x+A.y*B.y;</span><br><span class="line">&#125;</span><br><span class="line">double Length(Vector A)&#123;    //向量A长度</span><br><span class="line">    return sqrt(dot(A,A));</span><br><span class="line">&#125;</span><br><span class="line">double angle(Vector A,Vector B)&#123;    //向量A和B夹角</span><br><span class="line">    return acos(dot(A,B)/Length(A)/Length(B));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="向量外积（叉积）"><a href="#向量外积（叉积）" class="headerlink" title="向量外积（叉积）"></a>向量外积（叉积）</h3><p>简单地说，两个向量u和w得叉积等于u和w组成的三角形的有向面积的两倍。</p>
<p>叉积的二维意义—-有向面积：外积大小为由u，w这两个向量围成的平行四边形有向面积。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/%E5%8F%89%E7%A7%AF%E5%9B%BE%E7%A4%BA.png" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/%E5%8F%89%E7%A7%AF%E5%85%AC%E5%BC%8F.png" alt></p>
<p>两向量的叉积为一个矢量 a×b，设向量 P(x1,y1),Q(x2,y2)，向量 a 和向量 b 的叉积还是一个向量，长度为|PQ|=x1y2-x2y1;即为向量 P,Q 围成的四边形的面积。它的方向与向量PQ 垂直，并且使(P,Q,P×Q)成右手系。 </p>
<h4 id="几何意义-1"><a href="#几何意义-1" class="headerlink" title="几何意义"></a>几何意义</h4><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/%E5%8F%89%E7%A7%AF%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89.png" alt></p>
<p>不难发现，叉积不满足交换率，cross（u，w）=-corss（w，u）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double cross(Vector A,Vector B)  //叉积</span><br><span class="line">&#123;</span><br><span class="line">    return A.x*B.y-A.y*B.x;</span><br><span class="line">&#125;</span><br><span class="line">double area(point A,point B,point C)	//已知三个点 p0,p1,p2 的叉积函数</span><br><span class="line">&#123;</span><br><span class="line">    return cross(B-A,C-A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>叉积的一个重要性质，判断两向量互相之间的顺逆时针关系。<br>若 P×Q&gt;0，则P在Q 的顺时针方向；<br>若 P×Q&lt;0，则P在Q 的逆时针方向；<br>若 P×Q=0，则P和Q 共线，但可能同向也可能反向；</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/5-9-1.png" alt></p>
<p>利用这一性质，可以将一个多边形的顶点按照顺时针或者逆时针方向排序，这就是极角排序。利用 sort 或者 qsort 函数，自己定义 cmp 函数即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//逆时针极角排序比较函数(double) </span><br><span class="line">bool cmp(const point &amp;a, const point &amp;b) &#123; </span><br><span class="line">double x = atan2(a.y, a.x), y = atan2(b.y, b.x); </span><br><span class="line">return x &lt; y; </span><br><span class="line">&#125; </span><br><span class="line">//象限极角排序比较函数(int)，不失精度 </span><br><span class="line">int cross(point p1,point p2,point p0)&#123; </span><br><span class="line">return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y); </span><br><span class="line">&#125; </span><br><span class="line">sort(p+1,p+n,cmp);</span><br></pre></td></tr></table></figure>
<h3 id="两向量的位置关系"><a href="#两向量的位置关系" class="headerlink" title="两向量的位置关系"></a>两向量的位置关系</h3><p>把叉积和点积组合在一起，很容易判断两向量的位置关系。如图所示，括号第一个数是点积的符号，第二个是叉积的符号。第一个向量u总是向右，另一个向量w的各种情况都包含在了图中。比如当w的中点在下图左上方的第二象限时点积为负担叉积均为正，用（-，+）表示。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/5-9-2.png" alt></p>
<h2 id="点和直线"><a href="#点和直线" class="headerlink" title="点和直线"></a>点和直线</h2><h3 id="点到直线的距离"><a href="#点到直线的距离" class="headerlink" title="点到直线的距离"></a>点到直线的距离</h3><p>点到直线的距离是一个常用函数，可以用叉积求出，即用平行四边形的面积除以底。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double DistoLine(point P,point A,point B) //点p到直线AB距离</span><br><span class="line">&#123;</span><br><span class="line">    Vector v1=B-A,v2=P-A;</span><br><span class="line">    return fabs(cross(v1,v2))/Length(v1);	//如果不取绝对值，得到的是有向距离</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="点到线段的距离"><a href="#点到线段的距离" class="headerlink" title="点到线段的距离"></a>点到线段的距离</h3><p>点到线段有两种可能：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-11-%E7%82%B9%E5%88%B0%E7%BA%BF%E6%AE%B5%E8%B7%9D%E7%A6%BB.png" alt></p>
<p>简单地说，设投影点为Q，如果Q在线段AB上，则所求距离就是P点直线AB的距离（右）。如果Q在射线BA上，则所求为PA距离；否则为PB距离。判断Q的位置可以用点积进行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double DistoSegment(point P,point A,point B)&#123;</span><br><span class="line">    if(A==B) return Length(P-A);</span><br><span class="line">    Vector v1=B-A,v2=P-A,v3=P-B;</span><br><span class="line">    if(dcmp(dot(v1,v2))&lt;0) return Length(v2);</span><br><span class="line">    if(dcmp(dot(v1,v3))&gt;0) return Length(v3);</span><br><span class="line">    return fabs(cross(v1,v2))/Length(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断点是否在线段上"><a href="#判断点是否在线段上" class="headerlink" title="判断点是否在线段上"></a>判断点是否在线段上</h4><p>判断点 Q 在线段 P1P2 上的两条依据：<br>①(Q-P1)*(P2-P1)=0;<br>②Q 在以 P1,P2 为对角顶点的矩形内。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool onSegment(point p1,point p2,point Q)&#123;</span><br><span class="line">if( (Q.x-p1.x)*(p2.y-p1.y)==(p2.x-p1.x)*(Q.y-p1.y)&amp;&amp;min(p1.x,p2.x)&lt;=Q.x&amp;&amp;Q.x&lt;=max(p1.x,p2.x)&amp;&amp;min(p1.y,p2.y)&lt;=Q.y&amp;&amp;Q.y&lt;= max(p1.y,p2.y) )</span><br><span class="line">return 1;</span><br><span class="line">else return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线段相交"><a href="#线段相交" class="headerlink" title="线段相交"></a>线段相交</h3><p>最为直观的想法：解析几何法</p>
<p>弊端：运算误差大，运算次数多</p>
<p>误差来源：浮点运算</p>
<p>另外，编程难度事实上也很大（区域判断）</p>
<p>计算几何做法：运用叉积点积和位置关系</p>
<h4 id="线段规范相交"><a href="#线段规范相交" class="headerlink" title="线段规范相交"></a>线段规范相交</h4><p>定义线段规范相交为两线段相交恰好有一个公共点且不是任一线段的端点</p>
<p>充要条件：每条线段的两个端点都在另一条线段的两侧</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-11-%E8%A7%84%E8%8C%83%E7%9B%B8%E4%BA%A4%E4%B8%8E%E9%9D%9E%E8%A7%84%E8%8C%83%E7%9B%B8%E4%BA%A4.png" alt></p>
<p>只有（1）是规范相交，其它是非规范相交。非规范相交的情况还有很多。</p>
<h5 id="跨立实验"><a href="#跨立实验" class="headerlink" title="跨立实验"></a>跨立实验</h5><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-11-%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C.png" alt></p>
<h5 id="规范相交"><a href="#规范相交" class="headerlink" title="规范相交"></a>规范相交</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool SegmentItersection(point a1, point a2, point b1, point b2)</span><br><span class="line">&#123;</span><br><span class="line">    double c1 = cross(a2-a1, b1-a1), c2 = cross(a2-a1, b2-a1),</span><br><span class="line">    c3 = cross(b2-b1, a1-b1), c4 = cross(b2-b1, a2-b1);</span><br><span class="line">    return dcmp(c1)*dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3)*dcmp(c4) &lt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线段相交-1"><a href="#线段相交-1" class="headerlink" title="线段相交"></a>线段相交</h5><p>如果允许在端点处相交怎么办？</p>
<p>首先可能共线重叠</p>
<p>其次就是交点是端点</p>
<p>如果交点是端点</p>
<p>就判断几次点是否在线段上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//判断点p是否在线段a1 a2上</span><br><span class="line">bool OnSegment(point p,point a1,point a2)</span><br><span class="line">&#123;</span><br><span class="line">  return dcmp(cross(a1-p,a2-p))==0&amp;&amp;dcmp(dot(a1-p,a2-p))&lt;0; //线段包含端点时改成&lt;=</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多边形问题"><a href="#多边形问题" class="headerlink" title="多边形问题"></a>多边形问题</h2><h3 id="多边形面积"><a href="#多边形面积" class="headerlink" title="多边形面积"></a>多边形面积</h3><p>两向量的叉积的几何意义是以这两个向量为邻边的平行四边形的有向面积，我们可以利用这一点来求简单多边形的面积。所谓简单多边形就是任何不相邻的两条边都没有交点，包括凸多边形和凹多边形。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-11-%E5%87%B8.png" alt><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-11-%E5%87%B9.png" alt></p>
<p>求下面多边形的面积，已知个顶点的坐标。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-11-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF.png" alt></p>
<p>注意：在引入叉积后，面积就可以为负值，就有了“负面积”的概念。“负面积”方便了我们的运算。</p>
<p>可以取p[0]点为划分顶点，一方面可以少算两个叉积（0和任何向量的叉积都等于0），另一方面也减少乘法溢出的可能性，还不用特殊处理（i=n-1时，下一个顶点p[0]而不是p[n]，因为p[n]不存在）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//取p[0]为划分顶点</span><br><span class="line">double PolygonArea(vector&lt;Point&gt; p) &#123;</span><br><span class="line">  int n = p.size();</span><br><span class="line">  double area = 0;</span><br><span class="line">  for(int i = 1; i &lt; n-1; i++)</span><br><span class="line">    area += Cross(p[i]-p[0], p[i+1]-p[0]);</span><br><span class="line">  return area/2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以取坐标原点为划分点，乘法次数减少。</p>
<h3 id="点在多边形内外判断"><a href="#点在多边形内外判断" class="headerlink" title="点在多边形内外判断"></a>点在多边形内外判断</h3><h4 id="判断点是否在三角形内"><a href="#判断点是否在三角形内" class="headerlink" title="判断点是否在三角形内"></a>判断点是否在三角形内</h4><p>点 P 在三角形 ABC 内部常用的又两种方法，面积法和叉积法，面积法即为 </p>
<p>S△PAB+S△PAC+S△PBC=S△ABC </p>
<p>其中三角形面积计算公式为 S=1/2×|cross(a,b)| </p>
<p>叉积法 </p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-11-%E7%82%B9%E4%B8%8E%E4%B8%89%E8%A7%92%E5%BD%A2.png" alt></p>
<p>利用叉积的正负号判断，如图所示，AP 在向量 AC 的顺时针方向，CP 在向量 BC 的顺时针方向，BP 在向量 BC 的顺时针方向，利用这一性质推广，那么可以利用叉积的正负号来判断一个点是否在一个凸多边形内部。</p>
<h4 id="判断点是否在多边形内"><a href="#判断点是否在多边形内" class="headerlink" title="判断点是否在多边形内"></a>判断点是否在多边形内</h4><p>一般而言，该问题有射线法和转角法两种处理手段</p>
<p>射线法：从这个点出发引向无穷远点一条直线，根据交点情况确定点的位置</p>
<p>转角法：计算多边形每条边的转角，若最后相消为0则在外部，否则在内部</p>
<p>射线法：特殊情况不易处理</p>
<p>转角法：三角运算时间开销大</p>
<h5 id="射线法"><a href="#射线法" class="headerlink" title="射线法"></a>射线法</h5><p>以要判断的点为起点任作一射线，计算该射线与多边形的交点数目。</p>
<p>若有偶数个交点则在形外，否则在形内。</p>
<p>若与线段在端点处相交或重合，则要进行复杂的判断。此时可另取一射线。</p>
<h5 id="转角法"><a href="#转角法" class="headerlink" title="转角法"></a>转角法</h5><p>把多边形每条边的转角加起来，如果是360度，就在多边形内，如果是0度就在外面，180度则是在边界上</p>
<p>直接最要求角度用到反三角函数精度差且费时</p>
<h5 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h5><p>假设有一条向右的射线，统计多边形穿过这条射线正反多少次，把这个数记为绕数wn，逆时针穿过时，wn加1，顺时针穿过时，wn减1。</p>
<p>注意在程序实现时，判断是否穿过，以及穿过方向时，需要用叉积判断输入点在左边还是右边。</p>
<h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int isPointinPolygon(point p,vector&lt;point&gt;poly)</span><br><span class="line">&#123;</span><br><span class="line">    int wn=0;</span><br><span class="line">    int n=poly.size();</span><br><span class="line">    for (int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (OnSegment(p,poly[i],poly[(i+1)%n])) return -1;    //边界</span><br><span class="line">        int k=dcmp(Cross(poly[(i+1)%n]-poly[i],p-poly[i]));</span><br><span class="line">        int d1=dcmp(poly[i].y-p.y);</span><br><span class="line">        int d2=dcmp(poly[(i+1)%n].y - p.y);</span><br><span class="line">        if (k&gt;0&amp;&amp;d1&lt;=0&amp;&amp;d2&gt;0) wn++;</span><br><span class="line">        if (k&lt;0&amp;&amp;d2&lt;=0&amp;&amp;d1&gt;0) wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (wn!=0) return 1;  //内部</span><br><span class="line">    return 0;   //外部</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点在凸多边形内的判定更简单，只需判断是否在所有边的左边（假设各个顶点按照逆时针顺序排列）</p>
<h3 id="多边形重心"><a href="#多边形重心" class="headerlink" title="多边形重心"></a>多边形重心</h3><h4 id="三角形重心"><a href="#三角形重心" class="headerlink" title="三角形重心"></a>三角形重心</h4><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-11-%E4%B8%89%E8%A7%92%E5%BD%A2%E9%87%8D%E5%BF%83.png" alt></p>
<h4 id="多边形重心-1"><a href="#多边形重心-1" class="headerlink" title="多边形重心"></a>多边形重心</h4><p>将多边形拆分为N个三角形，分别求其重心和面积，可以想象，原来的质量均匀分布在内部的区域上，而现在质量仅分布在这N个重心点上（等价变换），这时就可以利用刚才猜想的公式了。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-11-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%87%8D%E5%BF%83.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">point PolyGravity(point *p,int n)</span><br><span class="line">&#123;</span><br><span class="line">    point ans=point(0,0);</span><br><span class="line">    double sumArea=0,area;</span><br><span class="line">    for(int i=2;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        area=cross(p[i-1]-p[0],p[i]-p[0]);</span><br><span class="line">        sumArea+=area;</span><br><span class="line">        ans.x+=(p[0].x+p[i-1].x+p[i].x)*area;</span><br><span class="line">        ans.y+=(p[0].y+p[i-1].y+p[i].y)*area;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans/(sumArea*3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解析几何"><a href="#解析几何" class="headerlink" title="解析几何"></a>解析几何</h2><p>交点的计算：求两线段，两直线，线段和直线的交点<br>①判断两线段是否相交：<br>我们分两步确定两条线段是否相交：<br>(1)快速排斥试验<br>设以线段 P1P2 为对角线的矩形为 R， 设以线段 Q1Q2 为对角线的矩形为 T，如果R和T不相交，显然两线段不会相交。<br>(2)跨立试验<br>如果两线段相交，则两线段必然相互跨立对方。若 P1P2 跨立 Q1Q2 ，则矢量 ( P1 - Q1 ) 和( P2 - Q1 )位于矢量( Q2 - Q1 ) 的两侧，即 ( P1 - Q1 ) × ( Q2 - Q1 ) <em> ( P2 - Q1 ) × ( Q2 - Q1 ) &lt; 0。<br>上式可改写成 ( P1 - Q1 ) × ( Q2 - Q1 ) </em> ( Q2 - Q1 ) × ( P2 - Q1 ) &gt; 0。<br>当 ( P1 - Q1 ) × ( Q2 - Q1 ) = 0 时，说明 ( P1 - Q1 ) 和 ( Q2 - Q1 )共线，但是因为已经通过快速排斥试验，所以 P1 一定在线段 Q1Q2 上；同理，( Q2 - Q1 ) ×(P2 - Q1 ) = 0 说明 P2 一定在线段 Q1Q2 上。所以判断 P1P2 跨立 Q1Q2 的依据是： </p>
<p>( P1 - Q1 ) × ( Q2 - Q1 ) <em> ( Q2 - Q1 ) × ( P2 - Q1 ) &gt;= 0。<br>同理判断 Q1Q2 跨立 P1P2 的依据是：<br>( Q1 - P1 ) × ( P2 - P1 ) </em> ( P2 - P1 ) × ( Q2 - P1 ) &gt;= 0。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-11-%E5%AE%9E%E9%AA%8C.png" alt></p>
<p>另外，“规范相交”指的是两条线段恰有唯一一个不是端点的公共点；而如果一条线段的一个端点在另一条线段上，或者两条线段部分重合，则视为“非规范相交”，以下代码是“非规范相交”。 </p>
<p>结合 poj2653 练习，代码可参考：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const double eps = 1e-10;</span><br><span class="line">struct point &#123; double x, y; &#125;;</span><br><span class="line">struct Line &#123; point begin, end; &#125;line[100001];</span><br><span class="line">double min(double a, double b) &#123; return a&lt;b ? a : b; &#125;</span><br><span class="line">double max(double a, double b) &#123; return a&gt;b ? a : b; &#125;</span><br><span class="line">bool inter(const Line &amp; M, const Line &amp; N) &#123;</span><br><span class="line">	point a = M.begin; point b = M.end;</span><br><span class="line">	point c = N.begin; point d = N.end;</span><br><span class="line">	if (min(a.x, b.x) &gt; max(c.x, d.x) || min(a.y, b.y)&gt;max(c.y, d.y) || min(c.x, d.x)&gt;max(a.x, b.x) || min(c.y, d.y) &gt; max(a.y, b.y)) return 0;</span><br><span class="line">	double h, i, j, k;</span><br><span class="line">	h = (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x);</span><br><span class="line">	i = (b.x - a.x)*(d.y - a.y) - (b.y - a.y)*(d.x - a.x);</span><br><span class="line">	j = (d.x - c.x)*(a.y - c.y) - (d.y - c.y)*(a.x - c.x);</span><br><span class="line">	k = (d.x - c.x)*(b.y - c.y) - (d.y - c.y)*(b.x - c.x);</span><br><span class="line">	return h*i &lt;= eps&amp;&amp;j*k &lt;= eps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②判断两直线是否相交：<br>首先判断两条直线是否在一条直线上，或者两条直线平行，否则一定相交，不平行且不在一条直线上则相交并且求出交点。<br>可结合 hrbustoj1104 练习，代码可参考： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">int main() &#123;</span><br><span class="line">	int t;</span><br><span class="line">	double x1, x2, x3, x4, y1, y2, y3, y4, x, y;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">	while (t--) &#123;</span><br><span class="line">		scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">		scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x3, &amp;y3, &amp;x4, &amp;y4);</span><br><span class="line">		if ((x2 - x1)*(y4 - y3) == (x4 - x3)*(y2 - y1)) &#123;</span><br><span class="line">			if ((x3 - x1)*(y4 - y2) == (x4 - x2)*(y3 - y1) &amp;&amp; (y4 - y3) != 0)</span><br><span class="line">				puts(&quot;LINE&quot;);//在一条直线的情况 </span><br><span class="line">			else</span><br><span class="line">				puts(&quot;NONE&quot;);//平行的情况 </span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			x = ((y1*(x2 - x1) - x1*(y2 - y1))*(x4 - x3) - (y3*(x4 - x3) - x3*(y4 -</span><br><span class="line">				y3))*(x2 - x1)) / ((y4 - y3)*(x2 - x1) - (y2 - y1)*(x4 - x3));</span><br><span class="line">			y = ((y1*(x2 - x1) - x1*(y2 - y1))*(y4 - y3) - (y3*(x4 - x3) - x3*(y4 -</span><br><span class="line">				y3))*(y2 - y1)) / ((y4 - y3)*(x2 - x1) - (y2 - y1)*(x4 - x3));</span><br><span class="line">			printf(&quot;POINT %.2f %.2f\n&quot;, x, y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③判断线段和直线的交点：<br>poj1039 判断直线和线段是否相交并求出交点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define eps 1.0e-8 </span><br><span class="line">struct Point &#123;</span><br><span class="line">	double x, y;</span><br><span class="line">&#125; point[25];</span><br><span class="line">int n;</span><br><span class="line">double ans;</span><br><span class="line">bool ok;</span><br><span class="line">double intersect(Point a1, Point b1, Point a2, Point b2) &#123;</span><br><span class="line">	double x1 = a1.x, x2 = b1.x, x3 = a2.x, x4 = b2.x;</span><br><span class="line">	double y1 = a1.y, y2 = b1.y, y3 = a2.y, y4 = b2.y;</span><br><span class="line">	double x = (y3 - y1 + x1*(y2 - y1) / (x2 - x1) - x3*(y4 - y3) / (x4 - x3)) / ((y2 -</span><br><span class="line">		y1) / (x2 - x1) - (y4 - y3) / (x4 - x3));</span><br><span class="line">	return x;</span><br><span class="line">&#125;</span><br><span class="line">void work(Point a, Point b) &#123;</span><br><span class="line">	b.y -= 1;</span><br><span class="line">	for (int i = 0; i&lt;n; i++) &#123;</span><br><span class="line">		Point p, q1, q2;</span><br><span class="line">		p.x = point[i].x;</span><br><span class="line">		p.y = a.y - (b.y - a.y) / (b.x - a.x)*(a.x - p.x);</span><br><span class="line">		if ((p.y + eps&lt;point[i].y&amp;&amp;p.y - eps&gt;point[i].y - 1) ||</span><br><span class="line">			abs(p.y - point[i].y)&lt;eps || abs(p.y - point[i].y + 1)&lt;eps)</span><br><span class="line">			continue;</span><br><span class="line">		if (i == 0) return;</span><br><span class="line">		if (p.y - eps&gt;point[i].y)</span><br><span class="line">			ans = max(ans, intersect(a, b, point[i - 1], point[i]));</span><br><span class="line">		else &#123;</span><br><span class="line">			q1 = point[i - 1];</span><br><span class="line">			q1.y -= 1;</span><br><span class="line">			q2 = point[i];</span><br><span class="line">			q2.y -= 1;</span><br><span class="line">			ans = max(ans, intersect(a, b, q1, q2));</span><br><span class="line">		&#125;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	ok = true;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n), n) &#123;</span><br><span class="line">		for (int i = 0; i&lt;n; i++)</span><br><span class="line">			scanf(&quot;%lf%lf&quot;, &amp;point[i].x, &amp;point[i].y);</span><br><span class="line">		ans = point[0].x;</span><br><span class="line">		ok = false;</span><br><span class="line">		for (int i = 0; i&lt;n; i++)</span><br><span class="line">			for (int j = 0; j&lt;n; j++)</span><br><span class="line">				if (i != j&amp;&amp;!ok)</span><br><span class="line">					work(point[i], point[j]);</span><br><span class="line">		if (ok)</span><br><span class="line">			printf(&quot;Through all the pipe.\n&quot;);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;%.2f\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>计算几何</tag>
        <tag>点积/叉积</tag>
      </tags>
  </entry>
  <entry>
    <title>[博弈论]博弈论基本题型及5大常见博弈论原理</title>
    <url>/2018/05/08/2018-05-08/</url>
    <content><![CDATA[<h2 id="取石子游戏"><a href="#取石子游戏" class="headerlink" title="取石子游戏"></a>取石子游戏</h2><p>根据题目的意思，看它属于哪种博弈，属于哪种博弈的变形。 然后根据对应的博弈模型的解题策略来求解， 有时候并不一定能够直接看出它属于哪种模型，那这个时候就可以通过判断自己每步可选的策略，对于自己每步走的，对当前局势的影响。然后推断出与之相对应的博弈模型。</p>
<h3 id="巴什博奕（Bash-Game）"><a href="#巴什博奕（Bash-Game）" class="headerlink" title="巴什博奕（Bash Game）"></a>巴什博奕（Bash Game）</h3><p>有n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取 m个。最后取光者得胜。</p>
<p>假设n = m + 1，那么无论如何取，先取者必输。因为先取者无论取多少，后者一次性便可将剩余取完。</p>
<p>胜利法则：如果 n=（m+1）r+s，（r 为任意自然数，s≤m),那么先取者要拿走 s 个物品，如果后取者拿走 k（≤m)个，那么先取者再拿走 m+1-k 个，结果剩下 （m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int iCase;</span><br><span class="line">	cin &gt;&gt; iCase;</span><br><span class="line">	while (iCase--) &#123;</span><br><span class="line">		int n, m;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		if (n % (m + 1) == 0) cout &lt;&lt; &quot;lost&quot; &lt;&lt; endl;</span><br><span class="line">		else cout &lt;&lt; &quot;win&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="威佐夫博奕（Wythoff-Game）"><a href="#威佐夫博奕（Wythoff-Game）" class="headerlink" title="威佐夫博奕（Wythoff Game）"></a>威佐夫博奕（Wythoff Game）</h3><p>有两堆物品，每堆各若干物品，两个人轮流从某堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</p>
<p>这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们 称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。 </p>
<p> 可以看出,a0=b0=0,ak 是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有如下三条性质：</p>
<p>1。任何自然数都包含在一个且仅有一个奇异局势中。</p>
<p>2。任意操作都可将奇异局势变为非奇异局势。</p>
<p>3。采用适当的方法，可以将非奇异局势变为奇异局势。</p>
<p>两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。</p>
<p>如何判定是否是奇异局势呢？</p>
<p>有如下公式： ak =[k（1+√5）/2]，bk= ak + k （k=0，1，2，…,n 方括号表示取整函数) </p>
<p>其中（1+√5）/2 = 1.618…,即为黄金分割数。因此,由 ak，bk 组成的矩形近似为黄金矩形，由于 2/（1+√5）=（√5-1）/2，可以先求出 j=[a（√5-1）/2]，若a=[ j（1+√5）/2]，那么 a = aj，bj = aj + j，若不等于，那么 a = aj+1，bj+1 = aj+1 + j + 1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;math.h&gt; </span><br><span class="line">const double ep1 = (sqrt(5.0) - 1.0) / 2.0;</span><br><span class="line">const double ep2 = (sqrt(5.0) + 1.0) / 2.0;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int m, n;</span><br><span class="line">	while (scanf(&quot;%d %d&quot;, &amp;m, &amp;n) != EOF) &#123;</span><br><span class="line">		if (m &gt; n) &#123;</span><br><span class="line">			int tmp;</span><br><span class="line">			tmp = m, m = n, n = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		int id = m * ep1;</span><br><span class="line">		int tmp1 = ep2 * id, tmp2 = id + tmp1;</span><br><span class="line">		int tmp3 = ep2 * (id + 1), tmp4 = id + 1 + tmp3;</span><br><span class="line">		if (tmp1 == m &amp;&amp; tmp2 == n) printf(&quot;0\n&quot;);</span><br><span class="line">		else if (tmp3 == m &amp;&amp; tmp4 == n) printf(&quot;0\n&quot;);</span><br><span class="line">		else printf(&quot;1\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="斐波那契博弈（Fibonacci-Nim）"><a href="#斐波那契博弈（Fibonacci-Nim）" class="headerlink" title="斐波那契博弈（Fibonacci Nim）"></a>斐波那契博弈（Fibonacci Nim）</h3><p>有一堆个数为 n 的石子，游戏双方轮流取石子，满足</p>
<p>1)先手不能在第一次把所有的石子取完； </p>
<p>2)之后每次可以取的石子数介于 1 到对手刚取的石子数的 2 倍之间（包含 1 和对手刚取的石子数的 2 倍）。</p>
<p>约定取走最后一个石子的人为赢家，求必败态。</p>
<p>这个和之前的 Wythoff’s Game 和取石子游戏 有一个很大的不同点，就是游戏规则的动态化。之前的规则中，每次可以取的石子的策略集合是基本固定的，但是这次有规则 2：一方每次可以取的石子数依赖于对手刚才取的石子数。 </p>
<p>胜利法则：先手胜当且 仅当 n 不是 Fibonacci 数。换句话说，必败态构成 Fibonacci 数列。 </p>
<p>证明：</p>
<p>这里需要借助“Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的 Fibonacci 数之和。 </p>
<p> FIB 数列的必败证明：</p>
<p>1、当 i=2 时，先手只能取 1 颗，显然必败，结论成立。 </p>
<p>2、假设当 i&lt;=k 时，结论成立。则当 i=k+1 时，f[i] = f[k]+f[k-1]。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">long long int f[50];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, i;</span><br><span class="line">	f[0] = f[1] = 1;</span><br><span class="line">	for (i = 2; i &lt; 50; i++) &#123;</span><br><span class="line">		f[i] = f[i - 1] + f[i - 2];</span><br><span class="line">	&#125;</span><br><span class="line">	while (cin &gt;&gt; n) &#123;</span><br><span class="line">		if (n == 0) break;</span><br><span class="line">		for (i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">			if (f[i] == n) break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (i &lt; 50) cout &lt;&lt; &quot;Second win&quot; &lt;&lt; endl;</span><br><span class="line">		else cout &lt;&lt; &quot;First win&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="K倍博弈"><a href="#K倍博弈" class="headerlink" title="K倍博弈"></a>K倍博弈</h3><p>共 n 个石子，两个人按顺序依次取石子。先手不能全部取完，之后每人取的个数不能超过另一个人上轮取的 K倍。 对于给定的 n, k， 先手是否有必胜的策略。</p>
<p>当 k=1 的时候 可知必败局面都是 2^i 将 n 分解成二进制，然后先手取掉最后一个 1，然后对方必然无法去掉更高的 1，而对方取完我方至少还能拿掉最后一 个 1 导致对方永远取不完。 </p>
<p>当 k=2 的时候，必败局面都是斐波那契数列。利用“先手去掉最后一个 1，则后手必不能去掉更高阶的 1 导致取不完”的思想，斐波那契数列有一个非常好 的性质就是：任意一个整数可以写成斐波那契数列中的不相邻的项的和，于是将 n 写成这种形式，先取走最后一个 1，对方能取的数是这个数*2，小于高 2 位的 1，所以取不完。</p>
<p>当 K 的时候， 想办法构造数列，将 n 写成数列中一些项的和，使得这些被取到的项的相邻两个倍数差距&gt;k 那么每次去掉最后一个 1 还是符合上面的条件。</p>
<p>设这个数列已经被构造了 i 项，第 i 项为 a[ i ]，前 i 项可以完美对 1..b[ i ] 编码使得每个编码的任意两项倍数&gt;K 那么有 a[ i+1 ] = b[ i ] + 1;这是显然的 因为 b[ i ] + 1 没法构造出来，只能新建一项表示。然后计算 b[ i+1] 既然要使用 a[ i+1 ] 那么下一项最多只能是某个 a[ t ] 使得 a[ t ] * K &lt; a[ i+1 ] 于是b[ i ] = b[ t ] + a[ i+1 ] 然后判断 n 是否在这个数列里面如果在，那么先手必败。否则不停的减掉数列 a 中的项构造出 n 的分解，最后一位就是了。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;string.h&gt; </span><br><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 2000000;</span><br><span class="line">int a[maxn], b[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, k;</span><br><span class="line">	int cas = 0, cass;</span><br><span class="line">	for (scanf(&quot;%d&quot;, &amp;cass); cass--;)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span><br><span class="line">		++cas;</span><br><span class="line">		printf(&quot;Case %d: &quot;, cas);</span><br><span class="line">		int i = 0, j = 0;</span><br><span class="line">		a[0] = b[0] = 1;</span><br><span class="line">		while (a[i]&lt;n)</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			a[i] = b[i - 1] + 1;</span><br><span class="line">			while (a[j + 1] * k&lt;a[i])</span><br><span class="line">				j++;</span><br><span class="line">			if (a[j] * k&lt;a[i])</span><br><span class="line">				b[i] = a[i] + b[j];</span><br><span class="line">			else</span><br><span class="line">				b[i] = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		if (a[i] == n)</span><br><span class="line">			puts(&quot;lose&quot;);</span><br><span class="line">		else puts(&quot;win&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SG函数的求解-SG博弈）"><a href="#SG函数的求解-SG博弈）" class="headerlink" title="ＳＧ函数的求解(SG博弈）"></a>ＳＧ函数的求解(SG博弈）</h3><p>给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负。</p>
<p>这个游戏可以认为是所有 Impartial Combinatorial Games 的抽象模型。也就是说，任何一个 ICG 都可以通过把每个局面看成一个顶点，对每个局面和它的子局面连一条有向边来抽象成这个“有向图游戏”。</p>
<p>下 面我们就在有向无环图的顶点上定义 Sprague-Garundy 函数。首先定义 mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如 mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。 </p>
<p>对于一个给定的有向无环图，定义关于图的每个顶点的 Sprague-Grundy 函数 g如下：<strong>g(x)=mex{ g(y) | y 是 x 的后继 }</strong>。</p>
<p>SG 函数的性质：</p>
<p>1.首先，所有的 terminal position 所对应的顶点，也就是没有出边的顶点，其 SG 值为 0，因为它的后继集合是空集。</p>
<p>2.然后对于一个 g(x)=0 的顶点 x，它的所有后继 y 都满足 g(y)!=0。</p>
<p>3.对于一个 g(x)!=0 的顶点，必定存在一个后继 y 满足 g(y)=0。 </p>
<p>以上这三句话表明，顶点 x 所代表的 postion 是 P-position 当且仅当 g(x)=0。我们通过计算有向无环图的每个顶点的 SG 值，就可以对每种局面找到必胜策略了。</p>
<h4 id="Nim-游戏的规则："><a href="#Nim-游戏的规则：" class="headerlink" title="Nim 游戏的规则："></a>Nim 游戏的规则：</h4><p>每次选择 一堆数量为 k 的石子，可以把它变成 0、变成 1、……、变成 k-1，但绝对不能保持 k不变。</p>
<h4 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h4><p>假设不是一枚棋子，而是n枚棋子，如何获胜？</p>
<p>让我们再来考虑一下顶点的 SG 值的意义。当 g(x)=k 时，表明对于任意一个0&lt;=i&lt;k，都存在 x 的一个后继 y 满足 g(y)=i。也 就是说，当某枚棋子的 SG 值是 k 时，我们可以把它变成 0、变成 1、……、变成 k-1，但绝对不能保持 k 不变。</p>
<p>这表明，如果将 n 枚棋子所在的顶 点的 SG 值看作 n 堆相应数量的石子，那么这个 Nim 游戏的每个必胜策略都对应于原来这 n 枚棋子的必胜策略！</p>
<p>对于 n 个棋子，设它们对应的顶点的 SG 值分别为(a1,a2,…,an)，再设局面(a1,a2,…,an)时的 Nim 游戏的一种必胜策略是把 ai 变成 k，那么原游戏的一种必胜策略就是把第 i 枚棋子移动到一个 SG 值为 k 的顶点。</p>
<p>其实我们还是只要证明这种多棋子的有向图游戏的局面是 P-position 当且仅当所有棋子所在的位置的 SG 函数的异或为 0。这个证明与上节的 Bouton’s Theorem 几乎是完全相同的，只需要适当的改几个名词就行了。</p>
<p>刚才，我为了使问题看上去更容易一些，认为 n 枚棋子是在一个有向图上移动，但如果不是在一个有向图上，而是每个棋子在一个有向图上，每次可 以任选一个棋子（也就是任选一个有向图）进行移动，这样也不会给结论带来任何变化。 所以我们可以定义有向图游戏的和(Sum of Graph Games)：设 G1、G2、……、Gn是 n 个有向图游戏，定义游戏 G 是 G1、G2、……、Gn 的和(Sum)，游戏 G的移动规则是：任选一个子游戏 Gi 并移动上面的棋子。Sprague-Grundy Theorem 就是：<strong>g(G)=g(G1)^g(G2)^…^g(Gn)</strong>。也就是说，游戏的和的 SG 函数值是它的所有子游戏的 SG 函数值的异或。 </p>
<p>再考虑在本文一开头的一句话：任何一个 ICG 都可以抽象成一个有向图游戏。所以“SG 函数”和“游戏的和”的概念就不是局限于有向图游戏。我们给每 个 ICG 的每个 position 定义 SG 值，也可以定义 n 个 ICG 的和。所以说当我们面对由 n 个游戏组合成的一个游戏时，只需对于每个游戏找出求它的每个 局面的 SG 值的方法，就可以把这些 SG 值全部看成 Nim 的石子堆，然后依照找 Nim 的必胜策略的方法来找这个游戏的必胜策略了！</p>
<h4 id="NIM游戏"><a href="#NIM游戏" class="headerlink" title="NIM游戏"></a>NIM游戏</h4><p>有 n 堆石子，每次可以从第 1 堆石子里取 1 颗、2 颗或 3颗，可以从第 2 堆石子里取奇数颗，可以从第 3 堆及以后石子里取任意颗… … 我们可以把它看作 3 个子游戏，第 1 个子游戏只有一堆石子，每次可以取 1、2、3颗，很容易看出 x 颗石子的局面的 SG 值是 x%4。第 2 个子游戏也是只有一 堆 石子，每次可以取奇数颗，经过简单的画图可以知道这个游戏有 x 颗石子时的 SG值是 x%2。第 3 个游戏有 n-2 堆石子，就是一个 Nim 游戏。对于原游戏的每 个局面，把三个子游戏的 SG 值异或一下就得到了整个游戏的 SG 值，然后就可以根据这个 SG 值判断是否有必胜策略以及做出决策了。其实看作 3 个子游戏还是保守了些，干脆看作 n 个子游戏，其中第 1、2 个子游戏如上所述，第 3 个及以后的子游戏都是“1 堆石子，每次取几颗都可以”，称为“任取石子游戏”，这个超简 单的游戏有 x 颗石子的 SG 值显然就是 x。其实，n 堆石子的 Nim 游戏本身不就是 n 个“任取石子游戏”的和吗？</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>SG 函数与“游戏的和”的概念不是让我们去组合、制造稀奇古怪的游戏，而是把遇到的看上去有些复杂的游戏试图分成若干个子游戏，对于每个比原游戏简化很多的子游戏找出它的 SG 函数，然后全部异或起来就得到了原游戏的 SG 函数，就可以解决原游戏了。</p>
<h4 id="HDU-3032-Nim-or-not-Nim"><a href="#HDU-3032-Nim-or-not-Nim" class="headerlink" title="HDU 3032 Nim or not Nim"></a>HDU 3032 Nim or not Nim</h4><p>Lasker’s Nim 游戏：每一轮允许两会中操作之一：①、从一堆石子中取走任意多个，②、将一堆数量不少于 2 的石子分成都不为空的两堆。</p>
<p>很明显：sg(0) = 0，sg(1) = 1。  状态 2 的后继有：0，1 和（1，1），他们的 SG 值分别为 0，1，0，所以 sg(2)=2。 状态 3 的后继有：0、1、2、（1，2），他们的 SG 值分别为 0、1、2、3，所以sg(3) = 4。 状态 4 的后继有：0、1、2、3、（1，3）和（2，2），他们的 SG 值分别为 0，1，2，4，5，0，所以 sg(4) = 3. 由数学归纳法可以得出 sg(4k)=4k-1;sg(4k+1)=4k+1;sg(4k+2)=4k+2;sg(4k+3)=4k+4;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int iCase;</span><br><span class="line">	cin &gt;&gt; iCase;</span><br><span class="line">	while (iCase--) &#123;</span><br><span class="line">		int n, cnt = 0, num;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		while (n--) &#123;</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			if (num % 4 == 0) num--;</span><br><span class="line">			else if (num % 4 == 3) num++;</span><br><span class="line">			cnt ^= num;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cnt == 0) cout &lt;&lt; &quot;Bob&quot; &lt;&lt; endl;</span><br><span class="line">		else cout &lt;&lt; &quot;Alice&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="寻找必败态"><a href="#寻找必败态" class="headerlink" title="寻找必败态"></a>寻找必败态</h2><p>必败态就是“在对方使用最优策略时，无论做出什么决策都会导致失败的局面”。其他的局面称为胜态，值得注意的是在 胜态下做出错误的决策也有可能导致失败。此类博弈问题的精髓就是让对手永远面对必败态。</p>
<p>必败态和胜态有着如下性质： </p>
<p>1、若面临末状态者为获胜则末状态为胜态否则末状态为必败态。 </p>
<p>2、一个局面是胜态的充要条件是该局面进行某种决策后会成为必败态。 </p>
<p>3、一个局面是必败态的充要条件是该局面无论进行何种决策均会成为胜态。 </p>
<p>这三条性质正是博弈树的原理，但博弈树是通过计算每一个局面是胜态还是必败态来解题，这样在局面数很多的情况下是很难做到的，此时，我们可以利用人脑的推演归纳能力找 到必败态的共性，就可以比较好的解决此类问题了。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>分析初始局势是属于哪种形态，然后根据博弈中的些结论去推导当前状态是否是必败态。 </p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>博弈论</tag>
        <tag>SG函数</tag>
        <tag>NIM游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>[数论]数论与与组合数学与线性代数中的常用算法总结</title>
    <url>/2018/05/07/2018-05-07/</url>
    <content><![CDATA[<h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="欧几里得算法（gcd）"><a href="#欧几里得算法（gcd）" class="headerlink" title="欧几里得算法（gcd）"></a>欧几里得算法（gcd）</h3><p>欧几里得算法又称辗转相除法，设两个数为a,b,则a,b最大公约数为gcd(a,b)=gcd(b,a%b)</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>设a&gt;=b, c = gcd( a, b), a = kc, b = jc,则k,j互素（否则c不为a，b最大公约数），则设 r = a % b,则a = mb + r,则r = a - mb = kc - mjc = ( k - mj ) c，因为k,j互素，则k-mj与j互素，gcd(a,b) = gcd(b,a%b)</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>如果判断两个数是否互素(最大公约数为1)，这时辗转相除法就方便得多。因为每一步都是取模，保证了数据减小的速度特别快。能够在很短时间内找到最大公约数。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//递归版</span><br><span class="line">int gcd(int a, int b) &#123;</span><br><span class="line">	return b ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line">//非递归版</span><br><span class="line">int gcd(int a, int b) &#123;</span><br><span class="line">	if (!a)</span><br><span class="line">		return b;</span><br><span class="line">	while (b) &#123;</span><br><span class="line">		int temp = b;</span><br><span class="line">		b = a%b;</span><br><span class="line">		a = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展欧几里得算法（exgcd）"><a href="#扩展欧几里得算法（exgcd）" class="headerlink" title="扩展欧几里得算法（exgcd）"></a>扩展欧几里得算法（exgcd）</h3><p>若a , b 不全为 0，则存在整数 x,y 使得 gcd(a,b)=xa+yb<br>对于辗转相除法的最后一项,此时 b=0,则 gcd(a,b)=1<em>a+0</em>b,因为 gcd(a,b)=gcd(b,a%b)则有 x<em>a+y</em>b=x1<em>b+y1</em>(a%b) 。将等式右边变形，b<em>x1+(a%b)</em>y1=b<em>x1+(a-(a/b)</em>b)<em>y1=a</em>y1+b<em>(x1-(a/b)</em>y1)<br>则，x=y1,y=x1-(a/b)*y1 则可由后向前迭代得到 x,y</p>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>对于扩展欧几里德定理的题，一般都需要进行一定的推导之后得到一个形式为xa+yb=c 的方程，然后根据 c 确定解是否存在，如果 c 可以被 gcd(a,b)整除，那么方程有解，否则方程无解。而且所得的解释不唯一的，对于一组解 x0,y0 则其所有解可以表示为x=x0+b/gcd(a,b)<em>t,y-y0-a/gcd(a,b)</em>t,t=0,+1,+2……一般会要求找出 x 或者 y 的最小正整数解，这个时候需要做一些调整。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int exgcd(int a, int b, int &amp;x, int &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">	if (b == 0)</span><br><span class="line">	&#123;</span><br><span class="line">		x = 1;</span><br><span class="line">		y = 0;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">	int d = exgcd(b, a%b, x, y);</span><br><span class="line">	int t = x;</span><br><span class="line">	x = y;</span><br><span class="line">	y = t - a / b*y;</span><br><span class="line">	return d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="筛法求素数"><a href="#筛法求素数" class="headerlink" title="筛法求素数"></a>筛法求素数</h3><p>筛素数的基本方法是用来筛选出一定范围内的素数</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>利用素数只有1和本身两个约数，且约数一定不大于自身。首先筛掉1.剩下的数选择最小的数为素数，然后筛掉它范围内所有的倍数，以此类推，直到筛为空时结束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool isprime[N];//N 表示范围</span><br><span class="line">int prime[N], cnt;</span><br><span class="line">void f()</span><br><span class="line">&#123;</span><br><span class="line">	int i, j;</span><br><span class="line">	cnt = 0;</span><br><span class="line">	memset(isprime, true, sizeof(isprime));</span><br><span class="line">	isprime[1] = false;</span><br><span class="line">	for (i = 2; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (isprime[i])</span><br><span class="line">		&#123;</span><br><span class="line">			prime[cnt++] = i;//记录素数</span><br><span class="line">			for (j = i*i; j &lt;= N; j += i)//因为小于 i 的所有的倍数都被筛过，所以直接从 i*i 开始，从这里也可以看出，筛素数时到 N^0.5就可以了</span><br><span class="line">				isprime[j] = false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>快速幂的目的就是做到快速求幂，假设我们要求a^b,按照朴素算法就是把a连乘b次，这样一来时间复杂度是O(n)级别，快速幂能做到O(logn)。</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>　　假设我们要求a^b，那么其实b是可以拆成二进制的，该二进制数第i位的权为2^(i-1)，例如当b==11时，a11=a(2^0+2^1+2^3)。11的二进制是1011，11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1，因此，我们将a¹¹转化为算 a2^0<em>a2^1</em>a2^3，也就是a1 <em> a2 </em> a8，原来算11次，现在算三次，但是这三项貌似不好求的样子….不急，下面会有详细解释。由于是二进制，很自然地想到用位运算这个强大的工具：&amp;和&gt;&gt;。&amp;运算通常用于二进制取位操作，例如一个数 &amp; 1 的结果就是取二进制的最末位。还可以判断奇偶x&amp;1==0为偶，x&amp;1==1为奇。>&gt;运算比较单纯,二进制去掉最后一位，不多说了，先放代码再解释。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int poww(int a, int b) &#123;</span><br><span class="line">    int ans = 1, base = a;</span><br><span class="line">    while (b != 0) &#123;</span><br><span class="line">        if (b &amp; 1 != 0)</span><br><span class="line">            ans *= base;</span><br><span class="line">        base *= base;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以b==11为例，b=&gt;1011,二进制从右向左算，但乘出来的顺序是 a^(2^0)<em>a^(2^1)</em>a^(2^3)，是从左向右的。我们不断的让base*=base目的即是累乘，以便随时对ans做出贡献。</p>
<p>　　其中要理解base <em> =base这一步：因为 base </em> base==base2，下一步再乘，就是base2 <em> base2==base4，然后同理  base4 </em> base4=base8，由此可以做到base–&gt;base2–&gt;base4–&gt;base8–&gt;base16–&gt;base32…….指数正是 2^i ，再看上面的例子，a¹¹= a1<em>a2</em>a8，这三项就可以完美解决了</p>
<h4 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h4><p><strong>矩阵乘法</strong></p>
<p>简单的说矩阵就是二维数组，数存在里面，矩阵乘法的规则:A*B=C</p>
<p><strong><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95.png" alt="img"></strong></p>
<p>其中c[i][j]为A的第i行与B的第j列对应乘积的和，即:<img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%85%AC%E5%BC%8F.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int N=100;  </span><br><span class="line">int c[N][N];  </span><br><span class="line">void multi(int a[][N],int b[][N],int n)//n是矩阵大小，n&lt;N  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(c,0,sizeof c);  </span><br><span class="line">    for(int i=1;i&lt;=n;i++)  </span><br><span class="line">        for(int j=1;j&lt;=n;j++)  </span><br><span class="line">        for(int k=1;k&lt;=n;k++)  </span><br><span class="line">        c[i][j]+=a[i][k]*b[k][j];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单，把快速幂算法中的乘法改成矩阵的乘法就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int N=10;  </span><br><span class="line">int tmp[N][N];  </span><br><span class="line">void multi(int a[][N],int b[][N],int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(tmp,0,sizeof tmp);  </span><br><span class="line">    for(int i=0;i&lt;n;i++)  </span><br><span class="line">        for(int j=0;j&lt;n;j++)  </span><br><span class="line">        for(int k=0;k&lt;n;k++)  </span><br><span class="line">        tmp[i][j]+=a[i][k]*b[k][j];  </span><br><span class="line">    for(int i=0;i&lt;n;i++)  </span><br><span class="line">        for(int j=0;j&lt;n;j++)  </span><br><span class="line">        a[i][j]=tmp[i][j];  </span><br><span class="line">&#125;  </span><br><span class="line">int res[N][N];  </span><br><span class="line">void Pow(int a[][N],int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(res,0,sizeof res);//n是幂，N是矩阵大小  </span><br><span class="line">    for(int i=0;i&lt;N;i++) res[i][i]=1;  </span><br><span class="line">    while(n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if(n&amp;1)  </span><br><span class="line">            multi(res,a,N);//res=res*a;复制直接在multi里面实现了；  </span><br><span class="line">        multi(a,a,N);//a=a*a  </span><br><span class="line">        n&gt;&gt;=1;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面放一个求斐波那契数列的矩阵快速幂模板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 10000;</span><br><span class="line">const int maxn = 35;</span><br><span class="line">int N;</span><br><span class="line">struct Matrix &#123;</span><br><span class="line">    int mat[maxn][maxn];</span><br><span class="line">    int x, y;</span><br><span class="line">    Matrix() &#123;</span><br><span class="line">        memset(mat, 0, sizeof(mat));</span><br><span class="line">        for (int i = 1; i &lt;= maxn - 5; i++) mat[i][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">inline void mat_mul(Matrix a, Matrix b, Matrix &amp;c) &#123;</span><br><span class="line">    memset(c.mat, 0, sizeof(c.mat));</span><br><span class="line">    c.x = a.x; c.y = b.y;</span><br><span class="line">    for (int i = 1; i &lt;= c.x; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= c.y; j++) &#123;</span><br><span class="line">            for (int k = 1; k &lt;= a.y; k++) &#123;</span><br><span class="line">                c.mat[i][j] += (a.mat[i][k] * b.mat[k][j]) % mod;</span><br><span class="line">                c.mat[i][j] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">inline void mat_pow(Matrix &amp;a, int z) &#123;</span><br><span class="line">    Matrix ans, base = a;</span><br><span class="line">    ans.x = a.x; ans.y = a.y;</span><br><span class="line">    while (z) &#123;</span><br><span class="line">        if (z &amp; 1 == 1) mat_mul(ans, base, ans);</span><br><span class="line">        mat_mul(base, base, base);</span><br><span class="line">        z &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    a = ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    while (cin &gt;&gt; N) &#123;</span><br><span class="line">        switch (N) &#123;</span><br><span class="line">            case -1: return 0;</span><br><span class="line">            case 0: cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; continue;</span><br><span class="line">            case 1: cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; continue;</span><br><span class="line">            case 2: cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; continue;</span><br><span class="line">        &#125;</span><br><span class="line">        Matrix A, B;</span><br><span class="line">        A.x = 2; A.y = 2;</span><br><span class="line">        A.mat[1][1] = 1; A.mat[1][2] = 1;</span><br><span class="line">        A.mat[2][1] = 1; A.mat[2][2] = 0;</span><br><span class="line">        B.x = 2; B.y = 1;</span><br><span class="line">        B.mat[1][1] = 1; B.mat[2][1] = 1;</span><br><span class="line">        mat_pow(A, N - 1);</span><br><span class="line">        mat_mul(A, B, B);</span><br><span class="line">        cout &lt;&lt; B.mat[1][1] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>φ(x)=x(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…..(1-1/pn),其中 p1, p2……pn 为 x 的所有质因数。</p>
<p>设 p 是素数 a 是一个正整数 φ(p^a)=p^a-p^a-1; m 与 n 互素 φ(mn)=φ(m)φ(n); φ(n)=n <em> sum(1-1/pi)/</em>pi 是与 n 的质因子n 为奇数时 φ(2n)=φ(n)。</p>
<h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><h4 id="基本的模运算"><a href="#基本的模运算" class="headerlink" title="基本的模运算"></a>基本的模运算</h4><p>(a + b)mod n=((a mod n) + (b mod n))mod n;</p>
<p>(a - b)mod n=((a mod n) - (b mod n))mod n;</p>
<p>(a <em> b)mod n=((a mod n) </em> (b mod n))mod n;</p>
<h3 id="数论4大定理"><a href="#数论4大定理" class="headerlink" title="数论4大定理"></a>数论4大定理</h3><h4 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h4><p>若p为质数，则p可整除(p-1)!+1。</p>
<h4 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h4><p>若n,a为正整数，且n,a互素，即gcd(a,n) = 1，则a^φ(n) ≡ 1 (mod n)</p>
<h5 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h5><p>设x（1），x（2），…，x(φ(n))是一个以n为模的简系，则ax（1），ax（2），…，ax（φ(n) ）也是一个以n为模的简系（因为（a，n）=1）。</p>
<p>于是有ax（1）ax（2）…ax（φ(n) ）≡x（1）x（2）…x(φ(n))（mod n），</p>
<p>所以a^φ(n) ≡ 1 (mod n)。</p>
<h4 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h4><p>假如p是质数，若p不能整除a，则 a^(p-1) ≡1（mod p），若p能整除a，则a^(p-1) ≡0（mod p）。</p>
<p>若p是质数，且a,p互质，那么 a的(p-1)次方除以p的余数恒等于1。</p>
<h5 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a><strong>证明</strong></h5><p>因为p是质数，且（a，p)=1，所以φ(p)=p-1。由欧拉定理可得a^(p-1) ≡1（mod p）。证毕。对于该式又有a^p ≡a（mod p），所以，费马小定理的另一种表述为：假如p是质数，且(a,p)=1，那么a^p ≡a（mod p）。</p>
<h4 id="孙子定理（中国剩余定理）"><a href="#孙子定理（中国剩余定理）" class="headerlink" title="孙子定理（中国剩余定理）"></a>孙子定理（中国剩余定理）</h4><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86.png" alt></p>
<h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><p>高斯消元法，是线性代数中的一个算法，可用来为线性方程组求解，求出矩阵的秩，以及求出可逆方阵的逆矩阵。当用于一个矩阵时，高斯消元法会产生出一个“行梯阵式”。利用矩阵化成的行阶梯型可以方便的得出未知数的解。</p>
<p>要用高斯消元，一般也会需要一定的推理，得出线性方程组，再利用高斯消元求解。</p>
<h2 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h2><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><h4 id="加法原理"><a href="#加法原理" class="headerlink" title="加法原理"></a>加法原理</h4><p>加法原理：做一件事，完成它可以有 n 类办法，第一类办法的方法属于集合 A1，第二类办法的方法属于集合 A2，……，第 n 类办法的方法属于集合 An，那么完成这件事的方法属于集合 A1UA2U…UAn。</p>
<p>分类的要求 ：每一类中的每一种方法都可以独立地完成此任务；两类不同办法中的具体方法，互不相同（即分类不重）；完成此任务的任何一种方法，都属于某一类（即分类不漏）</p>
<h4 id="乘法原理"><a href="#乘法原理" class="headerlink" title="乘法原理"></a>乘法原理</h4><p>乘法原理：做一件事，完成它需要分成 n 个步骤，做第一步有 m1 种不同的方法，做第二步有 m2 种不同的方法，……，做第 n 步有 mn 种不同的方法，那么完成这件事共有N=m1×m2×m3×…×mn 种不同的方法。</p>
<p>合理分步的要求,任何一步的一种方法都不能完成此任务，必须且只须连续完成这 n 步才能完成此任务；各步计数相互独立；只要有一步中所采取的方法不同，则对应的完成此事的方法也不同。</p>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>排列的定义及其计算公式：从 n 个不同元素中，任取 m(m≤n,m 与 n 均为自然数,下同）个元素按照一定的顺序排成一列，叫做从 n 个不同元素中取出 m 个元素的一个排列；从 n 个不同元素中取出 m(m≤n）个元素的所有排列的个数，叫做从 n 个不同元素中取出m 个元素的排列数，用符号 A(n,m）表示。A(n,m)=n(n-1)(n-2)……(n-m+1)= n!/(n-m)! 此外规定 0!=1 </p>
<p>组合的定义及其计算公式：从 n 个不同元素中，任取 m(m≤n）个元素并成一组，叫做从 n 个不同元素中取出 m 个元素的一个组合；从 n 个不同元素中取出 m(m≤n）个元素的所有组合的个数，叫做从 n 个不同元素中取出 m 个元素的组合数。用符号 C(n,m) 表示。C(n,m)==A(n,m)/m！；C(n,m)=C(n,n-m）。（n&gt;=m) </p>
<p>其他排列与组合公式 从 n 个元素中取出 m 个元素的循环排列数=A(n,m)/m=n!/m(n-m)!. n 个元素被分成 k 类，每类的个数分别是 n1,n2,…nk 这 n 个元素的全排列数为 n!/(n1！×n2！×…×nk!). k 类元素，每类的个数无限，从中取出 m 个元素的组合数为 C(m+k-1,m）。</p>
<h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><p>设 A1,A2 为有限集合，其元素个数分别为|A1|，|A2|,则| A1∪A2|=| A1+A2|-| A1∩A2|<br>这个定理，常称作包含排斥原理，也就是容斥原理。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86.png" alt></p>
<p>对于需要用到容斥原理的题型，一般都比较容易看出来用的方法，而且一般采用深搜的方法进行运算</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
        <tag>组合数学</tag>
        <tag>高斯消元</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>[图论]最短路三大算法——Dijkstra算法，Bellman-ford，floyed</title>
    <url>/2018/05/06/2018-05-06-1/</url>
    <content><![CDATA[<h2 id="Dijkstra算法（单源最短路径）"><a href="#Dijkstra算法（单源最短路径）" class="headerlink" title="Dijkstra算法（单源最短路径）"></a>Dijkstra算法（单源最短路径）</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>初使时令 S={V0},T={其余顶点}，T中顶点对应的距离值， 若存在&lt;V0,Vi&gt;，为&lt;V0,Vi&gt;弧上的权值（和ＳＰＦＡ初始化方式不同），若不存在&lt;V0,Vi&gt;，为Inf。</li>
<li>从T中选取一个其距离值为最小的顶点W(贪心体现在此处)，加入S(注意不是直接从S集合中选取，理解这个对于理解vis数组的作用至关重要)，对T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值比不加W的路径要短，则修改此距离值（上面两个并列for循环，使用最小点更新）。</li>
<li>重复上述步骤，直到S中包含所有顶点，即S=V为止（说明最外层是除起点外的遍历）。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int INF=0x3f3f3f3f;</span><br><span class="line">const int maxn=1200;</span><br><span class="line"></span><br><span class="line">int dist[maxn],g[maxn][maxn],N;</span><br><span class="line">bool vis[maxn];</span><br><span class="line"></span><br><span class="line">void dijkstra()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;=N;i++)</span><br><span class="line">        dist[i]=(i==1)?0:INF;</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int mark=-1,mindis=INF;</span><br><span class="line">        for(int j=1;j&lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[j]&amp;&amp;dist[j]&lt;mindis)</span><br><span class="line">            &#123;</span><br><span class="line">                mindis=dist[j];</span><br><span class="line">                mark=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[mark]=1;</span><br><span class="line"></span><br><span class="line">        for(int j=1;j&lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=min(dist[j],dist[mark]+g[mark][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Bellman-ford（单元最短路径，可带负环）"><a href="#Bellman-ford（单元最短路径，可带负环）" class="headerlink" title="Bellman-ford（单元最短路径，可带负环）"></a>Bellman-ford（单元最短路径，可带负环）</h2><p>为了能够求解边上带有负值的单源最短路径问题，Bellman(贝尔曼，动态规划提出者)和Ford(福特)提出了从源点逐次绕过其他顶点，以缩短到达终点的最短路径长度的方法。Bellman-ford算法是求含负权图的单源最短路径算法，效率很低，但代码很容易写。即进行不停地松弛，每次松弛把每条边都更新一下，若n-1次松弛后还能更新，则说明图中有负环，无法得出结果，否则就成功完成。Bellman-ford算法有一个小优化：每次松弛先设一个flag，初值为FALSE，若有边更新则赋值为TRUE，最终如果还是FALSE则直接成功退出。Bellman-ford算法浪费了许多时间做无必要的松弛，所以SPFA算法用队列进行了优化，效果十分显著，高效难以想象。SPFA还有SLF，LLL，滚动数组等优化。</p>
<p>递推公式(求顶点u到源点v的最短路径)：<br>$$<br>dist 1 [u] = Edge[v][u]<br>$$</p>
<p>$$<br>dist k [u] = min{ dist k-1 [u], min{ dist k-1 [j] + Edge[j][u] } }, j=0,1,…,n-1,j≠u<br>$$</p>
<p>Dijkstra算法和Bellman算法思想有很大的区别：Dijkstra算法在求解过程中，源点到集合S内各顶点的最短路径一旦求出，则之后不变了，修改  的仅仅是源点到T集合中各顶点的最短路径长度。Bellman算法在求解过程中，每次循环都要修改所有顶点的dist[ ]，也就是说源点到各顶点最短路径长度一直要到Bellman算法结束才确定下来。</p>
<h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul>
<li>单源最短路径(从源点s到其它所有顶点v)</li>
<li>有向图&amp;无向图(无向图可以看作(u,v),(v,u)同属于边集E的有向图)</li>
<li>边权可正可负(如有负权回路输出错误提示)</li>
<li>差分约束系统(至今貌似只看过一道题)</li>
</ul>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><ol>
<li>初始化：将除源点外的所有顶点的最短距离估计值 d[v] ←+∞, d[s] ←0</li>
<li>迭代求解：反复对边集E中的每条边进行松弛操作，使得顶点集V中的每个顶点v的最短距离估计值逐步逼近其最短距离；（运行|v|-1次，看下面的描述性证明(当做树)）</li>
<li>检验负权回路：判断边集E中的每一条边的两个端点是否收敛。如果存在未收敛的顶点，则算法返回false，表明问题无解；否则算法返回true，并且从源点可达的顶点v的最短距离保存在d[v]中</li>
</ol>
<p>Bellman-Ford算法是否一定要循环n-1次么？未必！其实只要在某次循环过程中，考虑每条边后，都没能改变当前源点到所有顶点的最短路径长度，那么Bellman-Ford算法就可以提前结束了(开篇提出的小优化就是这个)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool Bellman_Ford()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  for(int i = 1; i &lt;= nodenum; ++i) //初始化</span><br><span class="line"></span><br><span class="line">    dis[i] = (i == original ? 0 : MAX);</span><br><span class="line"></span><br><span class="line">  for(int i = 1; i &lt;= nodenum - 1; ++i)</span><br><span class="line"></span><br><span class="line">    for(int j = 1; j &lt;= edgenum; ++j)</span><br><span class="line"></span><br><span class="line">      if(dis[edge[j].v] &gt; dis[edge[j].u] + edge[j].cost) //松弛（顺序一定不能反~）</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        dis[edge[j].v] = dis[edge[j].u] + edge[j].cost;</span><br><span class="line"></span><br><span class="line">        pre[edge[j].v] = edge[j].u;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      bool flag = 1; //判断是否含有负权回路</span><br><span class="line"></span><br><span class="line">      for(int i = 1; i &lt;= edgenum; ++i)</span><br><span class="line"></span><br><span class="line">        if(dis[edge[i].v] &gt; dis[edge[i].u] + edge[i].cost)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          flag = 0;</span><br><span class="line"></span><br><span class="line">          break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return flag;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define N 105</span><br><span class="line">int res[N];//存储源点到每个顶点的最短距离值</span><br><span class="line">int g[N][N];</span><br><span class="line">int cnt[N];//每个点入队次数，判断是否出现负环</span><br><span class="line">int que[N*N];//队列</span><br><span class="line">bool in_que[N];//标记一个点是否已在队列中</span><br><span class="line">int front;//队首位置</span><br><span class="line">int rear;//队尾位置</span><br><span class="line">void spfa(int n,int src)</span><br><span class="line">&#123;</span><br><span class="line">    rear=front=0;</span><br><span class="line">    que[++rear]=src;</span><br><span class="line">    memset(res,0x3f3f3f3f,sizeof(res));</span><br><span class="line">    memset(in_que,0,sizeof(in_que));</span><br><span class="line">    res[src]=0;</span><br><span class="line">    while(front&lt;rear)</span><br><span class="line">    &#123;</span><br><span class="line">        int cur=que[++front];</span><br><span class="line">        in_que[cur]=0;</span><br><span class="line">        int i;</span><br><span class="line">        for(i=1; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(res[cur]+g[cur][i]&lt;res[i])</span><br><span class="line">            &#123;</span><br><span class="line">                res[i]=res[cur]+g[cur][i];</span><br><span class="line">                if(!in_que[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    que[++rear]=i;</span><br><span class="line">                    in_que=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floyed（全源最短路径）"><a href="#floyed（全源最短路径）" class="headerlink" title="floyed（全源最短路径）"></a>floyed（全源最短路径）</h2><p>Floyd算法的基本思想如下：从任意节点A到任意节点B的最短路径不外乎2种可能，1是直接从A到B，2是从A经过若干个节点到B，所以，我们假设dist(AB)为节点A到节点B的最短路径的距离，对于每一个节点K，我们检查dist(AK) + dist(KB) &lt; dist(AB)是否成立，如果成立，证明从A到K再到B的路径比A直接到B的路径短，我们便设置 dist(AB) = dist(AK) + dist(KB)，这样一来，当我们遍历完所有节点K，dist(AB)中记录的便是A到B的最短路径的距离。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int k=0; k&lt;n; ++k)</span><br><span class="line">  for (int i=0; i&lt;n; ++i)</span><br><span class="line">    for (int j=0; j&lt;n; ++j)</span><br><span class="line">            /*</span><br><span class="line">            实际中为防止溢出，往往需要选判断 dist[i][k]和dist[k][j]</span><br><span class="line">            都不是Inf ，只要一个是Inf，那么就肯定不必更新。 </span><br><span class="line">            */</span><br><span class="line">      if (dist[i][k] + dist[k][j] &lt; dist[i][j] )</span><br><span class="line">        dist[i][j] = dist[i][k] + dist[k][j];</span><br></pre></td></tr></table></figure>
<p>Floyd算法另一种理解DP，为理论爱好者准备的，上面这个形式的算法其实是Floyd算法的精简版，而真正的Floyd算法是一种基于DP(Dynamic Programming)的最短路径算法。设图G中n 个顶点的编号为1到n。令c [i, j, k]表示从i 到j 的最短路径的长度，其中k 表示该路径中的最大顶点，也就是说c[i,j,k]这条最短路径所通过的中间顶点最大不超过k。因此，如果G中包含边&lt;i, j&gt;，则c[i, j, 0] =边&lt;i, j&gt; 的长度；若i= j ，则c[i,j,0]=0；如果G中不包含边&lt;i, j&gt;，则c (i, j, 0)= +∞。c[i, j, n] 则是从i 到j 的最短路径的长度。对于任意的k&gt;0，通过分析可以得到：中间顶点不超过k 的i 到j 的最短路径有两种可能：该路径含或不含中间顶点k。若不含，则该路径长度应为c[i, j, k-1]，否则长度为 c[i, k, k-1] +c [k, j, k-1]。c[i, j, k]可取两者中的最小值。状态转移方程：c[i, j, k]=min{c[i, j, k-1], c [i, k, k-1]+c [k, j, k-1]}，k＞0。这样，问题便具有了最优子结构性质，可以用动态规划方法来求解。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/7-1.png" alt></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Dijkstra算法</tag>
        <tag>Floyd算法</tag>
      </tags>
  </entry>
  <entry>
    <title>[图论]二分图匹配基本算法之KM算法解析</title>
    <url>/2018/05/06/2018-05-06/</url>
    <content><![CDATA[<h2 id="最佳匹配"><a href="#最佳匹配" class="headerlink" title="最佳匹配"></a>最佳匹配</h2><p>如果一个二分图，X部和Y部的顶点数相等，若存在一个匹配包含X部与Y部的所有顶点，则称为完美匹配。</p>
<p>如果一个二分图，X部中的每一个顶点都与Y部中的一个顶点匹配，或者Y部中的每一个顶点也与X部中的一个顶点匹配，则该匹配为完备匹配。</p>
<p><strong>带权</strong>二分图的<strong>权值最大</strong>的<strong>完备匹配</strong>称为最佳匹配。二分图的最佳匹配不一定是二分图的最大权匹配。 可以添加一些权值为0的边，使得最佳匹配和最大权匹配统一起来。 如图所示：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-6-a.png" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-6-b.png" alt></p>
<h2 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h2><p>求二分图的最佳匹配有一个非常优秀的算法,可以做到O(N^3),这就是KM算法。</p>
<p>1.首先选择顶点数较少的为X部，初始时对X部的每一个顶点设置顶标，顶标的值为该点关联的最大边的权值，Y部的顶点顶标为0。</p>
<p>2.对于X部中的每个顶点，在相等子图中利用匈牙利算法找一条增广路径，如果没有找到，则修改顶标，扩大相等子图，继续找增广路径。当每个点都找到增广路径时，此时意味着每个点都在匹配中，即找到了二分图的完备匹配。该完备匹配即为二分图的最佳匹配。</p>
<p>3.当X部的所有顶点都找到了增广路径后，则找到了完备匹配，此完备匹配即为最佳匹配。</p>
<h3 id="相等子图"><a href="#相等子图" class="headerlink" title="相等子图"></a>相等子图</h3><p>因为每个顶点有一个顶标，如果我们选择边权等于两端点的顶标之和的边，它们组成的图称为相等子图。</p>
<h3 id="相等子图性质"><a href="#相等子图性质" class="headerlink" title="相等子图性质"></a>相等子图性质</h3><ol>
<li>在任意时刻，相等子图上的最大权匹配一定小于等于相等子图的顶标和。</li>
<li>在任意时刻，相等子图的顶标和即为所有顶点的顶标和。</li>
<li>扩充相等子图后，相等子图的顶标和将会减小。</li>
<li>当相等子图的最大匹配为原图的完备匹配时，匹配边的权值和等于所有顶点的顶标和，此匹配即为最佳匹配。</li>
</ol>
<h3 id="演示过程"><a href="#演示过程" class="headerlink" title="演示过程"></a>演示过程</h3><p>1.如图所示，1与a匹配权值为3，与c为4。2与a权值为2，与b权值为1，与c权值为3。3与c权值为5。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-6-1.png" alt></p>
<p>2.首先对每个顶点赋值，将左边的顶点赋值为<strong>最大权重</strong>，右边的顶点赋值为0。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-6-2.png" alt></p>
<p>3.进行匹配，我们匹配的原则是：只与权重相同的边匹配，若是找不到边匹配，对此条路径的所有左边顶点-1，右边顶点+1，再进行匹配，若还是匹配不到，重复+1和-1操作。对1进行匹配，符合匹配条件的边只有1-c边。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-6-3.png" alt></p>
<p>4.接着对2匹配，顶点2值为3，2-c边权重为3，但是，1已经匹配c了，发生了冲突，我们这时候第一时间应该想到的是，让2换个工作，但根据匹配原则，只有2-c边 3+0=0 满足要求，于是2不能换边了，那1能不能换边呢？对1来说，也是只有1-c边满足4+0=4的要求，于是1也不能换边，走投无路了，怎么办？</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-6-4.png" alt></p>
<p>5.从常识的角度思考：其实我们寻找<strong>最优匹配</strong>的过程，也就是<strong>帮每个X顶点找到他们权值最高的Y顶点</strong>，但是，有些顶点会冲突，比如现在，1，2和c的权值都是最高，这时我们应该让1或者3换顶点，但是这时候换的话我们只能换到降低权值的Y顶点，也就是说，如果令R=左边顶点所有值相加，若发生了冲突，则最终权值一定小于R，但是，我们现在只要求最优匹配，所以，如果1换顶点降低的权值比较少的话，<strong>我们是能接受的</strong>（对2同样如此）。</p>
<p>在KM算法中如何体现呢？</p>
<p>现在参与到这个冲突的顶点是1,2和c，令所有左边顶点值-1，右边顶点值+1，即 1-1,2-1. c+1。</p>
<p>我们进行了上述操作后会发现，若是左边有n个顶点参与运算，则右边就有n-1个顶点参与运算，整体效率值下降了1*（n-（n-1））=1，而对于1来说，1-c本来为可匹配的边，现在仍为可匹配边（3+1=4），对于2来说，2-c本来为可匹配的边，现在仍为可匹配的边（2+1=4），我们通过上述操作，为1增加了一条可匹配的边1-a，为B增加了一条可匹配的边2-a。</p>
<p>现在我们再来匹配，对2来说，2-a边 2+0=2，满足条件，所以2换边，a现在为未匹配状态，2-a匹配！</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-6-5.png" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-6-6.png" alt></p>
<p>6.我们现在匹配最后一条边3，3-c 5+1！=5，3边无边能匹配，所以3-1。现在3-c边 4+1=5，可以匹配，但是c已匹配了，发生冲突，3此时不能换边，于是便去找1，对于1来说，1-a此时也为可匹配边，但是a已匹配，1又去找2。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-6-7.png" alt></p>
<p>7.2现在无边可以匹配了，2+0！=1 ，现在的路径是3→c→1→a→2，所以1-1,2-1,3-1,a+1，c+1。如下图所示。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-6-9%20.png" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-6-8.png" alt></p>
<p>8.对于2来说，现在2-b 1+0=1 可匹配！使用匈牙利算法，对此条路径上的边取反。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-6-10.png" alt></p>
<h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool dfs(int s) //匈牙利算法找增广路径</span><br><span class="line">&#123;</span><br><span class="line">    visx[s]=1;</span><br><span class="line">    for(int i=1;i&lt;=cnty;i++) </span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            int t=wx[s]+wy[i]-dis[s][i];</span><br><span class="line">            if(t==0) &#123;</span><br><span class="line">                visy[i]=1;</span><br><span class="line">                if(linky[i]==0||dfs(linky[i]))&#123;</span><br><span class="line">                    linkx[s]=i,linky[i]=s;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t&gt;0)  //找出边权与顶标和的最小的差值</span><br><span class="line">            &#123;</span><br><span class="line">                if(t&lt;minz)minz=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">void km()</span><br><span class="line">&#123;</span><br><span class="line">    memset(linkx,0,sizeof linkx); //linkx[i]表示与X部中点i匹配的点</span><br><span class="line">    memset(linky,0,sizeof linky);</span><br><span class="line">    for(int i=1;i&lt;=cntx;i++)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            minz=INF;</span><br><span class="line">            memset(visx,0,sizeof visx);</span><br><span class="line">            memset(visy,0,sizeof visy);</span><br><span class="line">            if(dfs(i))break;</span><br><span class="line">            for(int j=1;j&lt;=cntx;j++)  //将交错树中X部的点的顶标减去minz</span><br><span class="line">            if(visx[j])wx[j]-=minz;</span><br><span class="line">            for(int j=1;j&lt;=cnty;j++) //将交错树中Y部的点的顶标加上minz</span><br><span class="line">            if(visy[j])wy[j]+=minz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>匹配</tag>
        <tag>图论</tag>
        <tag>二分图</tag>
        <tag>KM算法</tag>
      </tags>
  </entry>
  <entry>
    <title>[图论]二分图匹配基本算法之匈牙利算法解析</title>
    <url>/2018/05/05/2018-05-05/</url>
    <content><![CDATA[<h2 id="二分图概念"><a href="#二分图概念" class="headerlink" title="二分图概念"></a>二分图概念</h2><p>二分图（二部图），图论一种特殊的模型。设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（ i，j ）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。</p>
<p>简而言之，一个图所有的顶点被分成两部分，同一部分的顶点之间没有边。如图所示：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-5-5-1.png" alt></p>
<h2 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h2><p>给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。<br>极大匹配(Maximal Matching)是指在当前已完成的匹配下,无法再通过增加未完成匹配的边的方式来增加匹配的边数。最大匹配(maximum matching)是所有极大匹配当中边数最大的一个匹配。选择这样的边数最大的子集称为图的最大匹配问题。<br>如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配。</p>
<h2 id="增广路经"><a href="#增广路经" class="headerlink" title="增广路经"></a>增广路经</h2><p>增广路径的定义：设M为二分图G已匹配边的集合，若P是图G中一条连通两个未匹配顶点的路径（P的起点在X部，终点在Y部，反之亦可），并且属M的边和不属M的边(即已匹配和待匹配的边)在P上交替出现，则称P为相对于M的一条增广路径。<br>增广路径是一条“交错轨”。也就是说, 它的第一条边是目前还没有参与匹配的,第二条边参与了匹配,第三条边没有..最后一条边没有参与匹配,并且起点和终点还没有被选择过，这样交错进行,显然P有奇数条边</p>
<p>由增广路的定义可以推出下述三个结论：</p>
<ol>
<li>P的路径长度必定为奇数，第一条边和最后一条边都不属于M，因为两个端点分属两个集合，且未匹配。</li>
<li>P经过取反操作可以得到一个更大的匹配M’。</li>
<li>M为G的最大匹配当且仅当不存在相对于M的增广路径。 </li>
</ol>
<h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。</p>
<p>匈牙利算法基本模式：</p>
<hr>
<p>初始时最大匹配为空</p>
<p>​    while 找到增广路经</p>
<p>​        do 把增广路径加入到最大匹配中去</p>
<hr>
<p>具体过程如图所示：</p>
<p>1.如图所示，1可以与a，c匹配，2可以与a，b匹配，3可以与c匹配</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/5-6-1.png" alt></p>
<p>2.首先将对1进行搜索，1可以与a匹配，则将1与a相连</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/5-6-2.png" alt></p>
<p>3.再对2进行搜索，2可以与a匹配</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/5-6-3.png" alt></p>
<p>4.但是a已经与1匹配了，那么顺着a-&gt;1这条路找到1，再对1进行搜索，发现1还可以与c进行匹配，并且当前c还未与任何X区顶点匹配，则将1与c相连</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/5-6-4.png" alt></p>
<p>5.现在对3进行匹配，发现3可以与c匹配</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/5-6-5.png" alt></p>
<p>6.这时发现c已经匹配了，则顺着c-&gt;1这条路找到1，再对1进行搜索，发现1还可以与a匹配</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/5-6-6.png" alt></p>
<p>7.但a也已经匹配了，则顺着a-&gt;2这条路找到2，这时发现2还可以与b匹配，并且b当前还未与任何X顶点匹配，则将2与b匹配，之后得到的结果即为最大匹配</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/5-6-7.png" alt></p>
<p>以下是实现代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool find(int x) &#123;	//寻找增广路</span><br><span class="line">	for (int i = 1; i &lt;= N; i++) &#123;	//遍历Y部分顶点</span><br><span class="line">		if (road[x][i] &amp;&amp; !vis[i]) &#123;	//Y某顶点与X有路且未标记</span><br><span class="line">			vis[i] = true;</span><br><span class="line">			if (!link[i] || find(link[i])) &#123;	//如果Y顶点当前未与其他X匹配则直接与该点匹配，否则寻找增广路，然后将Y顶点与该顶点匹配</span><br><span class="line">				link[i] = x;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主程序调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i = 1; i &lt;= N; i++)&#123;	//对每一个X部分顶点进行遍历</span><br><span class="line">  memset(vis,false,sizeof(vis));</span><br><span class="line">  if(find(i))&#123;	//寻找增光路</span><br><span class="line">    ans++;	//最大匹配数量加1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例题：POJ3041</p>
<p>给一个N*N的矩阵，有些格子有障碍，要求我们消除这些障碍，问每次消除一行或一列的障碍，</p>
<p>最少要几次。这里将每行x看成一个X结点，每列Y看成一个Y结点，障碍的坐标x,y看成X到Y的</p>
<p>一条边，构建出图后，就变成了找最少的点，使得这些点与所有的边相邻，即最小点覆盖问题。</p>
<p>又继续敲了一遍匈牙利算法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N, K, ans;</span><br><span class="line">int road[520][520], head[520];</span><br><span class="line">bool vis[520];</span><br><span class="line">bool find(int x) &#123;</span><br><span class="line">	for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">		if (road[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">			vis[i] = true;</span><br><span class="line">			if (!head[i] || find(head[i])) &#123;</span><br><span class="line">				head[i] = x;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (cin &gt;&gt; N &gt;&gt; K) &#123;</span><br><span class="line">		ans = 0;</span><br><span class="line">		int x, y;</span><br><span class="line">		memset(road, 0, sizeof(road));</span><br><span class="line">		memset(head, 0, sizeof(head));</span><br><span class="line">		for (int i = 1; i &lt;= K; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			road[x][y] = 1;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">			memset(vis, false, sizeof(vis));</span><br><span class="line">			if (find(i)) &#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>匹配</tag>
        <tag>图论</tag>
        <tag>二分图</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title>[C++实战qqHelper]C++打造qq消息一键群发工具</title>
    <url>/2018/05/03/2018-05-03/</url>
    <content><![CDATA[<p>物联网时代，微信和qq带给我们生活诸多便利。如今办公学习交流通讯已经越来越离不开微信和qq了。但是目前仍存在一些缺陷，比如如果想某条消息发给全部好友，必须得一个一个的发送。尤其是节假日发送节日祝福时该缺陷越发明显。微信针对此现象推出了群发功能，但qq目前还没有该功能。因此此次借此小程序练习C++，用C++打造qq聊天一键群发功能。该小程序还在完善中。目前只能作用于电脑Windows操作系统，并且电脑聊天界面发送按钮需切换到按Enter直接发送，不要选择Ctrl+Enter。当前仅有发送功能，因此消息的对象是所有好友。之后有时间会陆续添加暂停，继续等操作。</p>
<p>具体代码以及实现过程在代码中逐条说明。这里就不具体说明了。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/%5BHH@%29DN@ZX@RS53DTVQ1KZ8.png" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/YBFUJCK%29LL7%7B%5BO4OJ0Q$8$1.png" alt></p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/QQHELPER%E6%88%AA%E5%9B%BE.png" alt></p>
<p>QQmessage.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">class QQmessage</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	QQmessage();</span><br><span class="line">	~QQmessage();</span><br><span class="line"></span><br><span class="line">	//类的入口 </span><br><span class="line">	static QQmessage *Instance()</span><br><span class="line">	&#123;</span><br><span class="line">		static QQmessage object;</span><br><span class="line">		</span><br><span class="line">		return &amp;object;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//入口函数</span><br><span class="line">	void Start(const wchar_t *msg);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	//开始线程</span><br><span class="line">	static unsigned int WINAPI RunThreadproc(void* param);</span><br><span class="line">	</span><br><span class="line">	//发送主函数</span><br><span class="line">	void SendAll();</span><br><span class="line"></span><br><span class="line">	//找到QQ窗口</span><br><span class="line">	HWND FindQQWindow();</span><br><span class="line"></span><br><span class="line">	//模拟按键</span><br><span class="line">	void PressKey(BYTE vkey);</span><br><span class="line"></span><br><span class="line">	//发送消息</span><br><span class="line">	void SendMsg();</span><br><span class="line"></span><br><span class="line">	//添加文本到剪贴板</span><br><span class="line">	void AddTextToClipboard();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	CString m_msg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>QQmessage.cpp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;QQmessage.h&quot;</span><br><span class="line"></span><br><span class="line">QQmessage::QQmessage()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QQmessage::~QQmessage()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//入口函数</span><br><span class="line">void QQmessage::Start(const wchar_t *msg)</span><br><span class="line">&#123;</span><br><span class="line">	m_msg = CString(msg); //输入的文本</span><br><span class="line"></span><br><span class="line">	_beginthreadex(NULL, 0, QQmessage::RunThreadproc, NULL, 0, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//开始线程</span><br><span class="line">unsigned int QQmessage::RunThreadproc(void* param)</span><br><span class="line">&#123;</span><br><span class="line">	QQmessage::Instance()-&gt;SendAll();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//发送主函数</span><br><span class="line">void QQmessage::SendAll()</span><br><span class="line">&#123;</span><br><span class="line">	int errorTimes = 0;  //打开对话框错误的次数!</span><br><span class="line">	//把text复制到剪贴板</span><br><span class="line">	AddTextToClipboard();</span><br><span class="line"></span><br><span class="line">	//技术到家. 做项目能力.</span><br><span class="line">	while (errorTimes&lt;= 4)</span><br><span class="line">	&#123;</span><br><span class="line">		HWND hQQWnd = FindQQWindow();</span><br><span class="line">		HWND hFrontWnd = GetForegroundWindow(); </span><br><span class="line"></span><br><span class="line">		if (hQQWnd != hFrontWnd)</span><br><span class="line">		&#123;</span><br><span class="line">			if (!SetForegroundWindow(hQQWnd))</span><br><span class="line">			&#123;</span><br><span class="line">				MessageBox(NULL, L&quot;没有找到QQ窗口&quot;, NULL, NULL);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (errorTimes == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			PressKey(VK_TAB);</span><br><span class="line">			PressKey(VK_TAB);</span><br><span class="line">		&#125;</span><br><span class="line">		PressKey(VK_DOWN);</span><br><span class="line">		PressKey(VK_RETURN);</span><br><span class="line"></span><br><span class="line">		HWND hCurFrontWnd = GetForegroundWindow();</span><br><span class="line">		if (hCurFrontWnd == hQQWnd)  //</span><br><span class="line">		&#123;</span><br><span class="line">			++errorTimes;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		errorTimes = 0;</span><br><span class="line">		SendMsg();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//找到QQ窗口</span><br><span class="line">HWND QQmessage::FindQQWindow()</span><br><span class="line">&#123;</span><br><span class="line">	HWND hWnd = FindWindow(L&quot;TXGuiFoundation&quot;,L&quot;QQ&quot;);  //Find  Window //获取QQ的窗口!!!</span><br><span class="line">	</span><br><span class="line">	//辅助工具就是这么做的</span><br><span class="line">	return hWnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//模拟按键</span><br><span class="line">void QQmessage::PressKey(BYTE vkey)</span><br><span class="line">&#123;</span><br><span class="line">	keybd_event(vkey, 0, 0, 0);  //按下(0)和弹起(KEYEVENTF_KEYUP)</span><br><span class="line">	Sleep(100);</span><br><span class="line">	keybd_event(vkey, 0, KEYEVENTF_KEYUP, 0);  //敲击TAB</span><br><span class="line">	Sleep(100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//发送消息  16GU盘</span><br><span class="line">void QQmessage::SendMsg()</span><br><span class="line">&#123;</span><br><span class="line">	//粘贴  +  发送</span><br><span class="line">	keybd_event(VK_CONTROL, 0, 0, 0);  //按下(0)和弹起(KEYEVENTF_KEYUP)</span><br><span class="line">	Sleep(100);</span><br><span class="line">	keybd_event(0x56, 0, 0, 0);  //按下(0)和弹起(KEYEVENTF_KEYUP)</span><br><span class="line">	Sleep(100);</span><br><span class="line"></span><br><span class="line">	keybd_event(0x56, 0, KEYEVENTF_KEYUP, 0);  //敲击TAB</span><br><span class="line">	Sleep(100);</span><br><span class="line">	keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);  //敲击TAB</span><br><span class="line">	Sleep(100); //你好 鲜花刷起来!</span><br><span class="line"></span><br><span class="line">	//发送</span><br><span class="line">	PressKey(VK_RETURN);</span><br><span class="line">	PressKey(VK_ESCAPE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//添加文本到剪贴板</span><br><span class="line">void QQmessage::AddTextToClipboard()</span><br><span class="line">&#123;</span><br><span class="line">	//1.把文本拷贝到全局变量!  </span><br><span class="line">	int memLen = m_msg.GetLength() * sizeof(wchar_t) + 2;</span><br><span class="line"></span><br><span class="line">	HANDLE hGloBal = GlobalAlloc(GHND,memLen);   //malloc  calloc  relloc </span><br><span class="line"></span><br><span class="line">	void* memAddr = GlobalLock(hGloBal);</span><br><span class="line"></span><br><span class="line">	ZeroMemory(memAddr, memLen);</span><br><span class="line"></span><br><span class="line">	memcpy(memAddr, (const void*)m_msg.GetBuffer(), memLen);</span><br><span class="line"></span><br><span class="line">	GlobalUnlock(hGloBal);</span><br><span class="line"></span><br><span class="line">	//操作剪贴板!  怎么把大象装进冰箱!</span><br><span class="line">	OpenClipboard(NULL);</span><br><span class="line">	EmptyClipboard();</span><br><span class="line">	SetClipboardData(CF_UNICODETEXT, hGloBal);</span><br><span class="line">	CloseClipboard();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>QQHelperDlg.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// QQHelperDlg.h : 头文件</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperDlg 对话框</span><br><span class="line">class CQQHelperDlg : public CDialogEx</span><br><span class="line">&#123;</span><br><span class="line">// 构造</span><br><span class="line">public:</span><br><span class="line">	CQQHelperDlg(CWnd* pParent = NULL);	// 标准构造函数</span><br><span class="line"></span><br><span class="line">// 对话框数据</span><br><span class="line">#ifdef AFX_DESIGN_TIME</span><br><span class="line">	enum &#123; IDD = IDD_QQHELPER_DIALOG &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	protected:</span><br><span class="line">	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV 支持</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 实现</span><br><span class="line">protected:</span><br><span class="line">	HICON m_hIcon;</span><br><span class="line"></span><br><span class="line">	// 生成的消息映射函数</span><br><span class="line">	virtual BOOL OnInitDialog();</span><br><span class="line">	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);</span><br><span class="line">	afx_msg void OnPaint();</span><br><span class="line">	afx_msg HCURSOR OnQueryDragIcon();</span><br><span class="line">	DECLARE_MESSAGE_MAP()</span><br><span class="line">public:</span><br><span class="line">	CString m_Msg;</span><br><span class="line">	afx_msg void OnBnClickedButton1();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>QQHelperDlg.cpp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// QQHelperDlg.cpp : 实现文件</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;QQHelper.h&quot;</span><br><span class="line">#include &quot;QQHelperDlg.h&quot;</span><br><span class="line">#include &quot;afxdialogex.h&quot;</span><br><span class="line">#include &quot;QQmessage.h&quot;</span><br><span class="line"></span><br><span class="line">#ifdef _DEBUG</span><br><span class="line">#define new DEBUG_NEW</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 用于应用程序“关于”菜单项的 CAboutDlg 对话框</span><br><span class="line"></span><br><span class="line">class CAboutDlg : public CDialogEx</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	CAboutDlg();</span><br><span class="line"></span><br><span class="line">// 对话框数据</span><br><span class="line">#ifdef AFX_DESIGN_TIME</span><br><span class="line">	enum &#123; IDD = IDD_ABOUTBOX &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	protected:</span><br><span class="line">	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持</span><br><span class="line"></span><br><span class="line">// 实现</span><br><span class="line">protected:</span><br><span class="line">	DECLARE_MESSAGE_MAP()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CAboutDlg::DoDataExchange(CDataExchange* pDX)</span><br><span class="line">&#123;</span><br><span class="line">	CDialogEx::DoDataExchange(pDX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperDlg 对话框</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CQQHelperDlg::CQQHelperDlg(CWnd* pParent /*=NULL*/)</span><br><span class="line">	: CDialogEx(IDD_QQHELPER_DIALOG, pParent)</span><br><span class="line">	, m_Msg(_T(&quot;&quot;))</span><br><span class="line">&#123;</span><br><span class="line">	m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CQQHelperDlg::DoDataExchange(CDataExchange* pDX)</span><br><span class="line">&#123;</span><br><span class="line">	CDialogEx::DoDataExchange(pDX);</span><br><span class="line">	DDX_Text(pDX, IDC_EDIT1, m_Msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_MESSAGE_MAP(CQQHelperDlg, CDialogEx)</span><br><span class="line">	ON_WM_SYSCOMMAND()</span><br><span class="line">	ON_WM_PAINT()</span><br><span class="line">	ON_WM_QUERYDRAGICON()</span><br><span class="line">	ON_BN_CLICKED(IDC_BUTTON1, &amp;CQQHelperDlg::OnBnClickedButton1)</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperDlg 消息处理程序</span><br><span class="line"></span><br><span class="line">BOOL CQQHelperDlg::OnInitDialog()</span><br><span class="line">&#123;</span><br><span class="line">	CDialogEx::OnInitDialog();</span><br><span class="line"></span><br><span class="line">	// 将“关于...”菜单项添加到系统菜单中。</span><br><span class="line"></span><br><span class="line">	// IDM_ABOUTBOX 必须在系统命令范围内。</span><br><span class="line">	ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX);</span><br><span class="line">	ASSERT(IDM_ABOUTBOX &lt; 0xF000);</span><br><span class="line"></span><br><span class="line">	CMenu* pSysMenu = GetSystemMenu(FALSE);</span><br><span class="line">	if (pSysMenu != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		BOOL bNameValid;</span><br><span class="line">		CString strAboutMenu;</span><br><span class="line">		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);</span><br><span class="line">		ASSERT(bNameValid);</span><br><span class="line">		if (!strAboutMenu.IsEmpty())</span><br><span class="line">		&#123;</span><br><span class="line">			pSysMenu-&gt;AppendMenu(MF_SEPARATOR);</span><br><span class="line">			pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动</span><br><span class="line">	//  执行此操作</span><br><span class="line">	SetIcon(m_hIcon, TRUE);			// 设置大图标</span><br><span class="line">	SetIcon(m_hIcon, FALSE);		// 设置小图标</span><br><span class="line"></span><br><span class="line">	// TODO: 在此添加额外的初始化代码</span><br><span class="line"></span><br><span class="line">	return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CQQHelperDlg::OnSysCommand(UINT nID, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">	if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX)</span><br><span class="line">	&#123;</span><br><span class="line">		CAboutDlg dlgAbout;</span><br><span class="line">		dlgAbout.DoModal();</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		CDialogEx::OnSysCommand(nID, lParam);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果向对话框添加最小化按钮，则需要下面的代码</span><br><span class="line">//  来绘制该图标。  对于使用文档/视图模型的 MFC 应用程序，</span><br><span class="line">//  这将由框架自动完成。</span><br><span class="line"></span><br><span class="line">void CQQHelperDlg::OnPaint()</span><br><span class="line">&#123;</span><br><span class="line">	if (IsIconic())</span><br><span class="line">	&#123;</span><br><span class="line">		CPaintDC dc(this); // 用于绘制的设备上下文</span><br><span class="line"></span><br><span class="line">		SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0);</span><br><span class="line"></span><br><span class="line">		// 使图标在工作区矩形中居中</span><br><span class="line">		int cxIcon = GetSystemMetrics(SM_CXICON);</span><br><span class="line">		int cyIcon = GetSystemMetrics(SM_CYICON);</span><br><span class="line">		CRect rect;</span><br><span class="line">		GetClientRect(&amp;rect);</span><br><span class="line">		int x = (rect.Width() - cxIcon + 1) / 2;</span><br><span class="line">		int y = (rect.Height() - cyIcon + 1) / 2;</span><br><span class="line"></span><br><span class="line">		// 绘制图标</span><br><span class="line">		dc.DrawIcon(x, y, m_hIcon);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		CDialogEx::OnPaint();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当用户拖动最小化窗口时系统调用此函数取得光标</span><br><span class="line">//显示。</span><br><span class="line">HCURSOR CQQHelperDlg::OnQueryDragIcon()</span><br><span class="line">&#123;</span><br><span class="line">	return static_cast&lt;HCURSOR&gt;(m_hIcon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//发送</span><br><span class="line">void CQQHelperDlg::OnBnClickedButton1()</span><br><span class="line">&#123;</span><br><span class="line">	// TODO: 在此添加控件通知处理程序代码</span><br><span class="line">	UpdateData(TRUE);</span><br><span class="line"></span><br><span class="line">	QQmessage::Instance()-&gt;Start(m_Msg.GetBuffer());//m_Msg实例编辑框的变量  文字</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>QQHelper.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// QQHelper.h : PROJECT_NAME 应用程序的主头文件</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#ifndef __AFXWIN_H__</span><br><span class="line">	#error &quot;在包含此文件之前包含“stdafx.h”以生成 PCH 文件&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#include &quot;resource.h&quot;		// 主符号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperApp: </span><br><span class="line">// 有关此类的实现，请参阅 QQHelper.cpp</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">class CQQHelperApp : public CWinApp</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	CQQHelperApp();</span><br><span class="line"></span><br><span class="line">// 重写</span><br><span class="line">public:</span><br><span class="line">	virtual BOOL InitInstance();</span><br><span class="line"></span><br><span class="line">// 实现</span><br><span class="line"></span><br><span class="line">	DECLARE_MESSAGE_MAP()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern CQQHelperApp theApp;</span><br></pre></td></tr></table></figure>
<p>QQHelper.cpp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// QQHelper.cpp : 定义应用程序的类行为。</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;QQHelper.h&quot;</span><br><span class="line">#include &quot;QQHelperDlg.h&quot;</span><br><span class="line"></span><br><span class="line">#ifdef _DEBUG</span><br><span class="line">#define new DEBUG_NEW</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperApp</span><br><span class="line"></span><br><span class="line">BEGIN_MESSAGE_MAP(CQQHelperApp, CWinApp)</span><br><span class="line">	ON_COMMAND(ID_HELP, &amp;CWinApp::OnHelp)</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperApp 构造</span><br><span class="line"></span><br><span class="line">CQQHelperApp::CQQHelperApp()</span><br><span class="line">&#123;</span><br><span class="line">	// 支持重新启动管理器</span><br><span class="line">	m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;</span><br><span class="line"></span><br><span class="line">	// TODO: 在此处添加构造代码，</span><br><span class="line">	// 将所有重要的初始化放置在 InitInstance 中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 唯一的一个 CQQHelperApp 对象</span><br><span class="line"></span><br><span class="line">CQQHelperApp theApp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperApp 初始化</span><br><span class="line"></span><br><span class="line">BOOL CQQHelperApp::InitInstance()</span><br><span class="line">&#123;</span><br><span class="line">	// 如果一个运行在 Windows XP 上的应用程序清单指定要</span><br><span class="line">	// 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，</span><br><span class="line">	//则需要 InitCommonControlsEx()。  否则，将无法创建窗口。</span><br><span class="line">	INITCOMMONCONTROLSEX InitCtrls;</span><br><span class="line">	InitCtrls.dwSize = sizeof(InitCtrls);</span><br><span class="line">	// 将它设置为包括所有要在应用程序中使用的</span><br><span class="line">	// 公共控件类。</span><br><span class="line">	InitCtrls.dwICC = ICC_WIN95_CLASSES;</span><br><span class="line">	InitCommonControlsEx(&amp;InitCtrls);</span><br><span class="line"></span><br><span class="line">	CWinApp::InitInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	AfxEnableControlContainer();</span><br><span class="line"></span><br><span class="line">	// 创建 shell 管理器，以防对话框包含</span><br><span class="line">	// 任何 shell 树视图控件或 shell 列表视图控件。</span><br><span class="line">	CShellManager *pShellManager = new CShellManager;</span><br><span class="line"></span><br><span class="line">	// 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题</span><br><span class="line">	CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));</span><br><span class="line"></span><br><span class="line">	// 标准初始化</span><br><span class="line">	// 如果未使用这些功能并希望减小</span><br><span class="line">	// 最终可执行文件的大小，则应移除下列</span><br><span class="line">	// 不需要的特定初始化例程</span><br><span class="line">	// 更改用于存储设置的注册表项</span><br><span class="line">	// TODO: 应适当修改该字符串，</span><br><span class="line">	// 例如修改为公司或组织名</span><br><span class="line">	SetRegistryKey(_T(&quot;应用程序向导生成的本地应用程序&quot;));</span><br><span class="line"></span><br><span class="line">	CQQHelperDlg dlg;</span><br><span class="line">	m_pMainWnd = &amp;dlg;</span><br><span class="line">	INT_PTR nResponse = dlg.DoModal();</span><br><span class="line">	if (nResponse == IDOK)</span><br><span class="line">	&#123;</span><br><span class="line">		// TODO: 在此放置处理何时用</span><br><span class="line">		//  “确定”来关闭对话框的代码</span><br><span class="line">	&#125;</span><br><span class="line">	else if (nResponse == IDCANCEL)</span><br><span class="line">	&#123;</span><br><span class="line">		// TODO: 在此放置处理何时用</span><br><span class="line">		//  “取消”来关闭对话框的代码</span><br><span class="line">	&#125;</span><br><span class="line">	else if (nResponse == -1)</span><br><span class="line">	&#123;</span><br><span class="line">		TRACE(traceAppMsg, 0, &quot;警告: 对话框创建失败，应用程序将意外终止。\n&quot;);</span><br><span class="line">		TRACE(traceAppMsg, 0, &quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 删除上面创建的 shell 管理器。</span><br><span class="line">	if (pShellManager != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		delete pShellManager;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#ifndef _AFXDLL</span><br><span class="line">	ControlBarCleanUp();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	// 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序，</span><br><span class="line">	//  而不是启动应用程序的消息泵。</span><br><span class="line">	return FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stdafx.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// stdafx.h : 标准系统包含文件的包含文件，</span><br><span class="line">// 或是经常使用但不常更改的</span><br><span class="line">// 特定于项目的包含文件</span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#ifndef VC_EXTRALEAN</span><br><span class="line">#define VC_EXTRALEAN            // 从 Windows 头中排除极少使用的资料</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#include &quot;targetver.h&quot;</span><br><span class="line"></span><br><span class="line">#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // 某些 CString 构造函数将是显式的</span><br><span class="line"></span><br><span class="line">// 关闭 MFC 对某些常见但经常可放心忽略的警告消息的隐藏</span><br><span class="line">#define _AFX_ALL_WARNINGS</span><br><span class="line"></span><br><span class="line">#include &lt;afxwin.h&gt;         // MFC 核心组件和标准组件</span><br><span class="line">#include &lt;afxext.h&gt;         // MFC 扩展</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;afxdisp.h&gt;        // MFC 自动化类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifndef _AFX_NO_OLE_SUPPORT</span><br><span class="line">#include &lt;afxdtctl.h&gt;           // MFC 对 Internet Explorer 4 公共控件的支持</span><br><span class="line">#endif</span><br><span class="line">#ifndef _AFX_NO_AFXCMN_SUPPORT</span><br><span class="line">#include &lt;afxcmn.h&gt;             // MFC 对 Windows 公共控件的支持</span><br><span class="line">#endif // _AFX_NO_AFXCMN_SUPPORT</span><br><span class="line"></span><br><span class="line">#include &lt;afxcontrolbars.h&gt;     // 功能区和控件条的 MFC 支持</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifdef _UNICODE</span><br><span class="line">#if defined _M_IX86</span><br><span class="line">#pragma comment(linker,&quot;/manifestdependency:\&quot;type=&apos;win32&apos; name=&apos;Microsoft.Windows.Common-Controls&apos; version=&apos;6.0.0.0&apos; processorArchitecture=&apos;x86&apos; publicKeyToken=&apos;6595b64144ccf1df&apos; language=&apos;*&apos;\&quot;&quot;)</span><br><span class="line">#elif defined _M_X64</span><br><span class="line">#pragma comment(linker,&quot;/manifestdependency:\&quot;type=&apos;win32&apos; name=&apos;Microsoft.Windows.Common-Controls&apos; version=&apos;6.0.0.0&apos; processorArchitecture=&apos;amd64&apos; publicKeyToken=&apos;6595b64144ccf1df&apos; language=&apos;*&apos;\&quot;&quot;)</span><br><span class="line">#else</span><br><span class="line">#pragma comment(linker,&quot;/manifestdependency:\&quot;type=&apos;win32&apos; name=&apos;Microsoft.Windows.Common-Controls&apos; version=&apos;6.0.0.0&apos; processorArchitecture=&apos;*&apos; publicKeyToken=&apos;6595b64144ccf1df&apos; language=&apos;*&apos;\&quot;&quot;)</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>stdafx.cpp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// stdafx.cpp : 只包括标准包含文件的源文件</span><br><span class="line">// QQHelper.pch 将作为预编译头</span><br><span class="line">// stdafx.obj 将包含预编译类型信息</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br></pre></td></tr></table></figure>
<p>Resource.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//&#123;&#123;NO_DEPENDENCIES&#125;&#125;</span><br><span class="line">// Microsoft Visual C++ 生成的包含文件。</span><br><span class="line">// 供 QQHelper.rc 使用</span><br><span class="line">//</span><br><span class="line">#define IDM_ABOUTBOX                    0x0010</span><br><span class="line">#define IDD_ABOUTBOX                    100</span><br><span class="line">#define IDS_ABOUTBOX                    101</span><br><span class="line">#define IDD_QQHELPER_DIALOG             102</span><br><span class="line">#define IDR_MAINFRAME                   128</span><br><span class="line">#define IDC_EDIT1                       1000</span><br><span class="line">#define IDC_BUTTON1                     1001</span><br><span class="line"></span><br><span class="line">// Next default values for new objects</span><br><span class="line">// </span><br><span class="line">#ifdef APSTUDIO_INVOKED</span><br><span class="line">#ifndef APSTUDIO_READONLY_SYMBOLS</span><br><span class="line">#define _APS_NEXT_RESOURCE_VALUE        130</span><br><span class="line">#define _APS_NEXT_COMMAND_VALUE         32771</span><br><span class="line">#define _APS_NEXT_CONTROL_VALUE         1002</span><br><span class="line">#define _APS_NEXT_SYMED_VALUE           101</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>targetver.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。</span><br><span class="line"></span><br><span class="line">// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将</span><br><span class="line">// 将 _WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。</span><br><span class="line"></span><br><span class="line">#include &lt;SDKDDKVer.h&gt;</span><br></pre></td></tr></table></figure>
<p>资源文件</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/QQHelper.ico" alt></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>[贪心+二分]HUST-Walking in the Forest+POJ-疯牛（求最小化最大值最大化最小值两道经典例题）</title>
    <url>/2018/05/01/2018-05-01/</url>
    <content><![CDATA[<p>今天刚好做了一道关于最大值最小化的问题，这类问题的基本思路就是二分加贪心。那就针对该类问题举两道经典例题进行总结吧。</p>
<h2 id="Walking-in-the-Forest-（最大值最小化例题）"><a href="#Walking-in-the-Forest-（最大值最小化例题）" class="headerlink" title="Walking in the Forest （最大值最小化例题）"></a><a href="https://www.nowcoder.com/acm/contest/106/K" target="_blank" rel="noopener">Walking in the Forest</a> （最大值最小化例题）</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>  It’s universally acknowledged that there’re innumerable trees in the campus of HUST. </p>
<p>  Now you’re going to walk through a large forest. There is a path consisting of N stones winding its way to the other side of the forest. Between every two stones there is a distance. Let di indicates the distance between the stone i and i+1.Initially you stand at the first stone, and your target is the N-th stone. You must stand in a stone all the time, and you can stride over arbitrary number of stones in one step. If you stepped from the stone i to the stone j, you stride a span of (di+di+1+…+dj-1). But there is a limitation. You’re so tired that you want to walk through the forest in no more than K steps. And to walk more comfortably, you have to minimize the distance of largest step.  </p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The first line contains two integer N and K as described above.</span><br><span class="line">Then the next line N-1 positive integer followed, indicating the distance between two adjacent stone.</span><br></pre></td></tr></table></figure>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">An integer, the minimum distance of the largest step.</span><br></pre></td></tr></table></figure>
<p>示例1</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 3 2 2 5</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<p>题意：</p>
<p>有n颗石子，每相邻两颗石子间又一个距离，因此n颗石子共有n-1段距离。现在要求你最多用k步从第一颗石子跳到最后一颗石子。现在让你求最大的一步至少需要跨多少距离。</p>
<p>题解：</p>
<p>典型的最大值最小化问题。用贪心+二分解决即可。先选取一个标准值，然后从第一颗石子往后距离相加，如果加了之后大于标准值，则步数stemp加一，距离清零。最后比较stemp是否小于等于k值。标准值的范围在相邻石子距离最大值ld与第一颗石子到最后一颗石子距离之间rd，因此每次选取中间值作为标准，如果stemp&gt;k，右边界限rd=mid-1，否则ld=mid+1。但需注意有组样例过大容易超时，因此尽量用long long代替int。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">long long  a[100010];</span><br><span class="line">int n, k;</span><br><span class="line">bool check(long long ld,long long rd,long long mind) &#123;</span><br><span class="line">	long long cnt = 0;</span><br><span class="line">	int stemp = 1;</span><br><span class="line">	for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">		if (cnt + a[i] &lt;= mind) &#123;</span><br><span class="line">			cnt += a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cnt = a[i];</span><br><span class="line">			stemp++;</span><br><span class="line">		&#125;</span><br><span class="line">		if (stemp &gt; k)</span><br><span class="line">			return false;</span><br><span class="line">	&#125;</span><br><span class="line">	if (stemp &lt;= k)</span><br><span class="line">		return true;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;k)) &#123;</span><br><span class="line">		long long maxn = 0, sumn = 0;</span><br><span class="line">		for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">			scanf(&quot;%lld&quot;, &amp;a[i]);</span><br><span class="line">			sumn += a[i];</span><br><span class="line">			if (maxn &lt; a[i])</span><br><span class="line">				maxn = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		long long ld = maxn;</span><br><span class="line">		long long rd = sumn;</span><br><span class="line">		long long mind = (ld + rd) / 2;</span><br><span class="line">		while (ld &lt;= rd) &#123;</span><br><span class="line">			bool flag = check(ld, rd, mind);</span><br><span class="line">			if (!flag) &#123;</span><br><span class="line">				ld = mind + 1;</span><br><span class="line">				mind = (ld + rd) / 2;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				rd = mind - 1;</span><br><span class="line">				mind = (ld + rd) / 2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%lld\n&quot;, ld);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="POJ2456疯牛-（最小值最大化例题）"><a href="#POJ2456疯牛-（最小值最大化例题）" class="headerlink" title="POJ2456疯牛 （最小值最大化例题）"></a>POJ2456疯牛 （最小值最大化例题）</h2><p>时间限制：1000 ms  |  内存限制：65535 KB</p>
<p>难度：4</p>
<ul>
<li><p>描述</p>
<p>农夫 John 建造了一座很长的畜栏，它包括N (2 &lt;= N &lt;= 100,000)个隔间，这些小隔间依次编号为x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000).但是，John的C (2 &lt;= C &lt;= N)头牛们并不喜欢这种布局，而且几头牛放在一个隔间里，他们就要发生争斗。为了不让牛互相伤害。John决定自己给牛分配隔间，使任意两头牛之间的最小距离尽可能的大，那么，这个最大的最小距离是什么呢？输入有多组测试数据，以EOF结束。第一行：空格分隔的两个整数N和C第二行——第N+1行：分别指出了xi的位置输出每组测试数据输出一个整数，满足题意的最大的最小值，注意换行。样例输入<code>5 312849</code>样例输出<code>3</code></p>
</li>
</ul>
<p>题意：有n个牛栏，选m个放进牛，相当于一条线段上有 n 个点，选取 m 个点，使得相邻点之间的最小距离值最大。</p>
<p>题解：首先给出n个牛棚的位置，那么每个牛棚之间的最小距离是和相邻两个牛棚之间的距离。因此，先给牛棚的位置排个序。将第一头牛放在0号位置，二分法不断缩进距离d，如果前一头牛放到了xi处，就要将下一头放到满足xi+d&lt;=xj的最小的xj处。这样保证最近的两头牛之间的距离都不会比当前的最小值小，如果每个都能满足这样放就可以作为最小值。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">#include&lt;algorithm&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">int v[100005];  </span><br><span class="line">int n, c;  </span><br><span class="line">int check(int d) &#123;  </span><br><span class="line">    int tmp = v[0], cnt = 1;  </span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;  </span><br><span class="line">        if (v[i] - tmp &gt;= d) &#123;  </span><br><span class="line">            cnt++;  </span><br><span class="line">            tmp = v[i];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (cnt &gt;= c)  </span><br><span class="line">        return 1;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    while (cin &gt;&gt; n &gt;&gt; c) &#123;  </span><br><span class="line">        for (int i = 0; i &lt; n; i++)  </span><br><span class="line">            cin &gt;&gt; v[i];  </span><br><span class="line">        sort(v, v + n);  </span><br><span class="line">        int l = 0, r = v[n - 1], mid;  </span><br><span class="line">        while (l &lt;= r) &#123;  </span><br><span class="line">            mid = (l + r) / 2;  </span><br><span class="line">            if (check(mid))  </span><br><span class="line">                l = mid + 1;  </span><br><span class="line">            else  </span><br><span class="line">                r = mid - 1;  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;%d\n&quot;, r);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>二分法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>贪心</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>The 15ph Zhejiang Provincial Collegiate Programming Contest Sponsored by TuSimple题解</title>
    <url>/2018/04/29/2018-04-29/</url>
    <content><![CDATA[<p>4月29日，13:30-18:30，<a href="http://acm.zju.edu.cn/onlinejudge/showContestProblems.do?contestId=378" target="_blank" rel="noopener">浙江大学程序设计校赛</a> </p>
<h2 id="A-Peak"><a href="#A-Peak" class="headerlink" title="A-Peak"></a>A-Peak</h2><p>题意：</p>
<p>有一串数字，问这串数字是否符合以下情况：</p>
<p>存在一个数在这串数的第k位置，即ak，以k为基准，k之前的数呈递增趋势，即ai-1 &lt; ai。k之后的数呈递减趋势，即ai-1 &gt; ai。ak不能为首元素和尾元素，且ak为最大的那个数。</p>
<p>题解：</p>
<p>水题，每输入一个数直接和前一个数进行比较，先递增判断直到比前一个数小，则递减判断。如果期间存在不符合情况的，则输出No,否则输出Yes。</p>
<h2 id="B-King-of-Karaoke"><a href="#B-King-of-Karaoke" class="headerlink" title="B - King of Karaoke"></a>B - King of Karaoke</h2><p>题意：</p>
<p>两个数组a，b，对a中的每个元素加k使得ai[i]=b[i]的个数最多。求k</p>
<p>题解：</p>
<p>只需用b中的每个元素减去a中的每个元素，即b[i]-a[i]，得到数组c，从中出现元素最多的那个数值的个数即为k。</p>
<h2 id="D-Sequence-Swapping"><a href="#D-Sequence-Swapping" class="headerlink" title="D - Sequence Swapping"></a>D - Sequence Swapping</h2><hr>
<p>Time Limit: 1 Second      Memory Limit: 65536 KB</p>
<hr>
<p>BaoBao has just found a strange sequence {&lt;, &gt;, &lt;, &gt;, , &lt;, &gt;} of length  in his pocket. As you can see, each element &lt;, &gt; in the sequence is an ordered pair, where the first element  in the pair is the left parenthesis ‘(‘ or the right parenthesis ‘)’, and the second element  in the pair is an integer.</p>
<p>As BaoBao is bored, he decides to play with the sequence. At the beginning, BaoBao’s score is set to 0. Each time BaoBao can select an integer , swap the -th element and the -th element in the sequence, and increase his score by , if and only if ,  ‘(‘ and  ‘)’.</p>
<p>BaoBao is allowed to perform the swapping any number of times (including zero times). What’s the maximum possible score BaoBao can get?</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>There are multiple test cases. The first line of the input contains an integer , indicating the number of test cases. For each test case:</p>
<p>The first line contains an integer  (), indicating the length of the sequence.</p>
<p>The second line contains a string  () consisting of ‘(‘ and ‘)’. The -th character in the string indicates , of which the meaning is described above.</p>
<p>The third line contains  integers  (). Their meanings are described above.</p>
<p>It’s guaranteed that the sum of  of all test cases will not exceed .</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case output one line containing one integer, indicating the maximum possible score BaoBao can get.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">6</span><br><span class="line">)())()</span><br><span class="line">1 3 5 -1 3 2</span><br><span class="line">6</span><br><span class="line">)())()</span><br><span class="line">1 3 5 -100 3 2</span><br><span class="line">3</span><br><span class="line">())</span><br><span class="line">1 -1 -1</span><br><span class="line">3</span><br><span class="line">())</span><br><span class="line">-1 -1 -1</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24</span><br><span class="line">21</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>For the first sample test case, the optimal strategy is to select  in order.</p>
<p>For the second sample test case, the optimal strategy is to select  in order.</p>
<p>题意：一串由‘(’与‘)’组成的字符串，其中每一个字符都有一个权值，如果两个相邻的字符a,b为‘（’‘）’，则这两个字符可以进行交换，交换后可获得a和b权值之积的权值sum。求如何操作可以获得最大权值sum。</p>
<p>题解：由于权值存在负数，因此如果相邻两个可以交换的字符如果异号则需谨慎考虑。先从第一个字符进行判断，如果为‘（’，则cur为该字符权值，然后继续判断，如果出现”)”，如果权值相乘为正，则cur不变，权值sum加上cur乘当前权值即cur<em>weight[i]。否则将cur和cur</em>weight[i]压栈，然后cur变为0，继续下一次判断。如果之后以此方法得到的权值为负，则看和栈顶元素相加后是否为正，若为正则取栈顶元素合成新元素，栈顶pop，再继续取栈判断。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int cur;</span><br><span class="line">	int cnt;</span><br><span class="line">&#125;;</span><br><span class="line">char str[1010];</span><br><span class="line">int wei[1010];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int t, n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">	while (t--) &#123;</span><br><span class="line">		scanf(&quot;%d%s&quot;, &amp;n, str);</span><br><span class="line">		for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;wei[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		stack&lt;node&gt;st;</span><br><span class="line">		int sum = 0;</span><br><span class="line">		int cur = 0;</span><br><span class="line">		int cnt = 0;</span><br><span class="line">		for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">			if (str[i] == &apos;(&apos;) &#123;</span><br><span class="line">				if (cur == 0) &#123;</span><br><span class="line">					cur = wei[i];</span><br><span class="line">				&#125;</span><br><span class="line">				else if (abs(cur) &lt; abs(cur + wei[i])) &#123;</span><br><span class="line">					cur = cur + wei[i];</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					cur = wei[i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (str[i] == &apos;)&apos;) &#123;</span><br><span class="line">				if (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0 &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt&gt;cur*wei[i]) &#123;</span><br><span class="line">					cnt = 0;</span><br><span class="line">					do &#123;</span><br><span class="line">						cur += st.top().cur;</span><br><span class="line">						cnt += st.top().cnt;</span><br><span class="line">						st.pop();</span><br><span class="line">					&#125; while (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0 &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; cur*wei[i]);</span><br><span class="line">					sum += cur*wei[i] + cnt;</span><br><span class="line">				&#125;</span><br><span class="line">				else if (cur*wei[i] &gt; 0) &#123;</span><br><span class="line">					sum += wei[i] * cur;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					if (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0) &#123;</span><br><span class="line">						cur += st.top().cur;</span><br><span class="line">						sum += cur*wei[i] + st.top().cnt;</span><br><span class="line">						st.pop();</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						if (!cur&amp;&amp;!st.empty()) &#123;</span><br><span class="line">							st.top().cnt += st.top().cur*wei[i];</span><br><span class="line">						&#125;</span><br><span class="line">						else &#123;</span><br><span class="line">							node tmp;</span><br><span class="line">							tmp.cnt = cur*wei[i];</span><br><span class="line">							tmp.cur = cur;</span><br><span class="line">							st.push(tmp);</span><br><span class="line">							cur = 0;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, sum);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="J-CONTINUE…"><a href="#J-CONTINUE…" class="headerlink" title="J - CONTINUE…?"></a>J - CONTINUE…?</h2><hr>
<p>Time Limit: 1 Second      Memory Limit: 65536 KB      Special Judge</p>
<hr>
<p>DreamGrid has  classmates numbered from  to . Some of them are boys and the others are girls. Each classmate has some gems, and more specifically, the -th classmate has  gems.</p>
<p>DreamGrid would like to divide the classmates into four groups , ,  and  such that:</p>
<ul>
<li>Each classmate belongs to exactly one group.</li>
<li>Both  and  consist only of girls. Both  and  consist only of boys.</li>
<li>The total number of gems in  and  is equal to the total number of gems in  and .</li>
</ul>
<p>Your task is to help DreamGrid group his classmates so that the above conditions are satisfied. Note that you are allowed to leave some groups empty.</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>There are multiple test cases. The first line of input is an integer  indicating the number of test cases. For each test case:</p>
<p>The first line contains an integer  () – the number of classmates.</p>
<p>The second line contains a string  () consisting of 0 and 1. Let  be the -th character in the string . If , the -th classmate is a boy; If , the -th classmate is a girl.</p>
<p>It is guaranteed that the sum of all  does not exceed .</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output a string consists only of {1, 2, 3, 4}. The -th character in the string denotes the group which the -th classmate belongs to. If there are multiple valid answers, you can print any of them; If there is no valid answer, output “-1” (without quotes) instead.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">10</span><br><span class="line">3</span><br><span class="line">101</span><br><span class="line">4</span><br><span class="line">0000</span><br><span class="line">7</span><br><span class="line">1101001</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br><span class="line">-1</span><br><span class="line">314</span><br><span class="line">1221</span><br><span class="line">3413214</span><br></pre></td></tr></table></figure>
<p>题意：</p>
<p>有一串由0和1组成的数字，该串数字的长度是n，即n个数。这n个数1代表男生，0代表女生，每个人有一个权值。这n个数按次序权值依次为1到n，即第i个人权值为i。现将女生分两队，即1队2队，男生分两队，即3队4队，问如何分配队员使1队+3队的权值总和等于2队＋4队的权值总和。（每队人数可以为0，如果有多种符合情况的组队方法，只需选择其中一种即可）</p>
<p>题解：</p>
<p>看似复杂，其实仔细想想，只需将所有数的权值相加除以2得到half，以half这个数为基准，看哪些数相加为half，如果没有输出-1。思路大致是这样。将所有数的性别情况用a[i]存储。然后从1加到n，得到的数除以2，如果不能整除则表示1队+3队永远不会等于2队+4队，直接输出-1。如果能整除，则以half为基准，sum为每次加的数，初始值为0。把1队和3队归为一队，把2队4队归为一队。先从最大的即n开始进行比较，如果n &lt; half，sum加上n。然后进行判断half - sum=tmp是否小于n，如果小于n则证明tmp这个数一定在n之前，那直接将n以及tmp分为1个队，其他人则自然分为另一个队。如果 &gt;= n，则再从n-1开始比较，如果sum+n-1这个数大于half，则表示n-1和之前标记的数不是一个队，则从n-2继续比较。一直循环下去，直到加完之后刚好等于half，则标记过的是一队，未标记的是另一对，再分别对这两队进行性别判断，再细分即可。这样直接用贪心就解决了</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">int a[100010], vis[100010];</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int t;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">	long long int sum = 0, half = 0;</span><br><span class="line">	while (t--) &#123;</span><br><span class="line">		int n;</span><br><span class="line">		sum = 0;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%1d&quot;, &amp;a[i]);</span><br><span class="line">			sum += i + 1;</span><br><span class="line">		&#125;</span><br><span class="line">		if (sum % 2 != 0) &#123;</span><br><span class="line">			printf(&quot;-1\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">			half = sum / 2;</span><br><span class="line">		sum = 0;</span><br><span class="line">		for (int i = n; i &gt; 0; i--) &#123;</span><br><span class="line">			if (sum + i &lt;= half) &#123;</span><br><span class="line">				sum += i;</span><br><span class="line">				vis[i - 1] = 1;</span><br><span class="line">				if (sum == half)</span><br><span class="line">					break;</span><br><span class="line">				else if (half - sum &lt; i) &#123;</span><br><span class="line">					vis[half - sum - 1] = 1;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">			if (a[i]) &#123;</span><br><span class="line">				if (vis[i])</span><br><span class="line">					printf(&quot;3&quot;);</span><br><span class="line">				else</span><br><span class="line">					printf(&quot;4&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (!a[i]) &#123;</span><br><span class="line">				if (vis[i])</span><br><span class="line">					printf(&quot;1&quot;);</span><br><span class="line">				else</span><br><span class="line">					printf(&quot;2&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="L-Doki-Doki-Literature-Club"><a href="#L-Doki-Doki-Literature-Club" class="headerlink" title="L - Doki Doki Literature Club"></a>L - Doki Doki Literature Club</h2><hr>
<p>Time Limit: 1 Second      Memory Limit: 65536 KB</p>
<hr>
<p><em>Doki Doki Literature Club!</em> is a visual novel developed by Team Salvato. The protagonist is invited by his childhood friend, Sayori, to join their high school’s literature club. The protagonist then meets the other members of the club: Natsuki, Yuri, and the club president Monika. The protagonist starts to participate in the club’s activities such as writing and sharing poetry, and grows close to the four girls. What a lovely story!</p>
<p>A very important feature of the game is its poetry writing mechanism. The player is given a list of various words to select from that will make up his poem. Each girl in the Literature Club has different word preferences, and will be very happy if the player’s poem is full of her favorite words.</p>
<p><img src="http://acm.zju.edu.cn/onlinejudge/showImage.do?name=poem.jpg" alt="img"><em>The poem writing mini-game (from wikipedia)</em></p>
<p>BaoBao is a big fan of the game and likes Sayori the most, so he decides to write a poem to please Sayori. A poem of  words  is nothing more than a sequence of  strings, and the happiness of Sayori after reading the poem is calculated by the formula</p>
<p>Given a list of  words and Sayori’s preference to each word, please help BaoBao select  words from the list and finish the poem with these  words to maximize the happiness of Sayori.</p>
<p>Please note that each word can be used at most <strong>once</strong>!</p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>There are multiple test cases. The first line of input contains an integer  (about 100), indicating the number of test cases. For each test case:</p>
<p>The first line contains two integers  and  (), indicating the number of words and the length of the poem.</p>
<p>For the following  lines, the -th line contains a string consisting of lowercased English letters  () and an integer  (), indicating the -th word and Sayori’s preference to this word. It’s guaranteed that  for all .</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>For each test case output one line containing an integer  and  strings  separated by one space, indicating the maximum possible happiness and the corresponding poem. If there are multiple poems which can achieve the maximum happiness, print the lexicographically smallest one.</p>
<p>Please, DO NOT output extra spaces at the end of each line, or your answer may be considered incorrect!</p>
<p>A <strong>sequence</strong> of  strings  is lexicographically smaller than another <strong>sequence</strong> of  strings , if there exists a  () such that  for all  and  is lexicographically smaller than .</p>
<p>A <strong>string</strong>  is lexicographically smaller than another <strong>string</strong> , if there exists a  () such that  for all  and , or  for all  and .</p>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">10 8</span><br><span class="line">hello 0</span><br><span class="line">world 0</span><br><span class="line">behind 0</span><br><span class="line">far 1</span><br><span class="line">be 2</span><br><span class="line">spring 10</span><br><span class="line">can 15</span><br><span class="line">comes 20</span><br><span class="line">winter 25</span><br><span class="line">if 200</span><br><span class="line">5 5</span><br><span class="line">collegiate 0</span><br><span class="line">programming -5</span><br><span class="line">zhejiang 10</span><br><span class="line">provincial 5</span><br><span class="line">contest -45</span><br><span class="line">3 2</span><br><span class="line">bcda 1</span><br><span class="line">bcd 1</span><br><span class="line">bbbbb 1</span><br><span class="line">3 2</span><br><span class="line">a 1</span><br><span class="line">aa 1</span><br><span class="line">aaa 1</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018 if winter comes can spring be far behind</span><br><span class="line">15 zhejiang provincial collegiate programming contest</span><br><span class="line">3 bbbbb bcd</span><br><span class="line">3 a aa</span><br></pre></td></tr></table></figure>
<p>题意：</p>
<p>有n个字符串，每个字符串都有一个权值。现从n个字符串中选择m个字符串，其中m个字符串选取的第i个字符串的权值乘i。问如何选择使权值之和最大，并输出这些字符串。如果权值相同则输出字符串优先级高的。</p>
<p>题解：按权值从大到小进行排序，如果权值相同则按字符串的首字符优先级从大到小排序。排完序后选择前m个字符串，第i字符串的权值乘i之后相加，输出相加值之后，再输出前m大的字符串即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">	string str;</span><br><span class="line">	long long int weight;</span><br><span class="line">&#125;;</span><br><span class="line">node level[110];</span><br><span class="line">bool cmp(node a,node b) &#123;</span><br><span class="line">	if (a.weight != b.weight)</span><br><span class="line">		return a.weight &gt; b.weight;</span><br><span class="line">	else &#123;</span><br><span class="line">		return a.str &lt; b.str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int t, n, m;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">	while (t--) &#123;</span><br><span class="line">		long long int h = 0;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">		for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; level[i].str &gt;&gt; level[i].weight;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(level, level + n, cmp);</span><br><span class="line">		for (int i = m; i &gt; 0; i--)</span><br><span class="line">			h += level[m - i].weight*i;</span><br><span class="line">		printf(&quot;%lld &quot;, h);</span><br><span class="line">		for (int i = 0; i &lt; m - 1; i++)</span><br><span class="line">			cout &lt;&lt; level[i].str &lt;&lt; &quot; &quot;;</span><br><span class="line">		cout &lt;&lt; level[m - 1].str &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="K-Lucky-7"><a href="#K-Lucky-7" class="headerlink" title="K - Lucky 7"></a>K - Lucky 7</h2><p>给一个数n和m，接下来n个数，问这n个数中是否存在一个数加m是7的倍数。</p>
<p>题解：</p>
<p>每输入一个数直接进行判断即可。</p>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>ZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>基于github搭建专属于自己的博客(高级篇)</title>
    <url>/2018/04/28/2018-04-28-3/</url>
    <content><![CDATA[<p>由于本人懒病又犯了，该部分后续再补上吧。大家不要介意啊。(#^.^#)</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>前端</tag>
        <tag>hexo</tag>
        <tag>node.js</tag>
        <tag>html/css</tag>
      </tags>
  </entry>
  <entry>
    <title>基于github搭建专属于自己的博客(进阶篇)</title>
    <url>/2018/04/28/2018-04-28-2/</url>
    <content><![CDATA[<p>本文基于上篇文章基础篇所写。有许多基于hexo的主题，每个不同的主题会需要不同的配置，主题配置文件在主题目录下的_config.yml。我们可以根据自己的情况选择适合自己的主题。我们选取其中一款主题NextT为模板进行演示。以下是本文的基本流程。</p>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>1.安装主题</p>
<p>2.启用主题</p>
<p>3.验证主题</p>
<p>4.设置语言</p>
<p>5.设置菜单</p>
<p>6.侧栏设置</p>
<p>7.尾栏设置</p>
<p>8.附页</p>
<h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 <strong>站点配置文件</strong>， 后者称为 <strong>主题配置文件</strong>。 </p>
<p>以NexT为例，首先在hexo文件夹中右键点击Git Base Here，或者终端锁定hexo根目录，然后输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>即可获取最新版主题，后续更新只需输入指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
<h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>在hexo根目录（blog）中打开站点配置文件（_config.yml）,搜索theme字段。修改theme: next</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>注意中间有空格。到此，NexT 主题安装完成。</p>
<h3 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h3><p>在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>首先启动 Hexo 本地站点，并开启调试模式，整个命令是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p> 在服务启动的过程，注意观察命令行输出是否有任何异常信息。 当命令行输出中提示出：INFO Hexo is running at <a href="http://0.0.0.0:4000/" target="_blank" rel="noopener">http://0.0.0.0:4000/</a>. Press Ctrl+C to stop.此时即可使用浏览器访问 <a href="http://localhost:4000/。" target="_blank" rel="noopener">http://localhost:4000/。</a></p>
<p>如果端口号被占用还是得先修改端口号，然后启动服务。即先输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server -p 5000</span><br></pre></td></tr></table></figure>
<p> 当命令行输出中提示出：INFO Hexo is running at <a href="http://0.0.0.0:5000/" target="_blank" rel="noopener">http://0.0.0.0:5000/</a>. Press Ctrl+C to stop.此时即可使用浏览器访问 <a href="http://localhost:5000/。" target="_blank" rel="noopener">http://localhost:5000/。</a></p>
<p>完成之后进行主题设定。借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。在next主题目录下的_config.yml文件中目前有四种模板，他们是：</p>
<p>Muse - 默认 Scheme，初代 NexT ，黑白主调，大量留白</p>
<p>Mist - Muse 的紧凑版本，整洁有序的单栏外观</p>
<p>Pisces - 双栏 Scheme，小家碧玉似的清新</p>
<p> Gemini - 双栏Scheme，简约淡雅的风尚</p>
<p>注释 # 即可。 以Pisce为例，选择 Pisce Scheme</p>
<h3 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h3><p>在<strong>站点根目录</strong>下修改配置文件_cofig.yml中的language为zh-Hans（简体中文）</p>
<p>目前 NexT 支持的语言如以下表格所示：</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>代码</th>
<th>设定实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>English</td>
<td>en</td>
<td>language: en</td>
</tr>
<tr>
<td>简体中文</td>
<td>zh-Hans</td>
<td>language: zh-Hans</td>
</tr>
<tr>
<td>Français</td>
<td>fr-FR</td>
<td>language: fr-FR</td>
</tr>
<tr>
<td>Português</td>
<td>pt</td>
<td>language: pt</td>
</tr>
<tr>
<td>繁體中文</td>
<td>zh-hk 或者 zh-tw</td>
<td>language: zh-hk</td>
</tr>
<tr>
<td>Русский язык</td>
<td>ru</td>
<td>language: ru</td>
</tr>
<tr>
<td>Deutsch</td>
<td>de</td>
<td>language: de</td>
</tr>
<tr>
<td>日本語</td>
<td>ja</td>
<td>language: ja</td>
</tr>
<tr>
<td>Indonesian</td>
<td>id</td>
<td>language: id</td>
</tr>
</tbody>
</table>
<h3 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h3><h4 id="菜单栏设置"><a href="#菜单栏设置" class="headerlink" title="菜单栏设置"></a>菜单栏设置</h4><p>菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。</p>
<p>编辑主题配置文件，修改以下内容： 设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。 菜单示例配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  archives: /archives</span><br><span class="line">  #about: /about</span><br><span class="line">  #categories: /categories</span><br><span class="line">  tags: /tags</span><br><span class="line">  #commonweal: /404.html</span><br></pre></td></tr></table></figure>
<p>若你的站点运行在子目录中，请将链接前缀的 / 去掉 NexT 默认的菜单项有（标注 的项表示需要手动创建这个页面）：</p>
<table>
<thead>
<tr>
<th>键值</th>
<th>设定值</th>
<th>显示文本（简体中文）</th>
</tr>
</thead>
<tbody>
<tr>
<td>home</td>
<td>home: /</td>
<td>主页</td>
</tr>
<tr>
<td>archives</td>
<td>archives: /archives</td>
<td>归档页</td>
</tr>
<tr>
<td>categories</td>
<td>categories: /categories</td>
<td>分类页</td>
</tr>
<tr>
<td>tags</td>
<td>tags: /tags</td>
<td>标签页</td>
</tr>
<tr>
<td>about</td>
<td>about: /about</td>
<td>关于页面</td>
</tr>
<tr>
<td>commonweal</td>
<td>commonweal: /404.html</td>
<td>公益 404</td>
</tr>
</tbody>
</table>
<p>设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 比如你在站点根目录中的配置文件设置language为zh-Hans，那么就要进入到主题目录下的languages文件中修改zh-Hans.yml，这样才能显示出菜单项新增的中文内容。以简体中文为例，若你需要添加一个菜单项，那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml。以下是默认情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: 首页</span><br><span class="line">  archives: 归档</span><br><span class="line">  categories: 分类</span><br><span class="line">  tags: 标签</span><br><span class="line">  about: 关于</span><br><span class="line">  search: 搜索</span><br><span class="line">  commonweal: 公益404</span><br></pre></td></tr></table></figure>
<p>设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。菜单图标配置示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  # Icon Mapping.</span><br><span class="line">  home: home</span><br><span class="line">  about: user</span><br><span class="line">  categories: th</span><br><span class="line">  tags: tags</span><br><span class="line">  archives: archive</span><br><span class="line">  commonweal: heartbeat</span><br></pre></td></tr></table></figure>
<h4 id="添加标签，分类"><a href="#添加标签，分类" class="headerlink" title="添加标签，分类"></a>添加标签，分类</h4><p>添加标签页面，前面通过修改next主题下的<code>_config.yml</code>文件中的menu选项，可以在主页面的菜单栏添加标签选项，但是此时点击标签，跳转的页面会显示page not found。此时我们要新建一个页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>在新建的index.md文件中添加type: “tags”</p>
<p>当要为某一篇文章添加标签，只需在b<code>log/source/_post</code>目录下的具体文章的tags中添加标签即可</p>
<p>添加分类页面，前面通过修改next主题下的<code>_config.yml</code>文件中的menu选项，可以在主页面的菜单栏添加分类选项。此时我们要新建一个页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>在新建的index.md文件中添加type: “categories”</p>
<p>当要为某一篇文章添加标签，只需在<code>blog/source/_post</code>目录下的具体文章的categories中添加分类即可。分类可按次序进行分级。</p>
<p>添加关于我页面，步骤和以上差不多</p>
<p>在新建的index.md文件中添加内容</p>
<h3 id="侧栏设置"><a href="#侧栏设置" class="headerlink" title="侧栏设置"></a>侧栏设置</h3><p>设置侧栏位置，修改主题目录下sidebar的position值</p>
<p>设置头像，在站点根目录下载配置文件中新增avatar，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下）</p>
<h3 id="尾栏设置"><a href="#尾栏设置" class="headerlink" title="尾栏设置"></a>尾栏设置</h3><p>修改底部的官方logo，找到 <code>\themes\next\layout\_partials\</code>下面的<code>footer.swig</code>文件，打开会发现，如下的语句：</p>
<p>第一个框 是下面侧栏的“日期❤ XXX”</p>
<p>如果想像我一样加东西，一定要在双大括号外面写。如：xxx,当然你要是想改彻底可以变量都删掉，看个人意愿。</p>
<p>第二个，是图一当中 “由Hexo驱动” 的Hexo链接，先给删掉防止跳转，如果想跳转当然也可以自己写地址，至于中文一会处理。注意删除的时候格式不能错，只把<code>&lt;a&gt;...&lt;/a&gt;</code>标签这部分删除即可，留着两个单引号’’,否则会出错哦。</p>
<p>第三个框也是最后一个了，这个就是更改图一后半部分“主题-Next.XX”,这个比较爽直接将<code>&lt;a&gt;..&lt;/a&gt;</code>都删掉，同样中文“主题”一会处理，删掉之后在上一行 ‘-’后面可以随意加上你想显示的东西，不要显示敏感信息哟，请自重。</p>
<p>接下来，处理剩余的中文信息。找到这个地方<code>\themes\next\languages\</code> 下面的语言文件zh-Hans.yml（这里以中文为例，有的习惯用英文的配置文件，道理一样，找对应位置即可）</p>
<p>看到了吧，这个就是传值传过去的，你想显示什么就在这里面大肆的去改动吧。其实在第二个框中，就可以把值都改掉，不用接受传值的方式，完全自己可以重写。不过我不建议那样做，因为传值这样只要是后续页面需要这几个值那么就都会通过取值去传过去，要是在刚才footer文件中直接写死，后续不一定哪个页面需要传值，但是值为空了或者还是原来的，可就尴尬了。所以还是这样改动吧。</p>
<h3 id="附页"><a href="#附页" class="headerlink" title="附页"></a>附页</h3><p>站点配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"># Site 网站</span><br><span class="line">title: 浅悠悠的个人博客   #网站标题</span><br><span class="line">subtitle: 。。。   #网站副标题</span><br><span class="line">description: 。。。   #网站描述</span><br><span class="line">author: 王骏   #您的名字</span><br><span class="line">language: zh-CN   #网站使用的语言</span><br><span class="line">timezone:           #网站时区。Hexo 默认使用您电脑的时区</span><br><span class="line"></span><br><span class="line"># URL 网址</span><br><span class="line">## 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。</span><br><span class="line">url: http://willxue.top</span><br><span class="line">permalink: :year/:month/:day/:title/    #生成文件名字的格式我改成blog/:title:year:month:day/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"># Directory 目录配置</span><br><span class="line">source_dir: source   #源文件夹，这个文件夹用来存放内容。</span><br><span class="line">public_dir: public   #公共文件夹，这个文件夹用于存放生成的站点文件。</span><br><span class="line">tag_dir: tags   #标签文件夹</span><br><span class="line">archive_dir: archives   #归档文件夹</span><br><span class="line">category_dir: categories   #分类文件夹</span><br><span class="line">code_dir: downloads/code    #nclude code 文件夹</span><br><span class="line">i18n_dir: :lang   #国际化（i18n）文件夹</span><br><span class="line">skip_render:   #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</span><br><span class="line"></span><br><span class="line"># Writing 文章</span><br><span class="line">new_post_name: :title.md   # 新建文章默认文件名</span><br><span class="line">default_layout: post   # 默认布局</span><br><span class="line">titlecase: false   # Transform title into titlecase</span><br><span class="line">external_link: true   # 在新标签中打开一个外部链接，默认为true</span><br><span class="line">filename_case: 0   #转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。</span><br><span class="line">render_drafts: false   #是否渲染_drafts目录下的文章，默认为false</span><br><span class="line">post_asset_folder: false   #启动 Asset 文件夹</span><br><span class="line">relative_link: false   #把链接改为与根目录的相对位址，默认false</span><br><span class="line">future: true   #显示未来的文章，默认false</span><br><span class="line">highlight:   #代码块的设置 </span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag   分类和标签的设置</span><br><span class="line">default_category: uncategorized   #默认分类</span><br><span class="line">category_map:   #分类别名</span><br><span class="line">tag_map:   #标签别名</span><br><span class="line"></span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"># Pagination 分页</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10   #每页显示的文章量 (0 = 关闭分页功能)</span><br><span class="line">pagination_dir: page   #分页目录</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br><span class="line"></span><br><span class="line">feed:</span><br><span class="line">  type: atom       #feed 类型 (atom/rss2)</span><br><span class="line">  path: atom.xml   #rss 路径</span><br><span class="line">  limit: 20        #在 rss 中最多生成的文章数(0显示所有)</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy: </span><br><span class="line">type: git </span><br><span class="line">  repository: https://github.com/imwillxue/imwillxue.github.com.git </span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>主题配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Site Information Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Place your favicon.ico to /source directory.</span><br><span class="line">favicon: /favicon.ico   #站标  可以放在hexo文件夹下的/source里</span><br><span class="line"></span><br><span class="line"># Set default keywords (Use a comma to separate)</span><br><span class="line">keywords: &quot;为学,willxue,willxue.top&quot;  #网站关键字</span><br><span class="line"></span><br><span class="line"># Set rss to false to disable feed link.</span><br><span class="line"># Leave rss as empty to use site&apos;s feed link.</span><br><span class="line"># Set rss to specific value if you have burned your feed already.</span><br><span class="line">rss:  #rss这里不设置 引文站点配置文件已经配置了 需要安装插件</span><br><span class="line"></span><br><span class="line"># Specify the date when the site was setup</span><br><span class="line">since: 1990  #网站时间 从xx开始 类似 1990-2016</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Menu Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># When running hexo in a subdirectory (e.g. domain.tld/blog)</span><br><span class="line"># Remove leading slashes ( &quot;/archives&quot; -&gt; &quot;archives&quot; )</span><br><span class="line">menu: #菜单路径设置 如果hexo在二级目录放置要去掉/</span><br><span class="line">  home: /</span><br><span class="line">  archives: /archives #归档</span><br><span class="line">  tags: /tags #标签</span><br><span class="line">  categories: /categories  #分类</span><br><span class="line">  about: /about #关于我</span><br><span class="line">  commonweal: /404.html  #公益404</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Enable/Disable menu icons.</span><br><span class="line"># Icon Mapping:</span><br><span class="line">#   Map a menu item to a specific FontAwesome icon name.</span><br><span class="line">#   Key is the name of menu item and value is the name of FontAwsome icon.</span><br><span class="line">#   When an question mask icon presenting up means that the item has no mapping icon.</span><br><span class="line">menu_icons:  #icon图标</span><br><span class="line">  enable: true</span><br><span class="line">  # Icon Mapping.</span><br><span class="line">  home: home</span><br><span class="line">  about: user</span><br><span class="line">  categories: th</span><br><span class="line">  tags: tags</span><br><span class="line">  archives: archive</span><br><span class="line">  commonweal: heartbeat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Scheme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Schemes  #next的三个scheme</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Sidebar Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Social links   #社交链接</span><br><span class="line">social:</span><br><span class="line">  GitHub: </span><br><span class="line">  Weibo:</span><br><span class="line">  Others:</span><br><span class="line"></span><br><span class="line"># Social Icons  #社交的图标</span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  # Icon Mappings</span><br><span class="line">  GitHub: github</span><br><span class="line">  Twitter: twitter</span><br><span class="line">  Weibo: weibo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Sidebar Avatar</span><br><span class="line"># in theme directory(source/images): /images/avatar.jpg</span><br><span class="line"># in site  directory(source/uploads): /uploads/avatar.jpg</span><br><span class="line"># default : /images/default_avatar.jpg</span><br><span class="line">avatar: http://7xrz9n.com1.z0.glb.clouddn.com/logo.png #头像</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># TOC in the Sidebar  #文章自动显示目录</span><br><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Automatically add list number to toc.  #目录是否自动显示数字序号</span><br><span class="line">  number: false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Creative Commons 4.0 International License.</span><br><span class="line"># http://creativecommons.org/  #自由协议</span><br><span class="line"># Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span><br><span class="line">#creative_commons: by-nc-sa</span><br><span class="line">#creative_commons:</span><br><span class="line"></span><br><span class="line">sidebar:</span><br><span class="line">  # Sidebar Position, available value: left | right</span><br><span class="line">  position: left</span><br><span class="line">  #position: right</span><br><span class="line"></span><br><span class="line">  # Sidebar Display, available value:</span><br><span class="line">  #  - post    expand on posts automatically. Default.</span><br><span class="line">  #  - always  expand for all pages automatically</span><br><span class="line">  #  - hide    expand only when click on the sidebar toggle icon.</span><br><span class="line">  #  - remove  Totally remove sidebar including sidebar toggle icon.</span><br><span class="line">  display: post</span><br><span class="line">  #display: always</span><br><span class="line">  #display: hide</span><br><span class="line">  #display: remove</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Misc Theme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Custom Logo.</span><br><span class="line"># !!Only available for Default Scheme currently.</span><br><span class="line"># Options:</span><br><span class="line">#   enabled: [true/false] - Replace with specific image</span><br><span class="line">#   image: url-of-image   - Images&apos;s url</span><br><span class="line">custom_logo:</span><br><span class="line">  enabled: false</span><br><span class="line">  image:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Code Highlight theme</span><br><span class="line"># Available value:</span><br><span class="line">#    normal | night | night eighties | night blue | night bright</span><br><span class="line"># https://github.com/chriskempson/tomorrow-theme</span><br><span class="line">highlight_theme: night</span><br><span class="line"></span><br><span class="line"># Automatically scroll page to section which is under &lt;!-- more --&gt; mark.</span><br><span class="line">scroll_to_more: true</span><br><span class="line"></span><br><span class="line"># Automatically Excerpt</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: false</span><br><span class="line">  length: 150</span><br><span class="line"></span><br><span class="line"># Use Lato font</span><br><span class="line">use_font_lato: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Third Party Services Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Swiftype Search API Key</span><br><span class="line">#swiftype_key:</span><br><span class="line"></span><br><span class="line"># Baidu Analytics ID</span><br><span class="line">#baidu_analytics:</span><br><span class="line"></span><br><span class="line"># Duoshuo ShortName</span><br><span class="line">duoshuo_shortname: imwillxue</span><br><span class="line"></span><br><span class="line"># Disqus</span><br><span class="line">#disqus_shortname:</span><br><span class="line"></span><br><span class="line"># Baidu Share</span><br><span class="line"># Available value:</span><br><span class="line">#    button | slide</span><br><span class="line">#baidushare:</span><br><span class="line">##  type: button</span><br><span class="line"></span><br><span class="line"># Share</span><br><span class="line">#jiathis:</span><br><span class="line">#add_this_id:</span><br><span class="line"></span><br><span class="line"># Share</span><br><span class="line">duoshuo_share: true</span><br><span class="line"></span><br><span class="line"># Google Webmaster tools verification setting</span><br><span class="line"># See: https://www.google.com/webmasters/</span><br><span class="line">#google_site_verification:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Google Analytics</span><br><span class="line">#google_analytics:</span><br><span class="line"></span><br><span class="line"># CNZZ count</span><br><span class="line">#cnzz_siteid:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Make duoshuo show UA</span><br><span class="line"># user_id must NOT be null when admin_enable is true!</span><br><span class="line"># you can visit http://dev.duoshuo.com get duoshuo user id.</span><br><span class="line">duoshuo_info:</span><br><span class="line">  ua_enable: true</span><br><span class="line">  admin_enable: true</span><br><span class="line">  user_id: 6262178932196377345</span><br><span class="line">  admin_nickname: 神</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Facebook SDK Support.</span><br><span class="line"># https://github.com/iissnan/hexo-theme-next/pull/410</span><br><span class="line">facebook_sdk:</span><br><span class="line">  enable: false</span><br><span class="line">  app_id:       #&lt;app_id&gt;</span><br><span class="line">  fb_admin:     #&lt;user_id&gt;</span><br><span class="line">  like_button:  #true</span><br><span class="line">  webmaster:    #true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: QImiFijLSOHYufsazlBVlwLg-gzGzoHsz</span><br><span class="line">  app_key: AMcYaNHy9Y5OdH42k0d4uSED</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Tencent analytics ID</span><br><span class="line"># tencent_analytics:</span><br><span class="line"></span><br><span class="line"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO</span><br><span class="line">baidu_push: true</span><br><span class="line"></span><br><span class="line">## 文章末尾是否显示打赏按钮</span><br><span class="line">donate: </span><br><span class="line">  enable: true</span><br><span class="line">  text: Enjoy it ? Donate me !  欣赏此文？求鼓励，求支持！</span><br><span class="line">  alipay: </span><br><span class="line">  wechat: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#! ---------------------------------------------------------------</span><br><span class="line">#! DO NOT EDIT THE FOLLOWING SETTINGS</span><br><span class="line">#! UNLESS YOU KNOW WHAT YOU ARE DOING</span><br><span class="line">#! ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Motion</span><br><span class="line">use_motion: true</span><br><span class="line"></span><br><span class="line"># Fancybox</span><br><span class="line">fancybox: true</span><br><span class="line"></span><br><span class="line"># Static files</span><br><span class="line">vendors: vendors</span><br><span class="line">css: css</span><br><span class="line">js: js</span><br><span class="line">images: images</span><br><span class="line"></span><br><span class="line"># Theme version</span><br><span class="line">version: 0.5.0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>前端</tag>
        <tag>hexo</tag>
        <tag>node.js</tag>
        <tag>html/css</tag>
      </tags>
  </entry>
  <entry>
    <title>基于github搭建专属于自己的博客（基础篇）</title>
    <url>/2018/04/28/2018-04-28-1/</url>
    <content><![CDATA[<p>以前学Django时，看的视频教程就是以搭建博客为案例讲解的。虽然最终也没搭建成功，但是当时就想搭建属于自己的博客。偶然间了解到了hexo搭建博客，恰好最近有空，索性就利用这段时间搭建一个属于自己的博客。首先，我先介绍一下用hexo搭建博客的基本流程：</p>
<h2 id="基本流程："><a href="#基本流程：" class="headerlink" title="基本流程："></a>基本流程：</h2><p>1.搭建前的准备（包括node.js，git，github账户的配置）</p>
<p>2.安装hexo</p>
<p>3.配置hexo</p>
<p>4.连接hexo与github page</p>
<p>5.发布文章</p>
<h3 id="搭建前的准备"><a href="#搭建前的准备" class="headerlink" title="搭建前的准备"></a>搭建前的准备</h3><p>1.安装node.js</p>
<p>2.安装git</p>
<p>3.github账户管理</p>
<h4 id="配置Node-js"><a href="#配置Node-js" class="headerlink" title="配置Node.js"></a>配置Node.js</h4><p>下载<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a>。根据自己电脑的配置自行安装。</p>
<p>安装完成后打开终端输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>进行是否安装成功测试。如不正确，回头检查哪一步错误。</p>
<h4 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h4><p><a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>官网。自行安装。</p>
<p>安装完成后打开终端输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
<p>以上步骤进行是否安装成功。如果安装失败自行面壁。</p>
<h4 id="github管理"><a href="#github管理" class="headerlink" title="github管理"></a>github管理</h4><p>已拥有账号可跳过注册此步</p>
<p>打开<a href="https://github.com/" target="_blank" rel="noopener">github</a>进行注册。</p>
<p>登录后点击右上角加号，选择New repository新建代码库。</p>
<p>进入代码库创建页面：</p>
<p>在Repository name下填写yourname.github.io，Description (optional)下填写描述（此步可忽略）。</p>
<p><strong>注意：我的github名称是qianyouyou ,这里就填qianyouyou.github.io</strong></p>
<p>建立后，点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages。点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。</p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>在合适的地方创建文件夹，这里我以E:/blog 为例子讲解，首先在E盘目录下创建blog文件夹，终端锁定该文件夹</p>
<p>在命令行输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo -g   //进行安装</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v   //检验是否安装成功。</span><br></pre></td></tr></table></figure>
<h3 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h3><p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init   //初始化该文件夹</span><br></pre></td></tr></table></figure>
<p>看到后面的“Start blogging with Hexo！”证明正在执行。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install   //安装所需要的组件</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g   //生成</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>开启服务器，访问该网址，正式体验Hexo</p>
<h3 id="连接hexo与github-page"><a href="#连接hexo与github-page" class="headerlink" title="连接hexo与github page"></a>连接hexo与github page</h3><p>设置Git的user name和email（如果是第一次的话）在blog文件夹里面鼠标右键，点击Git Base Here。</p>
<p>输入cd ~/.ssh，检查是否由.ssh的文件夹</p>
<p>输入ls，列出该文件下的内容</p>
<p>输入ssh-keygen -t rsa -C “<a href="mailto:xxxxxx@xx.com" target="_blank" rel="noopener">xxxxxx@xx.com</a>”，（你的邮箱）连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。</p>
<p> 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent</p>
<p>再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent</p>
<p>登录Github，点击头像下的settings，添加ssh</p>
<p>新建一个new ssh key，将id_rsa.pub文件里的内容复制上去</p>
<p>输入ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了</p>
<p><strong>问题：</strong>假如ssh-key配置失败，那么只要以下步骤就能完全解决</p>
<p>首先，清除所有的key-pair<br>ssh-add -D<br>rm -r ~/.ssh<br>删除你在github中的public-key</p>
<p>重新生成ssh密钥对<br>ssh-keygen -t rsa -C “<a href="mailto:xxx@xxx.com" target="_blank" rel="noopener">xxx@xxx.com</a>“</p>
<p>接下来正常操作<br>在github上添加公钥public-key:<br>1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板<br>2、在github上添加公钥时，直接复制即可<br>3、保存</p>
<p>测试：<br>在终端 ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p>
<p>配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾）</p>
<p>repo值是你在github项目里的ssh（右下角）</p>
<h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>新建一篇博客，在cmd执行命令：hexo new post “博客名”</p>
<p>这时候在我的 电脑的目录下 E:\blog\source\ _posts 将会看到 article title.md 文件</p>
<p>在生成以及部署文章之前，需要安装一个扩展：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g   // 生成</span><br><span class="line">hexo d   // 部署</span><br></pre></td></tr></table></figure>
<p>当然你也可以执行下面的命令，相当于上面两条命令的效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g -d   //在部署前先生成</span><br></pre></td></tr></table></figure>
<p>部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章。</p>
<p>到此为止，最基本的也是最全面的hexo+github搭建博客完结。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>前端</tag>
        <tag>hexo</tag>
        <tag>node.js</tag>
        <tag>html/css</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/04/24/2018-04-24/</url>
    <content><![CDATA[<p>Welcome to <a href="https://qianyouyou.cn/">My Blog</a>! This is my very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><p>1<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>hexo</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]堆的基本操作</title>
    <url>/2018/04/23/2018-04-23/</url>
    <content><![CDATA[<p>堆（heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：</p>
<p>1.堆总是一棵完全二叉树。</p>
<p>2.堆中某个节点的值总是不大于或不小于其父节点的值。</p>
<p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</p>
<p>本次操作具体以小根堆为例进行演示。</p>
<h2 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h2><p>一般采用树组存储，i结点的父结点下标为( i - 1 ) / 2。左子树的下标为2 <em> i + 1,右子树的下标为2 </em> i + 2。</p>
<p><img src="http://p7woygi8q.bkt.clouddn.com/7-1.png" alt></p>
<h2 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h2><h3 id="堆的插入"><a href="#堆的插入" class="headerlink" title="堆的插入"></a>堆的插入</h3><p>每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中——这就类似于<strong>直接插入排序</strong>中将一个数据并入到有序区间中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//  新加入i结点  其父结点为(i - 1) / 2  </span><br><span class="line">void MinHeapFixup(int a[], int i)  </span><br><span class="line">&#123;  </span><br><span class="line">    int j, temp;  </span><br><span class="line">    </span><br><span class="line">    temp = a[i];  </span><br><span class="line">    j = (i - 1) / 2;      //父结点  </span><br><span class="line">    while (j &gt;= 0 &amp;&amp; i != 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if (a[j] &lt;= temp)  </span><br><span class="line">            break;  </span><br><span class="line">          </span><br><span class="line">        a[i] = a[j];     //把较大的子结点往下移动,替换它的子结点  </span><br><span class="line">        i = j;  </span><br><span class="line">        j = (i - 1) / 2;  </span><br><span class="line">    &#125;  </span><br><span class="line">    a[i] = temp;</span><br></pre></td></tr></table></figure>
<p>插入时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void MinHeapAddNumber(int a[], int n, int nNum)  </span><br><span class="line">&#123;  </span><br><span class="line">    a[n] = nNum;  </span><br><span class="line">    MinHeapFixup(a, n);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆的删除"><a href="#堆的删除" class="headerlink" title="堆的删除"></a>堆的删除</h3><p>堆中每次都只能删除根结点，即第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点将一个数据的“下沉”过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//  从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2  </span><br><span class="line">void MinHeapFixdown(int a[], int i, int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    int j, temp;  </span><br><span class="line">  </span><br><span class="line">    temp = a[i];  </span><br><span class="line">    j = 2 * i + 1;  </span><br><span class="line">    while (j &lt; n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if (j + 1 &lt; n &amp;&amp; a[j + 1] &lt; a[j]) //在左右孩子中找最小的  </span><br><span class="line">            j++;  </span><br><span class="line">  </span><br><span class="line">        if (a[j] &gt;= temp)  </span><br><span class="line">            break;  </span><br><span class="line">  </span><br><span class="line">        a[i] = a[j];     //把较小的子结点往上移动,替换它的父结点  </span><br><span class="line">        i = j;  </span><br><span class="line">        j = 2 * i + 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    a[i] = temp;  </span><br><span class="line">&#125;  </span><br><span class="line">//在最小堆中删除数  </span><br><span class="line">void MinHeapDeleteNumber(int a[], int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    Swap(a[0], a[n - 1]);  </span><br><span class="line">    MinHeapFixdown(a, 0, n - 1);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建堆"><a href="#构建堆" class="headerlink" title="构建堆"></a>构建堆</h3><p>有了堆的插入和删除后，再考虑下如何对一个数据进行堆化操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//建立最小堆  </span><br><span class="line">void MakeMinHeap(int a[], int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    for (int i = n / 2 - 1; i &gt;= 0; i--)  </span><br><span class="line">        MinHeapFixdown(a, i, n);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>首先可以看到堆建好之后堆中第0个数据是堆中最小的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最小的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。</p>
<p>由于堆也是用数组模拟的，故堆化数组后，第一次将A[0]与A[n - 1]交换，再对A[0…n-2]重新恢复堆。第二次将A[0]与A[n – 2]交换，再对A[0…n - 3]重新恢复堆，重复这样的操作直到A[0]与A[1]交换。由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void MinheapsortTodescendarray(int a[], int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    for (int i = n - 1; i &gt;= 1; i--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Swap(a[i], a[0]);  </span><br><span class="line">        MinHeapFixdown(a, 0, i);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>[爬虫]python自动调用浏览器访问网页增加访问量</title>
    <url>/2018/04/22/2018-04-22-1/</url>
    <content><![CDATA[<p>该程序主要是为了增长访问量而写的，主要针对一些访问量与用户信息无关的网页，比如CSDN。当然前提是python安装相应的库。原理很简单，没有用到什么高端的爬虫技术，没有用到正则表达式什么的。其实就是调用你的浏览器，然后程序自动帮你打开你的博客网页，隔一段时间自动关闭，以此循环，刷访问量。不多说了，直接贴代码吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import webbrowser as web  </span><br><span class="line">import time  </span><br><span class="line">import os  </span><br><span class="line">import random  </span><br><span class="line">  </span><br><span class="line">count = random.randint(1, 2)  </span><br><span class="line">j = 0  </span><br><span class="line">aa = [80042845,80025162,80035076,80025133,80025068,80024813,79986200,79935658,79933992,79783339,79747976,79747322,79734593,79734363,79706272,79700188,79725018,79724244]  </span><br><span class="line">while j &lt; count:  </span><br><span class="line">    i = 0  </span><br><span class="line">    while i &lt;= 8:  </span><br><span class="line">        k = random.randint(0,17)  </span><br><span class="line">        web.open_new_tab(&apos;https://blog.csdn.net/qian_youyou/article/details/&apos;+str(aa[k]))  </span><br><span class="line">        i = i + 1  </span><br><span class="line">        time.sleep(3)  </span><br><span class="line">    else:  </span><br><span class="line">        time.sleep(20)  </span><br><span class="line">        os.system(&apos;taskkill /F /IM chrome.exe&apos;)  </span><br><span class="line">        # print &apos;time webbrower closed&apos;  </span><br><span class="line">  </span><br><span class="line">    j = j + 1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>[杂项项目]C语言打造智能AI小游戏——三子棋</title>
    <url>/2018/04/22/2018-04-22/</url>
    <content><![CDATA[<p>三子棋具体就不多介绍了，AI棋用O表示，我们的棋用X表示。先手后手自己选。这里主要说一下AI算法。首先AI会对整个棋盘MAP[3]，[3]进行遍历，每个格子都有一个权值weight[i][j]。权值的第一次计算方法是对每一行i每一列j进行计算，计算基于这一格有几种获胜的路线。例如没有走时，9个格的权值为：</p>
<table>
<thead>
<tr>
<th>[]</th>
<th>[]</th>
<th>[]</th>
<th></th>
<th>3</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>[]</td>
<td>[]</td>
<td>[]</td>
<td></td>
<td>2</td>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>[]</td>
<td>[]</td>
<td>[]</td>
<td></td>
<td>3</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>角落有横竖斜三种获胜方法，边有横竖两种方法，中心有横竖两斜4种方法。假如某格有X阻挡，那么权值会相应变化，例如</p>
<table>
<thead>
<tr>
<th>[]</th>
<th>[]</th>
<th>[]</th>
<th></th>
<th>2</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>[]</td>
<td>X</td>
<td>[]</td>
<td></td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>[]</td>
<td>[]</td>
<td>[]</td>
<td></td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>由于有中心阻挡，那么角只有横竖两种方法赢，因此权值为2。但该AI还需继续优化。例如以下：</p>
<table>
<thead>
<tr>
<th>[]</th>
<th>X</th>
<th>[]</th>
<th></th>
<th>1</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>[]</td>
<td>0</td>
<td>[]</td>
<td></td>
<td>1</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>X</td>
<td>X</td>
<td>0</td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>AI面对这种情况，本来下在第一个格子就赢了，但他会选择权值为2的格子。因此我们可以在现有权值条件的情况下，在附加个权值。假如某一格子的路线上已经有AI的子了，那么该条路线上未落子的所有格子权值再加1，如果有两个已落子的AI格子权值就加2。例如以下情况：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th>原权值</th>
<th></th>
<th></th>
<th></th>
<th>优化</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>[]</td>
<td>X</td>
<td>[]</td>
<td></td>
<td>2</td>
<td>0</td>
<td>2</td>
<td></td>
<td>5</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>[]</td>
<td>0</td>
<td>[]</td>
<td></td>
<td>2</td>
<td>0</td>
<td>2</td>
<td></td>
<td>3</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>[]</td>
<td>X</td>
<td>0</td>
<td></td>
<td>2</td>
<td>0</td>
<td>0</td>
<td></td>
<td>3</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>第一个格子5是由于斜路线上有两个子，那在原有的基础2上先加1，再加2，所以权值为2+1+2。第2行第3列权值为4，因为横竖两条路线均有1个子，因此权值为2+1+1，其余格子路线上均有1个子，因此权值为2+1。这样落在权值5那个格子上AI就赢了。</p>
<p>但是仅仅这些判断是不够的。例如：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th>原权值</th>
<th></th>
<th></th>
<th></th>
<th>优化</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>[]</td>
<td>X</td>
<td></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td></td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>[]</td>
<td>0</td>
<td>[]</td>
<td></td>
<td>1</td>
<td>0</td>
<td>1</td>
<td></td>
<td>2</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>[]</td>
<td>[]</td>
<td>0</td>
<td></td>
<td>1</td>
<td>2</td>
<td>0</td>
<td></td>
<td>2</td>
<td>4</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>AI会选择权值为4的格子。那此时AI选择权值为2的格子时，你只需要走一步就赢了，AI就输了，因此该AI算法还得继续。</p>
<p>那么AI可以逆向思考一番，AI可以考虑一下当前情况在计算AI权值的同时再计算一次我们的权值。例如上面例子：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th>AI</th>
<th></th>
<th></th>
<th></th>
<th>你</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>[]</td>
<td>X</td>
<td></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td></td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>[]</td>
<td>0</td>
<td>[]</td>
<td></td>
<td>1</td>
<td>0</td>
<td>1</td>
<td></td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>[]</td>
<td>[]</td>
<td>0</td>
<td></td>
<td>1</td>
<td>2</td>
<td>0</td>
<td></td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>优化AI</td>
<td></td>
<td></td>
<td></td>
<td>优化你</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>2</td>
<td>0</td>
<td></td>
<td>0</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>2</td>
<td>0</td>
<td>2</td>
<td></td>
<td>2</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>2</td>
<td>4</td>
<td>0</td>
<td></td>
<td>2</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>我们把两个权值相加（另外把AI的权值应该再加1，因为AI判断赢要优先于输或平，假如AI方有权值大的，代表一步能赢的，我方也有这种情况，那相加权值相同，AI既可以选择赢棋那一格，也可以选择堵你将要赢的那一格。但AI判断赢要优先于堵对方赢。例子就不举了）：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th>相加权</th>
<th></th>
<th></th>
<th></th>
<th>加1权</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>[]</td>
<td>X</td>
<td></td>
<td>0</td>
<td>6</td>
<td>0</td>
<td></td>
<td>0</td>
<td>7</td>
<td>0</td>
</tr>
<tr>
<td>[]</td>
<td>0</td>
<td>[]</td>
<td></td>
<td>4</td>
<td>0</td>
<td>2</td>
<td></td>
<td>5</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>[]</td>
<td>[]</td>
<td>0</td>
<td></td>
<td>4</td>
<td>4</td>
<td>0</td>
<td></td>
<td>5</td>
<td>4</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>因此AI判断到这里就会堵你了。</p>
<p>AI算法就介绍到这里，至于三子棋程序，由于过于简单，就不过多介绍了。主要介绍AI思想，Windows系统编译的程序。如果是Linux需要把以下代码改下。接下来我就贴上代码，供参考，如有不懂欢迎留言。</p>
<p>project.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once  </span><br><span class="line">#define COLUMN 3  </span><br><span class="line">#define ROW 3  </span><br><span class="line">#define GOON 0  </span><br><span class="line">#define WIN -1  </span><br><span class="line">#define DEFEAT 1  </span><br><span class="line">void init(char(*MAP)[COLUMN]);  </span><br><span class="line">int victory(char(*MAP)[COLUMN]);  </span><br><span class="line">bool check(char(*MAP)[COLUMN]);  </span><br><span class="line">void show(char(*MAP)[COLUMN]);  </span><br><span class="line">void check_stemp(char(*MAP)[COLUMN], int *x, int *y);  </span><br><span class="line">void ai_auto(char(*MAP)[COLUMN]);  </span><br><span class="line">int menu();  </span><br><span class="line">int first_hand(char(*MAP)[COLUMN]);  </span><br><span class="line">int ai_hand(char(*MAP)[COLUMN]);  </span><br><span class="line">void play(char(*MAP)[COLUMN]);</span><br></pre></td></tr></table></figure>
<p>project.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;  </span><br><span class="line">#include&lt;stdlib.h&gt;  </span><br><span class="line">#include&lt;string.h&gt;  </span><br><span class="line">#include&quot;project.h&quot;  </span><br><span class="line">int vis[ROW][COLUMN];  </span><br><span class="line">int weight[ROW][COLUMN];  </span><br><span class="line">int x, y;  </span><br><span class="line">void init(char(*MAP)[COLUMN]) &#123;  </span><br><span class="line">    for (int i = 0; i &lt; ROW; i++)  </span><br><span class="line">        for (int j = 0; j &lt; COLUMN; j++) &#123;  </span><br><span class="line">            MAP[i][j] = &apos; &apos;;  </span><br><span class="line">            vis[i][j] = 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">int victory(char(*MAP)[COLUMN]) &#123;  </span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;  </span><br><span class="line">        if (MAP[i][0] == &apos;X&apos;&amp;&amp;MAP[i][1] == &apos;X&apos;&amp;&amp;MAP[i][2] == &apos;X&apos;)  </span><br><span class="line">            return WIN;  </span><br><span class="line">        else if (MAP[i][0] == &apos;O&apos;&amp;&amp;MAP[i][1] == &apos;O&apos;&amp;&amp;MAP[i][2] == &apos;O&apos;)  </span><br><span class="line">            return DEFEAT;  </span><br><span class="line">        if (MAP[0][i] == &apos;X&apos;&amp;&amp;MAP[1][i] == &apos;X&apos;&amp;&amp;MAP[2][i] == &apos;X&apos;)  </span><br><span class="line">            return WIN;  </span><br><span class="line">        else if (MAP[0][i] == &apos;O&apos;&amp;&amp;MAP[1][i] == &apos;O&apos;&amp;&amp;MAP[2][i] == &apos;O&apos;)  </span><br><span class="line">            return DEFEAT;  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (MAP[0][0] == &apos;X&apos;&amp;&amp;MAP[1][1] == &apos;X&apos;&amp;&amp;MAP[2][2] == &apos;X&apos;)  </span><br><span class="line">        return WIN;  </span><br><span class="line">    else if (MAP[0][0] == &apos;O&apos;&amp;&amp;MAP[1][1] == &apos;O&apos;&amp;&amp;MAP[2][2] == &apos;O&apos;)  </span><br><span class="line">        return DEFEAT;  </span><br><span class="line">    if (MAP[0][2] == &apos;X&apos;&amp;&amp;MAP[1][1] == &apos;X&apos;&amp;&amp;MAP[2][0] == &apos;X&apos;)  </span><br><span class="line">        return WIN;  </span><br><span class="line">    else if (MAP[0][2] == &apos;O&apos;&amp;&amp;MAP[1][1] == &apos;O&apos;&amp;&amp;MAP[2][0] == &apos;O&apos;)  </span><br><span class="line">        return DEFEAT;  </span><br><span class="line">    return GOON;  </span><br><span class="line">&#125;  </span><br><span class="line">bool check(char(*MAP)[COLUMN]) &#123;  </span><br><span class="line">    for (int i = 0; i &lt; ROW; i++)  </span><br><span class="line">        for (int j = 0; j &lt; COLUMN; j++)  </span><br><span class="line">            if (!vis[i][j])  </span><br><span class="line">                return false;  </span><br><span class="line">    return true;  </span><br><span class="line">&#125;  </span><br><span class="line">void show(char(*MAP)[COLUMN]) &#123;  </span><br><span class="line">    printf(&quot;-------------\n&quot;);  </span><br><span class="line">    for (int i = 0; i &lt; ROW; i++) &#123;  </span><br><span class="line">        printf(&quot;|&quot;);  </span><br><span class="line">        for (int j = 0; j &lt; COLUMN; j++) &#123;  </span><br><span class="line">            printf(&quot; %c &quot;, MAP[i][j]);  </span><br><span class="line">            printf(&quot;|&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;\n&quot;);  </span><br><span class="line">        printf(&quot;-------------\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">void check_stemp(char(*MAP)[COLUMN], int *x, int *y) &#123;  </span><br><span class="line">    while (*x &gt; 3 || *x &lt;= 0 || *y&gt;3 || *y &lt;= 0 || MAP[*y - 1][*x - 1] != &apos; &apos;) &#123;  </span><br><span class="line">        system(&quot;cls&quot;);  </span><br><span class="line">        show(MAP);  </span><br><span class="line">        printf(&quot;Input error, please reenter!\n&quot;);  </span><br><span class="line">        scanf(&quot;%d%d&quot;, x, y);  </span><br><span class="line">    &#125;  </span><br><span class="line">    MAP[*y - 1][*x - 1] = &apos;X&apos;;  </span><br><span class="line">    vis[*y - 1][*x - 1] = 1;  </span><br><span class="line">&#125;  </span><br><span class="line">void Empowerment(char(*MAP)[COLUMN], int(*weight)[COLUMN], char ai_X, char ai_0, int flag) &#123;  </span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;  </span><br><span class="line">        if (MAP[i][0] != ai_X&amp;&amp;MAP[i][1] != ai_X&amp;&amp;MAP[i][2] != ai_X) &#123;  </span><br><span class="line">            weight[i][0]++;  </span><br><span class="line">            weight[i][1]++;  </span><br><span class="line">            weight[i][2]++;  </span><br><span class="line">            int tmp = 1;  </span><br><span class="line">            for (int j = 0; j &lt; 3; j++)  </span><br><span class="line">                if (MAP[i][j] == ai_0) &#123;  </span><br><span class="line">                    weight[i][0] += tmp+flag;  </span><br><span class="line">                    weight[i][1] += tmp+flag;  </span><br><span class="line">                    weight[i][2] += tmp+flag;  </span><br><span class="line">                    tmp += 10;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (MAP[0][i] != ai_X&amp;&amp;MAP[1][i] != ai_X&amp;&amp;MAP[2][i] != ai_X) &#123;  </span><br><span class="line">            weight[0][i]++;  </span><br><span class="line">            weight[1][i]++;  </span><br><span class="line">            weight[2][i]++;  </span><br><span class="line">            int tmp = 1;  </span><br><span class="line">            for (int j = 0; j &lt; 3; j++)  </span><br><span class="line">                if (MAP[j][i] == ai_0) &#123;  </span><br><span class="line">                    weight[0][i] += tmp+flag;  </span><br><span class="line">                    weight[1][i] += tmp+flag;  </span><br><span class="line">                    weight[2][i] += tmp+flag;  </span><br><span class="line">                    tmp += 10;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (MAP[0][0] != ai_X&amp;&amp;MAP[1][1] != ai_X&amp;&amp;MAP[2][2] != ai_X) &#123;  </span><br><span class="line">        weight[0][0]++;  </span><br><span class="line">        weight[1][1]++;  </span><br><span class="line">        weight[2][2]++;  </span><br><span class="line">        int tmp = 1;  </span><br><span class="line">        for (int j = 0; j &lt; 3; j++)  </span><br><span class="line">            if (MAP[j][j] == ai_0) &#123;  </span><br><span class="line">                weight[0][0] += tmp+flag;  </span><br><span class="line">                weight[1][1] += tmp+flag;  </span><br><span class="line">                weight[2][2] += tmp+flag;  </span><br><span class="line">                tmp += 10;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (MAP[0][2] != ai_X&amp;&amp;MAP[1][1] != ai_X&amp;&amp;MAP[2][0] != ai_X) &#123;  </span><br><span class="line">        weight[0][2]++;  </span><br><span class="line">        weight[1][1]++;  </span><br><span class="line">        weight[2][0]++;  </span><br><span class="line">        int tmp = 1;  </span><br><span class="line">        for (int j = 0; j &lt; 3; j++)  </span><br><span class="line">            if (MAP[j][2 - j] == ai_0) &#123;  </span><br><span class="line">                weight[0][2] += tmp+flag;  </span><br><span class="line">                weight[1][1] += tmp+flag;  </span><br><span class="line">                weight[2][0] += tmp+flag;  </span><br><span class="line">                tmp += 10;  </span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">void ai_auto(char(*MAP)[COLUMN]) &#123;  </span><br><span class="line">    int weight[3][3] = &#123; 0 &#125;;  </span><br><span class="line">    Empowerment(MAP, weight, &apos;X&apos;, &apos;O&apos;, 1);  </span><br><span class="line">    Empowerment(MAP, weight, &apos;O&apos;, &apos;X&apos;, 0);  </span><br><span class="line">    int maxn = -1;  </span><br><span class="line">    int maxm = -1;  </span><br><span class="line">    for (int i = 0; i &lt; 3; i++)  </span><br><span class="line">        for (int j = 0; j &lt; 3; j++) &#123;  </span><br><span class="line">            if (vis[i][j])  </span><br><span class="line">                weight[i][j] = -1;  </span><br><span class="line">            if (maxn &lt; weight[i][j]) &#123;  </span><br><span class="line">                maxn = weight[i][j];  </span><br><span class="line">                maxm = i * 3 + j;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    MAP[maxm / 3][maxm % 3] = &apos;O&apos;;  </span><br><span class="line">    vis[maxm / 3][maxm % 3] = 1;  </span><br><span class="line">&#125;  </span><br><span class="line">int menu() &#123;  </span><br><span class="line">    int tmp;  </span><br><span class="line">    printf(&quot;*************************************************************\n&quot;);  </span><br><span class="line">    printf(&quot;* Please enter: * 1:First hand * 2.Back hand * Others:Close *\n&quot;);  </span><br><span class="line">    printf(&quot;*************************************************************\n&quot;);  </span><br><span class="line">    scanf(&quot;%d&quot;, &amp;tmp);  </span><br><span class="line">    return tmp;  </span><br><span class="line">&#125;  </span><br><span class="line">int first_hand(char(*MAP)[COLUMN]) &#123;  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    show(MAP);  </span><br><span class="line">    printf(&quot;Please enter:x y\n&quot;);  </span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);  </span><br><span class="line">    check_stemp(MAP, &amp;x, &amp;y);  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    show(MAP);  </span><br><span class="line">    if (victory(MAP) == WIN) &#123;  </span><br><span class="line">        printf(&quot;Congratulations on your victory, you are as smart as Qianyouyou.\n&quot;);  </span><br><span class="line">        return 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    else if (check(MAP)) &#123;  </span><br><span class="line">        printf(&quot;Draw.As smart as me.\n&quot;);  </span><br><span class="line">        return 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">int ai_hand(char(*MAP)[COLUMN]) &#123;  </span><br><span class="line">    ai_auto(MAP);  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    show(MAP);  </span><br><span class="line">    if (victory(MAP) == DEFEAT) &#123;  </span><br><span class="line">        printf(&quot;You lose, you&apos;re as stupid as a pig.\n&quot;);  </span><br><span class="line">        return 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    else if (check(MAP)) &#123;  </span><br><span class="line">        printf(&quot;Draw.As smart as me.\n&quot;);  </span><br><span class="line">        return 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">void play(char(*MAP)[COLUMN]) &#123;  </span><br><span class="line">    while (!check(MAP) || victory(MAP) == GOON) &#123;  </span><br><span class="line">        if (first_hand(MAP))  </span><br><span class="line">            break;  </span><br><span class="line">        if (ai_hand(MAP))  </span><br><span class="line">            break;  </span><br><span class="line">    &#125;  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;  </span><br><span class="line">#include&lt;stdlib.h&gt;  </span><br><span class="line">#include&quot;project.h&quot;  </span><br><span class="line">char MAP[ROW][COLUMN];  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    char str[2];  </span><br><span class="line">    do &#123;  </span><br><span class="line">        init(MAP);  </span><br><span class="line">        switch (menu()) &#123;  </span><br><span class="line">        case 1:  </span><br><span class="line">            first_hand(MAP);  </span><br><span class="line">        case 2: &#123;  </span><br><span class="line">            ai_hand(MAP);  </span><br><span class="line">            play(MAP);  </span><br><span class="line">        &#125;  </span><br><span class="line">        default: &#123;  </span><br><span class="line">            printf(&quot;Do you need to start again?(Y/N)&quot;);  </span><br><span class="line">            scanf(&quot;%s&quot;, str);  </span><br><span class="line">        &#125;break;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; while (str[0] == &apos;Y&apos; || str[0] == &apos;y&apos;);  </span><br><span class="line">    printf(&quot;Thank you for using!\n&quot;);  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
        <tag>项目</tag>
        <tag>博弈论</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>[排序]求解第k大分值</title>
    <url>/2018/04/21/2018-04-21/</url>
    <content><![CDATA[<p>描述：</p>
<p>Arch0n老师is a rich man, 他靠自己的才华和智商年纪轻轻就赚了不少钱。为了训练自己的智商，他经常玩一些interesting的游戏来训练自己的智商，比如什么RGB游戏，还有和妹子一块玩Don’t Starve。</p>
<p>言归正传，今天他又发明了一个新的interesting game。Ar老师手上有一堆卡牌，然后卡牌上写了一个数字Ai(正整数)，当前他有n张牌，然后他总是随机取出两张来，然后他一眼就能看出这两牌中哪一张小（相同就取相同的，这操作好像对于Ar老师来说太简单了），作为这两张牌的有效分值，然后呢他陷入了沉思，对于n张牌取两张牌显然有确定的组合可能性，有n<em>(n-1)/2对组合，然后他想知道所有这些组合中第k大的分值是多少。输入描述:输入一个t表示数据组数；(0&lt;t&lt;=10)接下来一行是n,k,表示n张牌和最后第k大的分值；（1&lt;n&lt;2500,保证0&lt;k&lt;=n</em>(n-1)/2）接下来一行是n个值ai，表示第i张牌上的数字(0 &lt; ai &lt;= 10000000)。输出描述:每组数据输出一行，即第k大的分值为多少。</p>
<p>示例</p>
<p>输入</p>
<p>2</p>
<p>3 2</p>
<p>1 2 3</p>
<p>3 1</p>
<p>4 2 1</p>
<p>输出</p>
<p>1</p>
<p>2</p>
<p>题解：</p>
<p>首先将这n个数进行从大到小排序，a[0]储存第1大，a[1]储存第2大……第2个和第1个比较最小的是第2个，第3个和前两个比较较小的均是第3个，第4个和前3个比较均是第4个，以此递推，第n个数和n前n-1个比较均是n较小。将所有情况全排列很容易超时，因此我们可以从第k大这个k下手。由于a[0]最大，因此a[0]和任意比较都不会输出a[0]。那么首先k为1输出a[1],1&lt;k&lt;=1+2输出a[2],1+2&lt;k&lt;=1+2+3输出a[3]……现在应该很清楚了吧。可以设置一个变量cnt，和i,从1开始，cnt每次加1，i每次加cnt，直到i加到比k大或者等于时，那么此时的a[cnt]就是第k大的数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">#include&lt;algorithm&gt;  </span><br><span class="line">int cmp(int a, int b) &#123;  </span><br><span class="line">    return a &gt; b;  </span><br><span class="line">&#125;  </span><br><span class="line">int T, N, k, a[100010];  </span><br><span class="line">using namespace std;  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    cin &gt;&gt; T;  </span><br><span class="line">    while (T--) &#123;  </span><br><span class="line">        cin &gt;&gt; N &gt;&gt; k;  </span><br><span class="line">        for (int i = 0; i &lt; N; i++) &#123;  </span><br><span class="line">            cin &gt;&gt; a[i];  </span><br><span class="line">        &#125;  </span><br><span class="line">        sort(a, a + N, cmp);  </span><br><span class="line">        int cnt = 1, i = 1;  </span><br><span class="line">        for (int i = 1; i &lt; k; i += cnt) &#123;  </span><br><span class="line">            cnt++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        cout &lt;&lt; a[cnt] &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>[杂项项目]C语言实现小游戏——控制台扫雷</title>
    <url>/2018/04/20/2018-04-20-2/</url>
    <content><![CDATA[<p>程序比较简单，需要输入坐标x，y进行翻牌。当时现场演示时不到50分钟边讲边写的，实现了基本的扫雷功能，只是没有计分计时排名之类的辅助功能。由于程序较简单，也没必要再加工了。另外本程序的特点是第一次输入一定不会是雷。此外，如果翻牌后周围没有雷，即为0，将会搜索周围所以为0的牌。此处用到了dfs。仅供参考。</p>
<p>项目版：</p>
<p>mine.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once  </span><br><span class="line">#define BOOM 10  </span><br><span class="line">#define SIZE 10  </span><br><span class="line">void init(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int a, int b);//初始化扫雷页面</span><br><span class="line">void dfs(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int i, int j);//如果展开面为0，通过深搜将周围所以为0的区域展开  </span><br><span class="line">int check(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y);//判断胜利条件  </span><br><span class="line">void show(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y);//展示扫雷页面</span><br></pre></td></tr></table></figure>
<p>mine.cpp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;  </span><br><span class="line">#include&lt;stdlib.h&gt;  </span><br><span class="line">#include&lt;string.h&gt;  </span><br><span class="line">#include&lt;time.h&gt;  </span><br><span class="line">#include&quot;mine.h&quot;  </span><br><span class="line">int stemp[8][2] = &#123; &#123; 0,1 &#125;,&#123; 0,-1 &#125;,&#123; 1,0 &#125;,&#123; -1,0 &#125;,&#123; 1,1 &#125;,&#123; -1,-1 &#125;,&#123; 1,-1 &#125;,&#123; -1,1 &#125; &#125;;//深搜时上下左右四个方向搜索  </span><br><span class="line">void init(char (*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int a, int b) &#123;  </span><br><span class="line">    int x, y;  </span><br><span class="line">    visit[a][b] = 0;  </span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;  </span><br><span class="line">        do &#123;  </span><br><span class="line">            x = rand() % SIZE + 1;  </span><br><span class="line">            y = rand() % SIZE + 1;  </span><br><span class="line">        &#125; while (visit[x][y] == 0);  </span><br><span class="line">        if (visit[x][y] == -1) &#123;  </span><br><span class="line">            visit[x][y] == 0;  </span><br><span class="line">            MAP[x][y] = &apos;*&apos;;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE; i++) &#123;  </span><br><span class="line">        for (int j = 1; j &lt;= SIZE; j++) &#123;  </span><br><span class="line">            if (MAP[i][j] != &apos;*&apos;) &#123;  </span><br><span class="line">                MAP[i][j] = &apos;0&apos;;  </span><br><span class="line">                for (int k = 0; k &lt; 8; k++) &#123;  </span><br><span class="line">                    if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;*&apos;)  </span><br><span class="line">                        MAP[i][j]++;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">void dfs(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int i, int j) &#123;  </span><br><span class="line">    visit[i][j] = 1;  </span><br><span class="line">    for (int k = 0; k &lt; 8; k++) &#123;  </span><br><span class="line">        if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;0&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1)  </span><br><span class="line">            dfs(MAP, visit, i + stemp[k][0], j + stemp[k][1]);  </span><br><span class="line">        else if (MAP[i + stemp[k][0]][j + stemp[k][1]] != &apos;*&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1)  </span><br><span class="line">            visit[i + stemp[k][0]][j + stemp[k][1]] = 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">int check(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y) &#123;  </span><br><span class="line">    if (MAP[x][y] == &apos;*&apos;) &#123;  </span><br><span class="line">        visit[x][y] = 1;  </span><br><span class="line">        return 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    else if (MAP[x][y] == &apos;0&apos;) &#123;  </span><br><span class="line">        dfs(MAP, visit, x, y);  </span><br><span class="line">    &#125;  </span><br><span class="line">    else  </span><br><span class="line">        visit[x][y] = 1;  </span><br><span class="line">    int temp = 0;  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE; i++)  </span><br><span class="line">        for (int j = 1; j &lt;= SIZE; j++) &#123;  </span><br><span class="line">            if (visit[i][j] == -1)  </span><br><span class="line">                temp++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    if (temp == BOOM)  </span><br><span class="line">        return 2;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">void show(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y) &#123;  </span><br><span class="line">    printf(&quot;-------------------------------------------------\n&quot;);  </span><br><span class="line">    for (int i = 0; i &lt;= SIZE + 1; i++) &#123;  </span><br><span class="line">        printf(&quot;|&quot;);  </span><br><span class="line">        for (int j = 0; j &lt;= SIZE + 1; j++) &#123;  </span><br><span class="line">            if (visit[i][j] == 1) &#123;  </span><br><span class="line">                printf(&quot; %c &quot;, MAP[i][j]);  </span><br><span class="line">                printf(&quot;|&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">            else &#123;  </span><br><span class="line">                printf(&quot;   &quot;);  </span><br><span class="line">                printf(&quot;|&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;\n&quot;);  </span><br><span class="line">        printf(&quot;-------------------------------------------------\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main.cpp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;  </span><br><span class="line">#include&lt;stdlib.h&gt;  </span><br><span class="line">#include&lt;string.h&gt;  </span><br><span class="line">#include&lt;time.h&gt;  </span><br><span class="line">#include&quot;mine.h&quot;  </span><br><span class="line">char MAP[SIZE + 2][SIZE + 2];  </span><br><span class="line">int visit[SIZE + 2][SIZE + 2];  </span><br><span class="line">int x, y;//坐标  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    srand(time(0));  </span><br><span class="line">    memset(visit, -1, sizeof(visit));  </span><br><span class="line">    MAP[0][0] = &apos; &apos;;  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE; i++) &#123;  </span><br><span class="line">        MAP[0][i] = &apos;A&apos; + i - 1;  </span><br><span class="line">        MAP[i][0] = &apos;a&apos; + i - 1;  </span><br><span class="line">        MAP[SIZE + 1][i] = &apos;A&apos; + i - 1;  </span><br><span class="line">        MAP[i][SIZE + 1] = &apos;a&apos; + i - 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE + 1; i++) &#123;  </span><br><span class="line">        visit[0][i] = 1;  </span><br><span class="line">        visit[i][0] = 1;  </span><br><span class="line">        visit[SIZE + 1][i] = 1;  </span><br><span class="line">        visit[i][SIZE + 1] = 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    show(MAP, visit, x, y);  </span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;y, &amp;x);  </span><br><span class="line">    init(MAP,visit, x, y);  </span><br><span class="line">    memset(visit, -1, sizeof(visit));  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE + 1; i++) &#123;  </span><br><span class="line">        visit[0][i] = 1;  </span><br><span class="line">        visit[i][0] = 1;  </span><br><span class="line">        visit[SIZE + 1][i] = 1;  </span><br><span class="line">        visit[i][SIZE + 1] = 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    check(MAP, visit, x, y);  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    show(MAP, visit, x, y);  </span><br><span class="line">    while (MAP[x][y] != &apos;*&apos;) &#123;  </span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;y, &amp;x);  </span><br><span class="line">        int res = check(MAP, visit, x, y);  </span><br><span class="line">        system(&quot;cls&quot;);  </span><br><span class="line">        show(MAP, visit, x, y);  </span><br><span class="line">        if (res == 2) &#123;  </span><br><span class="line">            printf(&quot;Win\n&quot;);  </span><br><span class="line">            system(&quot;pause&quot;);  </span><br><span class="line">            return 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">        else if (res == 1) &#123;  </span><br><span class="line">            printf(&quot;Lose\n&quot;);  </span><br><span class="line">            system(&quot;pause&quot;);  </span><br><span class="line">            return 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20180422105418722" alt="img"></p>
<p>另附原始版：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;  </span><br><span class="line">#include&lt;stdlib.h&gt;  </span><br><span class="line">#include&lt;string.h&gt;  </span><br><span class="line">#include&lt;time.h&gt;  </span><br><span class="line">#define BOOM 10  </span><br><span class="line">#define SIZE 10  </span><br><span class="line">char MAP[SIZE + 2][SIZE + 2];  </span><br><span class="line">int visit[SIZE + 2][SIZE + 2];  </span><br><span class="line">int x, y;  </span><br><span class="line">int stemp[8][2] = &#123; &#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;, &#123;-1,1&#125; &#125;;  </span><br><span class="line">void init(int a, int b) &#123;  </span><br><span class="line">    int x, y;  </span><br><span class="line">    visit[a][b] = 0;  </span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;  </span><br><span class="line">        do &#123;  </span><br><span class="line">            x = rand() % SIZE + 1;  </span><br><span class="line">            y = rand() % SIZE + 1;  </span><br><span class="line">        &#125; while (visit[x][y] == 0);  </span><br><span class="line">        if (visit[x][y] == -1) &#123;  </span><br><span class="line">            visit[x][y] == 0;  </span><br><span class="line">            MAP[x][y] = &apos;*&apos;;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE; i++) &#123;  </span><br><span class="line">        for (int j = 1; j &lt;= SIZE; j++) &#123;  </span><br><span class="line">            if (MAP[i][j] != &apos;*&apos;) &#123;  </span><br><span class="line">                MAP[i][j] = &apos;0&apos;;  </span><br><span class="line">                for (int k = 0; k &lt; 8; k++) &#123;  </span><br><span class="line">                    if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;*&apos;)  </span><br><span class="line">                        MAP[i][j]++;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">void dfs(int i, int j) &#123;  </span><br><span class="line">    visit[i][j] = 1;  </span><br><span class="line">    for (int k = 0; k &lt; 8; k++) &#123;  </span><br><span class="line">        if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;0&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1)  </span><br><span class="line">            dfs(i + stemp[k][0], j + stemp[k][1]);  </span><br><span class="line">        else if (MAP[i + stemp[k][0]][j + stemp[k][1]] != &apos;*&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1)  </span><br><span class="line">            visit[i + stemp[k][0]][j + stemp[k][1]] = 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">int check() &#123;  </span><br><span class="line">    if (MAP[x][y] == &apos;*&apos;) &#123;  </span><br><span class="line">        visit[x][y] = 1;  </span><br><span class="line">        return 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    else if (MAP[x][y] == &apos;0&apos;) &#123;  </span><br><span class="line">        dfs(x, y);  </span><br><span class="line">    &#125;  </span><br><span class="line">    else  </span><br><span class="line">        visit[x][y] = 1;  </span><br><span class="line">    int temp = 0;  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE; i++)  </span><br><span class="line">        for (int j = 1; j &lt;= SIZE; j++) &#123;  </span><br><span class="line">            if (visit[i][j] == -1)  </span><br><span class="line">                temp++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    if (temp == BOOM)  </span><br><span class="line">        return 2;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">void show() &#123;  </span><br><span class="line">    printf(&quot;-------------------------------------------------\n&quot;);  </span><br><span class="line">    for (int i = 0; i &lt;= SIZE + 1; i++) &#123;  </span><br><span class="line">        printf(&quot;|&quot;);  </span><br><span class="line">        for (int j = 0; j &lt;= SIZE + 1; j++) &#123;  </span><br><span class="line">            if (visit[i][j] == 1) &#123;  </span><br><span class="line">                printf(&quot; %c &quot;, MAP[i][j]);  </span><br><span class="line">                printf(&quot;|&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">            else &#123;  </span><br><span class="line">                printf(&quot;   &quot;);  </span><br><span class="line">                printf(&quot;|&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;\n&quot;);  </span><br><span class="line">        printf(&quot;-------------------------------------------------\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    srand(time(0));  </span><br><span class="line">    memset(visit, -1, sizeof(visit));  </span><br><span class="line">    MAP[0][0] = &apos; &apos;;  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE; i++) &#123;  </span><br><span class="line">        MAP[0][i] = &apos;A&apos; + i - 1;  </span><br><span class="line">        MAP[i][0] = &apos;a&apos; + i - 1;  </span><br><span class="line">        MAP[SIZE + 1][i] = &apos;A&apos; + i - 1;  </span><br><span class="line">        MAP[i][SIZE + 1] = &apos;a&apos; + i - 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE + 1; i++) &#123;  </span><br><span class="line">        visit[0][i] = 1;  </span><br><span class="line">        visit[i][0] = 1;  </span><br><span class="line">        visit[SIZE + 1][i] = 1;  </span><br><span class="line">        visit[i][SIZE + 1] = 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    show();  </span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);  </span><br><span class="line">    init(x, y);  </span><br><span class="line">    memset(visit, -1, sizeof(visit));  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE + 1; i++) &#123;  </span><br><span class="line">        visit[0][i] = 1;  </span><br><span class="line">        visit[i][0] = 1;  </span><br><span class="line">        visit[SIZE + 1][i] = 1;  </span><br><span class="line">        visit[i][SIZE + 1] = 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    check();  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    show();  </span><br><span class="line">    while (MAP[x][y] != &apos;*&apos;) &#123;  </span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);  </span><br><span class="line">        int res = check();  </span><br><span class="line">        system(&quot;cls&quot;);  </span><br><span class="line">        show();  </span><br><span class="line">        if (res == 2) &#123;  </span><br><span class="line">            printf(&quot;Win\n&quot;);  </span><br><span class="line">            system(&quot;pause&quot;);  </span><br><span class="line">            return 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">        else if (res == 1) &#123;  </span><br><span class="line">            printf(&quot;Lose\n&quot;);  </span><br><span class="line">            system(&quot;pause&quot;);  </span><br><span class="line">            return 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
        <tag>指针</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>[杂项项目]纯C语言实现随机生成数独九宫格</title>
    <url>/2018/04/20/2018-04-20-1/</url>
    <content><![CDATA[<p>一年前的程序，可以生成一个数独的九宫格。当时想这种方法想了3天，终于实现了。由于当时刚熟悉指针，因此指针用的比较多。本人比较懒，先把代码贴出来，后序补充具体实现方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;time.h&gt;  </span><br><span class="line">  </span><br><span class="line">void main()  </span><br><span class="line">&#123;  </span><br><span class="line">    int a[9][9] = &#123; 0 &#125;;  </span><br><span class="line">    int *p[3][3], *m[3][6], *n[3][6], *r[9][4], *aa[9][9];  </span><br><span class="line">    int **q[9];  </span><br><span class="line">    int i, j, k, l, h, t, s = 0;  </span><br><span class="line">    void rank(int *x, int *y);  </span><br><span class="line">    bool check(int a[9][9], int n);  </span><br><span class="line">    srand((int)time(0));  </span><br><span class="line">  </span><br><span class="line">    for (i = 0; i &lt; 3; i++)  </span><br><span class="line">        for (j = 0; j &lt; 3; j++)  </span><br><span class="line">            p[i][j] = &amp;a[i * 3 + 1][j * 3 + 1];  </span><br><span class="line">    for (k = 0; k &lt; 9; k++)  </span><br><span class="line">        q[k] = &amp;p[k / 3][k % 3];  </span><br><span class="line">    for (i = 0; i &lt; 3; i++)  </span><br><span class="line">        for (j = 0; j &lt; 6; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            m[i][j] = &amp;a[i * 3 + 1][2 * j - j / 2];  </span><br><span class="line">            n[i][j] = &amp;a[2 * j - j / 2][i * 3 + 1];  </span><br><span class="line">        &#125;  </span><br><span class="line">    for (k = 0; k &lt; 9; k++)  </span><br><span class="line">        for (l = 0; l &lt; 4; l++)  </span><br><span class="line">            r[k][l] = &amp;a[(k / 3) * 3 + (l / 2) * 2][(k % 3) * 3 + (l % 2) * 2];  </span><br><span class="line">    for (i = 0; i &lt; 9; i++)  </span><br><span class="line">        for (j = 0; j &lt; 9; j++)  </span><br><span class="line">            aa[i][j] = &amp;a[i][j];  </span><br><span class="line">step1:  </span><br><span class="line">    for (i = 0; i &lt; 9; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">    next1:  </span><br><span class="line">        **q[i] = rand() % 10;  </span><br><span class="line">        if (**q[i] == 0)  </span><br><span class="line">            goto next1;  </span><br><span class="line">        for (j = 0; j &lt; i; j++)  </span><br><span class="line">            if (**q[j] == **q[i])  </span><br><span class="line">                goto next1;  </span><br><span class="line">    &#125;  </span><br><span class="line">step2:  </span><br><span class="line">    for (i = 0; i &lt; 3; i++)  </span><br><span class="line">        for (j = 0; j &lt; 6; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">        next2:  </span><br><span class="line">            *m[i][j] = rand() % 10;  </span><br><span class="line">            if (*m[i][j] == 0)  </span><br><span class="line">                goto next2;  </span><br><span class="line">            for (k = 0; k &lt; 3; k++)  </span><br><span class="line">                if (*m[i][j] == *p[i][k])  </span><br><span class="line">                    goto next2;  </span><br><span class="line">            for (k = 0; k &lt; j; k++)  </span><br><span class="line">                if (*m[i][j] == *m[i][k])  </span><br><span class="line">                    goto next2;  </span><br><span class="line">            for (k = 0; k &lt; i; k++)  </span><br><span class="line">                if (*m[i][j] == *m[k][j])  </span><br><span class="line">                    goto step2;  </span><br><span class="line">        &#125;  </span><br><span class="line">step3:  </span><br><span class="line">    for (i = 0; i &lt; 3; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">    next4:  </span><br><span class="line">        for (j = 0; j &lt; 6; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">        next3:  </span><br><span class="line">            *n[i][j] = rand() % 10;  </span><br><span class="line">            if (*n[i][j] == 0)  </span><br><span class="line">                goto next3;  </span><br><span class="line">            for (k = 0; k &lt; 3; k++)  </span><br><span class="line">                if (*n[i][j] == *p[k][i])  </span><br><span class="line">                    goto next3;  </span><br><span class="line">            for (k = 0; k &lt; j; k++)  </span><br><span class="line">                if (*n[i][j] == *n[i][k])  </span><br><span class="line">                    goto next3;  </span><br><span class="line">            for (l = 0; l &lt; 2; l++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                if (*n[i][j] == *m[j / 2][i * 2 + l])  </span><br><span class="line">                    goto next4;  </span><br><span class="line">            &#125;  </span><br><span class="line">            for (k = 0; k &lt; i; k++)  </span><br><span class="line">                if (*n[i][j] == *n[k][j])  </span><br><span class="line">                    goto step3;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">step4:  </span><br><span class="line">    for (i = 0; i &lt; 3; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        for (h = 0; h &lt; 2; h++)  </span><br><span class="line">        &#123;  </span><br><span class="line">        next6:  </span><br><span class="line">            for (l = 0; l &lt; 3; l++)  </span><br><span class="line">                for (j = 0; j &lt; 2; j++)  </span><br><span class="line">                &#123;  </span><br><span class="line">                next5:  </span><br><span class="line">                    *r[i * 3 + l][h * 2 + j] = rand() % 10;  </span><br><span class="line">                    if (*r[i * 3 + l][h * 2 + j] == 0)  </span><br><span class="line">                        goto next5;  </span><br><span class="line">                    if (*r[i * 3 + l][h * 2 + j] == **q[i * 3 + l])  </span><br><span class="line">                        goto next5;  </span><br><span class="line">                    for (k = 0; k &lt; h * 2 + j; k++)  </span><br><span class="line">                        if (*r[i * 3 + l][h * 2 + j] == *r[i * 3 + l][k])  </span><br><span class="line">                            goto next5;  </span><br><span class="line">                    for (k = 0; k &lt; 2; k++)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        if (*r[i * 3 + l][h * 2 + j] == *m[i][l * 2 + k])  </span><br><span class="line">                            goto next5;  </span><br><span class="line">                        if (*r[i * 3 + l][h * 2 + j] == *n[l][i * 2 + k])  </span><br><span class="line">                            goto next5;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    for (k = 0; k &lt;= l * 3 + j * 2; k++)  </span><br><span class="line">                        for (t = 0; t &lt; k; t++)  </span><br><span class="line">                            if (a[i * 3 + h * 2][k] == a[i * 3 + h * 2][t])  </span><br><span class="line">                                goto next6;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">step5:  </span><br><span class="line">    for (i = 0; i &lt; 3; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if (check(a, i) == false)  </span><br><span class="line">        &#123;  </span><br><span class="line">            for (j = 0; j &lt; 9; j++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                rank(aa[j][i * 3], aa[j][i * 3 + 2]);  </span><br><span class="line">                if (check(a, i) == false)  </span><br><span class="line">                    rank(aa[j][i * 3], aa[j][i * 3 + 2]);  </span><br><span class="line">                else if (check(a, i) == true)  </span><br><span class="line">                    break;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (check(a, i) == false)  </span><br><span class="line">        &#123;  </span><br><span class="line">            for (j = 0; j &lt; 9; j++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                for (k = 8; k &gt; j; k--)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    rank(aa[j][i * 3], aa[j][i * 3 + 2]);  </span><br><span class="line">                    rank(aa[k][i * 3], aa[k][i * 3 + 2]);  </span><br><span class="line">                    if (check(a, i) == false)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        rank(aa[j][i * 3], aa[j][i * 3 + 2]);  </span><br><span class="line">                        rank(aa[k][i * 3], aa[k][i * 3 + 2]);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    else if (check(a, i) == true)  </span><br><span class="line">                        break;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (check(a, i) == true)  </span><br><span class="line">                    break;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (check(a, i) == false)  </span><br><span class="line">        &#123;  </span><br><span class="line">            for (l = 0; l &lt; 9; l++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                for (j = l + 1; j &lt; 9; j++)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    for (k = 8; k &gt; j; k--)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        rank(aa[l][i * 3], aa[l][i * 3 + 2]);  </span><br><span class="line">                        rank(aa[j][i * 3], aa[j][i * 3 + 2]);  </span><br><span class="line">                        rank(aa[k][i * 3], aa[k][i * 3 + 2]);  </span><br><span class="line">                        if (check(a, i) == false)  </span><br><span class="line">                        &#123;  </span><br><span class="line">                            rank(aa[l][i * 3], aa[l][i * 3 + 2]);  </span><br><span class="line">                            rank(aa[j][i * 3], aa[j][i * 3 + 2]);  </span><br><span class="line">                            rank(aa[k][i * 3], aa[k][i * 3 + 2]);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        else if (check(a, i) == true)  </span><br><span class="line">                            break;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    if (check(a, i) == true)  </span><br><span class="line">                        break;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (check(a, i) == true)  </span><br><span class="line">                    break;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (check(a, i) == false)  </span><br><span class="line">        &#123;  </span><br><span class="line">            for (l = 0; l &lt; 6; l++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                for (h = l + 1; h &lt; 7; h++)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    for (j = h + 1; j &lt; 8; j++)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        for (k = 8; k &gt; j; k--)  </span><br><span class="line">                        &#123;  </span><br><span class="line">                            rank(aa[l][i * 3], aa[l][i * 3 + 2]);  </span><br><span class="line">                            rank(aa[h][i * 3], aa[h][i * 3 + 2]);  </span><br><span class="line">                            rank(aa[j][i * 3], aa[j][i * 3 + 2]);  </span><br><span class="line">                            rank(aa[k][i * 3], aa[k][i * 3 + 2]);  </span><br><span class="line">                            if (check(a, i) == false)  </span><br><span class="line">                            &#123;  </span><br><span class="line">                                rank(aa[l][i * 3], aa[l][i * 3 + 2]);  </span><br><span class="line">                                rank(aa[h][i * 3], aa[h][i * 3 + 2]);  </span><br><span class="line">                                rank(aa[j][i * 3], aa[j][i * 3 + 2]);  </span><br><span class="line">                                rank(aa[k][i * 3], aa[k][i * 3 + 2]);  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            else if (check(a, i) == true)  </span><br><span class="line">                                break;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        if (check(a, i) == true)  </span><br><span class="line">                            break;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    if (check(a, i) == true)  </span><br><span class="line">                        break;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (check(a, i) == true)  </span><br><span class="line">                    break;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (check(a, i) == false)  </span><br><span class="line">            goto step4;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;+---------------+---------------+---------------+\n&quot;);  </span><br><span class="line">    printf(&quot;|               |               |               |\n&quot;);  </span><br><span class="line">    for (i = 0; i &lt; 9; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;|   &quot;);  </span><br><span class="line">        for (j = 0; j &lt; 9; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            printf(&quot;%-4d&quot;, a[i][j]);  </span><br><span class="line">            if ((j + 1) % 3 == 0)  </span><br><span class="line">                printf(&quot;|   &quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;\n&quot;);  </span><br><span class="line">        printf(&quot;|               |               |               |\n&quot;);  </span><br><span class="line">        if ((i + 1) % 3 == 0)  </span><br><span class="line">        &#123;  </span><br><span class="line">            printf(&quot;+---------------+---------------+---------------+\n&quot;);  </span><br><span class="line">            if (i &lt; 8)  </span><br><span class="line">                printf(&quot;|               |               |               |\n&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void rank(int *x, int *y)  </span><br><span class="line">&#123;  </span><br><span class="line">    int t;  </span><br><span class="line">    t = *x;  </span><br><span class="line">    *x = *y;  </span><br><span class="line">    *y = t;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">bool check(int a[9][9], int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    int i, j;  </span><br><span class="line">    for (i = 0; i &lt; 9; i++)  </span><br><span class="line">        for (j = 0; j &lt; i; j++)  </span><br><span class="line">            if (a[i][n * 3] == a[j][n * 3])  </span><br><span class="line">                return false;  </span><br><span class="line">    return true;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
        <tag>指针</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>[杂项项目]纯C语言实现控制台小游戏——数字拼图</title>
    <url>/2018/04/20/2018-04-20/</url>
    <content><![CDATA[<p>一年前写的小游戏，当时感觉小有成就，现在发现缺陷真的很多。不禁感叹，当时为什么会用那么多goto呢。在这里真的建议大家不要用goto。只是现在懒得改了，毕竟是小程序。贴出来供大家参考。如果有时间后序再添加注释。如有问题欢迎评论。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include&lt;math.h&gt;  </span><br><span class="line">#include &lt;time.h&gt;  </span><br><span class="line">#define max 10  </span><br><span class="line">int x, y, step, label = 0;  </span><br><span class="line">typedef struct score &#123;  </span><br><span class="line">    int steps, steps2;  </span><br><span class="line">    double times;  </span><br><span class="line">    char name[18];  </span><br><span class="line">&#125;score;  </span><br><span class="line">score sco[max + 1];  </span><br><span class="line">char ch, buff[3];  </span><br><span class="line">bool flag, flag1 = false;  </span><br><span class="line">clock_t start, finish;  </span><br><span class="line">bool over()&#123;  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    printf(&quot;\n\n\n\n\t\t\t您共用了 %d 步 ,耗时 %.3f 分钟\n&quot;, step, (double)(finish - start) / 40000);  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    printf(&quot;\n\n\n\n\n\n\n\n\t*******************  您是否重新开始游戏 (Y/N) ?  *******************\n\n&quot;);  </span><br><span class="line">    scanf(&quot;%s&quot;, buff);  </span><br><span class="line">    ch = buff[0];  </span><br><span class="line">    if (ch != &apos;n&apos;&amp;&amp;ch != &apos;N&apos;) &#123;  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125;  </span><br><span class="line">    else &#123;  </span><br><span class="line">        printf(&quot;\n\n\n\n\t++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n&quot;);  </span><br><span class="line">        printf(&quot;\t+++++++++++++++++++++++++   感谢您的使用   +++++++++++++++++++++++++\n&quot;, step);  </span><br><span class="line">                printf(&quot;\t++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n&quot;);  </span><br><span class="line">        system(&quot;pause&quot;);  </span><br><span class="line">        exit(0);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return true;  </span><br><span class="line">&#125;  </span><br><span class="line">void rank(score sco[],int n) &#123;  </span><br><span class="line">    int i, j;  </span><br><span class="line">    sco[0] = sco[n];  </span><br><span class="line">    for (i = 0; i &lt; n; i++)  </span><br><span class="line">        if (sco[n].steps2&gt;sco[i].steps2) &#123;  </span><br><span class="line">            for (j = n; j &gt; i; j--)  </span><br><span class="line">                sco[j] = sco[j - 1];  </span><br><span class="line">            sco[i] = sco[0];  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">    for (j = i - 1; j &gt; 0; j--)  </span><br><span class="line">        if (sco[i].steps2 == sco[j].steps2&amp;&amp;sco[i].steps &lt; sco[j].steps)  </span><br><span class="line">            sco[0] = sco[i], sco[i] = sco[j], sco[j] = sco[0], i = j;  </span><br><span class="line">        else if (sco[i].steps2 == sco[j].steps2&amp;&amp;sco[i].steps == sco[j].steps)  </span><br><span class="line">            if (sco[i].times &lt; sco[j].times)  </span><br><span class="line">                sco[0] = sco[i], sco[i] = sco[j], sco[j] = sco[0], i = j;  </span><br><span class="line">&#125;  </span><br><span class="line">int check2(int *p, int n) &#123;  </span><br><span class="line">    int i, j, flag2 = 0;  </span><br><span class="line">    for (i = 1; i &lt; n*n - 1; i++)   </span><br><span class="line">        for (j = 0; j &lt; i; j++)   </span><br><span class="line">            if (p[j] &gt; p[i])  </span><br><span class="line">                flag2++;  </span><br><span class="line">    if (!flag2)  </span><br><span class="line">        return 0;  </span><br><span class="line">    else if (flag2 % 2 == 0)  </span><br><span class="line">        return 2;  </span><br><span class="line">    else  </span><br><span class="line">        return 1;  </span><br><span class="line">&#125;  </span><br><span class="line">bool check(int *p,int n) &#123;  </span><br><span class="line">    int i;  </span><br><span class="line">    flag = true;  </span><br><span class="line">    for (i = 0; i&lt;n*n - 1; i++)  </span><br><span class="line">        if (p[i] != i + 1)  </span><br><span class="line">            flag = false;  </span><br><span class="line">    if (flag) &#123;  </span><br><span class="line">        flag1 = false;  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return true;  </span><br><span class="line">&#125;  </span><br><span class="line">int operation(int *p,int n) &#123;  </span><br><span class="line">    scanf(&quot;%s&quot;, buff);  </span><br><span class="line">    ch = buff[0];  </span><br><span class="line">    if (ch &gt;= &apos;a&apos;&amp;&amp;ch &lt;= &apos;z&apos;)  </span><br><span class="line">        ch -= 32;  </span><br><span class="line">    switch (ch) &#123;  </span><br><span class="line">    case &apos;A&apos;: if (y == n - 1) return 1;  </span><br><span class="line">        p[x*n + y] = p[x*n + y + 1];  </span><br><span class="line">        p[x*n + y + 1] = 0;  </span><br><span class="line">        y++;  </span><br><span class="line">        step++;  </span><br><span class="line">        return 1;  </span><br><span class="line">    case &apos;W&apos;: if (x == n - 1) return 1;  </span><br><span class="line">        p[x*n + y] = p[(x + 1)*n + y];  </span><br><span class="line">        p[(x + 1)*n + y] = 0;  </span><br><span class="line">        x++;  </span><br><span class="line">        step++;  </span><br><span class="line">        return 1;  </span><br><span class="line">    case &apos;D&apos;: if (y == 0) return 1;  </span><br><span class="line">        p[x*n + y] = p[x*n + y - 1];  </span><br><span class="line">        p[x*n + y - 1] = 0;  </span><br><span class="line">        y--;  </span><br><span class="line">        step++;  </span><br><span class="line">        return 1;  </span><br><span class="line">    case &apos;S&apos;: if (x == 0) return 1;  </span><br><span class="line">        p[x*n + y] = p[(x - 1)*n + y];  </span><br><span class="line">        p[(x - 1)*n + y] = 0;  </span><br><span class="line">        x--;  </span><br><span class="line">        step++;  </span><br><span class="line">        return 1;  </span><br><span class="line">    case &apos;R&apos;: return 2;  </span><br><span class="line">    case &apos;M&apos;: return 3;  </span><br><span class="line">    case &apos;Q&apos;: printf(&quot;\n\n\t********************* 您是否要离开游戏 (Y/N) ? *********************\n\n&quot;);  </span><br><span class="line">        scanf(&quot;%s&quot;, buff);  </span><br><span class="line">        ch = buff[0];  </span><br><span class="line">        if (ch == &apos;y&apos; || ch == &apos;Y&apos;)  </span><br><span class="line">            return 4;  </span><br><span class="line">        else  </span><br><span class="line">            return 1;  </span><br><span class="line">    default: return 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">void map(int *p, int n) &#123;  </span><br><span class="line">    int i, j;  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    printf(&quot;\n\n\n&quot;);  </span><br><span class="line">    for (i = 0; i &lt; n; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;\t&quot;);  </span><br><span class="line">        for (j = 0; j &lt; n; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if (p[n*i + j] != 0)  </span><br><span class="line">                printf(&quot;%-4d&quot;, p[n*i + j]);  </span><br><span class="line">            else  </span><br><span class="line">                printf(&quot;    &quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;\n\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    printf(&quot;\n\t按方向键移动卡片至无卡片的地方  W:上 S:下 A:左 D:右 M:返回菜单 R:换图 Q:退出\n\n&quot;);  </span><br><span class="line">    finish = clock();  </span><br><span class="line">    printf(&quot;\n\t\t\t\t步数: %d\t 使用时间: %.3f 分钟 \n\n&quot;, step, (double)(finish - start) / 40000);  </span><br><span class="line">&#125;  </span><br><span class="line">void reset(int *p, int n) &#123;  </span><br><span class="line">    int i, j, flag2;  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    do &#123;  </span><br><span class="line">        for (i = 0; i &lt; n*n - 1; i++) &#123;  </span><br><span class="line">            do &#123;  </span><br><span class="line">                flag2 = 1;  </span><br><span class="line">                p[i] = rand() % (n*n - 1) + 1;  </span><br><span class="line">                for (j = 0; j &lt; i; j++)  </span><br><span class="line">                    if (p[i] == p[j])  </span><br><span class="line">                        flag2 = 0;  </span><br><span class="line">            &#125; while (!flag2);  </span><br><span class="line">        &#125;  </span><br><span class="line">        flag2 = check2(p, n);  </span><br><span class="line">        if (flag2 == 1) &#123;  </span><br><span class="line">            flag2 = p[n*n - 2];  </span><br><span class="line">            p[n*n - 2] = p[n*n - 3];  </span><br><span class="line">            p[n*n - 3] = flag2;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; while (!flag2);  </span><br><span class="line">    p[n*n - 1] = 0;  </span><br><span class="line">    for (i = 0; i&lt;n; i++)  </span><br><span class="line">        for (j = 0; j&lt;n; j++)  </span><br><span class="line">            if (p[i*n + j] == 0)&#123;  </span><br><span class="line">                x = i;  </span><br><span class="line">                y = j;  </span><br><span class="line">            &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">void help() &#123;  </span><br><span class="line">    int i = 0;  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    printf(&quot;\n\n\n\n\t--------------------------------+ 基本操作 +--------------------------------\n\n&quot;);  </span><br><span class="line">    printf(&quot;\n\n\t按方向键移动卡片至无卡片的地方  W:上 S:下 A:左 D:右 M:返回菜单 R:换图 Q:退出\n\n&quot;);  </span><br><span class="line">    printf(&quot;\n\n\t---------------------------+ 浅悠悠（王骏）制作 +---------------------------\n\n&quot;);  </span><br><span class="line">    if (label == 0)  </span><br><span class="line">        printf(&quot;\n\n\t--------------------------+ 暂时没有任何游戏记录 +--------------------------\n\n&quot;);  </span><br><span class="line">    else  </span><br><span class="line">        for (i = 1; i &lt;= label; i++)  </span><br><span class="line">            printf(&quot;\n\n\t  第%02d名：%-18s  步数：%-5d   阶数：%-5d   时间：%-6.3lf分钟\n\n&quot;,  </span><br><span class="line">                i, sco[i].name, sco[i].steps, sco[i].steps2, sco[i].times);  </span><br><span class="line">    printf(&quot;\n\n\t----------------------------+ 按任意键返回菜单 +----------------------------\n\n&quot;);  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">void game() &#123;  </span><br><span class="line">    int n, *p;  </span><br><span class="line">    int mark;  </span><br><span class="line">    do &#123;  </span><br><span class="line">        system(&quot;cls&quot;);  </span><br><span class="line">        printf(&quot;\n\n\n\n\t------------------+ 请输入阶数（推荐3——20阶） +------------------\n\n&quot;);  </span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);  </span><br><span class="line">        if (n &gt; 1)  </span><br><span class="line">            p = (int*)calloc(n*n, sizeof(int));  </span><br><span class="line">        else  </span><br><span class="line">            printf(&quot;\t********************** 您输入有误，请重新输入 **********************\n\n&quot;), system(&quot;pause&quot;);  </span><br><span class="line">    &#125; while (n &lt;= 1);  </span><br><span class="line">next1:  </span><br><span class="line">    step = 0;  </span><br><span class="line">    start = clock();  </span><br><span class="line">    reset(p, n);  </span><br><span class="line">next2:  </span><br><span class="line">    map(p, n);  </span><br><span class="line">    if (check(p, n) == false) &#123;  </span><br><span class="line">        printf(&quot;\n\n\t=================+ 恭喜您完成游戏，请输入您的姓名 +=================\n\n&quot;);  </span><br><span class="line">        scanf(&quot;%s&quot;, sco[++label].name);  </span><br><span class="line">        sco[label].steps = step;  </span><br><span class="line">        sco[label].steps2 = n;  </span><br><span class="line">        sco[label].times = (double)(finish - start) / 40000;  </span><br><span class="line">        rank(sco, label);  </span><br><span class="line">        if (over() == false)  </span><br><span class="line">            return;  </span><br><span class="line">    &#125;  </span><br><span class="line">    mark = operation(p, n);  </span><br><span class="line">    if (mark == 1)  </span><br><span class="line">        goto next2;  </span><br><span class="line">    else if (mark == 2)  </span><br><span class="line">        goto next1;  </span><br><span class="line">    else if (mark == 3)  </span><br><span class="line">        return;  </span><br><span class="line">    else if (mark == 4)  </span><br><span class="line">        if (over() == false)  </span><br><span class="line">            return;  </span><br><span class="line">    free(p);  </span><br><span class="line">&#125;  </span><br><span class="line">int main()&#123;  </span><br><span class="line">    srand((int)time(0));      </span><br><span class="line">    do &#123;  </span><br><span class="line">        system(&quot;cls&quot;);  </span><br><span class="line">        printf(&quot;\t-------------+ 欢迎来到浅悠悠数字拼图，请选择您的操作 +-------------\n\n&quot;);  </span><br><span class="line">        printf(&quot;\t-----+  1.开始游戏  +-----+  2.帮助  +-----+  0(或其他).退出  +-----\n\n&quot;);  </span><br><span class="line">        printf(&quot;\t++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n&quot;);  </span><br><span class="line">        scanf(&quot;%s&quot;, buff);  </span><br><span class="line">        ch = buff[0];  </span><br><span class="line">        switch (ch)&#123;  </span><br><span class="line">        case&apos;1&apos;:  </span><br><span class="line">            game(); break;  </span><br><span class="line">        case&apos;2&apos;:  </span><br><span class="line">            help(); break;  </span><br><span class="line">        case&apos;0&apos;:  </span><br><span class="line">            exit(0);  </span><br><span class="line">        default:  </span><br><span class="line">            exit(0);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; while (ch != &apos;0&apos;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>[BFS]正向BFS+hash解决八码问题</title>
    <url>/2018/04/18/2018-04-18/</url>
    <content><![CDATA[<p>八数码问题，可以用单向广搜、双向广搜、A*、IDA等多种方法求解。具体可以参考：<a href="http://www.cnblogs.com/goodness/archive/2010/05/04/1727141.html" target="_blank" rel="noopener">八数码的八境界</a></p>
<p>Description</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1  2  3  4 </span><br><span class="line"></span><br><span class="line"> 5  6  7  8 </span><br><span class="line"></span><br><span class="line"> 9 10 11 12 </span><br><span class="line"></span><br><span class="line">13 14 15  x</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1  2  3  4    1  2  3  4    1  2  3  4    1  2  3  4 </span><br><span class="line"></span><br><span class="line"> 5  6  7  8    5  6  7  8    5  6  7  8    5  6  7  8 </span><br><span class="line"></span><br><span class="line"> 9  x 10 12    9 10  x 12    9 10 11 12    9 10 11 12 </span><br><span class="line"></span><br><span class="line">13 14 11 15   13 14 11 15   13 14  x 15   13 14 15  x </span><br><span class="line"></span><br><span class="line">           r-&gt;           d-&gt;           r-&gt;</span><br></pre></td></tr></table></figure>
<p>Input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  2  3 </span><br><span class="line"></span><br><span class="line">x  4  6 </span><br><span class="line"></span><br><span class="line">7  5  8</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 x 4 6 7 5 8</span><br></pre></td></tr></table></figure>
<p>Output</p>
<p>You will print to standard output either the word <code></code>unsolvable’’, if the puzzle has no solution, or a string consisting entirely of the letters ‘r’, ‘l’, ‘u’ and ‘d’ that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line.</p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2  3  4  1  5  x  7  6  8</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ullddrurdllurdruldr</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<p>本题一共仅有9！种结果，因此求解方法很多。一开始采用stl进行存储，但一直超时，后来改用hash轻轻松松就过了。判重时9！个排列如果用数组直接保存，每一位保存一个维度，数组开不了那么大。因此可以根据康托展开进行判重，每一种排列对应成一个整形数字，9！种排列一共9！个数字，提高了hash效率。此外，对于x我们暂且当做9处理，而123456789的康托展开是1，因此bfs的终止条件就设为当前状态的康拓展开是否为1。此外，由于本次采用正向bfs，而输出结果时需要输出之前的状态，string储存太慢，queue队列会丢失之前的状态，因此用数组充当队列，用pre追溯上一个状态在队列中的下标。解决代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">#include&lt;cstdio&gt;  </span><br><span class="line">#include&lt;string&gt;  </span><br><span class="line">#include&lt;cstring&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">const int MAXN = 400000;  </span><br><span class="line">int fac[9] = &#123; 1, 1, 2, 6, 24, 120, 720, 5040, 40320&#125;;  </span><br><span class="line">int dir[4][2] = &#123; &#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125; &#125;;  </span><br><span class="line">int opp[4] = &#123; &apos;u&apos;,&apos;d&apos;,&apos;l&apos;,&apos;r&apos; &#125;;  </span><br><span class="line">bool vis[MAXN];  </span><br><span class="line">struct node &#123;  </span><br><span class="line">    int stadus;  </span><br><span class="line">    int cur[9];  </span><br><span class="line">    int loc;  </span><br><span class="line">    char path;  </span><br><span class="line">    int pre;  </span><br><span class="line">&#125;;  </span><br><span class="line">node qu[MAXN];  </span><br><span class="line">int cantor(int s[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int sum = 0;  </span><br><span class="line">    for (int i = 0; i&lt;9; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        int num = 0;  </span><br><span class="line">        for (int j = i + 1; j&lt;9; j++)  </span><br><span class="line">            if (s[j]&lt;s[i])  </span><br><span class="line">                num++;  </span><br><span class="line">        sum += num*fac[8 - i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    return sum + 1;  </span><br><span class="line">&#125;  </span><br><span class="line">int bfs(node now) &#123;  </span><br><span class="line">    memset(vis, false, sizeof(vis));  </span><br><span class="line">    int x, y;  </span><br><span class="line">    int front = 0, end = 0;  </span><br><span class="line">    node no = now;  </span><br><span class="line">    qu[end++] = no;  </span><br><span class="line">    vis[now.stadus] = true;  </span><br><span class="line">    while (front &lt; end) &#123;  </span><br><span class="line">        no = qu[front++];  </span><br><span class="line">        x = no.loc / 3;  </span><br><span class="line">        y = no.loc % 3;  </span><br><span class="line">        if (no.stadus == 1)  </span><br><span class="line">            return front - 1;  </span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;  </span><br><span class="line">            node cc = no;  </span><br><span class="line">            int xx = x + dir[i][0];  </span><br><span class="line">            int yy = y + dir[i][1];  </span><br><span class="line">            if (xx &lt; 3 &amp;&amp; xx &gt;= 0 &amp;&amp; yy &lt; 3 &amp;&amp; yy &gt;= 0) &#123;  </span><br><span class="line">                cc.cur[x * 3 + y] = cc.cur[x * 3 + y] ^ cc.cur[xx * 3 + yy];  </span><br><span class="line">                cc.cur[xx * 3 + yy] = cc.cur[x * 3 + y] ^ cc.cur[xx * 3 + yy];  </span><br><span class="line">                cc.cur[x * 3 + y] = cc.cur[x * 3 + y] ^ cc.cur[xx * 3 + yy];  </span><br><span class="line">                cc.stadus = cantor(cc.cur);  </span><br><span class="line">                if (!vis[cc.stadus]) &#123;  </span><br><span class="line">                    vis[cc.stadus] = true;  </span><br><span class="line">                    cc.loc = xx * 3 + yy;  </span><br><span class="line">                    cc.path = opp[i];  </span><br><span class="line">                    cc.pre = front - 1;  </span><br><span class="line">                    qu[end++] = cc;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return -1;  </span><br><span class="line">&#125;  </span><br><span class="line">void show(int a) &#123;  </span><br><span class="line">    if (qu[a].pre) &#123;  </span><br><span class="line">        show(qu[a].pre);  </span><br><span class="line">    &#125;  </span><br><span class="line">    printf(&quot;%c&quot;, qu[a].path);  </span><br><span class="line">&#125;  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    string tmp;  </span><br><span class="line">    while (getline(cin, tmp)) &#123;  </span><br><span class="line">        int i = 0, cnt = 0;  </span><br><span class="line">        node temp;  </span><br><span class="line">        while (tmp[i]) &#123;  </span><br><span class="line">            if (tmp[i] == &apos; &apos;) &#123;  </span><br><span class="line">                i++;  </span><br><span class="line">                continue;  </span><br><span class="line">            &#125;  </span><br><span class="line">            else if (tmp[i] == &apos;x&apos;) &#123;  </span><br><span class="line">                temp.loc = cnt;  </span><br><span class="line">                temp.cur[cnt] = 9;  </span><br><span class="line">                cnt++;  </span><br><span class="line">                i++;  </span><br><span class="line">            &#125;  </span><br><span class="line">            else &#123;  </span><br><span class="line">                temp.cur[cnt] = tmp[i] - &apos;0&apos;;  </span><br><span class="line">                cnt++;  </span><br><span class="line">                i++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        temp.stadus = cantor(temp.cur);  </span><br><span class="line">        int ans = bfs(temp);  </span><br><span class="line">        ans != -1 ? show(ans) : printf(&quot;-1&quot;);  </span><br><span class="line">        cout &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>八数码</tag>
        <tag>康托展开</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>[位运算]dfs+位运算解决N皇后问题</title>
    <url>/2018/04/13/2018-04-13/</url>
    <content><![CDATA[<p>在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。</p>
<p>你的任务是，对于给定的N，求出有多少种合法的放置方法。共有若干行，表示棋盘和皇后的数量；如果N=0，表示结束。</p>
<p>分析：</p>
<p>本篇文章重点介绍位运算解决N皇后的思想，并不是解决特定的问题。和普通算法一样，这是一个递归过程，程序一行一行地寻找可以放皇后的地方。过程带三个参数，row、ld和rd，分别表示在纵列和两个对角线方向的限制条件下这一行的哪些地方不能放。我们以6×6的棋盘为例，看看程序是怎么工作的。假设现在已经递归到第四层，前三层放的子已经标在左图上了。红色、蓝色和绿色的线分别表示三个方向上有冲突的位置，位于该行上的冲突位置就用row、ld和rd中的1来表示。把它们三个并起来，得到该行所有的禁位，取反后就得到所有可以放的位置。注意递归调用时三个参数的变化，每个参数都加上了一个禁位，但两个对角线方向的禁位对下一行的影响需要平移一位。最后，如果递归到某个时候发现row=111111了，说明六个皇后全放进去了，此时程序从第1行跳到第11行，找到的解的个数加一。</p>
<p><img src="https://img-blog.csdn.net/20180413230947558" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;  </span><br><span class="line">#include&lt;math.h&gt;  </span><br><span class="line">int N, Count, res;  </span><br><span class="line">void dfs(int row, int ld, int rd) &#123;  </span><br><span class="line">    if (row == res) &#123;  </span><br><span class="line">        Count++;  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int j = 1; j &lt;= res; j &lt;&lt;= 1)  </span><br><span class="line">        if (row != (row | j) &amp;&amp; ld != (ld | j) &amp;&amp; rd != (rd | j))  </span><br><span class="line">            dfs(row | j, (ld | j) &lt;&lt; 1 &amp; res, (rd | j) &gt;&gt; 1);  </span><br><span class="line">&#125;  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    while (~scanf(&quot;%d&quot;, &amp;N), N) &#123;  </span><br><span class="line">        Count = 0;  </span><br><span class="line">        res = pow(2, N) - 1;  </span><br><span class="line">        dfs(0, 0, 0);  </span><br><span class="line">        printf(&quot;%d\n&quot;, Count);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>DFS</tag>
        <tag>ACM/ICPC</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>[位运算]位运算的4个简单应用</title>
    <url>/2018/04/13/2018-04-13-1/</url>
    <content><![CDATA[<p>\1. 不用任何比较判断两个数中大的那个数</p>
<p>我们将两个数做差，得到另一个数，判断这个数的符号位就可以了。当然，不能直接使用判断语句，所以我们使用位运算来操作。</p>
<p><img src="https://img-blog.csdn.net/20180413201217682?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5feW91eW91/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>\2. 两个相同的数异或结果等于0。</p>
<p>就这道题而言，在运算过程中会产生一个中间值，即a与b的异或结果，a异或b再异或b就会等于a，如果第二次异或a就会等于b。</p>
<p><img src="https://img-blog.csdn.net/20180413201328872?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5feW91eW91/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>所以直接三个异或就可以搞定</p>
<p><img src="https://img-blog.csdn.net/20180413201410925?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5feW91eW91/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>\3. 整数的二进制中有多少个1</p>
<p>每次循环采用n&amp;=(n-1)，这样可以跳过二进制位是0的数。</p>
<p><img src="https://img-blog.csdn.net/2018041320150040?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5feW91eW91/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20180413201511860?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5feW91eW91/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>\4. 数组中只有一个数出现了奇数次，其他数都出现偶数次，找出这个数</p>
<p>这道题还是使用了异或的性质，两个相同的数异或等于0，遍历一遍数组就可以得到出现奇数次的那个数。</p>
<p><img src="https://img-blog.csdn.net/20180413201623168?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5feW91eW91/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言允许初始化列表中末尾出现多余的逗号</title>
    <url>/2018/04/01/2018-04-01/</url>
    <content><![CDATA[<p>C语言允许初始化列表中出现多余的逗号，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int days[] = &#123; 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, &#125;;</span><br></pre></td></tr></table></figure>
<p>为什么这种特性是有用的？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">   </span><br><span class="line">int main(int argc,char** argv)&#123;  </span><br><span class="line">    enum qs&#123;  </span><br><span class="line">        Va = 5,  </span><br><span class="line">        Vb,  </span><br><span class="line">        Vc,  </span><br><span class="line">    &#125; s;  </span><br><span class="line">   </span><br><span class="line">    printf(&quot;a=%d,b=%d,c=%d&quot;,Va,Vb,Vc);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像enum枚举中的条目有可能是根据其它资源来的，而程序员会制作代码生成工具来生成它，所以就允许enum中的多余逗号。像int i = 9,j = 0;这种用法完全可以拆成int i=9;int j=0;因此不会增加代码生成器的负担，所以不支持int i=9,j=0,;</p>
<p>像这种代码，如果用代码生成器去读资源然后写进去，那么每生成一行都需要在末尾加一个逗号来分隔。C允许最后一行有多余的逗号，那就可以不用单独去处理最后一行了，减轻了代码生成器的制作负担，同时因为不用自行删除最后一个逗号，代码生成器的编写也就更不容易出错了。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C陷阱与缺陷</tag>
      </tags>
  </entry>
  <entry>
    <title>树的遍历（根据后序遍历中序遍历推出层序遍历）</title>
    <url>/2018/03/29/2018-03-29/</url>
    <content><![CDATA[<p>对于二叉树的遍历，分为深度优先遍历与广度优先遍历，广度优先遍历有时又称作层序遍历。而深度优先遍历又分为前序遍历，中序遍历和后序遍历。三者之间的区别主要在于根结点的遍历顺序。前序遍历的顺序是根结点-&gt;左子树-&gt;右子树，中序遍历顺序是左子树-&gt;根结点-&gt;右子树，后序遍历顺序是左子树-&gt;右子树-&gt;根结点。现在给出树的后序遍历与中序遍历，要求写出该树的层序遍历。以下是pat上的例题：</p>
<p>给定一棵二叉树的后序遍历和中序遍历，请你输出其层序遍历的序列。这里假设键值都是互不相等的正整数。</p>
<p><strong>输入格式：</strong></p>
<p>输入第一行给出一个正整数N（&lt;=30），是二叉树中结点的个数。第二行给出其后序遍历序列。第三行给出其中序遍历序列。数字间以空格分隔。</p>
<p><strong>输出格式：</strong></p>
<p>在一行中输出该树的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">2 3 1 5 7 6 4</span><br><span class="line">1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 1 6 3 5 7 2</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<p>树的后序遍历特点是最后一个遍历的永远是根结点，由样例很容易看到4即为该树的根结点。而中序遍历的特点是根结点的左边永远是根结点的左子树部分，右边永远是根结点的右子树部分。而树的每一个子树都可以作为新的根。因此二者结合起来很容易将整个树构建出来。以样例为例，首先可以从后序遍历确定4为根结点，然后对照着中序遍历找到4的中序位置为第4位，然后以4为界将树分为以左子树为根的树和以右子树为根的树。现在可以确定根的左子树与右子树的个数分别为m，n，而后序遍历先遍历左子树部分，因此可以确定左子树部分为第1~m位，右子树部分为m+1~m+n位，最后一位为根结点。而左子树部分最后一位即第n位为左子树部分的根即左子树，同理右子树也一样。由此我们只需建立一个树遍历的函数ergodic(int root, int start, int end, int index)即可。其中root为根结点，start与end为由该根结点所衍生出的所有子树的范围，index记录该树的位置。由后序遍历可知end即为根结点的位置，有start开始遍历中序，直到找到根结点在中序遍历中的位置i，在以i为界划分为（start，i-1）与（i+1，end）两部分，而root则为后序遍历中（start，end）中的end位置，即为root-end+i-1的位置。我们初始树的所有结点为-1，意味空值，因此最终搭建的树只需按顺序遍历所有有值部分即可。以下是代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">#include&lt;vector&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">vector&lt;int&gt;post, in, level(100000, -1);  </span><br><span class="line">int N;  </span><br><span class="line">void ergodic(int root, int start, int end, int index) &#123;  </span><br><span class="line">    int i = start;  </span><br><span class="line">    if (start &gt; end)  </span><br><span class="line">        return;  </span><br><span class="line">    while (i &lt; end&amp;&amp;in[i] != post[root])  </span><br><span class="line">        i++;  </span><br><span class="line">    level[index] = post[root];  </span><br><span class="line">    //cout &lt;&lt; root &lt;&lt; start &lt;&lt; end &lt;&lt; i &lt;&lt; endl;  </span><br><span class="line">    ergodic(root - 1 - end + i, start, i - 1, 2 * index + 1);  </span><br><span class="line">    ergodic(root - 1, i + 1, end, 2 * index + 2);  </span><br><span class="line">&#125;  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    cin &gt;&gt; N;  </span><br><span class="line">    post.resize(N);  </span><br><span class="line">    in.resize(N);  </span><br><span class="line">    for (int i = 0; i &lt; N; i++)  </span><br><span class="line">        cin &gt;&gt; post[i];  </span><br><span class="line">    for (int i = 0; i &lt; N; i++)  </span><br><span class="line">        cin &gt;&gt; in[i];  </span><br><span class="line">    ergodic(N - 1, 0, N - 1, 0);  </span><br><span class="line">    for (int i = 0, cnt = 0; i &lt; level.size(); i++) &#123;  </span><br><span class="line">        if (level[i] != -1) &#123;  </span><br><span class="line">            cout &lt;&lt; level[i];  </span><br><span class="line">            cnt != N - 1 ? cout &lt;&lt; &apos; &apos; : cout &lt;&lt; endl;  </span><br><span class="line">            cnt++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于前序遍历也一样，因为前序遍历的特点和后序遍历的特点刚好相反，前序遍历第第一位总是根结点。根据两种遍历即可推出整棵树的结构，搭建完树的结构，任何遍历都会很方便。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>pat天梯赛</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++八进制赋值与输入常见陷阱</title>
    <url>/2018/03/29/2018-03-29-1/</url>
    <content><![CDATA[<p>在C语言及C++中，一个整形数值前如果有一个数字0，则代表该整形数值为八进制数。例如int a，a = 010，则a的十进制数值为8，八进制数值为10。但是在输入a的时候，输入010，如果用scanf（“%d”，&amp;a），则将会被当做十进制10识别。而在c++中使用cout&lt;&lt;a时，也将会被默认为十进制输入。以下是测试用例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    int a = 010;  </span><br><span class="line">    cout &lt;&lt;&quot;将010赋给a时：a = &quot;&lt;&lt; a &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; &quot;请输入a:&quot;;  </span><br><span class="line">    cin &gt;&gt; a;  </span><br><span class="line">    cout &lt;&lt; &quot;将010输入给a时：a = &quot; &lt;&lt; a;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20180329185511263" alt="img"></p>
<p>由此可知，cout默认是以十进制进行输入的。因此，我们在赋值与输入时，得格外注意进制之间的转换。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct temp&#123;  </span><br><span class="line">    int a;  </span><br><span class="line">    int b;  </span><br><span class="line">    int c;  </span><br><span class="line">&#125;temp_1 = &#123; 001,  </span><br><span class="line">            010,  </span><br><span class="line">            222  </span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>
<p>我们经常会在赋值时为了将数值对齐显得美观而在数值之前添加0，这样往往会导致得到的结果错误，因为系统将之默认为八进制赋值。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>进制</tag>
        <tag>C陷阱与缺陷</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据结构]L2-022. 重排链表</title>
    <url>/2018/03/28/2018-03-28-3/</url>
    <content><![CDATA[<h1 id="L2-022-重排链表"><a href="#L2-022-重排链表" class="headerlink" title="L2-022. 重排链表"></a>L2-022. 重排链表</h1><p>给定一个单链表 L1→L2→…→Ln-1→Ln，请编写程序将链表重新排列为 Ln→L1→Ln-1→L2→…。例如：给定L为1→2→3→4→5→6，则输出应该为6→1→5→2→4→3。</p>
<p><strong>输入格式：</strong></p>
<p>每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址和结点总个数，即正整数N (&lt;= 105)。结点的地址是5位非负整数，NULL地址用-1表示。</p>
<p>接下来有N行，每行格式为：</p>
<p><em>Address Data Next</em></p>
<p>其中<em>Address</em>是结点地址；<em>Data</em>是该结点保存的数据，为不超过105的正整数；<em>Next</em>是下一结点的地址。题目保证给出的链表上至少有两个结点。</p>
<p><strong>输出格式：</strong></p>
<p>对每个测试用例，顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00100 6</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 -1</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">68237 6 00100</span><br><span class="line">00100 1 99999</span><br><span class="line">99999 5 12309</span><br><span class="line">12309 2 00000</span><br><span class="line">00000 4 33218</span><br><span class="line">33218 3 -1</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<p>一道数据结构链表题。由于每一次输出链表两边的元素，因此可以构建一个双向链表。即结构体中储存上一个元素pre，数据data，下一个元素next。然后设置一个根结点root和尾结点tail，分别指向第一个结点地址和最后一个结点地址。先输出tail，tail指向对应上一个元素pre。再输出root，root指向对应下一个元素next，以此循环。直到tail与root相遇时输出tail，终止循环。输出tail对应数据时，可以输出tail，data，root，输出root对应数据时，可以输出root，data，tail。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;  </span><br><span class="line">#define Maxn 100000  </span><br><span class="line">using namespace std;  </span><br><span class="line">struct Lists &#123;  </span><br><span class="line">  int pre;  </span><br><span class="line">  int data;  </span><br><span class="line">  int next;  </span><br><span class="line">  Lists() &#123;  </span><br><span class="line">    pre = -1;  </span><br><span class="line">    data = 0;  </span><br><span class="line">    next = -1;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;List[Maxn];  </span><br><span class="line">int main() &#123;  </span><br><span class="line">  int root, N, tail;  </span><br><span class="line">  scanf(&quot;%d%d&quot;, &amp;root, &amp;N);  </span><br><span class="line">  for (int i = 0; i &lt; N; i++) &#123;  </span><br><span class="line">    int temp;  </span><br><span class="line">    scanf(&quot;%d&quot;, &amp;temp);  </span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;List[temp].data, &amp;List[temp].next);  </span><br><span class="line">    if (List[temp].next != -1)  </span><br><span class="line">      List[List[temp].next].pre = temp;  </span><br><span class="line">    else  </span><br><span class="line">      tail = temp;  </span><br><span class="line">  &#125;  </span><br><span class="line">  int flag = 0;  </span><br><span class="line">  while (root != tail) &#123;  </span><br><span class="line">    printf(&quot;%05d %d %05d\n&quot;, tail, List[tail].data, root);  </span><br><span class="line">    tail = List[tail].pre;  </span><br><span class="line">    if (root == tail)  </span><br><span class="line">      break;  </span><br><span class="line">    printf(&quot;%05d %d %05d\n&quot;, root, List[root].data, tail);  </span><br><span class="line">    root = List[root].next;  </span><br><span class="line">  &#125;  </span><br><span class="line">  printf(&quot;%05d %d -1\n&quot;, root, List[root].data);  </span><br><span class="line">  return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>pat天梯赛</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>[并查集]L2-024. 部落</title>
    <url>/2018/03/28/2018-03-28-2/</url>
    <content><![CDATA[<h1 id="L2-024-部落"><a href="#L2-024-部落" class="headerlink" title="L2-024. 部落"></a>L2-024. 部落</h1><p>时间限制</p>
<p>120 ms</p>
<p>内存限制</p>
<p>65536 kB</p>
<p>代码长度限制</p>
<p>8000 B</p>
<p>判题程序</p>
<p>Standard</p>
<p>作者</p>
<p>陈越</p>
<p>在一个社区里，每个人都有自己的小圈子，还可能同时属于很多不同的朋友圈。我们认为朋友的朋友都算在一个部落里，于是要请你统计一下，在一个给定社区中，到底有多少个互不相交的部落？并且检查任意两个人是否属于同一个部落。</p>
<p><strong>输入格式：</strong></p>
<p>输入在第一行给出一个正整数N（&lt;= 104），是已知小圈子的个数。随后N行，每行按下列格式给出一个小圈子里的人：</p>
<p>K P[1] P[2] … P[K]</p>
<p>其中K是小圈子里的人数，P[i]（i=1, .., K）是小圈子里每个人的编号。这里所有人的编号从1开始连续编号，最大编号不会超过104。</p>
<p>之后一行给出一个非负整数Q（&lt;= 104），是查询次数。随后Q行，每行给出一对被查询的人的编号。</p>
<p><strong>输出格式：</strong></p>
<p>首先在一行中输出这个社区的总人数、以及互不相交的部落的个数。随后对每一次查询，如果他们属于同一个部落，则在一行中输出“Y”，否则输出“N”。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3 10 1 2</span><br><span class="line">2 3 4</span><br><span class="line">4 1 5 7 8</span><br><span class="line">3 9 6 4</span><br><span class="line">2</span><br><span class="line">10 5</span><br><span class="line">3 7</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 2</span><br><span class="line">Y</span><br><span class="line">N</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<p>本题又是一道并查集。我的做法是用映射，将所有人映射到对应的圈子中。例如第i个圈子共有k个人，分别为k1…kj…kk。则map[kj]=i。倘若kj已经有对应的圈子，那将两个圈子联系起来。即Union（map[kj]，i）。此外设置计数器sum，每一次执行完map[kj]=i之后sum++，即未重复的人加一。最后计算每一个圈子i是否等于pre[i]，计算独立圈子的个数。判断两个人是否是一个部落，只需查询他们映射的圈子是否相同，即root(map[a])是否等于root(map[b])。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">#include&lt;cstdio&gt;  </span><br><span class="line">#define MAXN 10005  </span><br><span class="line">using namespace std;  </span><br><span class="line">int N, k;  </span><br><span class="line">int pre[MAXN];  </span><br><span class="line">int maps[MAXN];  </span><br><span class="line">int root(int x) &#123;  </span><br><span class="line">    while (x != pre[x]) &#123;  </span><br><span class="line">        pre[x] = pre[pre[x]];  </span><br><span class="line">        x = pre[x];  </span><br><span class="line">    &#125;  </span><br><span class="line">    return x;  </span><br><span class="line">&#125;  </span><br><span class="line">void Union(int px,int py) &#123;  </span><br><span class="line">    px = root(px);  </span><br><span class="line">    py = root(py);  </span><br><span class="line">    if (px != py)  </span><br><span class="line">        pre[py] = px;  </span><br><span class="line">&#125;  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    cin &gt;&gt; N;  </span><br><span class="line">    int sum = 0;  </span><br><span class="line">    for (int i = 0; i &lt; MAXN; i++) &#123;  </span><br><span class="line">        pre[i] = i;  </span><br><span class="line">        maps[i] = 0;  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 1; i &lt;= N; i++) &#123;  </span><br><span class="line">        cin &gt;&gt; k;  </span><br><span class="line">        while (k--) &#123;  </span><br><span class="line">            int temp;  </span><br><span class="line">            cin &gt;&gt; temp;  </span><br><span class="line">            if (!maps[temp]) &#123;  </span><br><span class="line">                maps[temp] = i;  </span><br><span class="line">                sum++;  </span><br><span class="line">            &#125;  </span><br><span class="line">            else   </span><br><span class="line">                Union(maps[temp], i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    int count = 0;  </span><br><span class="line">    for (int i = 1; i &lt;= N; i++)  </span><br><span class="line">        if (pre[i] == i)  </span><br><span class="line">            count++;  </span><br><span class="line">    printf(&quot;%d %d\n&quot;, sum, count);  </span><br><span class="line">    cin &gt;&gt; k;  </span><br><span class="line">    while (k--) &#123;  </span><br><span class="line">        int xx, yy;  </span><br><span class="line">        cin &gt;&gt; xx &gt;&gt; yy;  </span><br><span class="line">        if (root(maps[xx]) == root(maps[yy]))  </span><br><span class="line">            printf(&quot;Y\n&quot;);  </span><br><span class="line">        else  </span><br><span class="line">            printf(&quot;N\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>pat天梯赛</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>C++结构体内部初始化</title>
    <url>/2018/03/28/2018-03-28-1/</url>
    <content><![CDATA[<p>我都知道，c语言中结构体内部是不支持初始化的。如果要初始化结构体，可以在声明变量时进行初始化。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Test&#123;  </span><br><span class="line">    int a;  </span><br><span class="line">    char b;  </span><br><span class="line">    double c;  </span><br><span class="line">&#125;;  </span><br><span class="line">Test test_1 = &#123; 1, &apos;a&apos;, 0 &#125;;</span><br></pre></td></tr></table></figure>
<p>然而c++中结构体内部在声明变量的同时可以声明函数，这为结构体内部初始化提供了很大的便利。</p>
<p>因此上面用例可以写成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Test&#123;  </span><br><span class="line">    int a;  </span><br><span class="line">    char b;  </span><br><span class="line">    double c;  </span><br><span class="line">    Test()&#123;  </span><br><span class="line">        a = 1;  </span><br><span class="line">        b = &apos;a&apos;;  </span><br><span class="line">        c = 0;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这为定义结构体时关于初始化问题提供了很大的便利。</p>
<p>以下是代码及运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">struct Test &#123;  </span><br><span class="line">    int a;  </span><br><span class="line">    char b;  </span><br><span class="line">    double c;  </span><br><span class="line">    Test() &#123;  </span><br><span class="line">        a = 1;  </span><br><span class="line">        b = &apos;a&apos;;  </span><br><span class="line">        c = 0;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;Text_1;  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    cout &lt;&lt; Text_1.a &lt;&lt; endl &lt;&lt; Text_1.b &lt;&lt; endl &lt;&lt; Text_1.c;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/2018032811400643" alt="img"></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>[模拟]来一瓶82年拉菲（酒杯问题）</title>
    <url>/2018/03/28/2018-03-28/</url>
    <content><![CDATA[<p>问题描述：</p>
<p>悠神最近过生日，朋友纷纷来贺。现有一瓶82年拉菲与若干酒杯。酒杯呈三角形酒塔摆放，即每一个酒杯摆放在下一层两个酒杯中间，最下面一层酒杯摆放在桌面上。共有N(1&lt;=N&lt;=20)层酒杯，第k层共有k个酒杯。悠神将拉菲倒进第一层的酒杯中，速度为1杯/s，倒满后酒会向左右两个方向溢出，假设会全部溢出到这个酒杯下面相邻的两个酒杯中。然而悠神有洁癖，他不喜欢浪费，更不喜欢浸湿他心爱的桌布，所以请你计算一下第几秒之后桌布会被浸湿。</p>
<p>eg：如图所示为3层时的情况。第一层倒满需要1s，第二次倒满需要2s，第三层首次倒满需要2s。所以共需1+2+2=5s。</p>
<p><img src="https://img-blog.csdn.net/20180328110952393" alt="img"></p>
<p>输入：</p>
<p>输入N(1&lt;=N&lt;=20)。</p>
<p>输出：</p>
<p>桌布浸湿时至少所需时间（取整数）。</p>
<p>输入样例：</p>
<p>2</p>
<p>输出样例：</p>
<p>3</p>
<p>分析：</p>
<p>桌布浸湿只与最下层最中间位置何时倒满有关，因此只需计算最下层中间位置酒杯的状态。由于时间取整，所以只需模拟出第一杯共倒了多少杯酒，即为多少s。而每一个酒杯共倒了多少酒与上一层相邻两个酒杯相关，及第i层第j个酒杯的酒只与第i-1层第j-1个和第j个酒杯的酒相关。及wine[i][j]=wine[i-1][j-1]+wine[i-1][j];由于酒杯有两种状态，及未满状态和倒满状态，所以要判断wine[i-1]层的酒是否&gt;1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;  </span><br><span class="line">#include&lt;string.h&gt;  </span><br><span class="line">#define MAXN 20  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    int N;  </span><br><span class="line">    while (~scanf(&quot;%d&quot;, &amp;N)) &#123;  </span><br><span class="line">        double wine[MAXN + 1][MAXN + 1] = &#123; 0 &#125;;  </span><br><span class="line">        double temp = 0;  </span><br><span class="line">        while (wine[N][N / 2 + 1] &lt; 1) &#123;  </span><br><span class="line">            memset(wine, 0, sizeof(wine));  </span><br><span class="line">            temp++;  </span><br><span class="line">            wine[1][1] = temp;  </span><br><span class="line">            for (int i = 1; i &lt;= N; i++) &#123;  </span><br><span class="line">                for (int j = 1; j &lt;= i; j++) &#123;  </span><br><span class="line">                    wine[i][j] += (wine[i - 1][j - 1] &gt; 1 ? (wine[i - 1][j - 1] - 1) / 2.0 : 0) + (wine[i - 1][j] &gt; 1 ? (wine[i - 1][j] - 1) / 2.0 : 0);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;%g\n&quot;, wine[1][1]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>训练之路</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>模拟</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title>[BFS]愿天下有情人都是失散多年的兄妹</title>
    <url>/2018/03/26/2018-03-26-1/</url>
    <content><![CDATA[<h2 id="题目概述："><a href="#题目概述：" class="headerlink" title="题目概述："></a>题目概述：</h2><h2 id="L2-016-愿天下有情人都是失散多年的兄妹"><a href="#L2-016-愿天下有情人都是失散多年的兄妹" class="headerlink" title="L2-016. 愿天下有情人都是失散多年的兄妹"></a>L2-016. 愿天下有情人都是失散多年的兄妹</h2><p>时间限制</p>
<p>200 ms</p>
<p>内存限制</p>
<p>65536 kB</p>
<p>代码长度限制</p>
<p>8000 B</p>
<p>判题程序</p>
<p>Standard</p>
<p>作者</p>
<p>陈越</p>
<p>呵呵。大家都知道五服以内不得通婚，即两个人最近的共同祖先如果在五代以内（即本人、父母、祖父母、曾祖父母、高祖父母）则不可通婚。本题就请你帮助一对有情人判断一下，他们究竟是否可以成婚？</p>
<p><strong>输入格式：</strong></p>
<p>输入第一行给出一个正整数N（2 &lt;= N &lt;= 104），随后N行，每行按以下格式给出一个人的信息：</p>
<p>本人ID 性别 父亲ID 母亲ID</p>
<p>其中ID是5位数字，每人不同；性别M代表男性、F代表女性。如果某人的父亲或母亲已经不可考，则相应的ID位置上标记为-1。</p>
<p>接下来给出一个正整数K，随后K行，每行给出一对有情人的ID，其间以空格分隔。</p>
<p>注意：题目保证两个人是同辈，每人只有一个性别，并且血缘关系网中没有乱伦或隔辈成婚的情况。</p>
<p><strong>输出格式：</strong></p>
<p>对每一对有情人，判断他们的关系是否可以通婚：如果两人是同性，输出“Never Mind”；如果是异性并且关系出了五服，输出“Yes”；如果异性关系未出五服，输出“No”。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24</span><br><span class="line">00001 M 01111 -1</span><br><span class="line">00002 F 02222 03333</span><br><span class="line">00003 M 02222 03333</span><br><span class="line">00004 F 04444 03333</span><br><span class="line">00005 M 04444 05555</span><br><span class="line">00006 F 04444 05555</span><br><span class="line">00007 F 06666 07777</span><br><span class="line">00008 M 06666 07777</span><br><span class="line">00009 M 00001 00002</span><br><span class="line">00010 M 00003 00006</span><br><span class="line">00011 F 00005 00007</span><br><span class="line">00012 F 00008 08888</span><br><span class="line">00013 F 00009 00011</span><br><span class="line">00014 M 00010 09999</span><br><span class="line">00015 M 00010 09999</span><br><span class="line">00016 M 10000 00012</span><br><span class="line">00017 F -1 00012</span><br><span class="line">00018 F 11000 00013</span><br><span class="line">00019 F 11100 00018</span><br><span class="line">00020 F 00015 11110</span><br><span class="line">00021 M 11100 00020</span><br><span class="line">00022 M 00016 -1</span><br><span class="line">00023 M 10012 00017</span><br><span class="line">00024 M 00022 10013</span><br><span class="line">9</span><br><span class="line">00021 00024</span><br><span class="line">00019 00024</span><br><span class="line">00011 00012</span><br><span class="line">00022 00018</span><br><span class="line">00001 00004</span><br><span class="line">00013 00016</span><br><span class="line">00017 00015</span><br><span class="line">00019 00021</span><br><span class="line">00010 00011</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Never Mind</span><br><span class="line">Yes</span><br><span class="line">Never Mind</span><br><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分析：</span><br></pre></td></tr></table></figure>
<p>利用广度优先搜索，将每个人及双亲放入集合mab中，假如集合长度为改变，则说明mab中已存在这个人，则证明双方是近亲。visit用来记录层数。五层时结束搜索。</p>
<p>AC代码BFS：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">#include&lt;set&gt;  </span><br><span class="line">#include&lt;queue&gt;  </span><br><span class="line">#include&lt;cstring&gt;  </span><br><span class="line">#define MAXN 100005  </span><br><span class="line">using namespace std;  </span><br><span class="line">struct inf &#123;  </span><br><span class="line">    int fa;  </span><br><span class="line">    int ma;  </span><br><span class="line">    char sex;  </span><br><span class="line">&#125;;  </span><br><span class="line">inf node[MAXN];  </span><br><span class="line">int visit[MAXN];  </span><br><span class="line">bool flag[MAXN];  </span><br><span class="line">int N;  </span><br><span class="line">bool BFS(int x1,int x2) &#123;  </span><br><span class="line">    memset(visit, 0, sizeof(visit));  </span><br><span class="line">    queue&lt;int&gt;family;  </span><br><span class="line">    set&lt;int&gt;mab;  </span><br><span class="line">    family.push(x1);  </span><br><span class="line">    family.push(x2);  </span><br><span class="line">    visit[x1] = 1;  </span><br><span class="line">    visit[x2] = 1;  </span><br><span class="line">    while (!family.empty()) &#123;  </span><br><span class="line">        int top = family.front();  </span><br><span class="line">        family.pop();  </span><br><span class="line">        int size = mab.size();  </span><br><span class="line">        mab.insert(top);  </span><br><span class="line">        if (mab.size() == size) &#123;  </span><br><span class="line">            return true;  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (visit[top] &lt;= 4) &#123;  </span><br><span class="line">            if (node[top].fa) &#123;  </span><br><span class="line">                family.push(node[top].fa);  </span><br><span class="line">                visit[node[top].fa] += visit[top] + 1;  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (node[top].ma) &#123;  </span><br><span class="line">                family.push(node[top].ma);  </span><br><span class="line">                visit[node[top].ma] += visit[top] + 1;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return false;  </span><br><span class="line">&#125;  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    cin &gt;&gt; N;  </span><br><span class="line">    memset(node, 0, sizeof(node));  </span><br><span class="line">    memset(flag, 0, sizeof(flag));  </span><br><span class="line">    while (N--) &#123;  </span><br><span class="line">        int id, fa, ma;  </span><br><span class="line">        char ch[2];  </span><br><span class="line">        scanf(&quot;%d%s%d%d&quot;, &amp;id, ch, &amp;fa, &amp;ma);  </span><br><span class="line">        node[id].sex = ch[0];  </span><br><span class="line">        flag[id] = true;  </span><br><span class="line">        if (fa != -1) &#123;  </span><br><span class="line">            node[id].fa = fa;  </span><br><span class="line">            node[fa].sex = &apos;M&apos;;  </span><br><span class="line">            flag[fa] = true;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (ma != -1) &#123;  </span><br><span class="line">            node[id].ma = ma;  </span><br><span class="line">            node[ma].sex = &apos;F&apos;;  </span><br><span class="line">            flag[ma] = true;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cin &gt;&gt; N;  </span><br><span class="line">    while (N--) &#123;  </span><br><span class="line">        int per1, per2;  </span><br><span class="line">        cin &gt;&gt; per1 &gt;&gt; per2;  </span><br><span class="line">        if (node[per1].sex == node[per2].sex)  </span><br><span class="line">            printf(&quot;Never Mind\n&quot;);  </span><br><span class="line">        else &#123;  </span><br><span class="line">            if (BFS(per1, per2))  </span><br><span class="line">                printf(&quot;No\n&quot;);  </span><br><span class="line">            else  </span><br><span class="line">                printf(&quot;Yes\n&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>pat天梯赛</tag>
      </tags>
  </entry>
  <entry>
    <title>vector的嵌套实现二维数组，解决矩阵相乘问题</title>
    <url>/2018/03/26/2018-03-26/</url>
    <content><![CDATA[<p>定义vector的元素可以是一个vector。比如， vector&lt;vector<int>&gt; 即表示一个二维int数组，里层的vector表示第一维， 外层的vector表示第二维。</int></p>
<h2 id="例题描述：L1-048-矩阵A乘以B"><a href="#例题描述：L1-048-矩阵A乘以B" class="headerlink" title="例题描述：L1-048. 矩阵A乘以B"></a>例题描述：L1-048. 矩阵A乘以B</h2><p>时间限制</p>
<p>400 ms</p>
<p>内存限制</p>
<p>65536 kB</p>
<p>代码长度限制</p>
<p>8000 B</p>
<p>判题程序</p>
<p>Standard</p>
<p>给定两个矩阵A和B，要求你计算它们的乘积矩阵AB。需要注意的是，只有规模匹配的矩阵才可以相乘。即若A有Ra行、Ca列，B有Rb行、Cb列，则只有Ca与Rb相等时，两个矩阵才能相乘。</p>
<p><strong>输入格式：</strong></p>
<p>输入先后给出两个矩阵A和B。对于每个矩阵，首先在一行中给出其行数R和列数C，随后R行，每行给出C个整数，以1个空格分隔，且行首尾没有多余的空格。输入保证两个矩阵的R和C都是正数，并且所有整数的绝对值不超过100。</p>
<p><strong>输出格式：</strong></p>
<p>若输入的两个矩阵的规模是匹配的，则按照输入的格式输出乘积矩阵AB，否则输出“Error: Ca != Rb”，其中Ca是A的列数，Rb是B的行数。</p>
<p>输入样例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">3 4</span><br><span class="line">7 8 9 0</span><br><span class="line">-1 -2 -3 -4</span><br><span class="line">5 6 7 8</span><br></pre></td></tr></table></figure>
<p>输出样例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 4</span><br><span class="line">20 22 24 16</span><br><span class="line">53 58 63 28</span><br></pre></td></tr></table></figure>
<p>输入样例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">38 26</span><br><span class="line">43 -5</span><br><span class="line">0 17</span><br><span class="line">3 2</span><br><span class="line">-11 57</span><br><span class="line">99 68</span><br><span class="line">81 72</span><br></pre></td></tr></table></figure>
<p>输出样例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error: 2 != 3</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">#include&lt;vector&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">int M1, N1, M2, N2;  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    cin &gt;&gt; M1 &gt;&gt; N1;  </span><br><span class="line">    vector&lt;int&gt;alie(N1);  </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt;ahang(M1);  </span><br><span class="line">    for (int i = 0; i &lt; M1; i++) &#123;  </span><br><span class="line">        for (int j = 0; j &lt; N1; j++) &#123;  </span><br><span class="line">            scanf(&quot;%d&quot;, &amp;alie[j]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        ahang[i] = alie;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cin &gt;&gt; M2 &gt;&gt; N2;  </span><br><span class="line">    vector&lt;int&gt;blie(N2);  </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt;bhang(M2);  </span><br><span class="line">    for (int i = 0; i &lt; M2; i++) &#123;  </span><br><span class="line">        for (int j = 0; j &lt; N2; j++) &#123;  </span><br><span class="line">            scanf(&quot;%d&quot;, &amp;blie[j]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        bhang[i] = blie;  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (N1 != M2)  </span><br><span class="line">        printf(&quot;Error: %d != %d\n&quot;, N1, M2);  </span><br><span class="line">    else &#123;  </span><br><span class="line">        vector&lt;int&gt;anslie(N2);  </span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;anshang(M1);  </span><br><span class="line">        for (int i = 0; i &lt; M1; i++) &#123;  </span><br><span class="line">            for (int j = 0; j &lt; N2; j++) &#123;  </span><br><span class="line">                anslie[j] = 0;  </span><br><span class="line">                for (int k = 0; k &lt; N1; k++)  </span><br><span class="line">                    anslie[j] += ahang[i][k] * bhang[k][j];  </span><br><span class="line">            &#125;  </span><br><span class="line">            anshang[i] = anslie;  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;%d %d\n&quot;, M1, N2);  </span><br><span class="line">        for (int i = 0; i &lt; M1; i++) &#123;  </span><br><span class="line">            for (int j = 0; j &lt; N2 - 1; j++)  </span><br><span class="line">                printf(&quot;%d &quot;, anshang[i][j]);  </span><br><span class="line">            printf(&quot;%d\n&quot;, anshang[i][N2 - 1]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练之路</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
        <tag>算法</tag>
        <tag>pat天梯赛</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔</title>
    <url>/2018/02/03/2018-02-03/</url>
    <content><![CDATA[<p>韶光浅，</p>
<p>岁月转轴调弦</p>
<p>悠悠流曲耳边，</p>
<p>依依情记心间</p>
<p>又是一季似水流年</p>
<p>愿你跨过千山，</p>
<p>归来一如从前</p>
<p>——浅悠悠</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>摘星集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS与DFS的用途与选择</title>
    <url>/2018/02/01/2018-02-01/</url>
    <content><![CDATA[<p>1.BFS是用来搜索最短径路的解是比较合适的，比如求最少步数的解，最少交换次数的解，因为BFS搜索过程中遇到的解一定是离根最近的，所以遇到一个解，一定就是最优解，此时搜索算法可以终止。这个时候不适宜使用DFS，因为DFS搜索到的解不一定是离根最近的，只有全局搜索完毕，才能从所有解中找出离根的最近的解。（当然这个DFS的不足，可以使用迭代加深搜索ID-DFS去弥补）<br>2.空间优劣上，DFS是有优势的，DFS不需要保存搜索过程中的状态，而BFS在搜索过程中需要保存搜索过的状态，而且一般情况需要一个队列来记录。<br>3.DFS适合搜索全部的解，因为要搜索全部的解，那么BFS搜索过程中，遇到离根最近的解，并没有什么用，也必须遍历完整棵搜索树，DFS搜索也会搜索全部，但是相比DFS不用记录过多信息，所以搜素全部解的问题，DFS显然更加合适。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类的3种继承方式</title>
    <url>/2018/01/24/2018-01-24/</url>
    <content><![CDATA[<p>众所周知，C++类中的成员(函数/变量)拥有三种访问权限：</p>
<pre><code>public:用该关键字修饰的成员表示公有成员，该成员不仅可以在类内可以被访问，在类外也是可以被访问的，是类对外提供的可访问接口；

private:用该关键字修饰的成员表示私有成员，该成员仅在类内可以被访问，在类体外是隐藏状态；

protected:用该关键字修饰的成员表示保护成员，保护成员在类体外同样是隐藏状态，但是对于该类的派生类来说，相当于公有成员，在派生类中可以被访问。

对一个类的派生类来说，在继承基类的过程中，不仅包含了基类的所有成员，还增加了自己的成员，而派生类中成员的访问权限则会因为继承权限方式的不同而不同。

相对于派生类成员的访问权限比较简单(派生类成员的访问权限就是取决于派生类中定义的权限)，从基类中继承的成员的访问权限就相对较为复杂，这并不是简单地照搬基类的成员访问权限。基类成员在派生类中的访问权限与继承的方式有着密切的关系，在不同的继承方式下，访问权限也是不同的，总结如下：

**若继承方式是public，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限；**

**若继承方式是private，基类所有成员在派生类中的访问权限都会变为私有(private)权限；**

**若继承方式是protected，基类的共有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限，私有成员在派生类中的访问权限仍然是私有(private)权限。**
</code></pre><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/18-01-24-%E7%BB%A7%E6%89%BF-1.png" alt></p>
<p>注意：</p>
<ol>
<li>C++中struct与class的唯一区别是类内成员struct默认为public，class默认为private。</li>
<li>同一类的对象之间类内可以互相访问任意成员，派生类与基类之间类内可访问除私有成员外的任意成员，所有类外只能访问公有成员。</li>
<li>无论哪种继承方式，基类的公有和保护成员都可以被派生类的成员访问。</li>
<li>无论哪种继承方式，基类的私有成员都不可以被派生类的成员和对象访问。</li>
<li>只有公有继承时，基类的公有成员才可以被派生类的对象访问。</li>
<li>在被继承时，基类的保护成员及和公有成员行为一致。</li>
<li>在被类的对象访问时，保护成员和私有成员的行为一致。</li>
</ol>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>sstream和strstream的用法</title>
    <url>/2018/01/24/2018-01-24-1/</url>
    <content><![CDATA[<p>在C++有两种字符串流,也称为数组I/O流，一种在 strstream 中定义，另一种在 sstream 中定义。它们实现的东西基本一样。<br>strstream里包含：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class strstreambuf;</span><br><span class="line">class istrstream;</span><br><span class="line">class ostrstream;</span><br><span class="line">class strstream;</span><br></pre></td></tr></table></figure>
<p>它们是基于C类型字符串char*编写的</p>
<p>sstream中包含：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class stringbuf;</span><br><span class="line">class istringstream;</span><br><span class="line">class ostringstream;</span><br><span class="line">class stringstream;</span><br></pre></td></tr></table></figure>
<p>它们是基于std::string编写的</p>
<p>因此ostrstream::str()返回的是char*类型的字符串<br>而ostringstream::str()返回的是std::string类型的字符串<br>在使用的时候要注意到二者的区别，一般情况下推荐使用std::string类型的字符串<br>当然如果为了保持和C的兼容，使用strstream也是不错的选择。<br>但要记住一点,strstream虽仍然是C++语言标准的一部分,但已被C++标准宣称为“deprecated”，也就是不再提倡使用了，也说不定以后干粹就没了。</p>
<p>先介绍一下sstream</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//strigstream流以空格为边界符,使用其须包含sstream头文件</span><br><span class="line">//istringstream 用法</span><br><span class="line">istringstream istring;</span><br><span class="line">string ss(&quot;ss 8346520&quot;);</span><br><span class="line">istring.str(ss);</span><br><span class="line">int i=0;</span><br><span class="line">string s;</span><br><span class="line">istring&gt;&gt;s&gt;&gt;i;</span><br><span class="line">cout&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">istringstream istring(&quot;ss 8346520&quot;);</span><br><span class="line">int i=0;</span><br><span class="line">string s;</span><br><span class="line">istring&gt;&gt;s&gt;&gt;i;</span><br><span class="line">cout&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>都将打印：s内容是ss,i内容是8346520的结果;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//ostringstream 用法</span><br><span class="line">string s=&quot;test&quot;;</span><br><span class="line">int i=8346520;</span><br><span class="line">int j=0;</span><br><span class="line">string s1;</span><br><span class="line">ostringstream ostring; //不能写成ostringstream ostring&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;i;</span><br><span class="line">ostring&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;i;</span><br><span class="line">cout&lt;&lt;ostring.str()&lt;&lt;endl; //ostring流内保存内容是test 8346520</span><br><span class="line">istringstream istring(ostring.str());</span><br><span class="line">istring&gt;&gt;s1&gt;&gt;j;//要注意此处的顺序;</span><br><span class="line">cout&lt;&lt;s1&lt;&lt;&quot;――――&quot;&lt;&lt;j&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>简单说说strstream:<br>基于数组的类有istrstream、ostrstream和strstream。它们分别用来创建输入、输出和输入／输出流。这些类的基类之一是strstreambuf，它定义了派生类使用的几个底层的具体属性。<br>除了strstreambuf以外，istream也是istrstream的基类。类ostrstream包括了类ostream。<br>strstream也包括了类iostream。所以，所有基于数组的类和“普通”I／O类一样存取相同的成员函数。<br>创建基于数组的输出流要将一个输出流和一个数组关联起来，可使用下列ostream的构造函数：<br>ostrstream ostr（char＊buf，int size，int mode＝ios：：out）；<br>其中，buf是指向数组的指针，该数组接收写入流的字符。数组的长度由参数size确定。缺省时，流以输出方式打开，但也可以将几项或在一起复合为所需的方式（例如，可以包含ios：：app使输出添加在数组中已存在的信息的尾部）。mode的缺省值可以满足大多数的要求。一旦打开了一个基于数组的输出流，所有对这个流的输出就放在数组中。但是，任何输出都不能写到数组的限界之外，任何这种企图都会导致错误。</p>
<p>下面是一个介绍基于数组的输出流的简单程序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;strstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arraysize=50;</span><br><span class="line">char *pbuffer=new char[arraysize];</span><br><span class="line">ostrstream ostr(pbuffer,arraysize,ios::out);</span><br><span class="line">ostr&lt;&lt;&quot;Hello&quot;&lt;&lt;&quot; &quot;;</span><br><span class="line">ostr&lt;&lt;99-14&lt;&lt;hex&lt;&lt;&quot; &quot;;</span><br><span class="line">ostr.setf(ios::showbase);</span><br><span class="line">ostr&lt;&lt;100&lt;&lt;ends; //使用ostrstream输出到流对象的时候,要用ends结束字符串</span><br><span class="line">cout&lt;&lt;pbuffer;</span><br><span class="line">delete[] pbuffer;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用数组作输入:<br>要将输入流和数组关联起来，可使用下列istrstream的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">istrstream istr（char*buf）；</span><br></pre></td></tr></table></figure>
<p>其中，buf是指向数组的指针，该数组作为每次向流输入的字符源。buf所指的数组必须以空结束。空结束符从不从数组中读取。</p>
<p>下面是一个用字符串输入的例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;strstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">const char s[]=&quot;10 Hello 15 12.23 done&quot;;</span><br><span class="line">istrstream ins(s);</span><br><span class="line">int i;</span><br><span class="line">char str[80];</span><br><span class="line">float f;</span><br><span class="line">//reading： 10 Hello</span><br><span class="line">ins &gt;&gt;i;ins &gt;&gt;str;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">// reading：f 12.23 done.</span><br><span class="line">ins&gt;&gt;i;</span><br><span class="line">ins&gt;&gt;f;</span><br><span class="line">ins&gt;&gt;str;</span><br><span class="line">cout&lt;&lt;hex&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;f&lt;&lt;&quot; &quot;&lt;&lt;str;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
        <tag>字符串</tag>
        <tag>字符串流</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式练习题集(附答案)</title>
    <url>/2018/01/21/2018-01-21/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​                好久到没有去写关于正则表达式的总结了，虽然自己写了一些关于正则表达式的东西。但是</p>
<p>​           感觉上对正则表达式还停留在网上查找的阶段，对于大部分的人来说，很难写自己的正则表达式</p>
<p>​           对于正则表达式笔者也做过相关的总结。呃，过了一段时间还是模糊了。因此找一些练习题来找</p>
<p>​           回自己的记忆。</p>
<p>​                需要说明的是这些练习题有的是网上的！</p>
<h2 id="初级练习"><a href="#初级练习" class="headerlink" title="初级练习"></a>初级练习</h2><p>​                   1、求非负整数 : ^\d+$</p>
<p>​                       Tips:需要注意的是这个匹配模式为多行模式下进行的</p>
<p>​             <img src="https://img-blog.csdn.net/20130504111437758" alt="img"></p>
<p>​                  2、匹配正整数： ^[1-9]<em>[1-9][0-9]</em>$ 在网上也有这种写法的 ^[0-9]<em>[1-9][0-9]</em>$</p>
<p>​                      这里截图我也不贴了，前者指能匹配123012这种整数，而后者可以匹配001230。</p>
<p>​                       取舍就看实际的需要了</p>
<p>​                  3、非正整数：^(-\d+|(0+))$</p>
<p>​                  4、负整数：^-[0-9]<em>[1-9][0-9]</em>$  </p>
<p>​                  5、整数 ：^-?\d+$</p>
<p>​                  6、非负浮点数 ：^\d+(.\d+)?$</p>
<p>​                  7、正浮点数 ：^(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]</em>.[0-9]+)|([0-9]<em>[1-9][0-9]</em>))$</p>
<p>​                  8、非正浮点数 ：^((-\d+(.\d+)?)|(0+(.0+)?))$</p>
<p>​                  9、负浮点数：^(-(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]</em>.[0-9]+)|([0-9]<em>[1-9][0-9]</em>)))$</p>
<p>​                 10、浮点数：^(-?\d+)(.\d+)?$</p>
<p>​                 11、有数字、26个英文字母组成的字符串：^[A-Za-z0-9]+$</p>
<h2 id="中级练习"><a href="#中级练习" class="headerlink" title="中级练习"></a>中级练习</h2><p>​                   1、长度为8-10的用户密码（以字母开头、数字、下划线）</p>
<p>​                        ^[a-zA-Z]\w{7,10}$</p>
<p>​                   2、验证输入只能是汉字 ： ^[\u4e00-\u9fa5]{0,}$</p>
<p>​                   3、电子邮箱验证：^\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*$</p>
<p>​                   4、URL地址验证：^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$</p>
<p>​                   5、电话号码的验证：请参考：<a href="http://blog.csdn.net/kiritor/article/details/8733469" target="_blank" rel="noopener">http://blog.csdn.net/kiritor/article/details/8733469</a></p>
<p>​                   6、简单的身份证号验证：\d{15}|\d{18}$</p>
<p>​                   …………………………          </p>
<h2 id="高级练习"><a href="#高级练习" class="headerlink" title="高级练习"></a>高级练习</h2><p>​                  1、提取并捕获html标签内容：</p>
<p>​                     &lt;a(?: [^&gt;]<em>)+href=([^ &gt;]</em>)(?: [^&gt;]<em>)</em>&gt;</p>
<p>​               <img src="https://img-blog.csdn.net/20130504123855693" alt="img"></p>
<p>​                    &lt;OPTION\s.*?&gt;</p>
<p>​               <img src="https://img-blog.csdn.net/20130504124150703" alt="img"></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Git教程</title>
    <url>/2018/01/20/2018-01-20/</url>
    <content><![CDATA[<h3 id="1-Git简介"><a href="#1-Git简介" class="headerlink" title="1.Git简介"></a>1.Git简介</h3><p>Git是目前世界上最先进的分布式版本控制系统，在处理各种项目时都十分高效，而且非常的高大上。</p>
<p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。而且集中式版本控制系统是必须联网才能工作。</p>
<p>Git是分布式版本控制系统，它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。</p>
<h3 id="2-Git安装（仅列出在Windows系统下的安装过程）"><a href="#2-Git安装（仅列出在Windows系统下的安装过程）" class="headerlink" title="2.Git安装（仅列出在Windows系统下的安装过程）"></a>2.Git安装（仅列出在Windows系统下的安装过程）</h3><p>打开<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git官网</a>下载安装程序，然后按照默认选项安装即可。</p>
<p>安装完成后，打开Git bash软件，弹出一个类似cmd的命令行窗口，证明安装成功。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-01-20.png" alt="img"></p>
<p>安装完成后，需要进行设置，在命令行输入以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>顾名思义，这是设置你的名字和Email地址。</p>
<p>我们可以查看一下用户名和密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">$ git config user.email</span><br></pre></td></tr></table></figure>
<p>假如我们这时候报错，证明Git的用户名和密码没有配置成功，我们还可以这样做：</p>
<p>在用户主目录下找到 .git 文件夹： <img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-01-20-1.png" alt="img"></p>
<p>然后打开 config 文件，这是专门用来配置和读取相应的工作环境变量的，在里面加上如图所示内容：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-01-20-2.png" alt="img"></p>
<p>这样也就完成了对Git用户名和邮箱的配置。</p>
<h3 id="3-创建版本库"><a href="#3-创建版本库" class="headerlink" title="3.创建版本库"></a>3.创建版本库</h3><p>版本库(repository)也叫仓库，可以看做一个目录，这个目录里的所以文件都由Git进行管理，每个文件的修改、删除，Git都能跟踪。</p>
<p>1.选择一个合适的地方，创建一个空目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir learngit //创建一个名叫learngit的空目录</span><br><span class="line">$ cd learngit //把learngit设置为当前目录</span><br><span class="line">$ pwd //查看当前目录</span><br><span class="line">/c/Users/Administrator/learngit</span><br></pre></td></tr></table></figure>
<p>如果使用Windows系统，要保证目录名不包含中文。</p>
<p>2.通过如下命令把这个目录变成Git可以管理的仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/Administrator/learngit/.git/</span><br></pre></td></tr></table></figure>
<p>这样Git就把仓库建好啦，我们可以看到在当前目录下多了一个 .git的目录，这个目录是Git来跟踪管理版本库的。</p>
<p>3.把文件添加到版本库</p>
<p>我们在 learngit 目录下编写一个 readme.txt 文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure>
<p>(1) 用 git add 命令，把文件添加到仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure>
<p>执行以上命令，没有任何显示。</p>
<p>(2) 用 git commit 命令，把文件提交到仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot; //-m后面输入的是本次提交的说明，可以输入任意内容。</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+) //1 file changed：1个文件被改动（新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt内有两行内容）</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure>
<h3 id="4-修改文件"><a href="#4-修改文件" class="headerlink" title="4.修改文件"></a>4.修改文件</h3><p>我们已经成功添加并提交了一个 readme.txt 文件，继续修改 readme.txt 文件，改成如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure>
<p>运行 git status 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status //查看仓库当前的状态</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit: //没有文件将要被提交</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">    modified:   readme.txt</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>上面的命令告诉我们，readme.txt 文件被修改过了，但还没有准备提交的修改。</p>
<p>如果我们想知道上次是怎么修改readme.txt 文件的，需要用 git diff 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system. //这一句是被删掉的</span><br><span class="line">+Git is a distributed version control system. //这一句是新添加的</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure>
<p>接下来还是那两步：</p>
<p>(1) git add </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure>
<p>没有任何输出，这时候可以用 git status 查看一下当前仓库状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed: //将要被提交的文件包括 readme.txt</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">    modified:   readme.txt</span><br></pre></td></tr></table></figure>
<p>(2) git commit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;add distributed&quot;</span><br><span class="line">[master e475afc] add distributed</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p>再用 git status 查看一下当前仓库状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean //当前没有需要提交的修改，而且，工作目录是干净的。</span><br></pre></td></tr></table></figure>
<h3 id="5-版本回退"><a href="#5-版本回退" class="headerlink" title="5.版本回退"></a>5.版本回退</h3><p>如果我们继续对 readme.txt 文件进行修改，改成如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure>
<p>然后添加并提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m &quot;append GPL&quot;</span><br><span class="line">[master 1094adb] append GPL</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p>到目前为止，readme.txt 文件一共有三个版本被提交到了 Git 仓库里，我们可以用 git log 命令进行查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log //查看历史记录</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line">    append GPL</span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure>
<p>我们还可以加上 –pretty=oneline 参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file //一大串数字是 commit id ，而且每个人的都不一样。</span><br></pre></td></tr></table></figure>
<p>好了，现在如果我们想把 readme.txt 文件退回到上一个版本，就可以使用 git reset 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^ //HEAD表示当前版本，则HEAD^表示上一个版本，那么上上版本就是HEAD^^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure>
<p>这时候用 cat 命令查看一下 readme.txt 的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt //查看 readme.txt 文件的内容</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure>
<p>果然 readme.txt 文件返回到了上一个版本。</p>
<p>我们现在想要回到最新的版本，还是使用 git reset 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard 1094a //这里不能用HEAD而必须使用 commit id ，因为最新版本在之前返回时已经被删除了，1094a就是最新版本的 commit id，可以在之前的代码中查到</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure>
<p>这时再查看一下 readme.txt 文件内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure>
<p>果然，又回到了最新的版本。</p>
<h3 id="6-工作区和暂存区"><a href="#6-工作区和暂存区" class="headerlink" title="6.工作区和暂存区"></a>6.工作区和暂存区</h3><p>工作区（Working Directory）</p>
<p>learngit 文件夹就是一个工作区。</p>
<p>版本库（Repository）</p>
<p>工作区有个隐藏目录 .git ，这个不算工作区，而是 Git 的版本库。</p>
<p>版本库里面的 index(stage) 文件叫暂存区，还有Git为我们自动创建的第一个分支 master ，以及指向 master 的一个指针叫做 HEAD。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-01-20-git-1.png" alt="img"></p>
<p>前面我们提到过，如果我们想把文件添加到Git里面时，需要分两步：</p>
<p>第一步是用 git add 把文件添加进去，实际上就是把文件修改添加到暂存区。</p>
<p>第二步是用 git commit 提交更改，实际上就是把暂存区的所有内容提交到当前分支。（我们现在只有唯一一个分支 master，所以现在就是往 master 分支上提交更改）</p>
<p>我们可以实践一下：</p>
<p>在 readme.txt 文件中加上一行内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br></pre></td></tr></table></figure>
<p>然后在工作区新建一个 LICENSE 文本文档（任意内容）</p>
<p>使用两次 git add 命令分别把 readme.txt 和 LICENSE 都添加后，可以用 git status 命令查看一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   LICENSE</span><br><span class="line">    modified:   readme.txt</span><br></pre></td></tr></table></figure>
<p>现在，暂存区的状态就变成这样了：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-01-20-git-2.png" alt="img"></p>
<p>再使用 git commit 命令把暂存区的所有修改提交到分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;understand how stage works&quot;</span><br><span class="line">[master e43a48b] understand how stage works</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 LICENSE</span><br></pre></td></tr></table></figure>
<p>这时候的工作区就是干净的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>这时候版本库就变成了这样：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-01-20-git-3.png" alt="img"></p>
<h3 id="7-管理修改"><a href="#7-管理修改" class="headerlink" title="7.管理修改"></a>7.管理修改</h3><p>Git 如此的优秀是因为，Git 跟踪并管理的不是文件，而是修改。</p>
<p>我们对 readme.txt 文件进行修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes.</span><br></pre></td></tr></table></figure>
<p>然后，添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#       modified:   readme.txt</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<p>然后再修改 readme.txt 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt </span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure>
<p>提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;git tracks changes&quot;</span><br><span class="line">[master 519219b] git tracks changes</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p>这时候我们查看一下状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>我们可以发现，第二次修改并没有被提交。</p>
<p>因为在工作区的第一次修改被放入暂存区，准备提交；而在工作区的第二次修改并没有被放入暂存区，所以， git commit命令只负责把暂存区的修改提交了。</p>
<p>提交后，我们可以用 git diff HEAD – readme.txt 命令去查看工作区和版本库里面最新版本的区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff HEAD -- readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 76d770f..a9c5755 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,4 +1,4 @@</span><br><span class="line"> Git is a distributed version control system.</span><br><span class="line"> Git is free software distributed under the GPL.</span><br><span class="line"> Git has a mutable index called stage.</span><br><span class="line">-Git tracks changes.</span><br><span class="line">+Git tracks changes of files.</span><br></pre></td></tr></table></figure>
<h3 id="8-撤销修改"><a href="#8-撤销修改" class="headerlink" title="8.撤销修改"></a>8.撤销修改</h3><p>假如说你在 readme.txt 文件中添加了一行内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure>
<p>最后一行是万万不能让BOSS看到的，应该怎么撤销呢？</p>
<p>(1) 没有 git add 之前</p>
<p>可以手动删除最后一行，手动把文件恢复到上一个版本的状态。然后再用 git checkout – file 命令丢弃工作区的修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -- readme.txt //把readme.txt文件在工作区的修改全部撤销。</span><br></pre></td></tr></table></figure>
<p>现在看一下 readme.txt 文件内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure>
<p>果然复原了。</p>
<p>(2) git add了，但没有git commit</p>
<p>这时候的修改添加到了暂存区，但没有提交到分支，用 git status 查看一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    modified:   readme.txt</span><br></pre></td></tr></table></figure>
<p>这时候我们可以使用 git reset HEAD file 命令把把暂存区的修改撤销掉，重新放回工作区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD readme.txt //git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区，HEAD表示最新版本。</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M    readme.txt</span><br></pre></td></tr></table></figure>
<p>现在再用 git status 查看一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   readme.txt //暂存区是干净的，工作区有修改。</span><br></pre></td></tr></table></figure>
<p>这时候再丢弃工作区的修改就OK了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -- readme.txt //丢弃工作区的修改。</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>终于大功告成了。</p>
<p>(3) 既 git add 了，也 git commit 了</p>
<p>可以回退到上一个版本，见回退版本内容。</p>
<h3 id="9-删除文件"><a href="#9-删除文件" class="headerlink" title="9.删除文件"></a>9.删除文件</h3><p>在工作区即 learngit 文件夹下新建一个 test.txt 文件，并添加和提交到Git：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add test.txt&quot;</span><br><span class="line">[master b84166e] add test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br></pre></td></tr></table></figure>
<p>这时候可用 rm 命令删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rm test.txt</span><br></pre></td></tr></table></figure>
<p>这时工作区和版本库就不一样了。</p>
<p>现在又分两种情况：</p>
<p>(1) 确实要从版本库中删除该文件，那就用 git rm 命令删除，并且 git commit：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm &apos;test.txt&apos;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;remove test.txt&quot;</span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure>
<p>这时候文件就从版本库被删除了。</p>
<p>(2) 文件被删错了。因为版本库里有，所以很好恢复：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -- test.txt //用版本库里的版本替换工作区的版本。</span><br></pre></td></tr></table></figure>
<h3 id="10-远程仓库准备工作"><a href="#10-远程仓库准备工作" class="headerlink" title="10.远程仓库准备工作"></a>10.远程仓库准备工作</h3><p>在开始这部分之前，我们需要自行注册GitHub账号。而且，因为你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以需要设置：</p>
<p>(1) 创建SSH Key。在用户主目录下<img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-01-20-3.png" alt="img">，看看有没有.ssh 目录，如果有的话，看此目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果有，直接跳到下一步。如果没有，打开Git Bash，创建SSH</p>
<p>(2) 登陆GitHub，打开”Account settings”</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-01-20-github-1.png" alt="img"></p>
<p>然后点击”Add SSH and GPG Keys”，再点击”New SSH Key”进行SSH Key 的创建，填上任意 Title ，把 id_rsa.pub 中的内容复制到Key文本框内：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-01-20-github-2.png" alt="img"></p>
<h3 id="11-添加远程库"><a href="#11-添加远程库" class="headerlink" title="11.添加远程库"></a>11.添加远程库</h3><p>现在我们已经在本地创建了一个Git仓库了，又想在GitHub上创建一个Git仓库，然后让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。那么我们应该怎么做呢？</p>
<p>首先，登陆GitHub，在右上角找到“Create a new repo”按钮，创建一个新的仓库：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-01-20-github-3.png" alt="img"></p>
<p>在Repository name填入 test（因为我已经创建完成了，所以提示此用户名存在）其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-01-20-github-5.png" alt="img"></p>
<p>如上图所示我已经把本地仓库的内容推送到了GitHub上了，大家创建完以后应该是一个空的仓库。这时候我们可以在本地tset仓库下运行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:qian-youyou/test.git //“qian-youyou”是我的GitHub的账户名，你需要填写你自己的账户名</span><br></pre></td></tr></table></figure>
<p>添加后，远程库的名字就是 origin ，这是Git默认的叫法。</p>
<p>然后，我们就可以把本地库的所有内容推送到远程库上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 20, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.</span><br><span class="line">Total 20 (delta 5), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (5/5), done.</span><br><span class="line">To github.com:RFHzhj/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;.</span><br></pre></td></tr></table></figure>
<p>使用 git push 命令，就是把当前分支 master 推送到远程。</p>
<p>因为远程库是空的，所以我们在第一次推送 master 分支时，要加上 -u 参数，Git不但会把本地的<code>master 分支内容推送的远程新的 master 分支，还会把本地的</code> master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2018-01-20-github-4.png" alt="img"></p>
<p>从现在起，只要本地作了提交，就可以通过命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>把本地 master 分支的最新修改推送至GitHub。现在，我们拥有了真正的分布式版本库。</p>
<h3 id="12-从远程库克隆"><a href="#12-从远程库克隆" class="headerlink" title="12.从远程库克隆"></a>12.从远程库克隆</h3><p>我们的学习过程是先有了本地库，后有了远程库，然后再对远程库进行关联。</p>
<p>其实，我们大部分时候是先创建远程库，然后再从远程库克隆。</p>
<p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/git.png" alt></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>梦的索引</title>
    <url>/2017/05/20/2017-05-20/</url>
    <content><![CDATA[<p>梦的索引</p>
<p>浅悠悠 </p>
<p>5.20 </p>
<p>to.** (从此，某人不理我)</p>
<p>一 </p>
<p>风，轻拢着寒衣， </p>
<p>愁云，悄然漫入天际。</p>
<p> 夜，显得如此孤寂。</p>
<p> 寂静，淹没了每一个字节，</p>
<p> 而我，沉浸在如梦般的程序。 </p>
<p>不妨覆盖这寂寞的夜色， </p>
<p>将整个世界虚拟。 </p>
<p>二 </p>
<p>调用一个time函数， </p>
<p>永不熄灭的星空由我来设计。 </p>
<p>早晨迎接春的花香， </p>
<p>午后拥抱夏的暖阳， </p>
<p>黄昏品尝秋的硕果， </p>
<p>静夜寻觅冬的足迹。 </p>
<p>四季以奇幻的循环交替。 </p>
<p>三 </p>
<p>调用一个process函数， </p>
<p>柏拉图的理想国由我来开辟。 </p>
<p>辽阔的天空一碧如洗， </p>
<p>雄鹰与黄鹂整齐地共鸣，</p>
<p> 城市以和谐的进程刷新， </p>
<p>物竞天择已被仁爱更替。 </p>
<p>世界如蒲公英般无忧无虑。 </p>
<p>四 </p>
<p>再定义一个爱你的函数， </p>
<p>永恒是爱的生命周期。 </p>
<p>星空因你而努力闪耀， </p>
<p>四季因你而相伴朝夕， </p>
<p>花儿酿香渲染着你的气息， </p>
<p>阳光拂晓映射着你的甜蜜。 </p>
<p>在这个世界里， </p>
<p>你是唯一的主题。 </p>
<p>五 </p>
<p>我将自己作为参数， </p>
<p>向爱你的函数传递， </p>
<p>却意外发现你并不在我的域。 </p>
<p>我开始不断重载爱的定义， </p>
<p>将你我的变量封存在同一结构体。 </p>
<p>但很快系统出现了bug。 </p>
<p>当进程陷入死循环时， </p>
<p>才发现此算法不可逆。 </p>
<p>六 </p>
<p>也许你已在我的世界</p>
<p>永远赋上了静态的属性。 </p>
<p>系统不断将思念返回压入我的堆栈， </p>
<p>而我的内存此刻已满满是你。 </p>
<p>我向系统申请最后一点内存， </p>
<p>打开心的端口监听你的信息， </p>
<p>返回却总是操作失败的消息。 </p>
<p>七 </p>
<p>我想重写爱的模板， </p>
<p>再一次将爱传递， </p>
<p>却无法返回你也爱我的信息。 </p>
<p>我试图虚拟出最后一点内存， </p>
<p>将“你爱我吗”的字符串压入栈尾， </p>
<p>打开最后的端口传递给你。 </p>
<p>八 </p>
<p>倘若返回值为真， </p>
<p>我愿释放掉整个世界的内存， </p>
<p>从此只储存关于你的回忆。 </p>
<p>否则我愿析构自己， </p>
<p>将所有的喜怒哀乐封进内域。 </p>
<p>从此不需要让你知道， </p>
<p>我一直爱你。 </p>
<p>九 </p>
<p>此端，彼岸， </p>
<p>谁在孤独地将二叉树上的结点遍历？ </p>
<p>谁苦苦寻找连接着爱的网络服务器？ </p>
<p>虚拟，现实， </p>
<p>我是茫茫内存中哪一个孤独的进程？ </p>
<p>又是匆匆人海里哪一个寻梦的躯体？ </p>
<p>十 </p>
<p>我能编译出整个世界， </p>
<p>却无法虚拟真实的你。 </p>
<p>爱的程序， </p>
<p>也解不开你我的局。 </p>
<p>也许程序注定是梦， </p>
<p>而你， </p>
<p>永远是我梦的索引。 </p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>摘星集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>丽日芳馨</title>
    <url>/2017/05/11/2017-05-11/</url>
    <content><![CDATA[<p>映日清风浴春蕾，萋萋谁解芳草馨。</p>
<p>蝶羽蹁跹花儿醉，野韵泊然守天浔。</p>
<p>春风化雨蝶双去，冷月袭风蕊浸淋。</p>
<p>愁霖散尽曙光见，一片清新护花魂。</p>
<p>（本来是写给方大仙的，然后就误会了，方大仙再也没理过我。唉，从此江郎才尽。不过至少曾经我一直在像她学习）</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>绛影流风</title>
    <url>/2016/12/09/2016-12-09/</url>
    <content><![CDATA[<p>红尘滚滚浸离情，泪眼朦胧残月明。</p>
<p>乍见羲和乘风耀，一笑淡然气自雄。</p>
<p>流飞翰墨升丹气，朗润丹青贯玉虹。</p>
<p>愿效流风倾岁月，何人与我竞峥嵘。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>雪韵</title>
    <url>/2016/11/23/2016-11-23/</url>
    <content><![CDATA[<p>霞霄铸雪竟蹁跹，荡入苍穹冻川峦。</p>
<p>乾坤万里皆悸颤，日恼月愧不胜寒。</p>
<p>借得阳煦三分暖，化作凌霜戏犂元。</p>
<p>莫道冰心无暖意，且看清洁满人间。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>踏莎行·缘归梦</title>
    <url>/2016/10/13/2016-10-13/</url>
    <content><![CDATA[<p>晨曦送暖，莺韵翩跹，桃花春风共缠绵。</p>
<p>笑靥倾墨润青笺，无悔牵绊话尘缘。</p>
<p>暮色如烟，花落无言，江水未竭浸桑田。</p>
<p>梦里飞花随风远，空留一诺伴心眠。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>长相思·空城</title>
    <url>/2016/09/15/2016-09-15/</url>
    <content><![CDATA[<p>秋谧静，月朦胧，</p>
<p>中秋晚月浸空城。城涌人匆匆。</p>
<p>人味浓，情味空，</p>
<p>万径同归意难融。双袖迎清风。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>十六字令</title>
    <url>/2016/09/11/2016-09-11/</url>
    <content><![CDATA[<p>琴，一曲弦歌揽客心。曲终尽，何处觅知音。</p>
<p>棋，黑白博弈方寸迷。红尘局，进退两迷离。</p>
<p>书，满腹离愁一纸出。皆归寂，墨韵话孤独。</p>
<p>画，妙笔浸润满庭花。花易落，秀色映谁家。</p>
<p>诗，相思化作墨中痴。声声慢，平仄为谁织。</p>
<p>酒，彼时笑靥遵底留。断肠人，独酌夜无休。</p>
<p>花，群芳争艳恋春霞。秋风起，流水逝芳华。</p>
<p>茶，一叶清香静繁华。淳意散，花叶隔天涯。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>一剪梅·尘埃</title>
    <url>/2016/07/12/2016-07-12/</url>
    <content><![CDATA[<p>风起流尘自轻狂，翛然而往，孑然飘扬。</p>
<p>奈何落地满凄凉，天也苍苍，路也茫茫。</p>
<p>泪浸尘埃人断肠，烟隐轩窗，人隐何方？</p>
<p>莫如引歌醉残阳，一曲新词，笑尽沧桑。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>参商永离</title>
    <url>/2016/06/20/2016-06-20/</url>
    <content><![CDATA[<p>白首双星寄麒麟，</p>
<p>只是相觅恰黄昏。</p>
<p>夕阳有意聚离人，</p>
<p>冷月无情散星辰。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>十六字令</title>
    <url>/2016/05/21/2016-05-21/</url>
    <content><![CDATA[<p>棉，<br>细雨蒙蒙润娇颜，<br>风飘絮，<br>离絮苦缠绵。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>云行在天</title>
    <url>/2016/04/26/2016-04-26/</url>
    <content><![CDATA[<p>玄霄蔽月百生愁，</p>
<p>星海云游榆光羞。</p>
<p>御风万里乾坤尽，</p>
<p>谁人与我竞风流？</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>情茧</title>
    <url>/2016/03/28/2016-03-28/</url>
    <content><![CDATA[<p>残阳月掩掠青笺，青笺墨泣染长夜。</p>
<p>长夜辗转盼天明，天明又患残阳浅。</p>
<p>今宵又惊昨日梦，梦里飞花舞翩跹。</p>
<p>落英片片蝶成茧，为孰憔悴为孰残。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>西江月·蝶双飞</title>
    <url>/2016/02/14/2016-02-14/</url>
    <content><![CDATA[<p>华灯逐日争明，烟花伴月共辉。<br>身隔千里心相随，胜过瑶池相会。<br>今夕天涯独行，明夕伴君同归。<br>风雨缠绵蝶双飞，换得此生无悔。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>长相思·寄云梦</title>
    <url>/2016/02/08/2016-02-08/</url>
    <content><![CDATA[<p>风萧萧，</p>
<p>雨萧萧，</p>
<p>风雨同程伴君老，</p>
<p>奈何山水遥。</p>
<p>云悄悄，</p>
<p>梦悄悄，</p>
<p>行云织梦芳踪渺，</p>
<p>梦里相思扰。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>词穷墨尽</title>
    <url>/2016/01/28/2016-01-28/</url>
    <content><![CDATA[<p>词叹墨尽难续情，</p>
<p>墨笑词穷一场空。</p>
<p>风润墨痕惊旧梦，</p>
<p>伊人随梦泪随风。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>心泪无痕</title>
    <url>/2016/01/08/2016-01-08/</url>
    <content><![CDATA[<p>瑟瑟寒风眷高楼，</p>
<p>街明巷寂夜悠悠。</p>
<p>独倚寒窗忆旧梦，</p>
<p>痴笑不觉心泪流。</p>
<p>青丝悄然落眉头，</p>
<p>欲笺新词只剩愁。</p>
<p>满腹情思何处寄？</p>
<p>唯有黯然藏心头。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>梦里飞花</title>
    <url>/2015/12/27/2015-12-27/</url>
    <content><![CDATA[<p>梦里飞花 </p>
<p>浅悠悠 </p>
<p>梨花点点， </p>
<p>琴瑟缓缓。 </p>
<p>谁把情话， </p>
<p>浸润成芽？</p>
<p> …… </p>
<p>繁花艳艳， </p>
<p>诗意绵绵。 </p>
<p>谁把韶光， </p>
<p>谱写成夏？ </p>
<p>…… </p>
<p>黄花依依， </p>
<p>棋子稀稀。 </p>
<p>谁把芳华， </p>
<p>飘落成砂？ </p>
<p>…… </p>
<p>雪花凄凄， </p>
<p>画笔寂寂。 </p>
<p>谁把青丝， </p>
<p>染成白发？ </p>
<p>…… </p>
<p>梦里飞花， </p>
<p>孑然自暇。 </p>
<p>谁的牵挂，</p>
<p> 散尽天涯。 </p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>摘星集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>冲高</title>
    <url>/2015/12/19/2015-12-19/</url>
    <content><![CDATA[<p>凌云雄鹰击红日，悬崖欲起先折翅；</p>
<p>梧桐枝头重生凤，涅槃之时浴火噬；</p>
<p>不经雨困长风袭，怎显鸿鹄冲天势；</p>
<p>孰敢与天试比高？且看我辈腾飞时。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>冰清</title>
    <url>/2015/11/20/2015-11-20/</url>
    <content><![CDATA[<p>霜飘雪绵竞翩跹，</p>
<p>巧借寒气铸玉颜。</p>
<p>冷面洁骨身如镜，</p>
<p>笑看浮云舞成眠。</p>
<p>栖居严冬梅相伴，</p>
<p>不与浑水染尘烟。</p>
<p>岂是冰蕊无情意？</p>
<p>因守清纯在人间。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>沁园春·约定</title>
    <url>/2015/11/07/2015-11-07/</url>
    <content><![CDATA[<p>一日倾心，百日梦萦，终日魂销。</p>
<p>叹忆中所思，芳踪飘渺，梦中所念，素裹妖娆。</p>
<p>一向情深，奈何缘浅，咫尺之川万里遥。</p>
<p>平生意，化双飞双宿，共度花朝。</p>
<p>西风锐利如刀，惟连理双枝紧缠绕。</p>
<p>看风吹雾散，雨驻清涟。海誓山盟，怎能风飘。</p>
<p>山重水复，柳暗花明，一叶轻舟过险涛。</p>
<p>天涯路，愿青骢共骑，轻揽子腰。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>鹧鸪天·断肠人</title>
    <url>/2015/10/31/2015-10-31/</url>
    <content><![CDATA[<p>风袭青枝花欲坠，青枝倾尽心中累。</p>
<p>长恨残风戏嫩蕊，此身无力空心碎。</p>
<p>词中意，曲中悲。哀弦危柱有谁醉？</p>
<p>潇潇冷雨送寒归，点滴皆是离人泪。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>梦·曲</title>
    <url>/2015/10/21/2015-10-21/</url>
    <content><![CDATA[<p>夜轻轻舞动着寒衣， </p>
<p>风放纵着月色般的音律。 </p>
<p>指尖轻触着跳动的音符， </p>
<p>在轻快的乐曲中将双目微闭。 </p>
<p>…… </p>
<p>曲中回荡着少年悠扬的乐音， </p>
<p>陪伴着少女轻盈的笑语。 </p>
<p>琴声轻拂着清脆的鸟鸣， </p>
<p>与你我一起赞美这自由的天地。 </p>
<p>…… </p>
<p>风儿为这祥和的音符歌唱， </p>
<p>雨点为这宁静的四季舞动， </p>
<p>悠闲的人们不再追名逐利， </p>
<p>星星在你我怀中无忧的睡去。 </p>
<p>…… </p>
<p>我没有那演绎梦境的曲， </p>
<p>只有一把弹奏孤独的琴。 </p>
<p>漫天繁星早已没了踪迹， </p>
<p>只留下忧郁的孩子沉醉在梦里…… </p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>摘星集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>遥光</title>
    <url>/2015/10/14/2015-10-14/</url>
    <content><![CDATA[<p>日逐朝霞去昨痕，</p>
<p>轻抚晨光盼伊人。</p>
<p>繁星带月匆匆过，</p>
<p>只盼芳踪梦里寻。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>月隐风轻</title>
    <url>/2015/09/27/2015-09-27/</url>
    <content><![CDATA[<p>风暖寒霜月无踪，</p>
<p>惟有孤夜伴秋风。</p>
<p>纵使秋风解我意，</p>
<p>旧愁吹去新愁生。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>鹊桥仙·一眼万年</title>
    <url>/2015/08/20/2015-08-20/</url>
    <content><![CDATA[<p>双星作合，</p>
<p>金风玉露，</p>
<p>朗月惹得谁羡。</p>
<p>悠悠天上一光年，</p>
<p>隔不断、深情一眼。</p>
<p>丝落无声，</p>
<p>天涯遥望，</p>
<p>织云又忆初见。</p>
<p>依依心上一瞬间，</p>
<p>便无悔、挚爱万年。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title>蝶恋花·相思字</title>
    <url>/2015/08/14/2015-08-14/</url>
    <content><![CDATA[<p>秋风落尽花憔悴，</p>
<p>蝶欲起舞，</p>
<p>只怜茧中愧。</p>
<p>共饮青春赋一醉，</p>
<p>却叹聚散最心累。</p>
<p>此刻相思赋予谁，</p>
<p>彼时笑语，</p>
<p>漫天随风归。</p>
<p>失散绝句谁轻吟，</p>
<p>空弹高山对流水。</p>
]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
</search>
